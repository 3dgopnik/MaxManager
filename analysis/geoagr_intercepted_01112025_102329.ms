--wishlist:
/*			
		+георгию: семинар с описанием принципов работы с использованием скрипта и без
		вытянуть из него текст:
		семинар по облегчению работы с помощью скрипта, с описанием принципов работы, измененения форкфлоу и другая технология создания модели
		показать и описать главные процессы работы, как разрабатывать модели нпм впм

		назначение id в меш едит без перевода геометрии в поли
		
		+переразмер Fit mat, переработать перескейл-перетайл текстур на весь мультимат 
		переразмер текстур через rescale density
		добавить аналогичную опцию в rescale density		
		
		раздвигание или слияние ребер, стоящих на плоскости полигона, проверка с расстановкой точек или с выделением вершин	
		объединение элементов, нарезание эджей в месте пересечения
		polyop.cutFace 		
		
		выделение полигонов выходящих за рамки юдимов
		
		переименовать интерфейс: значки и символы добавить

		тайлинг текстуры через командную строку
		
		проверка текстурных отступов в текстурах по новым правилам
		
		прикрутить через питон имэдж мэджик
		открывать тип srgb через питон для скорости
		
		для модуля деревьев переработать поиск и отделение веток
		выбор решения о нужных ветках автоматизировать
		
		оптимизировать положение текстур на всех атласах, вытащить из скрипта у немца полробности, может поможет
		
		flip faces, выворачивать наружу компланарные фейсы, которые направлены друг на друга нормалями
		btn_FlipFaces разворачивать неправильные фейсы у компланарных объектов, типа заборов, стекол, веток

		condense для самого объекта, сделан только материал-конденсирование, надо доделать пкм для конденсирования объекта под материал
		
		для раздвигания фейсов сначала раздвигать мелкие элементы по площади, потом крупные, надо делать массив, потом сортировать
		
		в роллауте чекера с длинными строками имена объектов ставить в начало строк

		рендеринг на плоскость фасада или объекта маф, получение текстур и атласа, подстановка камеры
		рендеринг вокруг элементов маф, получение текстур и атласа
		
		добавление проверки расстояний между светильниками
		добавление нового диапазона в раздвигание
		размер картинок в наборе, проверка связанных
		размер между лоскутами развертки в текстурах, проверка паддинга

		идея для скрипта: используя максимально допустимые значения с запасом, брала текстуры с архвиз матов, брала текущий реалворд или боксовый мапинг,
		понимало что текстуры надо повторить n-раз для достижения ее в 7.6 метра и 4096 пикселей ну или если 2048 то повторяло тупо 4 а потом по размерам 
		чтобы тайлящиеся текстуры были всегда под 7.6 метра плюс минус там подскейлить будет незаметно на таком размере,
		можно даже переназначить такой мат и перебоксомапить модель 
		и нарезать развернуть разложить на атлас или юдимы
		
		триангуляция через meshlib
		попробовать прикрутить python к максу, чтобы обращаться по нему к библиотекам meshlib meshlab, попробовать C# аналогично
		
		список проверки по всем новым правилам, проверка по всем пунктам правил по очереди в дереве, с возможностью составления отчетов, со скринами вьюпорта, с коментариями, с экспортом в pdf

		объединение объектов для CAD импортированных форм - для моделинга

		грид слайсер, не резать очень сильно рядом с существующим еджем, 
		продуцирование треугольников меньше милиметра, 
		указать возможный трешхолд, ближе которого, если есть ребро, то разрез не делать
		?замена polyop.slice на polyop.cutFace
		polyop.cutFace <Poly poly> <int face> <point3 start> <point3 destination> <point3 projdir> node:<node=unsupplied>
		polyop.slice <Poly poly> <facelist> <ray plane_and_dir> node:<node=unsupplied>
		<bool><EditablePoly>.slice <point3>slicePlaneNormal <point3>slicePlaneCenter [flaggedFacesOnly:<bool>] [faceFlags:<DWORD>] 
		flaggedFacesOnly default value: false
		faceFlags default value: 1
		<index><EditablePoly>.cutFaces <index>startFace <point3>startPosition <point3>endPosition <point3>viewDirectionCut 
		using a plane defined by the point specified by the two face positions and the view direction. 

		PCloudToMesh по точкам строить поверхность земли (или сделать через meshlib converter)

		проверка через реи в комнату из стекол, чтобы делать какие-то стекла одинарными, какие-то двойными

		проверка формы UCX вокруг исходной, отступы до 30см и 1м
		
		смещалки UV по разным привязкам, например, перемещение под левый нижний угол в первый юдим

		transfer edges на разделенных эджах и вершинах

		?место попадания IntersectRay проверять: мерить по расстоянию от вертексов предполагаемого фейса до источника ray (другого фейса) и до pos пересечения и проверять в плоскости ли это искомого фейса
		?раздвигать повертексно параллельные фейсы, разобраться с разнонаправленными фейсами

		у пересекающихся фейсов исправлять положения вертексов, придумать как направление раздвига понимать

		разобраться со скриптом PopulateTerrain, что можно вытащить оттуда для скрипта проекции
		
		надо доделать лицензии другого типа, ограниченные по времени, и сделать возможность получения оставшегося времени из ключа
		
		редактор текстуры синхронизированный с разверткой, перемещения на развертки отражаются на текстуре (перемещение, поворот, масштаб, копирование области, всё под разверткой)
		
		сделать сжатие больших текстур по ограничению под размер под новые правила
		?вернуть сжатие текстур в браузер текстур работы с глубиной цвета
		
		сохранение проектов - переделать взятие ini из каталога в максе, а не каталога скрипта
		
		добавить проверку в развертке кирпичей, что весь набор выделенных фейсов лежит в юдиме целиком и не отмечен рескейл, значит не надо проводить работу

		доделать авторазвертку произвольных поверхностей с детриангуляцией и выделением кривых эджей с брэком развертки
		добавить планарный мэпинг на уровне простых полигонов
		добавить его в меню ошибочных текселей polyop.setMapFace <Poly poly> <int mapChannel> <int map face index> <map vertex array>Sets the map vertices for the specified map face. 
		
		?сделать работу кнопки с указанием целевого острова
		сделалать работу кнопки с указанием целевого выбора фейсов в поли объекте, с последующим трансфером полигонов в развертку

		разрезание UCX convex concave, пока ставится полная триангуляция для concave

		работа таблиц площадей поли и плотностей текселей с эдитмеш
		?формула подсчета плотностей текселей, альтернативная

		?проверка апдейта скрипта из облака
		
		работа с инвертированными фейсами <void><Unwrap_UVW>.selectInvertedFaces() 
		
		?OSL материал UDIM
		
		сохранение поворота и индекса ОКМ ТЕ в настройках INI, завести поля в скрипте
		
		?UDIM to IDs оптимизировать для скорости, сделать выбор по рамке выделения в юдиме, а не перебирать по лоскутам
		
		список и поля для создания текстур для лоуполи по аналогии с хайполи, проверка имен
		
		загрузка сохраненных названий объектов для проекта
		выбор сохраненных путей из списка для раздела сохранения настроек
		
		заполнение полей Geojson с объяснением
		вывод справочников для категорий для заполнения полей, округ, номер, код, советы по формированию имен

		создание grid helper ориентированного вдоль объекта и назначение его на авктивный вьюпорт
		activegrid = undefined 
		
		тест объектов на ошибки согласно регламенту
		тест имен текстур на ошибки регламента
		
*/

--macroScript GeoAGR category:"Geoscript"
(
	setclipboardText " "
	--escapeEnable = false
	--main programm
	escapeEnable = true
	
	fn DisableProcessWindowsGhosting =
    (
		local source = StringStream ("using System.Runtime.InteropServices; public class DisableWindowsGhosting{ [DllImport(\"user32.dll\")]  public static extern bool DisableProcessWindowsGhosting();  }")

		compilerParams = dotnetobject "System.CodeDom.Compiler.CompilerParameters"
		compilerParams.ReferencedAssemblies.Add("System.dll");
		compilerParams.GenerateInMemory = on
		csharpProvider = dotnetobject "Microsoft.CSharp.CSharpCodeProvider"
		compilerResults = csharpProvider.CompileAssemblyFromSource compilerParams #(source as String)
		flush source
		close source
		if (compilerResults.Errors.Count > 0 ) then
		(
			local errs = stringstream ""
			for i = 0 to (compilerResults.Errors.Count-1) do
			(
				local err = compilerResults.Errors.Item[i]
				format "Error:% Line:% Column:% %\n" err.ErrorNumber err.Line err.Column err.ErrorText to:errs
			)
			format "%\n" errs
			undefined
		)
		else
		(
			compilerResults.CompiledAssembly.CreateInstance "DisableWindowsGhosting"
		)
    )
	
	fn gettime = 
	(
		local client = dotnetObject "System.Net.Sockets.TcpClient" "time.nist.gov" 13
		client.SendTimeout = 2000
		local streamReader = dotnetObject "System.IO.StreamReader" (client.GetStream())
		local response = streamReader.ReadToEnd asDotnetObject:true
 
		local utcDateTimeString = response.Substring 7 17 asDotNetObject:true
		local localDateTime = (dotnetClass "System.DateTime").ParseExact utcDateTimeString "yy-MM-dd HH:mm:ss" (dotnetClass "System.Globalization.CultureInfo").InvariantCulture (dotnetClass "System.Globalization.DateTimeStyles").AssumeUniversal
 
		streamReader.Dispose()
		--print (localDateTime.ToString())
		localDateTime.ToString()
	)
	
	fn translit t =
	(
		nm = ""
		if t != undefined then
			if t.count > 0 then 
			(
				for j in #{1..t.count} do
					case t[j] of
					(
						"А": nm+="A"
						"Б": nm+="B"
						"В": nm+="V"
						"Г": nm+="G"
						"Д": nm+="D"
						"Е": nm+="E"
						"Ё": nm+="Yo"
						"Ж": nm+="Zh"
						"З": nm+="Z"
						"И": nm+="I"
						"Й": nm+="J"
						"К": nm+="K"
						"Л": nm+="L"
						"М": nm+="M"
						"Н": nm+="N"
						"О": nm+="O"
						"П": nm+="P"
						"Р": nm+="R"
						"С": nm+="S"
						"Т": nm+="T"
						"У": nm+="U"
						"Ф": nm+="F"
						"Х": nm+="H"
						"Ц": nm+="Cz"
						"Ч": nm+="Ch"
						"Ш": nm+="Sh"
						"Щ": nm+="Shch"
						"Ъ": nm+=""
						"Ы": nm+="Y"
						"Ь": nm+=""
						"Э": nm+="E"
						"Ю": nm+="Yu"
						"Я": nm+="Ya"
						"а": nm+="a"
						"б": nm+="b"
						"в": nm+="v"
						"г": nm+="g"
						"д": nm+="d"
						"е": nm+="e"
						"ё": nm+="yo"
						"ж": nm+="zh"
						"з": nm+="z"
						"и": nm+="i"
						"й": nm+="j"
						"к": nm+="k"
						"л": nm+="l"
						"м": nm+="m"
						"н": nm+="n"
						"о": nm+="o"
						"п": nm+="p"
						"р": nm+="r"
						"с": nm+="s"
						"т": nm+="t"
						"у": nm+="u"
						"ф": nm+="f"
						"х": nm+="h"
						"ц": nm+="cz"
						"ч": nm+="ch"
						"ш": nm+="sh"
						"щ": nm+="shch"
						"ъ": nm+=""
						"ы": nm+="y"
						"ь": nm+=""
						"э": nm+="e"
						"ю": nm+="yu"
						"я": nm+="ya"

						"0": nm+="0"
						"1": nm+="1"
						"2": nm+="2"
						"3": nm+="3"
						"4": nm+="4"
						"5": nm+="5"
						"6": nm+="6"
						"7": nm+="7"
						"8": nm+="8"
						"9": nm+="9"

						" ": nm+="_"
						"_": nm+="_"
						".": nm+="_"
						",": nm+=""
						"-": nm+=""
						"/": nm+=""
						"\\": nm+=""
						"'": nm+=""
						"`": nm+=""

						"A": nm+="A"
						"B": nm+="B"
						"C": nm+="C"
						"D": nm+="D"
						"E": nm+="E"
						"F": nm+="F"
						"G": nm+="G"
						"H": nm+="H"
						"I": nm+="I"
						"J": nm+="J"
						"K": nm+="K"
						"L": nm+="L"
						"M": nm+="M"
						"N": nm+="N"
						"O": nm+="O"
						"P": nm+="P"
						"Q": nm+="Q"
						"R": nm+="R"
						"S": nm+="S"
						"T": nm+="T"
						"U": nm+="U"
						"V": nm+="V"
						"W": nm+="W"
						"X": nm+="X"
						"Y": nm+="Y"
						"Z": nm+="Z"

						"a": nm+="a"
						"b": nm+="b"
						"c": nm+="c"
						"d": nm+="d"
						"e": nm+="e"
						"f": nm+="f"
						"g": nm+="g"
						"h": nm+="h"
						"i": nm+="i"
						"j": nm+="j"
						"k": nm+="k"
						"l": nm+="l"
						"m": nm+="m"
						"n": nm+="n"
						"o": nm+="o"
						"p": nm+="p"
						"q": nm+="q"
						"r": nm+="r"
						"s": nm+="s"
						"t": nm+="t"
						"u": nm+="u"
						"v": nm+="v"
						"w": nm+="w"
						"x": nm+="x"
						"y": nm+="y"
						"z": nm+="z"
						
						default: nm += t[j]
					)
			)
		nm	
	)
		
	fn check_file f = 
	(
		good = false
		if f != undefined then
		(
			f_name = getfilenamefile f + getfilenametype f
			--print f_name
			ff = filterstring f_name "."
			--print #(ff)
			if ff.count > 1 then
			(
				--print ff.count
				if ff.count == 2 then good = false --только одна точка, нет юдимов
				if ff.count > 2 then
				(
					--print (trimright (ff[ff.count - 1]) "0123456789")
					if (trimright (ff[ff.count - 1]) "0123456789") == "" then 
					(
						
						ss = filterstring (ff[ff.count - 2]) "_" --первый без точки должен содержить подчеркивания
						--print #(ss)
						--print ss.count
						if ss.count > 1 then
						(
							if ss[ss.count] == "1" then good = true --перед номером юдима стоит _1
						)
					)
				)
			)
		)
		--print good
		good
	)	
	
	fn check_file_uv f = 
	(
		good = false
		if f != undefined then
		(
			f_name = getfilenamefile f + getfilenametype f
			--print f_name
			ff = filterstring f_name "."
			--print #(ff)
			if ff.count > 1 then
			(
				--print ff.count
				if ff.count == 2 then good = false --только одна точка, нет юдимов
				if ff.count > 2 then
				(
					--print (trimright (ff[ff.count - 1]) "0123456789")
					if (trimright (ff[ff.count - 1]) "0123456789") == "" then 
					(
						good = true 
					)
				)
			)
		)
		--print good
		good
	)	
	
	fn uv_file_rename i =
	(
		local new = i
		if new != undefined and new != "" then
		(
			local s = getfilenamefile i
			local pat = getfilenamepath i
			local ext = getfilenametype i
								
			local ss = filterstring s "_"
			if ss.count > 1 then
			(
				local V = ss[ss.count]
				local U = ss[ss.count - 1]
				V = substitutestring V "V" "" --вертикальные юдимы
				U = substitutestring U "U" "" --горизонтальные юдимы
				if (U as integer) >= 1 and (U as integer) <= 10 and (V as integer) >= 1 and (V as integer) <= 10 then
				(
					local udim_num = 1000 + (U as integer) + (10 * (V as integer - 1))
					local str = ""
					for a = #{1..(ss.count - 2)} do str += ss[a] + "_"
					new = pat + str + "." + (udim_num as string) + ext
				)
			)
		)
		new
	)
	
	fn udim_to_uv_num i = 
	(
		local str = ""
		--udim_num = 1000 + (U as integer) + (10 * (V as integer - 1))
		if i != undefined and i >= 1001 then
		(
			--local uv_num = i - 1000
			--local U = (mod uv_num 10) + 1
			--local V = ((uv_num - (U - 1)) / 10) as integer + 1
			
			local uv_num = i - 1000
			local U = mod uv_num 10
			local V = ((uv_num - U) / 10) as integer + 1
			
			str = "U" + U as string + "V" + V as string
			--print str
		)
		str
	)
								
	fn get_hits s selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular =
	(
		err = #()
		if s != undefined and classof s == Editable_Poly then
		(
			for i in selfaces where not keyboard.escPressed do
			(
				local vec = polyop.getFaceNormal s i
				if invert_face then vec *= -1.0
				local points = #()
				--append points (polyop.getFaceCenter s i)
				append points (polyop.getSafeFaceCenter s i)
				if do_verts then
				(
					local verts = polyop.getVertsUsingFace s #{i}
					join points (for v in verts collect	(polyop.getvert s v))
				)
				
				if points.count > 0 then 
				(
					for poi in points where poi != undefined do
					(
						/*
						addModifier s (Edit_Mesh())
							
						hits_ex = intersectRayEx s (ray poi vec)
						--print #(hits_ex)
						if hits_ex != undefined then
						(
							if (distance poi hits_ex[1].pos >= minimum_range) and (distance poi hits_ex[1].pos <= maximum_range) and (abs(dot vec hits_ex[1].dir) >= near_perpendicular or abs(dot vec hits_ex[1].dir) <= (1.0 - near_perpendicular)) do 
							(
								appendIfUnique err #(i, direction * (distance poi hits_ex[1].pos), vec, hits_ex[1].pos, hits_ex[1].dir, hits_ex[2])
							)
						)	
						deleteModifier s 1
						*/						
						--	/*
						if do_verts then
						(
							hits = intersectRayScene (ray poi vec)
							--print #(hits_new)
							if hits.count > 0 then
							(
								for h in hits where (h[1] == s) and (distance poi h[2].pos >= minimum_range) and (distance poi h[2].pos <= maximum_range) and (abs(dot vec h[2].dir) >= near_perpendicular or abs(dot vec h[2].dir) <= (1 - near_perpendicular)) do 
								(
									appendIfUnique err #(i, direction * (distance poi h[2].pos), vec, h[2].pos, h[2].dir)
								)
							)
						)
						else
						(
							hits_new = intersectRay s (ray poi vec)
							if hits_new != undefined then
							(
								if (distance poi hits_new.pos >= minimum_range) and (distance poi hits_new.pos <= maximum_range) and (abs(dot vec hits_new.dir) >= near_perpendicular or abs(dot vec hits_new.dir) <= (1.0 - near_perpendicular)) do 
								(
									appendIfUnique err #(i, direction * (distance poi hits_new.pos), vec, hits_new.pos, hits_new.dir)
								)
							)
						)
						--*/
					)
				)
			)
		)
		err
	)
	
	fn getConvexEdges node show threshold ignoreHardEdges ignoreOpenEdges = 
		if iskindof node Editable_Poly then
		(
			local edgeFaces = polyop.getedgefaces 
			local faceNormal = polyop.getfacenormal 
			local faceCenter = polyop.getfacecenter 
			local faceSmooth = polyop.getfacesmoothgroup
			edges = #{}
			for e in (node.edges as bitarray) do
			(
				ff = edgeFaces node e
				if (not ignoreOpenEdges and ff.count != 2) or ((ff.count == 2) and (n1 = faceNormal node ff[1]; n2 = faceNormal node ff[2]; vc = faceCenter node ff[2] - faceCenter node ff[1]; (dot n1 vc <= 0) and (acos (dot n1 n2) > threshold) and (not ignoreHardEdges or (bit.and (faceSmooth node ff[1]) (faceSmooth node ff[2]) > 0)))) then append edges e
			)
			if show then node.selectededges = edges
			edges
		)	
	
	fn faces_to_elements s faces =
	(
		elems = #()
		part_of_faces = faces
		while not part_of_faces.isempty do with redraw off
		(
			if keyboard.escPressed then exit
			for i in part_of_faces where not keyboard.escPressed do 
			(
				elem = polyOp.getElementsUsingFace s #{i}
				--vv = polyop.getVertsUsingFace s elem
				--pp = for v in vv collect polyop.getVert s v
				--append elems #(elem, vv, pp) 
				append elems elem
				part_of_faces -= elem
				exit
			)
		)
		elems
	)	

	fn rotate_to_min_Y s step mini maxi =  			
	(
		gc()
		angles = 0.0 
		if s != undefined then
		(
			max create mode
			ss = copy s
			ResetXForm ss
			converttopoly ss
			mY = ss.min.y
			delete ss
			for ang = mini to maxi by step where not keyboard.escPressed do
			(
				ss = copy s
				ResetXForm ss
				converttopoly ss
				in coordsys world rotate ss (eulerangles 0 0 ang)
				ResetXForm ss
				converttopoly ss
				mmY = ss.min.y 
				if mmY < mY then
				(
					mY = mmY 
					angles = ang
				)
				delete ss
			)
			print angles
			--rotate s (eulerangles 0 0 angles)
		)
		angles
	)
	
	fn rotate_to_min_Y_gab s step mini maxi =  			
	(
		gc()
		angles = 0.0 
		if s != undefined then
		(
			max create mode
			local ss = copy s
			ResetXForm ss
			CenterPivot ss
			converttopoly ss
			local pos = ss.pivot
			local mY = abs (ss.max.y - ss.min.y)
			delete ss
			for ang = mini to maxi by step where not keyboard.escPressed do
			(
				local ss = copy s
				ResetXForm ss
				CenterPivot ss
				converttopoly ss
				in coordsys world rotate ss (eulerangles 0 0 ang)
				ResetXForm ss
				CenterPivot ss
				converttopoly ss
				mmY = abs (ss.max.y - ss.min.y)
				if mmY < mY then
				(
					mY = mmY 
					angles = ang
					local pos = ss.pivot
				)
				delete ss
			)
			format "angle=% pivot_ini=% pivot_fin=% \n" angles s.pivot pos
			--rotate s (eulerangles 0 0 angles)
		)
		angles
	)
	
	fn rotate_to_max_Y s step mini maxi =  			
	(
		gc()
		angles = 0.0 
		if s != undefined then
		(
			max create mode
			ss = copy s
			ResetXForm ss
			converttopoly ss
			mY = ss.max.y
			delete ss
			for ang = mini to maxi by step where not keyboard.escPressed do
			(
				ss = copy s
				ResetXForm ss
				converttopoly ss
				in coordsys world rotate ss (eulerangles 0 0 ang)
				ResetXForm ss
				converttopoly ss
				mmY = ss.max.y 
				if mmY > mY then
				(
					mY = mmY 
					angles = ang
				)
				delete ss
			)
			print angles
			--rotate s (eulerangles 0 0 angles)
		)
		angles
	)
	
	fn dist s elem1 elem2 d =
	(
		if not elem1.isempty and not elem2.isempty then 
		(
			local vv1 = polyop.getVertsUsingFace s elem1
			local vv2 = polyop.getVertsUsingFace s elem2
			local pp1 = for v1 in vv1 collect polyop.getVert s v1
			local pp2 = for v2 in vv2 collect polyop.getVert s v2	
			for p1 in pp1 do
				for p2 in pp2 where distance p1 p2 <= d do return true
		)
		return false 
	)		
	
	fn getNormals poly faces =
	(
		local normal = [0, 0, 0]
		for f in faces do normal += in coordsys poly (polyop.getFaceNormal poly f)
		return normalize (normal / faces.numberSet)
	)
	
	fn alignUVGizmo theObj theMap =
	(
		local a = copy theObj 
		converttopoly a  
		local faces = #{1..a.numFaces}
		delete a
		faceNormal = getNormals theObj faces
		worldUpVector = [0,0,1]
		rightVector = normalize (cross worldUpVector faceNormal)
		upVector = normalize (cross rightVector faceNormal)
		theMatrix = matrix3 rightVector upVector faceNormal [0,0,0]
		theMap.gizmo.transform = theMatrix
		theMatrix
	)

	fn addBBoxVertex bbpMax bbpMin p = 
	(
		if bbpMax == undefined then 
		(
			bbpMin = copy p
			bbpMax = copy p
		)
		if p.x > bbpMax.x then bbpMax.x = p.x
		if p.y > bbpMax.y then bbpMax.y = p.y
		if p.z > bbpMax.z then bbpMax.z = p.z

		if p.x < bbpMin.x then bbpMin.x = p.x
		if p.y < bbpMin.y then bbpMin.y = p.y
		if p.z < bbpMin.z then bbpMin.z = p.z
	)

	fn getcenters obj faces = 
	(
		centre = [0,0,0]
		if obj != undefined and classof obj == Editable_Poly then
		(
			if not faces.isempty then
			(
				for theFace in faces do center += polyOp.getSafeFaceCenter obj theFace
				centre /= faces.numberset
			)
		)
		centre
	)

	fn FitUVWMapToFace obj theMap =
	(
		local a = copy obj 
		converttopoly a  
		local faces = #{1..a.numFaces}
		delete a
		objTM = obj.objecttransform
		modTM = getModContextTM obj m --тут ошибка
		cfp = getcenters obj faces 
		fTM = theMap.gizmo.transform
		facePointList = #{}
		for theFace in faces do join facePointList (polyOp.getFaceVerts obj.baseobject theFace)
		bbpMax = undefined
		bbpMin = undefined
		for f in facePointList do
		(
			local fp = polyOp.getVert obj f
			addBBoxVertex bbpMax bbpMin ((fp * (inverse objTM) * (inverse fTM)))
		)
		avp = bbpMax - bbpMin
		bbpMiddle = bbpMin + avp / 2
		theMap.gizmo.pos = bbpMiddle * fTM * modTM
		theMap.length = avp.y
		theMap.width = avp.x
		theMap.height = avp.z
	)

	fn get_gabarites s = 
	(
		gab = 0
		if s != undefined then
		(
			if classof s == editable_poly then
			(
				local d = #()
				local pp = for v in #{1..polyop.getNumVerts s} collect polyop.getvert s v
				for p1 in pp do
					for p2 in pp where p1 != p2 do 
					(
						append d (distance [p1.x, p1.y, 0] [p2.x, p2.y, 0])
					)
				gab = amax d
				gab = amax (#((s.max.z - s.min.z), gab))
			)
		)
		gab
	)
	
	fn getVertNormal poly vert =
	(
		local normal = [0, 0, 0]
		local vertFaces = polyop.getFacesUsingVert poly vert
		if vertFaces.numberSet > 0 then
		(
			for f in vertFaces do normal += polyop.getFaceNormal poly f
			return normalize (normal / vertFaces.numberSet)
		)
		else return normal
	)

	fn convex_concave poly faces = 
	(
		arr = #{}
		if poly != undefined then
		(
			if faces.isempty then
			(
				return arr
			)
			else 
			(
				for f in faces do
				(	
					a = polyop.getSafeFaceCenter poly f
					b = polyop.getFaceCenter poly f
					if a != undefined and b != undefined then
					(
						if distance a b > 0 then arr += #{f}
					)
					else arr += #{f}
				)
				return arr
			)
		) 
		else return arr
	)

	fn getmaps filename = for i in #{1..AssetManager.GetNumAssets()} where ((AssetManager.GetAssetByIndex i).getType()) == #Bitmap and getfilenamefile ((AssetManager.GetAssetByIndex i).getfilename()) == getfilenamefile filename collect ((AssetManager.GetAssetByIndex i).getfilename())

	fn rou x = 
	(
		local x5 = x as integer
		local x6 = if x >= 0 then (x + 0.5) as integer else (x - 0.5) as integer
		local x7 = if x >= 0 then (x + 1) as integer else (x - 1) as integer	
		local x3 = if x5 == x6 then x5 else x7
		x3
	)

	fn fit_map sourcepath finalpath pos sc rez start = 
	(
		if doesfileexist sourcepath then
		(
			--finalpath = (getfilenamepath sourcepath) + (getfilenamefile sourcepath) + "_fit.png"
			local bm = openbitmap sourcepath gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if bm != undefined then
			(
				local wid = bm.width
				local hei = bm.height
				close bm
				free bm
				if wid != rez or hei != rez then 
				(
					--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^!" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^! " + "\"" + finalpath + "\"") startpath:start
				)
				
				--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
				--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "%% " + "\"" + finalpath + "\"") startpath:start
				--возможно тут ошибка, потому что надо масштабировать текстуру к текущему размеру, а потом на увеличение масштаба, а тут идет перезапись заново,
				--надо второй раз ставить не sourcepath -> finalpath а надо finalpath -> finalpath
				--если размер исходной текстуры и целевого размера разный, то текстура пересчитается на новый масштаб размера помимо масштаба от развертки
				
				HiddenDOSCommand ("magick " + "\"" + finalpath + "\"" + " -resize " + (sc*100) as string + "%% " + "\"" + finalpath + "\"") startpath:start
				
				wid = rez
				hei = rez
				local x_ = -(pos.x - 0.5)
				local y_ = -(pos.y - 0.5)
				local x = ((x_ * wid) as integer) 
				local y = ((y_ * hei) as integer) 
				x = if x >= 0 then "+" + (x as string) else (x as string)
				y = if y >= 0 then "+" + (y as string) else (y as string)
				format "fit_map scale=% x=% % y=% %\n" sc x_ x y_ y
				cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
				HiddenDOSCommand cmd startpath:start
				HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:start
			)	
		)
	)	

	/*
	fn fit_map_mat sourcepath finalpath pos sc rez start = 
	(
		if doesfileexist sourcepath then
		(
			--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^!" + " +repage -resize " + (sc*100) as string + "%% " + "\"" + finalpath + "\"") startpath:start
				
			HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^! " + "\"" + finalpath + "\"") startpath:start
			HiddenDOSCommand ("magick " + "\"" + finalpath + "\"" + " -resize " + (sc * 100) as string + "%% " + "\"" + finalpath + "\"") startpath:start
			--HiddenDOSCommand ("magick " + "\"" + finalpath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start

			wid = rez
			hei = rez
			--print rez
			
			--pos.x = pos.x - (rou (pos.x))
			--pos.y = pos.y - (rou (pos.y))	
				
			--добавляется смещение на пэддинг
			local x_ = rou ( ( ((sc / 2) - pos.x) ) * wid ) 
			local y_ = rou ( ( ((sc / 2) - pos.y) ) * hei )
			
			--local x_ = rou (((sc / 2) - pos.x + 0.5 - pos.x) * wid) 
			--local y_ = rou (((sc / 2) - pos.y + 0.5 - pos.y) * hei)

			--local x_ = rou (- (wid * (1 - sc) / 2) + ((0.5 - pos.x) * wid)) 
			--local y_ = rou (- (hei * (1 - sc) / 2) - ((0.5 - pos.y) * hei))

			--local x_ = rou (-(wid*(1-sc)/2) + ((0.5 - pos.x) * wid)) 
			--local y_ = rou (-(hei*(1-sc)/2) - ((0.5 - pos.y) * hei))
			
			--local x_ = rou (-(wid*(sc)/2) + ((0.5 - pos.x) * wid)) 
			--local y_ = rou (-(hei*(sc)/2) - ((0.5 - pos.y) * hei))

			local x = if x_ >= 0 then "+" + (x_ as string) else (x_ as string)
			local y = if y_ >= 0 then "+" + (y_ as string) else (y_ as string)
			format "pos=% scale=% x=% y=%\n" pos sc x y
			cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
			HiddenDOSCommand cmd startpath:start				

				
				
				local x_
				local y_
				--if sc >= 1.0 then
				--(
					x_ = (0.5 + 1 - sc - pos.x) * wid
					y_ = (0.5 + 1 - sc - pos.y) * hei 
				--)
				--else
				--(
				--	x_ = (1 - sc - pos.x) * wid
				--	y_ = (1 - sc - pos.y) * hei 					
				--)
					
				--local x_ = (0.5 - pos.x - sc) * wid
				--local y_ = (0.5 - pos.y - sc) * hei

				--local x_ = (0.5 - pos.x) * wid
				--local y_ = (0.5 - pos.y) * hei
				
				local x_ = x_ as integer 
				local y_ = y_ as integer 	
				
				--local x_ = pos.x 
				--local y_ = pos.y

				--local x_ = - pos.x + 0.5*sc  -- -(pos.x - 0.5)
				--local y_ = - pos.y + 0.5*sc  -- -(pos.y - 0.5)
				
				--local x_ = - pos.x*sc + 0.5
				--local y_ = - pos.y*sc + 0.5 
				--local x_ = 0.5 * sc
				--local y_ = 0.5 * sc
				--local x_ = rou (sc*0.5) --((x_ * wid) as integer) 
				--local y_ = rou (sc*0.5) --((y_ * hei) as integer) 
				
				local x = if x_ >= 0 then "+" + (x_ as string) else (x_ as string)
				local y = if y_ >= 0 then "+" + (y_ as string) else (y_ as string)
				format "fit_map scale=% wid=% hei=% x=% y=%\n" sc wid hei x y
				
				--cmd = "magick " + "\"" + finalpath + "\"" + " -define distort:viewport=" + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
				--cmd = "magick " + "\"" + finalpath + "\"" + " -define distort:viewport=" + wid as string + "x" + hei as string + x + y + " -virtual-pixel edge -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
				cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
				--cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + "+0+0 -virtual-pixel Edge -filter point -distort SRT 0 +repage -roll " + x as string + "x" + y as string + " " + "\"" + finalpath + "\""
				--cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + "+0+0 -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""

				print cmd
				HiddenDOSCommand cmd startpath:start
				--HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\"" + finalpath + "\"") startpath:start
			--)	
			
		)
	)		
	*/
	
	fn fit_map_new sourcepath finalpath pos sc rez start = 
	(
		if doesfileexist sourcepath then
		(
			local bm = openbitmap sourcepath gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if bm != undefined then
			(
				local wid = bm.width
				local hei = bm.height
				close bm
				free bm
				if wid != rez or hei != rez then 
				(
					--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^!" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^! " + "\"" + finalpath + "\"") startpath:start
				)
				
				--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
				HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "%% " + "\"" + finalpath + "\"") startpath:start
				--возможно тут ошибка, потому что надо масштабировать текстуру к текущему размеру, а потом на увеличение масштаба, а тут идет перезапись заново,
				--надо второй раз ставить не sourcepath -> finalpath а надо finalpath -> finalpath
				--если размер исходной текстуры и целевого размера разный, то текстура пересчитается на новый масштаб размера помимо масштаба от развертки
				
				wid = rez
				hei = rez

				pos.x = pos.x - (rou (pos.x))
				pos.y = pos.y - (rou (pos.y))	
				
				--добавляется смещение на пэддинг
				local x_ = rou (-(wid*(1-sc)/2) + (pos.x * wid)) 
				local y_ = rou (-(hei*(1-sc)/2) - (pos.y * hei))
				
				--local x_ = (wid*(1-sc)/2 + (pos.x * wid)) as integer -- -(pos.x - 0.5)
				--local y_ = (hei*(1-sc)/2 + (pos.y * hei)) as integer -- -(pos.y - 0.5)
				
				--работало
				--local x_ = (pos.x * wid) as integer -- -(pos.x - 0.5)
				--local y_ = (pos.y * hei) as integer -- -(pos.y - 0.5)
				
				--local x = ((x_ * wid) as integer) 
				--local y = ((y_ * hei) as integer) 
				local x = if x_ >= 0 then "+" + (x_ as string) else (x_ as string)
				local y = if y_ >= 0 then "+" + (y_ as string) else (y_ as string)
				format "fit_map scale=% x=% % y=% %\n" sc x_ x y_ y
				cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel edge -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
				HiddenDOSCommand cmd startpath:start
				--HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:start
			)	
		)
	)		
	
	fn fit_map_edge sourcepath finalpath pos sc mX mY mWidth mHeight start = 
	(
		if doesfileexist sourcepath then
		(
			--finalpath = (getfilenamepath sourcepath) + (getfilenamefile sourcepath) + "_fit.png"
			local bm = openbitmap sourcepath gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if bm != undefined then
			(
				local wid = bm.width
				local hei = bm.height
				local alpha = bm.hasalpha
				close bm
				free bm
				
				--if wid != rez or hei != rez then 
				--(
				--	HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^! " + "\"" + finalpath + "\"") startpath:start
					--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^!" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
				--)
				--else
				--(
					if doesFileExist finalpath then deleteFile finalpath
					if doesFileExist sourcepath then copyfile sourcepath finalpath
					--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
				--)

				--local x_ = ( (mX+mWidth/2) * wid ) as integer
				--local y_ = ( (1-mY-mHeight/2) * hei ) as integer

				local x_ = ( -(mX-(mX as integer)) * wid ) as integer
				local y_ = ( -(1-(mY - (mY as integer))-mHeight) * hei ) as integer
					
				--local x = ( pos.x * wid ) as integer
				--local y = ( pos.y * hei ) as integer
					
				local x = if x_ >= 0 then "+" + (abs(x_) as string) else "-" + (abs(x_) as string)
				local y = if y_ >= 0 then "+" + (abs(y_) as string) else "-" + (abs(y_) as string)
				
				--x = "+0"
				--y = "+0"
					
				format "scale=% x=% y=% pos=% wid=% hei=% mX=% mY=% mWidth=% mHeight=%\n " sc x y pos wid hei mX mY mWidth mHeight

				--HiddenDOSCommand ("magick " + "\"" + finalpath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
				HiddenDOSCommand ("magick " + "\"" + finalpath + "\"" + " -resize " + (sc*100) as string + "%% " + "\"" + finalpath + "\"") startpath:start
				local cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
				--local cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + "+0+0" + " -virtual-pixel Background -filter point -distort SRT 0 +repage -roll " + x as string + "x" + y as string + " " + "\"" + finalpath + "\""
				--local cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + ((wid * sc) as integer) as string + "x" + ((hei * sc) as integer) as string + "+0+0 -virtual-pixel Background -filter point -distort SRT 0 +repage -resize " + wid as string + "x" + hei as string + "^! -roll " + x as string + "x" + y as string + " " + "\"" + finalpath + "\""
				--local cmd = if alpha then "magick " + "\"" + finalpath + "\"" + " -filter point -resize " + (100/sc) as string + "^% +repage -background none -alpha Background -gravity southeast -extent " + wid as string + "x" + hei as string + " -roll " + x as string + "x" + y as string + " -define png:color-type=6 " + "\"" + finalpath + "\"" 
				--	else "magick " + "\"" + finalpath + "\"" + " -filter point -resize " + (100/sc) as string + "^% +repage -background black -alpha remove -alpha off -gravity southeast -geometry " + x + y + " -extent " + wid as string + "x" + hei as string + " -define png:color-type=6 " + "\"" + finalpath + "\"" 
				--print cmd
				HiddenDOSCommand cmd startpath:start
				HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:start
			)	
		)
	)	

	fn RGBtoHEX clrRGB = 
	(
		local result = "#"
		sRGBr = rou clrRGB.r
		sRGBg = rou clrRGB.g
		sRGBb = rou clrRGB.b
		result += if (bit.intAsHex sRGBr) < bit.intAsHex 16 then "0" + (bit.intAsHex sRGBr) as string else (bit.intAsHex sRGBr) as string
		result += if (bit.intAsHex sRGBg) < bit.intAsHex 16 then "0" + (bit.intAsHex sRGBg) as string else (bit.intAsHex sRGBg) as string
		result += if (bit.intAsHex sRGBb) < bit.intAsHex 16 then "0" + (bit.intAsHex sRGBb) as string else (bit.intAsHex sRGBb) as string
		result
	)
	
	fn RGBtoHEX_r clrRGB = 
	(
		local result = "#"
		sRGBr = rou clrRGB.r
		result += if (bit.intAsHex sRGBr) < bit.intAsHex 16 then "0" + (bit.intAsHex sRGBr) as string else (bit.intAsHex sRGBr) as string
		result += "0000"
		result
	)
		
	fn RGBtoHEX_g clrRGB = 
	(
		local result = "#00"
		sRGBg = rou clrRGB.g
		result += if (bit.intAsHex sRGBg) < bit.intAsHex 16 then "0" + (bit.intAsHex sRGBg) as string else (bit.intAsHex sRGBg) as string
		result += "00"
		result
	)
	
	fn RGBtoHEX_b clrRGB = 
	(
		local result = "#0000"
		sRGBb = rou clrRGB.b
		result += if (bit.intAsHex sRGBb) < bit.intAsHex 16 then "0" + (bit.intAsHex sRGBb) as string else (bit.intAsHex sRGBb) as string
		result
	)
	
	fn copy_mat tex_ini tex_fin start =
	(
		--format "from=% to=%\n" tex_ini tex_fin
		if doesfileexist tex_ini then
		(
			if not doesfileexist tex_fin then HiddenDOSCommand ("magick " + "\"" + tex_ini + "\""+ " PNG24:" + "\""+ tex_fin + "\"") startpath:start
			--if doesfileexist tex_fin then deletefile tex_fin
			--copyfile tex_ini tex_fin
		)
		true
	)
	
	fn render_map tex size filename =
	(
		if tex != undefined then
		(
			local rm = renderMap tex size:[size, size] fileName:filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			save rm quiet:true gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if doesFileExist rm.filename then print ("saved rendered map " + (filename as string)) else print ("did not save rendered map " + (filename as string) ) 
			close rm	
			free rm			
		)		
	)
	
	fn valid_bump c = 
	(
		local r = false
		r = case of
		(
			--(c.r >= 254 and c.g >= 254 and c.b >= 254): true
			(c.r <= 1 and c.g <= 1 and c.b >= 254): true
			(c.r >= 254 and c.g <= 1 and c.b >= 254): true
			(c.r <= 1 and c.g >= 254 and c.b >= 254): true
			( abs(c.r - 128) <= 1 and abs(c.g - 128) <= 1 and c.b >= 254): true
			default: false
		)			
		r
	)
	
	fn valid_opacity c = 
	(
		local r = false
		r = case of
		(
			(c.r >= 254 and c.g >= 254 and c.b >= 254): true
			(c.r <= 1 and c.g <= 1 and c.b <= 1): true
			(c.r == c.g and c.r == c.b and c.b == c.g): true
			default: false
		)			
		r
	)
	
	fn valid_reflect c = 
	(
		local r = false
		r = case of
		(
			(c.r >= 254 and c.g >= 254 and c.b >= 254): true
			(c.r <= 1 and c.g <= 1 and c.b <= 1): true
			(c.r == c.g and c.r == c.b and c.b == c.g): true
			default: false
		)			
		r
	)
	
	fn get_tex_filename tex =
	(
		local tex_filename = ""
		if isproperty tex #filename then --if hasProperty tex "filename" then 
			tex_filename = for m in (getmaps (tex.filename as string)) where doesFileExist m do exit with m --ищем текстуру не только по пути, а по assettracker
		tex_filename
	)
	
	fn tex_equal_size tex size =
	(
		local resize = false
		local bt = openBitMap tex gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
		if bt != undefined then
		(
			resize = if bt.width == size and bt.height == size then false else true
			close bt
			free bt
		)
		else resize = false
		resize
	)
									
	
	fn map_type m type =
	(
		--брать включение материала on-off, множитель карты, саму карту, множитель альбедо
		--если нет карты в слоте, брать цветовое значение и его множители
		--рефракшн переводить в опасити с размытием глосси
		
		local result --#(map, color, map_on, mult)

		case classof m of
		(			
			default: result = #(undefined, black, false, 100.0) 
			CoronaLayeredMtl: result = #(undefined, black, false, 100.0)
			
			Vraymtl:
			(
				result = case type of
				(
					"diffuse": #(m.texmap_diffuse, m.diffuse, m.texmap_diffuse_on, m.texmap_diffuse_multiplier)  
					"opacity": #(m.texmap_opacity, white, m.texmap_opacity_on, m.texmap_opacity_multiplier)
					"normal": #(m.texmap_bump, black, m.texmap_bump_on, m.texmap_bump_multiplier) 
					"bump": #(m.texmap_bump, black, m.texmap_bump_on, m.texmap_bump_multiplier) 
					"reflect": #(m.texmap_reflection, m.reflection, m.texmap_reflection_on, m.texmap_reflection_multiplier * m.reflection_weight)
					"refract": #(m.texmap_refraction, m.refraction, m.texmap_refraction_on, m.texmap_refraction_multiplier)
					"reflect_glossiness": #(m.texmap_reflectionGlossiness, white, m.texmap_reflectionGlossiness_on, m.texmap_reflectionGlossiness_multiplier)
					"refract_glossiness": #(m.texmap_refractionGlossiness, white, m.texmap_refractionGlossiness_on, m.texmap_refractionGlossiness_multiplier)
					"selfillum": #(m.texmap_self_illumination, m.selfIllumination, m.texmap_self_illumination_on, m.texmap_self_illumination_multiplier)
					--"translucent": #(m.texmap_translucency_color, , , )
					--"displace": #(texmap_displacement, , , )
					default: #(undefined, black, false, 100.0) 
				)
				/*
				Vraymtl
				  .preset : integer
				  .diffuse : color
				  .diffuse_roughness : float
				  .selfIllumination (Self_illumination) : color
				  .selfIllumination_gi (Self_illumination_GI) : boolean
				  .selfIllumination_multiplier (Self_illumination_multiplier) : float
				  .compensate_camera_exposure : boolean
				  .reflection_weight : float
				  .reflection : color
				  .reflection_glossiness : float
				  .hilight_glossiness : float
				  .reflection_subdivs : integer
				  .reflection_fresnel (Fresnel_reflections) : boolean
				  .reflection_maxDepth (Reflection_max_depth) : integer
				  .reflection_exitColor (Reflection_exit_color) : color
				  .reflection_useInterpolation (Reflection_use_interpolation) : boolean
				  .reflection_ior (Fresnel_IOR) : float
				  .reflection_metalness : float
				  .reflection_lockGlossiness (Reflection_lock_glossiness) : boolean
				  .reflection_lockIOR (Reflection_lock_IOR) : boolean
				  .reflection_dimDistance (Reflection_dim_distance) : worldUnits
				  .reflection_dimDistance_on (Reflection_dim_distance_on) : boolean
				  .reflection_dimDistance_falloff (Reflection_dim_distance_falloff) : float
				  .reflection_affectAlpha (Reflection_affect_channels) : integer
				  .refraction : color
				  .refraction_glossiness : float
				  .refraction_subdivs : integer
				  .refraction_ior : float
				  .refraction_fogColor (Refraction_fog_color) : color
				  .refraction_fogMult (Refraction_fog_multiplier) : float
				  .refraction_fogDepth (Refraction_fog_depth) : float
				  .refraction_fogBias (Refraction_fog_bias) : float
				  .refraction_affectShadows (Refraction_affect_shadows) : boolean
				  .refraction_affectAlpha (Refraction_affect_channels) : integer
				  .refraction_maxDepth (Refraction_max_depth) : integer
				  .refraction_exitColor (Refract_exit_color) : color
				  .refraction_useExitColor (Refraction_use_exit_color) : boolean
				  .refraction_useInterpolation (Refraction_use_interpolation) : boolean
				  .refraction_dispersion : float
				  .refraction_dispersion_on : boolean
				  .refraction_thinWalled (Refraction_thin_walled) : boolean
				  .translucency_on (Translucency_type) : integer
				  .translucency_amount : float
				  .translucency_thickness : worldUnits
				  .translucency_scatterCoeff (Translucency_scatter_coefficient) : float
				  .translucency_fbCoeff (Translucency_fwd_bck_coefficient) : float
				  .translucency_multiplier : float
				  .translucency_color : color
				  .translucency_surfaceLighting (Translucency_surface_lighting) : integer
				  .sheen_color : color
				  .sheen_glossiness : float
				  .coat_color : color
				  .coat_amount : float
				  .coat_glossiness : float
				  .coat_ior : float
				  .coat_bump_lock : boolean
				  .coat_darkening : float
				  .thinFilm_on (Enable_thin_film) : boolean
				  .thinFilm_thickness_min (Min_thin_film_thickness) : float
				  .thinFilm_thickness_max (Max_thin_film_thickness) : float
				  .thinFilm_ior (Thin_film_IOR) : float
				  .brdf_type : integer
				  .anisotropy : float
				  .anisotropy_rotation : float
				  .anisotropy_derivation : integer
				  .anisotropy_axis : integer
				  .anisotropy_channel : integer
				  .soften : float
				  .brdf_fixDarkEdges (Fix_dark_edges) : boolean
				  .gtr_gamma (GTR_tail_falloff) : float
				  .brdf_useRoughness (Use_roughness) : boolean
				  .option_traceDiffuse (Trace_diffuse) : boolean
				  .option_traceReflection (Trace_reflections) : boolean
				  .option_traceRefraction (Trace_refractions) : boolean
				  .option_doubleSided (Double_sided) : boolean
				  .option_reflectOnBack (Reflect_on_backside) : boolean
				  .option_useIrradMap (Use_irradiance_map) : boolean
				  .refraction_fogUnitsScale_on (Refraction_fog_units_scaling_on) : boolean
				  .option_traceDiffuseAndGlossy : integer
				  .option_cutOff (Cutoff) : float
				  .preservationMode (Preservation_mode) : integer
				  .option_environment_priority (Environment_priority) : integer
				  .effect_id : integer
				  .override_effect_id : boolean
				  .option_clampTextures (Clamp_textures) : boolean
				  .option_opacityMode (Opacity_mode) : integer
				  .option_glossyFresnel (Glossy_Fresnel) : boolean
				  .option_diffuse_roughness_model : integer
				  .option_gtrEnergyCompensation : integer
				  .option_openPBRMode : boolean
				  .texmap_diffuse (Diffuse_map) : texturemap
				  .texmap_diffuse_on (Diffuse_map_on) : boolean
				  .texmap_diffuse_multiplier (Diffuse_map_multiplier) : float
				  .texmap_reflection (Reflection_map) : texturemap
				  .texmap_reflection_on (Reflection_map_on) : boolean
				  .texmap_reflection_multiplier (Reflection_map_multiplier) : float
				  .texmap_refraction (Refraction_map) : texturemap
				  .texmap_refraction_on (Refraction_map_on) : boolean
				  .texmap_refraction_multiplier (Refraction_map_multiplier) : float
				  .texmap_bump (Bump_map) : texturemap
				  .texmap_bump_on (Bump_map_on) : boolean
				  .texmap_bump_multiplier (Bump_map_multiplier) : float
				  .texmap_reflectionGlossiness (Reflection_glossiness_map) : texturemap
				  .texmap_reflectionGlossiness_on (Reflection_glossiness_map_on) : boolean
				  .texmap_reflectionGlossiness_multiplier (Reflection_glossiness_map_multiplier) : float
				  .texmap_refractionGlossiness (Refraction_glossiness_map) : texturemap
				  .texmap_refractionGlossiness_on (Refraction_glossiness_map_on) : boolean
				  .texmap_refractionGlossiness_multiplier (Refraction_glossiness_map_multiplier) : float
				  .texmap_refractionIOR (IOR_map) : texturemap
				  .texmap_refractionIOR_on (IOR_map_on) : boolean
				  .texmap_refractionIOR_multiplier (IOR_map_multiplier) : float
				  .texmap_displacement (Displacement_map) : texturemap
				  .texmap_displacement_on (Displacement_map_on) : boolean
				  .texmap_displacement_multiplier (Displacement_map_multiplier) : float
				  .texmap_translucent (Translucency_map) : texturemap
				  .texmap_translucent_on (Translucency_map_on) : boolean
				  .texmap_translucent_multiplier (Translucency_map_multiplier) : float
				  .texmap_translucency_amount (Translucency_amount_map) : texturemap
				  .texmap_translucency_amount_on (Translucency_amount_map_on) : boolean
				  .texmap_translucency_amount_multiplier (Translucency_amount_map_multiplier) : float
				  .texmap_environment (Environment_map) : texturemap
				  .texmap_environment_on (Environment_map_on) : boolean
				  .texmap_hilightGlossiness (Hilight_glossiness_map) : texturemap
				  .texmap_hilightGlossiness_on (Hilight_glossiness_map_on) : boolean
				  .texmap_hilightGlossiness_multiplier (notUsed) : float
				  .texmap_reflectionIOR (Fresnel_IOR_map) : texturemap
				  .texmap_reflectionIOR_on (Fresnel_IOR_map_on) : boolean
				  .texmap_reflectionIOR_multiplier (Fresnel_IOR_map_multiplier) : float
				  .texmap_opacity (Opacity_map) : texturemap
				  .texmap_opacity_on (Opacity_map_on) : boolean
				  .texmap_opacity_multiplier (Opacity_map_multiplier) : float
				  .texmap_roughness (Roughness_map) : texturemap
				  .texmap_roughness_on (Roughness_map_on) : boolean
				  .texmap_roughness_multiplier (Roughness_map_multiplier) : float
				  .texmap_anisotropy (Anisotropy_map) : texturemap
				  .texmap_anisotropy_on (Anisotropy_map_on) : boolean
				  .texmap_anisotropy_multiplier (Anisotropy_map_multiplier) : float
				  .texmap_anisotropy_rotation (Anisotropy_rotation_map) : texturemap
				  .texmap_anisotropy_rotation_on (Anisotropy_rotation_map_on) : boolean
				  .texmap_anisotropy_rotation_multiplier (Anisotropy_rotation_map_multiplier) : float
				  .texmap_refraction_fog (Fog_color_map) : texturemap
				  .texmap_refraction_fog_on (Fog_color_map_on) : boolean
				  .texmap_refraction_fog_multiplier (Fog_color_map_multiplier) : float
				  .texmap_refraction_fog_depth (Fog_depth_map) : texturemap
				  .texmap_refraction_fog_depth_on (Fog_depth_map_on) : boolean
				  .texmap_refraction_fog_depth_multiplier (Fog_depth_map_multiplier) : float
				  .texmap_self_illumination (Self_illumination_map) : texturemap
				  .texmap_self_illumination_on (Self_illumination_map_on) : boolean
				  .texmap_self_illumination_multiplier (Self_illumination_map_multiplier) : float
				  .texmap_gtr_tail_falloff (GTR_tail_falloff_map) : texturemap
				  .texmap_gtr_tail_falloff_on (GTR_tail_falloff_map_on) : boolean
				  .texmap_gtr_tail_falloff_multiplier (GTR_tail_falloff_map_multiplier) : float
				  .texmap_metalness (Metalness_map) : texturemap
				  .texmap_metalness_on (Metalness_map_on) : boolean
				  .texmap_metalness_multiplier (Metalness_map_multiplier) : float
				  .texmap_sheen (Sheen_color_map) : texturemap
				  .texmap_sheen_on (Sheen_color_map_on) : boolean
				  .texmap_sheen_multiplier (Sheen_color_map_multiplier) : float
				  .texmap_sheen_glossiness (Sheen_glossiness_map) : texturemap
				  .texmap_sheen_glossiness_on (Sheen_glossiness_map_on) : boolean
				  .texmap_sheen_glossiness_multiplier (Sheen_glossiness_map_multiplier) : float
				  .texmap_coat_color (Coat_color_map) : texturemap
				  .texmap_coat_color_on (Coat_color_map_on) : boolean
				  .texmap_coat_color_multiplier (Coat_color_map_multiplier) : float
				  .texmap_coat_amount (Coat_amount_map) : texturemap
				  .texmap_coat_amount_on (Coat_amount_map_on) : boolean
				  .texmap_coat_amount_multiplier (Coat_amount_map_multiplier) : float
				  .texmap_coat_glossiness (Coat_glossiness_map) : texturemap
				  .texmap_coat_glossiness_on (Coat_glossiness_map_on) : boolean
				  .texmap_coat_glossiness_multiplier (Coat_glossiness_map_multiplier) : float
				  .texmap_coat_ior (Coat_IOR_map) : texturemap
				  .texmap_coat_ior_on (Coat_IOR_map_on) : boolean
				  .texmap_coat_ior_multiplier (Coat_IOR_map_multiplier) : float
				  .texmap_coat_bump (Coat_bump_map) : texturemap
				  .texmap_coat_bump_on (Coat_bump_map_on) : boolean
				  .texmap_coat_bump_multiplier (Coat_bump_map_multiplier) : float
				  .texmap_thinFilm_thickness (Thin_film_thickness_map) : texturemap
				  .texmap_thinFilm_thickness_on (Thin_film_thickness_map_on) : boolean
				  .texmap_thinFilm_thickness_multiplier (Thin_film_thickness_map_multiplier) : float
				  .texmap_thinFilm_ior (Thin_film_IOR_map) : texturemap
				  .texmap_thinFilm_ior_on (Thin_film_IOR_map_on) : boolean
				  .texmap_thinFilm_ior_multiplier (Thin_film_IOR_map_multiplier) : float
				  .texmap_sheen_color (alias for texmap_sheen)
				  .texmap_sheen_color_multiplier (alias for texmap_sheen_multiplier)
				  .texmap_sheen_color_on (alias for texmap_sheen_on)
				  .texmap_translucency_color (alias for texmap_translucent)
				  .texmap_translucency_color_multiplier (alias for texmap_translucent_multiplier)
				  .texmap_translucency_color_on (alias for texmap_translucent_on)
				  .reflect_minRate (Reflection_interpolation_min_rate) : integer
				  .reflect_maxRate (Reflection_interpolation_max_rate) : integer
				  .reflect_interpSamples (Reflection_interpolation_samples) : integer
				  .reflect_colorThreshold (Reflection_interpolation_color_threshold) : float
				  .reflect_normalThreshold (Reflection_interpolation_normal_threshold) : float
				  .refract_minRate (Refraction_interpolation_min_rate) : integer
				  .refract_maxRate (Refraction_interpolation_max_rate) : integer
				  .refract_interpSamples (Refraction_interpolation_samples) : integer
				  .refract_colorThreshold (Refraction_interpolation_color_threshold) : float
				  .refract_normalThreshold (Refraction_interpolation_normal_threshold) : float				
				*/
			)

			CoronaLegacyMtl:
			(
				result = case type of
				(
					"diffuse": #(m.texmapDiffuse, (color (m.colorDiffuse.r * m.levelDiffuse) (m.colorDiffuse.g * m.levelDiffuse) (m.colorDiffuse.b * m.levelDiffuse)), m.texmapOnDiffuse, m.levelDiffuse * m.mapamountDiffuse)  
					"opacity": #(m.texmapOpacity, (color (m.colorOpacity.r * m.levelOpacity) (m.colorOpacity.g * m.levelOpacity) (m.colorOpacity.b * m.levelOpacity)), m.texmapOnOpacity, m.levelOpacity * m.mapamountOpacity)
					"normal": #(m.texmapBump, black, m.texmapOnBump, 100.0 * m.mapamountBump) 
					"bump": #(m.texmapBump, black, m.texmapOnBump, 100.0 * m.mapamountBump) 
					"reflect": #(m.texmapReflect, (color (m.colorReflect.r * m.levelReflect) (m.colorReflect.g * m.levelReflect) (m.colorReflect.b * m.levelReflect)), m.texmapOnReflect, m.levelReflect * m.mapamountReflect)
					"refract": #(m.texmapRefract, (color (m.colorRefract.r * m.levelRefract) (m.colorRefract.g * m.levelRefract) (m.colorRefract.b * m.levelRefract)), m.texmapOnRefract, m.levelRefract)
					"reflect_glossiness": #(m.texmapReflectGlossiness, white, m.texmapOnReflectGlossiness, m.mapamountReflectGlossiness)
					"refract_glossiness": #(m.texmapRefractGlossiness, white, m.texmapOnRefractGlossiness, m.mapamountRefractGlossiness)
					"selfillum": #(m.texmapSelfIllum, (color (m.colorSelfIllum.r * m.levelSelfIllum) (m.colorSelfIllum.g * m.levelSelfIllum) (m.colorSelfIllum.b * m.levelSelfIllum)), m.texmapOnSelfIllum, m.levelSelfIllum * m.mapamountSelfIllum)
					--"translucent": #()
					--"displace": #()
					default: #(undefined, black, false, 100.0) 			
				)
				
				/*
				CoronaLegacyMtl
				  .colorDiffuse : color
				  .colorReflect : color
				  .colorRefract : color
				  .colorOpacity : color
				  .colorTranslucency : color
				  .colorSelfIllum : color
				  .levelDiffuse : float
				  .levelReflect : float
				  .levelRefract : float
				  .levelOpacity : float
				  .levelTranslucency : float
				  .levelSelfIllum : float
				  .texmapDiffuse : texturemap
				  .texmapReflect : texturemap
				  .texmapReflectGlossiness : texturemap
				  .texmapRefract : texturemap
				  .texmapRefractGlossiness : texturemap
				  .texmapOpacity : texturemap
				  .texmapBump : texturemap
				  .texmapTranslucency : texturemap
				  .texmapReflectAnisotropy : texturemap
				  .texmapReflectAnisotropyRotation : texturemap
				  .texmapIor : texturemap
				  .texmapFresnelIor : texturemap
				  .texmapDisplace : texturemap
				  .texmapReflectBgOverride : texturemap
				  .texmapRefractBgOverride : texturemap
				  .texmapSelfIllum : texturemap
				  .texmapOnDiffuse : boolean
				  .texmapOnReflect : boolean
				  .texmapOnRefract : boolean
				  .texmapOnReflectGlossiness : boolean
				  .texmapOnRefractGlossiness : boolean
				  .texmapOnOpacity : boolean
				  .texmapOnBump : boolean
				  .texmapOnTranslucency : boolean
				  .texmapOnAnisotropy : boolean
				  .texmapOnAnisotropyRotation : boolean
				  .texmapOnIor : boolean
				  .texmapOnFresnelIor : boolean
				  .texmapOnDisplacement : boolean
				  .texmapOnReflectBgOverride : boolean
				  .texmapOnRefractBgOverride : boolean
				  .texmapOnSelfIllum : boolean
				  .mapamountDiffuse : float
				  .mapamountReflect : float
				  .mapamountRefract : float
				  .mapamountReflectGlossiness : float
				  .mapamountRefractGlossiness : float
				  .mapamountOpacity : float
				  .mapamountBump : float
				  .mapamountTranslucency : float
				  .mapamountAnisotropy : float
				  .mapamountAnisotropyRotation : float
				  .mapamountIor : float
				  .mapamountFresnelIor : float
				  .mapamountSelfIllum : float
				  .reflectGlossiness : float
				  .refractGlossiness : float
				  .fresnelIor : float
				  .ior : float
				  .absorptionDistance : worldUnits
				  .absorptionColor : color
				  .bsdf : integer
				  .anisotropy : float
				  .anisotropyRotation : float
				  .alphaMode : integer
				  .gBufferOverride : integer
				  .displacementMinimum : worldUnits
				  .displacementWaterLevel : float
				  .displacementMaximum : worldUnits
				  .thin : boolean
				  .caustics : boolean
				  .texmapTranslucencyFraction : texturemap
				  .texmapOnTranslucencyFraction : boolean
				  .mapamountTranslucencyFraction : float
				  .scatterColor : color
				  .scatterDirectionality : float
				  .mapamountAbsorption : float
				  .texmapOnAbsorption : boolean
				  .texmapAbsorption : texturemap
				  .mapamountScatterColor : float
				  .texmapOnScatterColor : boolean
				  .texmapScatterColor : texturemap
				  .removedParam : boolean
				  .singleBounceOnly : boolean
				  .displacementWaterLevelOn : boolean
				  .legacyMode : boolean
				  .anisotropyOrientationMode : integer
				  .anisotropyOrientationUvwChannel : integer
				  .pbrMode : boolean
				  .opacityCutout : boolean
				  .refractDispersionEnable : boolean
				  .refractDispersion : float
				  .levelSss : float
				  .sssScatterColor : color
				  .sssRadius : worldUnits
				  .texmapOnSssAmount : boolean
				  .texmapOnSssRadius : boolean
				  .texmapSssAmount : texturemap
				  .texmapSssRadius : texturemap
				  .mapamountSssAmount : float
				  .mapamountSssRadius : float
				  .texmapOnSssScatterColor : boolean
				  .texmapSssScatterColor : texturemap
				  .mapamountSssScatterColor : float
				  .materialLibraryId : string
				  .mediaMode : integer
				  .renderElementPropagation : integer
				  .enableVolumetricCaustics : boolean
				*/
				--texmapReflect 
				--texmapReflectGlossiness
				--texmapRefract
				--texmapRefractGlossiness
				--texmapTranslucency
				--texmapDisplace
				--texmapSelfIllum 
			)
			
			CoronaPhysicalMtl:
			(
				result = case type of
				(
					"diffuse": #(m.baseTexmap, (color (m.baseColor.r * m.baseLevel) (m.baseColor.g * m.baseLevel)  (m.baseColor.b * m.baseLevel)), m.baseTexmapOn, m.baseLevel * m.baseMapAmount)  
					"opacity": #(m.opacityTexmap, (color (m.opacityColor.r * m.opacityLevel) (m.opacityColor.g * m.opacityLevel) (m.opacityColor.b * m.opacityLevel)), m.opacityTexmapOn, m.opacityLevel * m.opacityMapAmount)    
					"normal": #(m.baseBumpTexmap, black, m.baseBumpTexmapOn, 100.0 * m.baseBumpMapAmount)       
					"bump": #(m.baseBumpTexmap, black, m.baseBumpTexmapOn, 100.0 * m.baseBumpMapAmount)     
					"reflect": #(undefined, white, false, 100.0)  			--metalnessMode	
					"refract": #(m.refractionAmountTexmap, black, m.refractionAmountTexmapOn, m.refractionAmount * m.refractionAmountMapAmount)  
					"reflect_glossiness": #(m.baseRoughnessTexmap, white, m.baseRoughnessTexmapOn, m.baseRoughness * m.baseRoughnessMapAmount)  
					"refract_glossiness": #(undefined, white, false, 100.0)   
					"selfillum": #(m.selfIllumTexmap, m.selfIllumColor, m.selfIllumTexmapOn, m.selfIllumLevel * m.selfIllumMapAmount)    
					--"translucent": #()
					--"displace": #()
					default: #(undefined, black, false, 100.0) 			
				)				
				/*
				CoronaPhysicalMtl
				  .baseColor : color
				  .baseLevel : float
				  .baseTexmap : texturemap
				  .baseTexmapOn : boolean
				  .baseMapAmount : float
				  .metalnessMode : integer
				  .opacityColor : color
				  .opacityLevel : float
				  .opacityTexmap : texturemap
				  .opacityTexmapOn : boolean
				  .opacityMapAmount : float
				  .opacityCutout : boolean
				  .baseRoughness : float
				  .baseRoughnessTexmap : texturemap
				  .baseRoughnessTexmapOn : boolean
				  .baseRoughnessMapAmount : float
				  .baseAnisotropy : float
				  .baseAnisotropyTexmap : texturemap
				  .baseAnisotropyTexmapOn : boolean
				  .baseAnisotropyMapAmount : float
				  .baseAnisoRotation : float
				  .baseAnisoRotationTexmap : texturemap
				  .baseAnisoRotationTexmapOn : boolean
				  .baseAnisoRotationMapAmount : float
				  .baseIor : float
				  .baseIorTexmap : texturemap
				  .baseIorTexmapOn : boolean
				  .baseIorMapAmount : float
				  .refractionAmount : float
				  .refractionAmountTexmap : texturemap
				  .refractionAmountTexmapOn : boolean
				  .refractionAmountMapAmount : float
				  .dispersionEnable : boolean
				  .dispersion : float
				  .useThinMode : boolean
				  .useCaustics : boolean
				  .clearcoatAmount : float
				  .clearcoatAmountTexmap : texturemap
				  .clearcoatAmountTexmapOn : boolean
				  .clearcoatAmountMapAmount : float
				  .clearcoatIor : float
				  .clearcoatIorTexmap : texturemap
				  .clearcoatIorTexmapOn : boolean
				  .clearcoatIorMapAmount : float
				  .clearcoatRoughness : float
				  .clearcoatRoughnessTexmap : texturemap
				  .clearcoatRoughnessTexmapOn : boolean
				  .clearcoatRoughnessMapAmount : float
				  .sheenAmount : float
				  .sheenAmountTexmap : texturemap
				  .sheenAmountTexmapOn : boolean
				  .sheenAmountMapAmount : float
				  .sheenColor : color
				  .sheenColorTexmap : texturemap
				  .sheenColorTexmapOn : boolean
				  .sheenColorMapAmount : float
				  .sheenRoughness : float
				  .sheenRoughnessTexmap : texturemap
				  .sheenRoughnessTexmapOn : boolean
				  .sheenRoughnessMapAmount : float
				  .volumetricAbsorptionColor : color
				  .volumetricAbsorptionTexmap : texturemap
				  .volumetricAbsorptionTexmapOn : boolean
				  .volumetricAbsorptionMapAmount : float
				  .volumetricScatteringColor : color
				  .volumetricScatteringTexmap : texturemap
				  .volumetricScatteringTexmapOn : boolean
				  .volumetricScatteringMapAmount : float
				  .attenuationDistance : worldUnits
				  .scatterDirectionality : float
				  .scatterSingleBounce : boolean
				  .sssAmount : float
				  .sssAmountTexmap : texturemap
				  .sssAmountTexmapOn : boolean
				  .sssAmountMapAmount : float
				  .sssRadius : worldUnits
				  .sssRadiusTexmap : texturemap
				  .sssRadiusTexmapOn : boolean
				  .sssRadiusMapAmount : float
				  .sssScatterColor : color
				  .sssScatterTexmap : texturemap
				  .sssScatterTexmapOn : boolean
				  .sssScatterMapAmount : float
				  .displacementMinimum : worldUnits
				  .displacementMaximum : worldUnits
				  .displacementWaterLevelOn : boolean
				  .displacementWaterLevel : float
				  .displacementTexmap : texturemap
				  .displacementTexmapOn : boolean
				  .selfIllumColor : color
				  .selfIllumLevel : float
				  .selfIllumTexmap : texturemap
				  .selfIllumTexmapOn : boolean
				  .selfIllumMapAmount : float
				  .alphaMode : integer
				  .gBufferOverride : integer
				  .anisotropyOrientationMode : integer
				  .anisotropyOrientationUvwChannel : integer
				  .renderElementPropagation : integer
				  .materialLibraryId : string
				  .baseBumpTexmap : texturemap
				  .baseBumpTexmapOn : boolean
				  .baseBumpMapAmount : float
				  .bgOverrideReflectTexmap : texturemap
				  .bgOverrideReflectTexmapOn : boolean
				  .bgOverrideRefractTexmap : texturemap
				  .bgOverrideRefractTexmapOn : boolean
				  .translucencyFraction : float
				  .translucencyFractionTexmap : texturemap
				  .translucencyFractionTexmapOn : boolean
				  .translucencyFractionMapAmount : float
				  .thinAbsorptionColor : color
				  .thinAbsorptionTexmap : texturemap
				  .thinAbsorptionTexmapOn : boolean
				  .thinAbsorptionMapAmount : float
				  .clearcoatAbsorptionColor : color
				  .clearcoatAbsorptionTexmap : texturemap
				  .clearcoatAbsorptionTexmapOn : boolean
				  .clearcoatAbsorptionMapAmount : float
				  .clearcoatBumpTexmap : texturemap
				  .clearcoatBumpTexmapOn : boolean
				  .clearcoatBumpMapAmount : float
				  .metalnessTexmap : texturemap
				  .metalnessTexmapOn : boolean
				  .roughnessMode : integer
				  .preset : integer
				  .edgeColor : color
				  .edgeColorTexmap : texturemap
				  .edgeColorTexmapOn : boolean
				  .edgeColorMapAmount : float
				  .translucencyColor : color
				  .translucencyColorTexmap : texturemap
				  .translucencyColorTexmapOn : boolean
				  .translucencyColorMapAmount : float
				  .useComplexIor : boolean
				  .complexIorNRed : float
				  .complexIorNGreen : float
				  .complexIorNBlue : float
				  .complexIorKRed : float
				  .complexIorKGreen : float
				  .complexIorKBlue : float
				  .iorMode : integer
				  .baseTail : float
				  .baseTailTexmap : texturemap
				  .baseTailTexmapOn : boolean
				  .baseTailMapAmount : float
				  .normalFilteringMode : integer
				  .enableVolumetricCaustics : boolean
				
				*/
				--baseTexmap
				--baseBumpTexmap
				--metalnessTexmap
				--baseRoughnessTexmap 
				--opacityTexmap 
			)
								
			Physical_Material:
			(
				--Рафнесс в глоссинесс, металлисити в рефлект
				result = case type of
				(
					"diffuse": #(m.base_color_map, m.base_color, m.base_color_map_on, m.base_weight)  
					"opacity": #(m.cutout_map, white, m.cutout_map_on, 100.0)  
					"normal": #(m.bump_map, black, m.bump_map_on, m.bump_map_amt)   
					"bump": #(m.bump_map, black, m.bump_map_on, m.bump_map_amt)   
					"reflect": #(m.reflectivity_map /*m.metalness_map*/, m.refl_color, m.refl_color_map_on /*m.metalness_map_on*/, m.metalness)  				
					"refract": #(undefined, black, false, 100.0) 
					"reflect_glossiness": #(m.roughness_map, black, m.roughness_map_on, m.roughness)  --roughness_inv
					"refract_glossiness": #(undefined, white, false, 100.0) 
					"selfillum": #(m.emission_map, m.emit_color, m.emission_map_on, m.emission /*m.emission_map*/)  
					--"translucent": #()
					--"displace": #()
					default: #(undefined, black, false, 100.0) 			
				)					
				
				/*
				Physical_Material
				  .material_mode : integer
				  .base_weight : float
				  .base_color : color
				  .reflectivity : float
				  .roughness : float
				  .roughness_inv : boolean
				  .metalness : float
				  .refl_color (Reflection_Color) : color
				  .diff_roughness (Diffuse_Roughness) : float
				  .brdf_mode : boolean
				  .brdf_low : float
				  .brdf_high : float
				  .brdf_curve (Brdf_Exponent) : float
				  .anisotropy : float
				  .anisoangle (Anisotropy_Angle) : float
				  .aniso_mode : integer
				  .aniso_channel : integer
				  .transparency : float
				  .trans_color (Transparency_Color) : color
				  .trans_depth (Transparency_Depth) : float
				  .trans_roughness (Transparency_Roughness) : float
				  .trans_roughness_inv : boolean
				  .trans_roughness_lock : boolean
				  .trans_ior (Index_of_Refraction) : float
				  .thin_walled : boolean
				  .dispersion : float
				  .trans_scatter_color (Transparency_Scatter_Color) : color
				  .trans_scatter_aniso (Transparency_Scatter_Anisotropy) : float
				  .scattering : float
				  .sss_color : color
				  .sss_depth : float
				  .sss_scale : float
				  .sss_scatter_color : color
				  .emission : float
				  .emit_color (Emission_Color) : color
				  .emit_luminance (Luminance) : float
				  .emit_kelvin (Kelvin_Degrees) : float
				  .coating (Coating_Weight) : float
				  .coat_color (Coating_Color) : color
				  .coat_roughness (Coating_Roughness) : float
				  .coat_roughness_inv : boolean
				  .coat_affect_color (Coating_Affect_Color) : float
				  .coat_affect_roughness (Coating_Affect_Roughness) : float
				  .coat_ior (Coating_IOR) : float
				  .coat_anisotropy (Coating_Anisotropy) : float
				  .coat_anisoangle (Coating_Anisotropy_Angle) : float
				  .sheen (Sheen_Weight) : float
				  .sheen_color : color
				  .sheen_roughness : float
				  .thin_film (Thin_Film_Weight) : float
				  .thin_film_thickness : float
				  .thin_film_ior : float
				  .base_weight_map : texturemap
				  .base_color_map : texturemap
				  .reflectivity_map : texturemap
				  .refl_color_map : texturemap
				  .roughness_map : texturemap
				  .metalness_map : texturemap
				  .diff_rough_map (Diffuse_Roughness_Map) : texturemap
				  .anisotropy_map : texturemap
				  .aniso_angle_map (Anisotropy_Angle_Map) : texturemap
				  .transparency_map : texturemap
				  .trans_color_map (Transparency_Color_Map) : texturemap
				  .trans_rough_map (Transparency_Roughness_Map) : texturemap
				  .trans_ior_map (IOR_Map) : texturemap
				  .scattering_map : texturemap
				  .sss_color_map : texturemap
				  .sss_scale_map : texturemap
				  .emission_map : texturemap
				  .emit_color_map (Emission_Color_Map) : texturemap
				  .coat_map (Coating_Weight_Map) : texturemap
				  .coat_color_map (Coating_Color_Map) : texturemap
				  .coat_rough_map (Coating_Roughness_Map) : texturemap
				  .bump_map : texturemap
				  .coat_bump_map (Coating_Bump_Map) : texturemap
				  .displacement_map : texturemap
				  .cutout_map : texturemap
				  .coat_aniso_map (Coating_Anisotropy_Map) : texturemap
				  .coat_aniso_angle_map (Coating_Anisotropy_Angle_Map) : texturemap
				  .sheen_map (Sheen_Weight_Map) : texturemap
				  .sheen_color_map : texturemap
				  .sheen_rough_map (Sheen_Roughness_Map) : texturemap
				  .thin_film_map (Thin_Film_Weight_Map) : texturemap
				  .thin_film_ior_map : texturemap
				  .base_weight_map_on : boolean
				  .base_color_map_on : boolean
				  .reflectivity_map_on : boolean
				  .refl_color_map_on : boolean
				  .roughness_map_on : boolean
				  .metalness_map_on : boolean
				  .diff_rough_map_on : boolean
				  .anisotropy_map_on : boolean
				  .aniso_angle_map_on : boolean
				  .transparency_map_on : boolean
				  .trans_color_map_on : boolean
				  .trans_rough_map_on : boolean
				  .trans_ior_map_on : boolean
				  .scattering_map_on : boolean
				  .sss_color_map_on : boolean
				  .sss_scale_map_on : boolean
				  .emission_map_on : boolean
				  .emit_color_map_on : boolean
				  .coat_map_on : boolean
				  .coat_color_map_on : boolean
				  .coat_rough_map_on : boolean
				  .coat_aniso_map_on : boolean
				  .coat_aniso_angle_map_on : boolean
				  .sheen_map_on : boolean
				  .sheen_color_map_on : boolean
				  .sheen_rough_map_on : boolean
				  .thin_film_map_on : boolean
				  .thin_film_ior_map_on : boolean
				  .bump_map_on : boolean
				  .coat_bump_map_on : boolean
				  .displacement_map_on : boolean
				  .cutout_map_on : boolean
				  .bump_map_amt (Bump_Map_Amount) : float
				  .clearcoat_bump_map_amt (Coating_Bump_Map_Amount) : float
				  .displacement_map_amt (Displacement_Map_Amount) : float
				  .EffectiveLuminance : color
				*/
				--base_color_map
				--bump_map
				--roughness_map 
				--cutout_map
				--emission_map
				--emit_color
				--metalness_map
			)

			Standardmaterial:
			(
				result = case type of
				(
					"diffuse": #(m.diffuseMap, m.diffuse, m.diffuseMapEnable, m.diffuseMapAmount)  
					"opacity": #(m.opacityMap, white, m.opacityMapEnable, m.opacityMapAmount * m.opacity)  
					"normal": #(m.bumpMap, black, m.bumpMapEnable, m.bumpMapAmount)    
					"bump": #(m.bumpMap, black, m.bumpMapEnable, m.bumpMapAmount)    
					"reflect": #(m.specularMap, m.specular, m.specularMapEnable, m.specularMapAmount)   
					--"reflect": #( m.reflectionMap, black, m.specularMapEnable, m.reflectionMapAmount)    				
					"refract": #(m.refractionMap, black, refractionMapEnable, refractionMapAmount)  
					"reflect_glossiness": #(m.glossinessMap, white, m.glossinessMapEnable, m.glossinessMapAmount)  
					"refract_glossiness": #(undefined, white, false, 100.0)  
					"selfillum": #(m.selfIllumMap, m.selfIllumColor, m.selfIllumMapEnable, m.selfIllumAmount / 100 * m.selfIllumMapAmount)   
					--"translucent": #()
					--"displace": #()
					default: #(undefined, black, false, 100.0) 			
				)	
				
				/*
				Standardmaterial
				  .shaderType : integer
				  .wire : boolean
				  .twoSided : boolean
				  .faceMap : boolean
				  .faceted : boolean
				  .shaderByName : string
				  .opacityType : integer
				  .opacity : percent
				  .filterColor (Filter_Color) : color
				  .filterMap (Filter_Map) : texturemap
				  .opacityFallOffType : integer
				  .opacityFallOff (Falloff) : percent
				  .ior (Index_of_Refraction) : float
				  .wireSize (Wire_Size) : float
				  .wireUnits : integer
				  .applyReflectionDimming : boolean
				  .dimLevel (Dim_Level) : float
				  .reflectionLevel (Reflection_Level) : float
				  .sampler : integer
				  .samplerQuality (Sampler_Quality) : float
				  .samplerEnable (Sampler_Enable) : boolean
				  .samplerAdaptThreshold : float
				  .samplerAdaptOn : boolean
				  .subSampleTextureOn : boolean
				  .samplerAdvancedOptions : boolean
				  .samplerByName : string
				  .UserParam0 : float
				  .UserParam1 : float
				  .samplerUseGlobal : boolean
				  .mapEnables : boolean array
				  .maps : texturemap array
				  .mapAmounts : percent array
				  .adTextureLock : boolean
				  .ambientMap (alias for maps[0])
				  .ambientMapAmount (alias for mapAmounts[0])
				  .ambientMapEnable (alias for mapEnables[0])
				  .bumpMap (alias for maps[8])
				  .bumpMapAmount (alias for mapAmounts[8])
				  .bumpMapEnable (alias for mapEnables[8])
				  .diffuseMap (alias for maps[1])
				  .diffuseMapAmount (alias for mapAmounts[1])
				  .diffuseMapEnable (alias for mapEnables[1])
				  .displacementMap (alias for maps[11])
				  .displacementMapAmount (alias for mapAmounts[11])
				  .displacementMapEnable (alias for mapEnables[11])
				  .filterMap (alias for maps[7])
				  .filterMapAmount (alias for mapAmounts[7])
				  .filterMapEnable (alias for mapEnables[7])
				  .glossinessMap (alias for maps[4])
				  .glossinessMapAmount (alias for mapAmounts[4])
				  .glossinessMapEnable (alias for mapEnables[4])
				  .opacityMap (alias for maps[6])
				  .opacityMapAmount (alias for mapAmounts[6])
				  .opacityMapEnable (alias for mapEnables[6])
				  .reflectionMap (alias for maps[9])
				  .reflectionMapAmount (alias for mapAmounts[9])
				  .reflectionMapEnable (alias for mapEnables[9])
				  .refractionMap (alias for maps[10])
				  .refractionMapAmount (alias for mapAmounts[10])
				  .refractionMapEnable (alias for mapEnables[10])
				  .selfIllumMap (alias for maps[5])
				  .selfIllumMapAmount (alias for mapAmounts[5])
				  .selfIllumMapEnable (alias for mapEnables[5])
				  .specularLevelMap (alias for maps[3])
				  .specularLevelMapAmount (alias for mapAmounts[3])
				  .specularLevelMapEnable (alias for mapEnables[3])
				  .specularMap (alias for maps[2])
				  .specularMapAmount (alias for mapAmounts[2])
				  .specularMapEnable (alias for mapEnables[2])
				  .noExposureControl : boolean
				  .exposureControlInvertSelfIllum : boolean
				  .exposureControlInvertReflection : boolean
				  .exposureControlInvertRefraction : boolean
				  .ambient (Ambient_Color) : color
				  .diffuse (Diffuse_Color) : color
				  .specular (Specular_Color) : color
				  .adTextureLock : boolean
				  .adLock : boolean
				  .dsLock : boolean
				  .useSelfIllumColor : boolean
				  .selfIllumAmount (Self_Illumination) : percent
				  .selfIllumColor (Self_Illum_Color) : color
				  .specularLevel (Specular_Level) : percent
				  .glossiness : percent
				  .soften : float
				*/
				
				--DiffuseMap 
				--BumpMap 
				--ReflectionMap
				--OpacityMap 
				--GlossinessMap
			)
		)
		result
	)
	
	fn render_map_rect tex size size_thumb filename not_make_thumb start type =
	(
		if tex != undefined then
		(
			print tex
			
			local size1 = size
			local size2 = size
			
			local _copy_ = false
			local filename_temp = filename + ".png" --для картинки числа уникальных цветов, ширина = уникальные цвета
			
			--если исходная текстура в размер готовой, то ее копируем, если нет	то рендерим, также проверяем, есть ли у текстуры свойство filename, вдруг это другая карта
			if isproperty tex #filename then --if hasProperty tex "filename" then 
			(
				local tex_filename = ""
				for m in (getmaps (tex.filename as string)) where doesFileExist m do (tex_filename = m; exit) --ищем текстуру не только по пути, а по assettracker
				
				local b = openBitMap (tex_filename as string) --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
				if b != undefined then
				(
					format "% % %\n" b b.width b.height

					if b.width != b.height then
					(
						if b.width > b.height then 
						(
							size1 = size
							size2 = size * b.height / b.width
						)
						else
						(
							size2 = size
							size1 = size * b.height / b.width					
						)
					)	
					
					if b.width == size and b.height == size then _copy_ = true
						
					if not not_make_thumb and b.width == size_thumb and b.height == size_thumb then 
					(
						size1 = size_thumb
						size2 = size_thumb
					)
					
					close b
					free b	
					
					if doesFileExist filename then deleteFile filename
					if _copy_ then 
					(
						if type != "Opacity" then 
						(
							/*
							if (getFilenameType (tex.filename as string)) == ".png" then 
							(
								copyFile (tex.filename as string) filename
								--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -background black -alpha remove -alpha off " + "\"" + filename + "\"") startpath:start --(getINISetting (GetDir #maxroot + "\\GeoScripts\\GeoAGR.ini") "Directories" "ImageMagick")
								--print ("copied " + (tex.filename as string) + " to " + (filename as string))
							)
							else 
							(
								HiddenDOSCommand ("magick " + "\"" + (tex.filename as string) + "\"" + " -define png:color-type=6 " + "\"" + filename + "\"") startpath:start --(getINISetting (GetDir #maxroot + "\\GeoScripts\\GeoAGR.ini") "Directories" "ImageMagick")
								--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off " + "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())
								--print ("magick " + "\"" + (tex.filename as string) + "\"" + " " + "\"" + filename + "\"")
							)
							*/
							HiddenDOSCommand ("magick " + "\"" + (tex_filename as string) + "\"" + " -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						)
						else
						(
							local alpha = false
							local b = openBitMap (tex_filename as string) --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
							if b != undefined then
							(
								if b.hasalpha then alpha = true else alpha = false
								close b
								free b		
									
								if alpha then
								(
									HiddenDOSCommand ("magick " + "\"" + (tex_filename as string) + "\"" + " -background black -alpha extract -unique-colors " + "\"" + filename_temp + "\"") startpath:start
									local bt = openBitMap filename_temp --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
									if bt != undefined then
									(
										if bt.width == 1 then 
										(
											--messageBox ("has alpha, width 1")
											HiddenDOSCommand ("magick " + "\"" + (tex_filename as string) + "\"" + " -threshold 50%% -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
										)
										else
										(
											--messageBox ("has alpha, width >1")
											HiddenDOSCommand ("magick " + "\"" + (tex_filename as string) + "\"" + " -transparent black -background black -alpha extract -threshold 50%% -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
										)
										close bt
										free bt	
										--if doesFileExist filename then deleteFile filename
										--HiddenDOSCommand ("magick " + "\"" + filename + ".jpg" + "\"" + " " + "\"" + filename + "\"") startpath:start	
										--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -alpha extract -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
									)
								)
								else
								(
									--messageBox ("no alpha")
									HiddenDOSCommand ("magick " + "\"" + (tex_filename as string) + "\"" + " -threshold 50%% -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
								)
							)
							--HiddenDOSCommand ("magick " + "\"" + (tex.filename as string) + "\"" + " " + "\"" + filename + "\"") startpath:start --(getINISetting (GetDir #maxroot + "\\GeoScripts\\GeoAGR.ini") "Directories" "ImageMagick")
						)
					)
				)
			)
			--print (classof tex)
			--print filename
			format "copy=%\n" _copy_
			if not _copy_ then
			(
				if doesFileExist filename then deleteFile filename
				local rm = renderMap tex size:[size1, size2] fileName:filename --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
				save rm quiet:true --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
				if doesFileExist rm.filename then print ("saved rendered map " + (filename as string)) else print ("did not save rendered map " + (filename as string)) 
				close rm	
				free rm		
			)

			case type of
			(
				"Diffuse":
				(
					HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -background black -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start --(getINISetting (GetDir #maxroot + "\\GeoScripts\\GeoAGR.ini") "Directories" "ImageMagick")
				)
				
				"Bump":
				(
					--проверять цвета на палитру normal, если не они, делать карты заново
					--HiddenDOSCommand ("normalmap.exe " + "\"" + filename + "\"" + " " + "\"" + filename + "\"" ) startpath:start
					HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -separate -threshold 50%% -combine -colors 32 -unique-colors " + "\"" + filename_temp + "\"") startpath:start
					local bt = openBitMap filename_temp --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
					if bt != undefined then
					(
						bt.gamma = 1.0
						local colors_quantity = #()
						if bt.width <= 32 then 
						(
							local line_bitmap = getPixels bt [0, 0] bt.width linear:true
							for pixel in line_bitmap where valid_bump pixel do append colors_quantity pixel							
							if (colors_quantity.count == 1 and bt.width == 1) or (colors_quantity.count == 4 and bt.width == 4) then ()
							else HiddenDOSCommand ("normalmap.exe " + "\"" + filename + "\"" + " " + "\"" + filename + "\"" ) startpath:start
						)
						else HiddenDOSCommand ("normalmap.exe " + "\"" + filename + "\"" + " " + "\"" + filename + "\"" ) startpath:start
						close bt
						free bt
					)
				)
				
				"Reflect":
				(
					--проверять цвета, если не чб, делать чб и загонять как erm канал
					--проверять, если erm канал по имени, то ничего не делать, итак в конце сделается
					if findstring (getfilenamefile filename) "_ERM_" == undefined then 
					(
						HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -separate -threshold 50%% -combine -colors 32 -unique-colors " + "\"" + filename_temp + "\"") startpath:start
						local bt = openBitMap filename_temp --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
						if bt != undefined then
						(
							bt.gamma = 1.0
							local colors_quantity = #()
							if bt.width <= 32 then 
							(
								local line_bitmap = getPixels bt [0, 0] bt.width linear:true
								for pixel in line_bitmap where valid_reflect pixel do append colors_quantity pixel							
								if colors_quantity.count != bt.width then 
								--делать чб картинку, загонять в канал ERM
								HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -monochrome -channel G -separate -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
							)
							close bt
							free bt
						)						
					)
					
				)
				
				"Opacity":
				(

					--вынимать альфу, проверять если не белая текстура, если чб, то оставлять как есть
					--print ("magick " + "\"" + filename + "\"" + " -background black -alpha extract -monochrome -alpha remove -alpha off png:color-type=6 " + "\"" + filename+ "\"")
					--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -background black -alpha extract -threshold 50%% -alpha remove -alpha off -monochrome " + "\"" + filename + ".jpg" + "\"") startpath:start
					--HiddenDOSCommand ("magick " + "\"" + filename + ".jpg" + "\"" + " " + "\"" + filename + "\"") startpath:start
					--if doesFileExist (filename + ".jpg") then deleteFile (filename + ".jpg")
					--if doesFileExist (filename + ".jpg") then copyFile (filename + ".jpg") filename

					local alpha = false
					local b = openBitMap filename --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
					if b != undefined then
					(
						if b.hasalpha then alpha = true else alpha = false
						close b
						free b		
									
						if alpha then
						(
							HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -background black -alpha extract -unique-colors " + "\"" + filename_temp + "\"") startpath:start
							local bt = openBitMap filename_temp --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
							if bt != undefined then
							(
								if bt.width == 1 then --альфаканал в виде сплошного цвета
								(
									--messageBox ("has alpha, width 1")
									HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off -threshold 50%% -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
								)
								else
								(
									--messageBox ("has alpha, width >1")
									HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -background black -alpha extract -threshold 50%% -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
								)
								close bt
								free bt	
								--if doesFileExist filename then deleteFile filename
								--HiddenDOSCommand ("magick " + "\"" + filename + ".jpg" + "\"" + " " + "\"" + filename + "\"") startpath:start	
								--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -alpha extract -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
							)
						)
						else
						(
							--messageBox ("no alpha")
							HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off -threshold 50%% -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						)
					)
						

						/*
						if b.hasalpha then 
						(
							HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -background black -alpha extract -threshold 50%% -alpha remove -alpha off " + "\"" + filename + "\"") startpath:start
							--if doesFileExist filename then deleteFile filename
							--HiddenDOSCommand ("magick " + "\"" + filename + ".jpg" + "\"" + " " + "\"" + filename + "\"") startpath:start	
							--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -alpha extract -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						)
						else 
						(
							HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -threshold 50%% -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						)
						close b
						free b								
					*/
					
					/*			
					HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -separate -threshold 50%% -combine -colors 32 -unique-colors " + "\"" + filename_temp + "\"") startpath:start
					local bt = openBitMap filename_temp gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
					if bt != undefined then
					(
						bt.gamma = 1.0
						local colors_quantity = #()
						if bt.width <= 32 then 
						(
							local line_bitmap = getPixels bt [0, 0] bt.width linear:true
							for pixel in line_bitmap where valid_opacity pixel do append colors_quantity pixel							
							if colors_quantity.count != bt.width then 
							(
								--вынимать альфу, если есть, если нет - делать чб картинку
								local b = openBitMap filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
								if b != undefined then
								(
									if b.hasalpha then HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -alpha extract -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
									else HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -monochrome -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
									close b
									free b								
								)
							)
							else
						)
						close bt
						free bt
					)
					*/
				)
			)
			
			local b = openBitMap filename --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if b != undefined then
			(
				local b_width = b.width
				local b_height = b.height
				close b
				free b	
				--if not not_make_thumb and b_width == size_thumb and b_height == size_thumb then 
				if (b_height != size or b_width != size) and (b_width != size_thumb and b_height != size_thumb) then
				(
					HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -interpolate Integer -filter point -resize " + size as string + "x" + size as string + "^! -define png:color-type=6 " + "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())
				)
			)
			--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off " + "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())
			if doesFileExist filename_temp then deleteFile filename_temp
		)		
	)
	
	fn render_map_diffuse tex tex_color tex_enabled tex_amount size filename start = 
	(
		if not doesDirectoryExist (getFilenamePath filename) then makeDir (getFilenamePath filename)
		local filename_temp = filename + ".png"
		
		if tex != undefined and tex_enabled then
		(
			local rm = renderMap tex size:[size, size] fileName:filename --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			save rm quiet:true --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if doesFileExist filename then print ("saved diffuse rendered map " + (filename as string)) else print ("did not save diffuse rendered map " + (filename as string) ) 
			--if doesFileExist (filename+".jpg") then deleteFile (filename+".jpg")
			--copyfile filename (filename+".jpg")
			close rm	
			free rm	
				
			--надо проверять, заглушка ли это (если нет альфы или альфа залитая цветом), если да, то делать ее маленьким размером

			local alpha = false
			local b = openBitMap (filename as string) --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if b != undefined then
			(
				alpha = if b.hasalpha then true else false
				close b
				free b		
				if alpha then
				(
					print "Diffuse have alpha"
					HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\"" + " -background black -alpha extract -unique-colors " + "\"" + filename_temp + "\"") startpath:start
					local bt = openBitMap filename_temp --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
					if bt != undefined then
					(
						format "alpha colors = % \n" bt.width
						if bt.width == 1 then 
						(
							--messageBox ("has alpha, width 1")
							--альфа в диффузе есть, но она сплошной цвет, тогда ее отключаем
							print "Diffuse have alpha, but its solid -> turn off"
							--print ("magick " + "\"" + (filename as string) + "\"" + " -brightness-contrast " + ((tex_amount - 100.0) as integer) as string + "x0 -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"")
							--HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\"" + " -brightness-contrast " + "0x-50 -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
							--magick bgnd overlay -compose blend -define compose:args={src_percent},{dst_percent} -composite result
							HiddenDOSCommand ("magick " + " ( -size " + size as string + "x" + size as string + " xc:black ) " + "\"" + (filename as string) + "\"" + " -compose blend -define compose:args=" + (tex_amount as integer) as string + " -composite -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
							HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\"" + " PNG24:" + "\""+ (filename as string) + "\"") startpath:start
						)
						else
						(
							--messageBox ("has alpha, width >1")
							--альфа в диффузе есть, она из разных цветов, тогда оставляем файл диффуза как есть
							print "Diffuse have alpha, not solid -> stay turn on"
							--print ("magick " + "\"" + (filename as string) + "\"" + " -brightness-contrast " + ((tex_amount - 100.0) as integer) as string + "x0 -alpha on -define png:color-type=6 " + "\"" + (filename as string) + "\"")
							--HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\"" + " -brightness-contrast " + "0x-50 -alpha on -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
							HiddenDOSCommand ("magick " + " ( -size " + size as string + "x" + size as string + " xc:black ) " + "\"" + (filename as string) + "\"" + " -compose blend -define compose:args=" + (tex_amount as integer) as string + " -composite -alpha on -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
							--print ("magick " + "\"" + (filename as string) + "\"" + " -brightness-contrast " + (tex_amount - 100.0) as string + "%% -alpha on -define png:color-type=6 " + "\"" + (filename as string) + "\"")
						)
						close bt
						free bt	
						if doesFileExist filename_temp then deleteFile filename_temp
					)
				)
				else
				(
					--messageBox ("no alpha")
					--тогда оставляем файл диффуза как есть
					print "Diffuse have alpha, not solid -> stay turn on"
					--print ("magick " + "\"" + (filename as string) + "\"" + " -brightness-contrast " + ((tex_amount - 100.0) as integer) as string + "x0 -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"") 
					--HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\"" + " -brightness-contrast " + "0x-50 -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
					HiddenDOSCommand ("magick " + " ( -size " + size as string + "x" + size as string + " xc:black ) " + "\"" + (filename as string) + "\"" + " -compose blend -define compose:args=" + (tex_amount as integer) as string + " -composite -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\"" + " PNG24:" + "\""+ (filename as string) + "\"") startpath:start
				)
			)
			--проверяем на колво цветов дифуз, если он с одним цветом, делаем его заглушкой
			if doesFileExist filename_temp then deleteFile filename_temp
			HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -colors 4096 -unique-colors " + "\"" + filename_temp + "\"") startpath:start	
			local bt = openBitMap filename_temp --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			local b = openBitMap (filename as string) --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			alpha = false
			if b != undefined then
			(
				alpha = if b.hasalpha then true else false
				close b
				free b
			)		
			else alpha = false
			
			if bt != undefined then
			(
				format "Diffuse colors count: %, have alpha: % \n" bt.width alpha
				if bt.width == 1 and not alpha then 
				(
					print "Diffuse have only one color -> resize to 256"
					--print ("magick " + "\"" + (filename as string) + "\"" + " -resize 256x256 -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"")
					HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\"" + " -resize 256x256 -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\""+ " PNG24:" + "\"" + (filename as string) + "\"") startpath:start --(GetINI_ImageMagick())
				)
				close bt
				free bt	
			)
			if doesFileExist filename_temp then deleteFile filename_temp
		)
		else
		(
			print "Diffuse have no texture - make solid 256 size"
			--HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX tex_color + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + (filename as string) + "\"") startpath:start --(GetINI_ImageMagick())
			HiddenDOSCommand ("magick " + " ( -size 256x256 xc:black ) ( -size 256x256 canvas:" + RGBtoHEX tex_color + " ) -compose blend -define compose:args=" + (tex_amount as integer) as string + " -composite -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
			HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\""+ " PNG24:" + "\"" + (filename as string) + "\"") startpath:start --(GetINI_ImageMagick())
		)
	)
	
	/*
	fn render_map_diffuse_opacity tex tex_opacity size filename start = 
	(
		local filename_opacity = filename + "_opacity.png"
		local filename_temp = filename + ".png"
		local opacity = false
		
		if tex_opacity != undefined then
		(				
			local rm = renderMap tex_opacity size:[size, size] fileName:filename_opacity gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			save rm quiet:true gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if doesFileExist rm.filename_opacity then 
			(
				print ("saved rendered map " + (filename_opacity as string)) 
				opacity = true
			)
			else 
			(
				print ("did not save rendered map " + (filename_opacity as string) ) 
				opacity = false
			)
			close rm	
			free rm	
			local bt = openBitMap filename_opacity gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if bt != undefined then
			(
				if bt.width == 1 then 
				(
					--messageBox ("has alpha, width 1")
					--opacity есть, но она сплошной цвет, тогда оставляем всё как есть
					opacity = false
				)
				else
				(
					--messageBox ("has alpha, width >1")
					--opacity есть, она из разных цветов, тогда надо будет внедрять ее в диффуз
					opacity = true
				)
				close bt
				free bt	
				--рано if doesFileExist filename_opacity then deleteFile filename_opacity
			)
		)
		else opacity = false
			
		if tex != undefined then
		(
			local rm = renderMap tex size:[size, size] fileName:filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			save rm quiet:true gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if doesFileExist rm.filename then print ("saved rendered map " + (filename as string)) else print ("did not save rendered map " + (filename as string) ) 
			close rm	
			free rm	

			local alpha = false
			local b = openBitMap (filename as string) gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if b != undefined then
			(
				if b.hasalpha then alpha = true else alpha = false
				close b
				free b		
				if alpha then
				(
					HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\"" + " -background black -alpha extract -unique-colors " + "\"" + filename_temp + "\"") startpath:start
					local bt = openBitMap filename_temp gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
					if bt != undefined then
					(
						if bt.width == 1 then 
						(
							--messageBox ("has alpha, width 1")
							--альфа в диффузе есть, но она сплошной цвет, тогда ее отключаем
							HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
						)
						else
						(
							--messageBox ("has alpha, width >1")
							--альфа в диффузе есть, она из разных цветов, тогда оставляем файл диффуза как есть
						)
						close bt
						free bt	
						if doesFileExist filename_temp then deleteFile filename_temp
					)
				)
				else
				(
					--messageBox ("no alpha")
					--тогда оставляем файл диффуза как есть
					HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + (filename as string) + "\""+ " PNG24:" + "\""+ (filename as string) + "\"") startpath:start
				)
			)
			
			if opacity then 
			(
				--magick composite -compose CopyOpacity mask_bite2.png drawn.png drawn_bite2.png
				HiddenDOSCommand ("magick composite -compose CopyOpacity " + "\"" + (filename_opacity as string) + "\"" + " " + "\"" + (tex_filename as string) + "\"" + " -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
			)
			if doesFileExist filename_opacity then deleteFile filename_opacity	
		)
	)
	*/
	
	fn render_map_opacity tex_opacity tex_color tex_enabled tex_amount size filename_diffuse start = 
	(
		if not doesDirectoryExist (getFilenamePath filename_diffuse) then makeDir (getFilenamePath filename_diffuse)
		local filename_opacity = filename_diffuse + "_opacity.png"
		local filename_temp = filename_diffuse + ".png"
		local opacity = false
		
		if tex_opacity != undefined and tex_enabled then
		(				
			local rm = renderMap tex_opacity size:[size, size] fileName:filename_opacity --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			save rm quiet:true --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			close rm	
			free rm				
			if doesFileExist (filename_opacity as string) then 
			(
				print ("saved opacity rendered map " + (filename_opacity as string)) 
				opacity = true
			)
			else 
			(
				print ("did not save opacity rendered map " + (filename_opacity as string) ) 
				opacity = false
			)

			HiddenDOSCommand ("magick " + "\"" + filename_opacity + "\"" + " -unique-colors " + "\"" + filename_temp + "\"") startpath:start
			local bt = openBitMap filename_temp --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if bt != undefined then
			(
				if bt.width == 1 then 
				(
					print "opacity map is solid, do not add to diffuse map"
					--messageBox ("has alpha, width 1")
					--opacity есть, но она сплошной цвет, тогда оставляем всё как есть
					opacity = false
				)
				else
				(
					print "opacity map not solid, add it to diffuse map"
					--messageBox ("has alpha, width >1")
					--opacity есть, она из разных цветов, тогда надо будет внедрять ее в диффуз
					opacity = true
				)
				close bt
				free bt	
				if doesFileExist filename_temp then deleteFile filename_temp
			)
			else opacity = false
		)
		else 
		(
			print "Opacity is a color, not texture"
			if tex_color == white then opacity = false
			else 
			(
				print "Opacity is not white"
				opacity = true
				HiddenDOSCommand ("magick -size " + size as string + "x" + size as string + " canvas:" + RGBtoHEX tex_color + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + filename_opacity + "\"") startpath:start --(GetINI_ImageMagick())
				HiddenDOSCommand ("magick " + "\"" + (filename_opacity as string) + "\""+ " PNG24:" + "\"" + (filename_opacity as string) + "\"") startpath:start --(GetINI_ImageMagick())
			)
		)			
		
		if opacity then 
		(
			--filename_diffuse
			print "Add opacity map to diffuse and blend to alpha"
			HiddenDOSCommand ("magick " + "\"" + filename_diffuse + "\"" + " -resize " + size as string + "x" + size as string + "^! " + "\"" + filename_diffuse + "\"") startpath:start
			--magick composite -compose CopyOpacity mask_bite2.png drawn.png drawn_bite2.png
			if (tex_amount - 100.0) != 0 then 
			--HiddenDOSCommand ("magick " + "\"" + (filename_opacity as string) + "\"" + " -brightness-contrast " + (tex_amount - 100.0) as string + "%% -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename_opacity as string) + "\"") startpath:start
			HiddenDOSCommand ("magick " + " ( -size " + size as string + "x" + size as string + " xc:black ) " + "\"" + (filename_opacity as string) + "\"" + " -compose blend -define compose:args=" + (tex_amount as integer) as string + " -composite -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename_opacity as string) + "\"") startpath:start
			else HiddenDOSCommand ("magick " + "\"" + (filename_opacity as string) + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename_opacity as string) + "\"") startpath:start
			
			--HiddenDOSCommand ("magick composite -compose CopyOpacity " + "\"" + filename_opacity + "\"" + " " + "\"" + filename_diffuse + "\"" + " alpha on -define png:color-type=6 " + "\"" + filename_diffuse + "\"") startpath:start
			--magick composite -compose CopyOpacity mask_bite2.png drawn.png drawn_bite2.png
			--HiddenDOSCommand ("composite -compose CopyOpacity " + "\"" + filename_opacity + "\"" + " " + "\"" + filename_diffuse + "\"" + " " + "\"" + filename_diffuse + "\"") startpath:start
			--HiddenDOSCommand ("magick " + "\"" + filename_diffuse + "\"" + " " + "\"" + filename_opacity + "\"" + " -compose CopyOpacity -composite -alpha on -define png:color-type=6 " + "\"" + filename_diffuse + "\"") startpath:start
			--HiddenDOSCommand ("magick " + "\"" + filename_diffuse + "\"" + " " + "\"" + filename_opacity + "\"" + " -alpha off -compose CopyOpacity -composite -define png:color-type=6 " + "\"" + filename_diffuse + "\"") startpath:start
			--magick composite -compose Dst_In  -gravity center label_A_white.png  rose: -alpha Set  compose_mask.png
			--HiddenDOSCommand ("composite -compose Dst_In " + "\"" + filename_opacity + "\"" + " " + "\"" + filename_diffuse + "\"" + " -alpha On " + "\"" + filename_diffuse + "\"") startpath:start
			--HiddenDOSCommand ("composite -compose CopyOpacity " + "\"" + filename_opacity + "\"" + " " + "\"" + filename_diffuse + "\"" + " " + "\"" + filename_diffuse + "\"") startpath:start
			
			HiddenDOSCommand ("magick " + "\"" + filename_diffuse + "\"" + " " + "\"" + filename_opacity + "\"" + " -alpha off -compose CopyOpacity -composite -define png:color-type=6 " + "\"" + filename_diffuse + "\"") startpath:start			HiddenDOSCommand ("magick " + "\"" + filename_diffuse + "\""+ " PNG24:" + "\"" + filename_diffuse + "\"") startpath:start --(GetINI_ImageMagick())
			--HiddenDOSCommand ("magick " + "\"" + filename_diffuse + "\""+ " PNG24:" + "\"" + filename_diffuse + "\"") startpath:start --(GetINI_ImageMagick())
		)
		
		if doesFileExist filename_opacity then deleteFile filename_opacity	
		if doesFileExist filename_temp then deleteFile filename_temp
	)
	
	fn render_map_bump tex tex_color tex_enabled tex_amount size filename start = 
	(
		if not doesDirectoryExist (getFilenamePath filename) then makeDir (getFilenamePath filename)
		local filename_temp = filename + ".png"
		if tex != undefined and tex_enabled then
		(
			local rm = renderMap tex size:[size, size] fileName:filename --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			save rm quiet:true --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if doesFileExist filename then print ("saved bump rendered map " + (filename as string)) else print ("did not save bump rendered map " + (filename as string) ) 
			close rm	
			free rm	
				
			--проверять цвета на палитру normal, если не они, делать карты заново
			--HiddenDOSCommand ("normalmap.exe " + "\"" + filename + "\"" + " " + "\"" + filename + "\"" ) startpath:start
			--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -separate -threshold 50%% -combine -colors 32 -unique-colors " + "\"" + filename_temp + "\"") startpath:start
			HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -colors 32 -unique-colors " + "\"" + filename_temp + "\"") startpath:start	
			local bt = openBitMap filename_temp --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if bt != undefined then
			(
				bt.gamma = 1.0
				local colors_quantity = #()
				if bt.width <= 32 then 
				(
					local line_bitmap = getPixels bt [0, 0] bt.width linear:true
					for pixel in line_bitmap where valid_bump pixel do append colors_quantity pixel							
					if (colors_quantity.count == 1 and bt.width == 1) or (colors_quantity.count == 4 and bt.width == 4) then ()
					else 
					(
						print "new normal map to be generated"
						if (tex_amount - 100.0) != 0.0 then 
							HiddenDOSCommand ("magick " + " ( -size " + size as string + "x" + size as string + " xc:black ) " + "\"" + (filename as string) + "\"" + " -compose blend -define compose:args=" + (tex_amount as integer) as string + " -composite -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
						--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -brightness-contrast " + (tex_amount - 100.0) as string + "%% -alpha remove -alpha off -define png:color-type=6 " +  "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())
						else HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("normalmap.exe " + "\"" + filename + "\"" + " " + "\"" + filename + "\"" ) startpath:start
					)
				)
				else 
				(
					print "new normal map to be generated"
					if (tex_amount - 100.0) != 0.0 then
						HiddenDOSCommand ("magick " + " ( -size " + size as string + "x" + size as string + " xc:black ) " + "\"" + (filename as string) + "\"" + " -compose blend -define compose:args=" + (tex_amount as integer) as string + " -composite -alpha remove -alpha off -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
					--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -brightness-contrast " + (tex_amount - 100.0) as string + "%% -alpha remove -alpha off -define png:color-type=6 " +  "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())
					else HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("normalmap.exe " + "\"" + filename + "\"" + " " + "\"" + filename + "\"" ) startpath:start
				)
				close bt
				free bt
			)
			HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())		
			if doesFileExist filename_temp then deleteFile filename_temp			
		)
		else 
		(
			if tex_color == black then 
			(
				--создать заглушку нейтрального normalmap цвета	
				print "make normal map 256 from black color"
				HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + filename + "\"") startpath:start
				HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())		
			)
			else 
			(
				--создать заглушку с цветом и сконвертировать
				print "make normal map 256 from none black color"
				HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX tex_color + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + filename + "\"") startpath:start
				HiddenDOSCommand ("normalmap.exe " + "\"" + filename + "\"" + " " + "\"" + filename + "\"" ) startpath:start
				HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())
				HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())				
			)				
		)
	)			
	
	fn render_map_reflect tex tex_color tex_enabled tex_amount size filename start = 
	(
		--хранит металлисити канал B в ERM, обрабатывается первым из трех каналов
		if not doesDirectoryExist (getFilenamePath filename) then makeDir (getFilenamePath filename)
		local filename_temp = filename + ".png"
		--local tex_filename = ""
		if tex != undefined and tex_enabled then
		(		
			local rm = renderMap tex size:[size, size] fileName:filename_temp --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			save rm quiet:true --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if doesFileExist filename_temp then print ("saved reflect rendered map " + (filename_temp as string)) else print ("did not save reflect rendered map " + (filename_temp as string) ) 
			close rm	
			free rm	
/*
			if isproperty tex #filename then --if hasProperty tex "filename" then 
				tex_filename = for m in (getmaps (tex.filename as string)) where doesFileExist m do exit with m --ищем текстуру не только по пути, а по assettracker
			else tex_filename = ""
					
			--если в пути текстуры был _ERM_, просто копируем текстуру, если нет, то создаем новый _ERM_ поканально, начиная с рефлекта в металлисити (Рафнесс в глоссинесс, металлисити в рефлект)		
			if findstring (getfilenamefile tex_filename) "_ERM_" == undefined then 
			(
*/
				--создаем новый _ERM_ поканально
				--задействовать tex_amount
				print "Make ERM map, Blue channel, Reflect -> Metallicity"
				if (tex_amount - 100.0) != 0 then 
					HiddenDOSCommand ("magick " + " ( -size " + size as string + "x" + size as string + " xc:black ) " + "\"" + (filename_temp as string) + "\"" + " -compose blend -define compose:args=" + (tex_amount as integer) as string + " -composite -channel B -separate -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
				--HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -brightness-contrast " + (tex_amount - 100.0) as string + "%% -channel B -separate -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
				else HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -channel B -separate -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
				--HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -channel B -separate -define png:color-type=6 " + "\"" + filename_temp + "\"") startpath:start
				
				--HiddenDOSCommand ("magick ( -size " + size as string + "x" + size as string + " canvas:#000000 ) ( -size " + size as string + "x" + size as string + " canvas:#000000 ) " + "\"" + filename_temp + "\"" + " -channel red,green,blue -combine -set colorspace sRGB -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
/*			)
			else
			(
				--проверить _ERM_ на заглушку, если не заглушка переразмер на большой размер, иначе в размер заглушки
				local bt = openBitMap tex_filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
				if bt != undefined then
				(
					if bt.width == 256 and bt.height == 256 then 
					(
						close bt
						free bt
						HiddenDOSCommand ("magick " + "\"" + tex_filename + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start				
					)
					else
					(
						close bt
						free bt
						HiddenDOSCommand ("magick " + "\"" + tex_filename + "\"" + " -resize " + size as string + "x" + size as string + "^! -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start				
					)
				)
				else
				(
					if (tex_amount - 100.0) != 0 then HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -brightness-contrast " + (tex_amount - 100.0) as string + "%% -channel B -separate -define png:color-type=6 " + "\"" + filename_temp + "\"") startpath:start
					else HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -channel B -separate -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
					HiddenDOSCommand ("magick ( -size " + size as string + "x" + size as string + " canvas:#000000 ) ( -size " + size as string + "x" + size as string + " canvas:#000000 ) " + "\"" + filename_temp + "\"" + " -channel red,green,blue -combine -set colorspace sRGB -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
					--HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
					--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -channel B -separate -define png:color-type=6 " + "\"" + filename + "\"") startpath:start	
					--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start	
				)
			)
*/			
			if doesFileExist filename_temp then deleteFile filename_temp	
		)
		else
		(
			--создать заглушку с цветом и сконвертировать в _ERM_ одного канала 
			print "Make ERM solid map 256, Blue channel, Reflect -> Metallicity"
			-- -background black -channel blue,green -combine -set colorspace sRGB			
			--HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX (tex_color) + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
			--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -channel B -separate -define png:color-type=6 " + "\"" + filename + "\"") startpath:start			
			--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())	
			--HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX_b (tex_color) + " -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
			--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start	
			--HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX_b (tex_color) + " -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
			HiddenDOSCommand ("magick -size " + size as string + "x" + size as string + " canvas:" + RGBtoHEX (tex_color) + " -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
		)
	)
	
	fn render_map_glossiness tex tex_color tex_enabled tex_amount size filename start =
	( 
		--хранит рафнесс канал G в ERM
		if not doesDirectoryExist (getFilenamePath filename) then makeDir (getFilenamePath filename)
		local filename_temp = filename + ".png"
		--local tex_filename = ""
		if tex != undefined and tex_enabled then
		(		
			local rm = renderMap tex size:[size, size] fileName:filename_temp --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			save rm quiet:true --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if doesFileExist filename_temp then print ("saved glossiness rendered map " + (filename_temp as string)) else print ("did not save glossiness rendered map " + (filename_temp as string) ) 
			close rm	
			free rm	
/*
			if isproperty tex #filename then --if hasProperty tex "filename" then 
				tex_filename = for m in (getmaps (tex.filename as string)) where doesFileExist m do exit with m --ищем текстуру не только по пути, а по assettracker
			else tex_filename = ""

			if findstring (getfilenamefile tex_filename) "_ERM_" == undefined then --если в пути текстуры был _ERM_, просто копируем текстуру, если нет, то создаем новый _ERM_ поканально, Рафнесс в глоссинесс, металлисити в рефлект
			(
*/
				print "Make ERM map, Green channel, Glosiness -> Roughness"
				if (tex_amount - 100.0) != 0 then 
					HiddenDOSCommand ("magick " + " ( -size " + size as string + "x" + size as string + " xc:black ) " + "\"" + (filename_temp as string) + "\"" + " -compose blend -define compose:args=" + (tex_amount as integer) as string + " -composite -channel G -separate -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
				--HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -brightness-contrast " + (tex_amount - 100.0) as string + "%% -channel G -separate -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
				else HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -channel G -separate -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
				--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " " + "\"" + filename_temp + "\"" + " -background black -channel blue,green -combine -set colorspace sRGB -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
				-- magick separate_red.gif separate_blue.gif -background black  -channel blue,red  -combine    rose_red_blue.gif -set colorspace sRGB
				--HiddenDOSCommand ("magick ( -size " + size as string + "x" + size as string + " canvas:#000000 ) " + "\"" + filename_temp + "\"" + " " + "\"" + filename + "\"" + " -channel red,green,blue -combine -set colorspace sRGB -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
				--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start	
/*			)
			else
			(
				--проверить _ERM_ на заглушк??, если не за??????лушка переразмер на большой размер, иначе в размер заглушки
				local bt = openBitMap tex_filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
				if bt != undefined then
				(
					if bt.width == 256 and bt.height == 256 then 
					(
						close bt
						free bt
						HiddenDOSCommand ("magick " + "\"" + tex_filename + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start				
					)
					else
					(
						close bt
						free bt
						HiddenDOSCommand ("magick " + "\"" + tex_filename + "\"" + " -resize " + size as string + "x" + size as string + "^! -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start				
					)
				)
				else
				(
					if (tex_amount - 100.0) != 0 then HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -brightness-contrast " + (tex_amount - 100.0) as string + "%% -channel G -negate -separate -define png:color-type=6 " + "\"" + filename_temp + "\"") startpath:start
					else HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -channel G -negate -separate -define png:color-type=6 " + "\"" + filename_temp + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " " + "\"" + filename_temp + "\"" + " " + "\"" + filename + "\"" + " -channel red,green,blue -combine -set colorspace sRGB -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start	
					
					--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
					--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start	
				)
			)
*/			
			if doesFileExist filename_temp then deleteFile filename_temp	
		)
		else
		(
			/*
			--создать заглушку с цветом и сконвертир??вать в _ERM_ одного канала
			--HiddenDOSCommand ("magick ( -size 256x256 canvas:" + RGBtoHEX tex_color + " -channel G -separate -alpha remove -alpha off -define png:color-type=6 " +  "\"" + filename_temp + "\"") startpath:start

			--добавить к другому каналу
			--заглушка может быть в этом канале, но не в другом, тогда надо переразмеривать заглушку
			local resize = false
			local bt = openBitMap filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if bt != undefined then
			(
				resize = if bt.width == 256 and bt.height == 256 then false else true
				close bt
				free bt
			)
			else resize = false
			if resize then HiddenDOSCommand ("magick -size " + size as string + "x" + size as string + " canvas:" + RGBtoHEX_g (color tex_color.r (255 - tex_color.g) tex_color.b) + " -define png:color-type=6 " + "\"" + filename_temp + "\"") startpath:start
			else HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX_g (color tex_color.r (255 - tex_color.g) tex_color.b) + " -define png:color-type=6 " + "\"" + filename_temp + "\"") startpath:start
			
			HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " " + "\"" + filename_temp + "\"" + " -background black -channel blue,green -combine -set colorspace sRGB -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
			HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())	
			if doesFileExist filename_temp then deleteFile filename_temp	
			*/
			print "Make ERM solid map 256, Green channel, Glosiness -> Roughness"
			HiddenDOSCommand ("magick -size " + size as string + "x" + size as string + " canvas:" + RGBtoHEX (tex_color) + " -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
		)
	)

	fn render_map_selfillum tex tex_color tex_enabled tex_amount size filename start = 
	(
		if doesDirectoryExist (getFilenamePath filename) then makeDir (getFilenamePath filename)
		local filename_temp = filename + ".png"
		--local tex_filename = ""
		if tex != undefined and tex_enabled then
		(		
			local rm = renderMap tex size:[size, size] fileName:filename_temp --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			save rm quiet:true --gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if doesFileExist filename_temp then print ("saved SelfIllum rendered map " + (filename_temp as string)) else print ("did not save SelfIllum rendered map " + (filename_temp as string) ) 
			close rm	
			free rm	
/*
			if isproperty tex #filename then --if hasProperty tex "filename" then 
				tex_filename = for m in (getmaps (tex.filename as string)) where doesFileExist m do exit with m --ищем текстуру не только по пути, а по assettracker
			else tex_filename = ""
					
			if findstring (getfilenamefile tex_filename) "_ERM_" == undefined then 
			(
*/
				--если в пути текстуры был _ERM_, просто копируем текстуру, если нет, то создаем новый _ERM_ поканально, Рафнесс в глоссинесс, металлисити в рефлект
				-- magick separate_red.gif separate_blue.gif -background black  -channel blue,red  -combine    rose_red_blue.gif -set colorspace sRGB
				print "Make ERM map, Red channel, Selfillumination -> Emission"
				--print ("magick " + " ( -size " + size as string + "x" + size as string + " xc:black ) " + "\"" + (filename_temp as string) + "\"" + " -compose blend -define compose:args=" + (tex_amount as integer) as string + " -composite -channel R -separate -define png:color-type=6 " + "\"" + (filename as string) + "\"")

				if (tex_amount - 100.0) != 0 then 
					HiddenDOSCommand ("magick " + " ( -size " + size as string + "x" + size as string + " xc:black ) " + "\"" + (filename_temp as string) + "\"" + " -compose blend -define compose:args=" + (tex_amount as integer) as string + " -composite -channel R -separate -define png:color-type=6 " + "\"" + (filename as string) + "\"") startpath:start
				--HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -brightness-contrast " + (tex_amount - 100.0) as string + "%% -channel R -separate -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
				else HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -channel R -separate -define png:color-type=6 " + "\"" + filename + "\"") startpath:start

				--HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " -channel R -separate -define png:color-type=6 " + "\"" + filename_temp + "\"") startpath:start
				--HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " " + "\"" + filename + "\"" + " " + "\"" + filename + "\"" + " -channel red,green,blue -combine -set colorspace sRGB -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
/*			)
			else
			(
				--проверить _ERM_ на заглушку, если не заглушка переразмер на большой размер, иначе в размер заглушки
				local bt = openBitMap tex_filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
				if bt != undefined then
				(
					if bt.width == 256 and bt.height == 256 then 
					(
						close bt
						free bt
						HiddenDOSCommand ("magick " + "\"" + tex_filename + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start				
					)
					else
					(
						close bt
						free bt
						HiddenDOSCommand ("magick " + "\"" + tex_filename + "\"" + " -resize " + size as string + "x" + size as string + "^! -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start				
					)
				)
				else
				(
					HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start	
				)			
			)
*/			
			if doesFileExist filename_temp then deleteFile filename_temp	
		)
		else
		(
			/*
			--создать заглушку с цветом и сконвертировать в _ERM_ одного канала
			--заглушка может быть в этом канале, но не в другом, тогда надо переразмеривать заглушку
			local resize = false
			local bt = openBitMap filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if bt != undefined then
			(
				resize = if bt.width == 256 and bt.height == 256 then false else true
				close bt
				free bt
			)
			else resize = false
			
			if resize then HiddenDOSCommand ("magick -size " + size as string + "x" + size as string + " canvas:" + RGBtoHEX_r (tex_color) + " -define png:color-type=6 " + "\"" + filename_temp + "\"") startpath:start
			else HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX_r (tex_color) + " -define png:color-type=6 " + "\"" + filename_temp + "\"") startpath:start
			--print ("magick -size 256x256 canvas:" + RGBtoHEX_r (tex_color) + " -define png:color-type=6 " + "\"" + filename_temp + "\"")
			--HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX tex_color + " -channel R -separate -alpha remove -alpha off -define png:color-type=6 " +  "\"" + filename_temp + "\"") startpath:start

			--добавить к другому каналу
			HiddenDOSCommand ("magick " + "\"" + filename_temp + "\"" + " " + "\"" + filename + "\"" + " " + "\"" + filename + "\"" + " -channel red,green,blue -combine -set colorspace sRGB -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
			HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " PNG24:" + "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())	
			if doesFileExist filename_temp then deleteFile filename_temp	
			*/
			print "Make ERM solid map 256, Red channel, Selfillumination -> Emission"
			--print ("magick -size " + size as string + "x" + size as string + " canvas:" + RGBtoHEX (tex_color) + " -define png:color-type=6 " + "\"" + filename + "\"")
			HiddenDOSCommand ("magick -size " + size as string + "x" + size as string + " canvas:" + RGBtoHEX (tex_color) + " -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
		)
	)
	
	fn ClearSpline tol =
	(
		for spl in selection do 
			(
				if classof spl==SplineShape or classof spl==line do
				(
					numLine=numSplines spl
					subSplinesArr=for i in 1 to numLine collect i
					for iLine in subSplinesArr do
					(
						bl = isClosed spl iLine
						--p1, p2, p3, v1, v2, Angle, comAng
						iKnots = numKnots spl iLine
						if iKnots < 3 do continue
						i=1
						while (i+2) <= iKnots do
						(
							p1=getKnotpoint spl iLine i
							p2=getKnotpoint spl iLine (i+1)
							p3=getKnotpoint spl iLine (i+2)
							v1=p1-p2
							v2=p3-p2
							Angle = acos (dot (normalize v1) (normalize v2))
							comAng=int(Angle*100)/100.0							
							if comAng>=180.0-tol then (deleteKnot spl iLine (i+1)) else i+=1
							iKnots = numKnots spl iLine
						)
						if bl do
						(
							p1 = getKnotPoint spl iLine (iKnots-1)
							p2 = getKnotPoint spl iLine iKnots
							p3 = getKnotPoint spl iLine 1
							v1=p1-p2
							v2=p3-p2
							Angle = acos (dot (normalize v1) (normalize v2))
							comAng=int(angle*100)/100.0
							if comAng>=180.0-tol then deleteKnot spl iLine iKnots
						)
					)
					updateShape spl
					--redrawviews()
				)--endif
			)--end s
	)
	
	fn resize_texture sourcepath filename res1 res2 =
	(		
		bm_source = openbitmap sourcepath
		bm_final = bitmap res1 res2 filename:filename hdr:false hasalpha:(bm_source.hasalpha)
		copy bm_source bm_final
		close bm_source
		free bm_source
		save bm_final
		close bm_final
		free bm_final
	)
	
	fn edge_lenght poly e =
	(	
		local vv = polyop.getVertsUsingEdge poly #{e}
		local pp = for v in vv collect polyop.getVert poly v
		distance pp[1] pp[2]
	)
	
	fn union a b =
	(	
		for i in a do appendifunique b i
		b
	)
	
	fn detriangulate poly edges faces uv sm ang an disputed del inv =
	(
		if not polyop.getMapSupport poly 1 then uv = false
		case of 
		(
			(sm and not uv and ang):
				for i in edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 --returns 0 as there is no second face 
					f2 = poly.GetEdgeFace i 2 --returns 0 as there is no second face 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 or acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then edges -= #{i}
					--p.GetVertexEdgeCount 1 --returns 2 for a corner vertex			
				)
			(not sm and not uv and ang): 
				for i in edges where not keyboard.escPressed do --for i in edges where not keyboard.escPressed and ((poly.GetEdgeFace i 1) == 0 or (poly.GetEdgeFace i 2) == 0) do edges -= #{i}
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then edges -= #{i}
				)
			(sm and uv and ang):
				for i in edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 or (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 or acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then edges -= #{i}						
				)
			(not sm and uv and ang):
				for i in edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 or acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then edges -= #{i}						
				)		
			(sm and not uv and not ang):
				for i in edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 then edges -= #{i}
				)
			(not sm and not uv and not ang): 
				for i in edges where not keyboard.escPressed and ((poly.GetEdgeFace i 1) == 0 or (poly.GetEdgeFace i 2) == 0) do edges -= #{i}
			(sm and uv and not ang):
				for i in edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 or (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 then edges -= #{i}						
				)
			(not sm and uv and not ang):
				for i in edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 then edges -= #{i}						
				)			
		)
		--edges остался без граничных ребер, без границ групп сглаживания, без границ разверток, без переломных ребер

		edges_ = #{}
		for f in faces where (polyop.getFaceDeg poly f) < 4 and not keyboard.escPressed do --исключить полики с числом вершин более 3, они уже детриангулированы
		(
			ee = polyop.getEdgesUsingFace poly #{f}
			ee = ee - (-edges) --из всех ребер текущего полигона вычитаем отобранные раннее ребра
			m = amax (for e in ee collect (edge_lenght poly e))
			for e in ee where m == edge_lenght poly e do edges_ += #{e} --если самое длинное, отбираем его
		)
		
		--edges остался с самыми длинными ребрами
		
		--исключить фейсы, у которых по нескольку ребер включены в список, ошибочно
		--пересесчитать и исключить с короткими
		if disputed then for f in faces where not keyboard.escPressed do
		(
			ee = polyop.getEdgesUsingFace poly #{f}
			if (ee * edges_).numberset > 1 then
			(			
				ee = ee - (-edges) --из всех ребер текущего полигона вычитаем отобранные раннее ребра
				m = amax (for e in ee collect (edge_lenght poly e))
				for e in ee where m > edge_lenght poly e do edges_ -= #{e} --если короткое, исключаем его
			)
		)		
		
		if not inv then
		(
			polyOp.setEdgeSelection poly edges_
			if del then undo "Detriangulate" on poly.remove selLevel:#edge
		)
		else
		(
			polyOp.setEdgeSelection poly ((polyop.getEdgesUsingFace poly faces) - edges_)
		)
	)

	fn select_edges poly edges faces uv sm ang an spn = --не работает повторный проход и первый уже тоже не хочет
	(
		--во многом схож с детриангуляцией, но нужно выбирать эджи, соединенные в общую змейку и имеющие минимальный порог отклонения на сторонние
		
		all_edges = #{1..polyop.getNumEdges poly} --polyop.getEdgesUsingFace poly faces
		sel_edges = #{}
		sel_edges = polyop.getOpenEdges poly --границы объекта, надо вычесть эджи от неиспользуемых фейсов
		
		sel_edges = edges * sel_edges --только границы выделенных полигонов 
		
		--сначала отсев эджей по группам сгл, границам объекта, изломам
		case of 
		(
			(sm and not uv and ang):
				for i in edges - sel_edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 --returns 0 as there is no second face 
					f2 = poly.GetEdgeFace i 2 --returns 0 as there is no second face 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 or acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then sel_edges += #{i}
					--p.GetVertexEdgeCount 1 --returns 2 for a corner vertex			
				)
			(not sm and not uv and ang): 
				for i in edges - sel_edges where not keyboard.escPressed do --for i in edges where not keyboard.escPressed and ((poly.GetEdgeFace i 1) == 0 or (poly.GetEdgeFace i 2) == 0) do edges -= #{i}
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then sel_edges += #{i}
				)
			(sm and uv and ang):
				for i in edges - sel_edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 or (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 or acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then edges -= #{i}						
				)
			(not sm and uv and ang):
				for i in edges - sel_edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 or acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then sel_edges += #{i}						
				)		
			(sm and not uv and not ang):
				for i in edges - sel_edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 then sel_edges += #{i}
				)
			(not sm and not uv and not ang): () --только граничные эджи уже набраны выше
				--for i in edges - sel_edges where not keyboard.escPressed and ((poly.GetEdgeFace i 1) == 0 or (poly.GetEdgeFace i 2) == 0) do sel_edges += #{i}
			(sm and uv and not ang):
				for i in edges - sel_edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 or (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 then sel_edges += #{i}						
				)
			(not sm and uv and not ang):
				for i in edges - sel_edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 then sel_edges += #{i}						
				)			
		)
		--print #(sel_edges)
		
		-- edges остался без граничных ребер, без границ групп сглаживания, без границ разверток, без переломных ребер
		-- sel_edges какие-то ребра, которые точно надо выбрать, но это еще не все
		
		--polyop.getOpenEdges <Poly poly>
		--polyop.getBorderFromEdge <Poly poly> <int edge>
		
		--edges -= sel_edges 

		bad = #{}
		good = #{} --sel_edges
		last = #{}
		last += sel_edges
		--current = #{} 
		angle = 45.0
		--while edges.numberset > 0 do
		--(
			print (edges.numberset)
			--if keyboard.escPressed then exit --with good
			--current = last
			for e in sel_edges where not keyboard.escPressed do
			(
				last = #{}
				vv1 = polyop.getVertsUsingEdge poly #{e} -- набор из двух вершин из выбранного ребра
				--ee = polyop.getEdgesUsingVert poly vv1 --набор ребер из всех вершин
				--ee -= #{e} --исключаем исходное ребро
				--pp1 = for v in vv1 collect polyop.getVert poly v --считаем точки в общем ребре		
				--vv2 = polyop.getVertsUsingEdge poly ee --набор вершин других ребер
				--pp2 = for v in vv2 collect polyop.getVert poly v --считаем точки в других ребрах	
				--vv2 -= vv1 --исключаем общие точки ребра (с двух сторон ребра по одной)
				
				pp1 = for v in vv1 collect polyop.getVert poly v
				for v in vv1 do
				(
					p1 = polyop.getVert poly v --точка из выбранной вершины
					ee = polyop.getEdgesUsingVert poly #{v} --набор ребер из текущей вершины  
					--ee -= #{e} --исключаем исходное ребро
					edges -= ee
					--ee минимум 3 шт, бывает по 7 шт и более, надо выбрать хотя бы один 
					for ed in ee where d != e do
					(
						vv2 = polyop.getVertsUsingEdge poly #{ed} --набор вершин одного из другого ребра
						vv2 -= #{v} --исключаем общую вершину
						pp2 = for w in vv2 collect polyop.getVert poly w --считаем точки в других вершинах
		
						for p2 in pp2 do
						(
							if p1 == pp1[1] then 
								angle = acos (dot (normalize (pp1[1] - pp1[2])) (normalize (pp1[1] - p2))) 
							else 
								angle = acos (dot (normalize (pp1[2] - pp1[1])) (normalize (pp1[2] - p2))) 	
							--print angle
							case of
							(				
								(angle >= abs(90 - spn) and angle <= (90 + spn)): last += #{ed}
								(angle >= abs(180 - spn) and angle <= (180 + spn)): last += #{ed}
								(angle <= spn): last += #{ed}
								default: bad += #{ed}
							)
							print last.numberset
						)
					)
				)
			)
			good += last
			--edges -= good
			--edges -= bad
			
		--)
		good += sel_edges
		
		polyOp.setEdgeSelection poly good
		/*
				for v in Verts where (nEdges = thePoly.GetVertexEdgeCount v) == 2 do 
				--for v in Verts where (nEdges = polyop.getEdgesUsingVert thePoly v).numberset == 2 do
				(
					if keyboard.escPressed then exit
					--if getProgressCancel() then exit
					--progressUpdate (100*v/cou)
					vv = #{} --набор вершин из парных эджей
					for e in nEdges do vv += polyop.getVertsUsingEdge thePoly #{e} --набираем из парных вершин в общий набор вершин
					vv -= #{v} --исключаем из набора общую вершину
					p1 = polyop.getVert thePoly v --считаем точку в общей вершине
					pp = for w in vv collect polyop.getVert thePoly w --считаем еще две точки от других вершин
					angle = acos (dot (normalize (p1 - pp[1])) (normalize (p1 - pp[2]))) 				
					if angle >= abs(180 - spn) or angle <= abs(spn) then Verts_Err += #{v} --если угол между векторами, исходящими из одной точки, развернутый и == 180 градусов, то это и есть ошибка - висячая вершина; также, если вектора направлены друг к другу из разных точек; также, если направлены в одну сторону из разных точек, тогда угол равен 0 --if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
				)
		*/
		--for f in faces where not keyboard.escPressed do 
		--(
		--	ee = polyop.getEdgesUsingFace poly #{f}
			
			--ee = ee - (-edges) --из всех ребер текущего полигона вычитаем отобранные раннее ребра
			--m = amax (for e in ee collect (edge_lenght poly e))
			--for e in ee where m == edge_lenght poly e do edges_ += #{e} --если самое длинное, отбираем его
		--)

		--polyOp.setEdgeSelection poly sel_edges
	)	
	
	fn transfer_edges_new =
	(	
		if selection.count == 1 then if selection[1].modifiers.count > 0 then undo "Collapse All" on convertToPoly selection[1]
		if selection.count == 1 and classof selection[1].baseobject == Editable_Poly then
		(
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			sel = selection[1].baseobject
					
			edges = #{}
			verts_ALL = #()
			edges_ = #{}
			--verts_ = #{}
			edges_good = #{}
				
			edges = polyop.getEdgeSelection sel
			--print #(edges)
			if not edges.isempty then 
				for i in edges do
				(
					verts = #()
					verts = polyop.getEdgeVerts sel i
					--print #(verts)
					append verts_ALL #{verts[1], verts[2]} 
					--join verts_ (verts as bitarray)
				)
			--polyop.setVertSelection sel verts_
			--subObjectLevel = 1							
		)
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			print #(verts_ALL)
			unwrapmod.setPolygonMode false
			unwrapmod.setTVElementMode false
			unwrapmod.unhide()
			unwrapmod.setTVSubObjectMode 2
			--verts_ = unwrapmod.getSelectedGeomVerts() 			
			--print #(verts_)
			--unwrapmod.selectVertices verts_
			--unwrapmod.vertToEdgeSelect()
			--unwrapmod.setTVSubObjectMode 2
			--unwrapmod.syncTVSelection()
			
			--<bitArray><Unwrap_UVW>.getSelectedGeomVertsByNode <node>node 
			--<void><Unwrap_UVW>.setSelectedGeomVertsByNode <bitArray>selection <node>node 
			
			faces_all_ = #{1..unwrapmod.numberPolygons()}
			unwrapmod.selectFaces faces_all_
			--<integer><Unwrap_UVW>.NumberVertices() 
			unwrapmod.faceToEdgeSelect() 
			--<void><Unwrap_UVW>.edgeToVertSelect() 
			edges_all_ = unwrapmod.getSelectedEdges()
			print #(edges_all_)
			
			for e_ in edges_all_ do
			(
				unwrapmod.selectEdges #{e_}
				unwrapmod.edgeToVertSelect() 
				unwrapmod.setTVSubObjectMode 1
				vv_ = unwrapmod.getSelectedVertices()
				unwrapmod.setSelectedGeomVertsByNode vv_ selection[1]
				polyop.setVertSelection sel vv_
				vv = polyop.getVertSelection sel 
				--vv = unwrapmod.getSelectedGeomVertsByNode selection[1]
				--print #(vv_)
				--print #(vv)
				if finditem verts_ALL vv != 0 then edges_good += #{e_}
					
				--exit
			)
			
			/*
			for v in verts_ALL do
					(
						edges_ = #{}
						unwrapmod.selectVertices v
						unwrapmod.vertToEdgeSelect()
						edges_ = unwrapmod.getSelectedEdges() --join edges_ (unwrapmod.getSelectedEdges())
						
						for e in edges_ do 
						(
							unwrapmod.selectEdges #{e}
							ve = #{}
							unwrapmod.edgeToVertSelect() 
							ve = unwrapmod.getSelectedVertices()
							format "ve=% v=%\n" ve v
							if (ve as array)[1] == (v as array)[1] and (ve as array)[2] == (v as array)[2] then append edges_good e
						)
					)	*/
			print edges_good
			unwrapmod.setTVSubObjectMode 2 
			if not edges_good.isempty then 
			(
				unwrapmod.selectEdges edges_good
			)

			
		)
		redrawViews()		
	)

		fn transfer_edges =
		(	
			if selection.count == 1 then if selection[1].modifiers.count > 0 then undo "Collapse All" on convertToPoly selection[1]
			if selection.count == 1 and classof selection[1].baseobject == Editable_Poly then
			(
				max modify mode
				unwrapmod = modpanel.getcurrentobject()
				sel = selection[1] --.baseobject
					
				edges = #{}
				verts_ALL = #()
				edges_ = #{}
				verts_ = #{}
				edges_good = #{}
					
				edges = polyop.getEdgeSelection sel
				print #(edges)
				if not edges.isempty then 
					for i in edges do
					(
						verts = #()
						verts = polyop.getEdgeVerts sel i
						--print #(verts)
						append verts_ALL #{verts[1],verts[2]} 
						join verts_ (verts as bitarray)
					)
				polyop.setVertSelection sel verts_
				--subObjectLevel = 1				
				
				if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
				(
					addmodifier selection[1] (Unwrap_UVW())
					unwrapmod = modpanel.getcurrentobject()
				)
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					print #(verts_ALL)
					unwrapmod.setPolygonMode false
					unwrapmod.setTVElementMode false
					unwrapmod.unhide()
					unwrapmod.setTVSubObjectMode 1
					verts_ = unwrapmod.getSelectedGeomVerts() 
					--unwrapmod.vertToEdgeSelect()
					--unwrapmod.setTVSubObjectMode 2
					unwrapmod.selectVertices verts_
					
					--<point3><Unwrap_UVW>.GetVertexPositionByNode <time>time <integer>index <node>node 
					--<void><Unwrap_UVW>.setSelectedGeomVerts <bitArray>selection 
					--<bitArray><Unwrap_UVW>.getSelectedGeomVertsByNode <node>node 
					--<void><Unwrap_UVW>.selectEdges <bitArray>selection 
					--<point3><Unwrap_UVW>.getVertexPosition <time>time <integer>index 
					--<void><Unwrap_UVW>.setSyncSelectionMode <boolean>sync --Sets the Sync. to Viewport mode. 
					--<void><Unwrap_UVW>.syncTVSelection() --Synchronizes the selection in the Editor to reflect the viewport selection
					
					for v in verts_ALL do
					(
						edges_ = #{}
						unwrapmod.selectVertices v
						unwrapmod.vertToEdgeSelect()
						edges_ = unwrapmod.getSelectedEdges() --join edges_ (unwrapmod.getSelectedEdges())
						
						for e in edges_ do 
						(
							unwrapmod.selectEdges #{e}
							ve = #{}
							unwrapmod.edgeToVertSelect() 
							ve = unwrapmod.getSelectedVertices()
							format "ve=% v=%\n" ve v
							if (ve as array)[1] == (v as array)[1] and (ve as array)[2] == (v as array)[2] then append edges_good e
						)
					)
					print edges_good
					unwrapmod.setTVSubObjectMode 2 
					if not edges_good.isempty then 
					(
						unwrapmod.selectEdges edges_good
					)
				)
			)
			redrawViews()
		)

	
	fn getFirstElBitarray a =
    (
        for i = 1 to a.count where a[i] do return i --плохой алгоритм, лучше в цикле брать первый эл-т и выходить из него
        0
    )

	fn ReadAllLines excel_file = 
	(
		if doesfileexist excel_file then 
		(
			try
			(
				local stri = (dotNetClass "System.IO.File").ReadAllLines excel_file ((dotNetClass "System.Text.Encoding").UTF8)
				stri
			)
			catch
			(
				messagebox ("файл занят другой программой\n" + excel_file)
				local stri = ""
				stri
			)
		)
		else
		(
			local stri = ""
			stri	
		)
	)

	fn WriteAllLines excel_file excel = 
	(
		try
		(
			--Writer = dotNetObject"System.IO.StreamWriter" excel_file false ((dotNetClass "System.Text.Encoding").GetEncoding("Windows-1251")) --ANSI
			--local Writer = dotNetObject"System.IO.StreamWriter" excel_file false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-16LE"))
			local Writer = dotNetObject"System.IO.StreamWriter" excel_file false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-8"))
			Writer.Write(excel)
			Writer.Close()
			free Writer
			free excel_file
			free excel
		)
		catch(print ("файл не записан: " + excel_file))
	)
	
	fn redrawscr_laca = gw.updatescreen()

	fn VertexShow = 
	(
		try 
		(
			if viewport.activeViewport != lastviewport do 
			(
				completeredraw()
				lastViewport = viewport.activeViewport 
			)
			if (selection.count == 1) and ((classof $.baseobject == Editable_Mesh) or (classof $.baseobject == Editable_Poly)) then
			(
				gw.setTransform (matrix3 1)
				if (classof $ == Editable_Mesh) then
					for gw_i in (getvertselection $) do gw.wtext ((gw.wTransPoint (getvert $ gw_i)) + [5,-5,0]) (gw_i as string) color:[231,217,55]
				else
					for gw_i in (polyop.getvertselection $.baseobject) do gw.wtext ((gw.wTransPoint (polyop.getvert $ gw_i)) + [5,-5,0]) (gw_i as string) color:[231,217,55]
				gw.enlargeupdaterect #whole
			)
		)
		catch()
	)

	fn FaceShow = 
	(
		try 
		(
			if viewport.activeViewport != lastviewport do 
			(
				completeredraw()
				lastViewport = viewport.activeViewport 
			)
			if (selection.count == 1) and ((classof $.baseobject == Editable_Mesh) or (classof $.baseobject == Editable_Poly)) then
			(
				gw.setTransform (matrix3 1)
				if (classof $ == Editable_Mesh) then
					for gw_i in (getfaceselection $) do 
					(
						local posss = [0,0,0]
						local face_i = meshop.getfacecenter $ gw_i
						gw.wtext ((gw.wtransPoint face_i)+[0,0,100]) (gw_i as string) color:[255,255,255]
					)
				else 
				(
					for gw_i in (polyop.getfaceselection $.baseobject) do 
					(
						local face_i = polyop.getfacecenter $ gw_i
						gw.wtext ((gw.wtransPoint face_i)+[0,0,100]) (gw_i as string) color:[255,255,255]
					)
				)				
				gw.enlargeupdaterect #whole
			)
		)
		catch()
	)
	
	fn GetBitmapTextures_Paths theObjects name_from name_to =
	(
		texMaps = #()
		for obj in theObjects do join texMaps (getClassInstances bitmapTexture target:obj asTrackViewPick:off) --for obj in theObjects do join texMaps (usedMaps obj) 
		--makeUniqueArray texMaps
		for i in texMaps where hasproperty i "filename" do i.filename = substitutestring i.filename name_from name_to
		texMaps
	)

	fn GetBitmapTextures theObjects name_from name_to =
	(
		subMapContainers = #()
		for obj in theObjects where obj.material != undefined do
		(
			for i in 1 to getNumSubMtls obj.material do append subMapContainers (getSubMtl obj.material i)
			append subMapContainers (obj.material)
		)
		for subMapContainer in subMapContainers do
		(
			for i in 1 to getNumSubTexmaps subMapContainer do
			(
				theSubTexMap = getSubTexMap subMapContainer i
				if theSubTexMap != undefined then
				(
					if (getNumSubTexmaps theSubTexMap) > 0 then append subMapContainers theSubTexMap
				)
			)
		)
		for i in subMapContainers do i.name = substitutestring i.name name_from name_to
		subMapContainers
	)

	fn GetINI_ImageMagick =
	(
		setIniForceUTF16Default true
		local filenameIni = GetDir #maxroot + "GeoScripts\\GeoAGR.ini" --getFilenamePath(getSourceFileName()) + "GeoAGR.ini"
		--print filenameIni
		local ImageMagickUseScriptDir = "true"
		local DirPath = GetDir #maxroot + "GeoScripts\\"
		
		ImageMagickUseScriptDir = getINISetting filenameIni "Directories" "ImageMagickUseScriptDir"
		if ImageMagickUseScriptDir != undefined then 
			if ImageMagickUseScriptDir != "true" then DirPath = (getINISetting filenameIni "Directories" "ImageMagick")
		print DirPath
		DirPath
	)
	
	fn GetINI_Projects_Names =
	(
		setIniForceUTF16Default true
		local filenameIni = getFilenamePath(getSourceFileName()) + "GeoAGR.ini"
		local NumIni = (getINISetting filenameIni "Projects" "Number") as integer
		local NamesIni = for i in #{1..NumIni} where hasINISetting filenameIni "Projects" ("Name" + (i as string)) collect getINISetting filenameIni "Projects" ("Name" + (i as string))
		NamesIni
	)

	fn GetINI_Current_Project_Name dir =
	(
		setIniForceUTF16Default true
		local filenameIni = getFilenamePath(getSourceFileName()) + "GeoAGR.ini"
		local NumIni = (getINISetting filenameIni "Projects" "Number") as integer
		NamesIni = ""
		for i in #{1..NumIni} where hasINISetting filenameIni "Projects" ("Name" + (i as string)) do 
		(
			NameIni = getINISetting filenameIni "Projects" ("Name" + (i as string))
			Folder = if hasINISetting filenameIni NameIni "Folder" then getINISetting filenameIni NameIni "Folder" else ""
			if Folder == dir then NamesIni = NameIni
		)
		NamesIni
	)

	fn GetINI_Current_Project_Index dir =
	(
		setIniForceUTF16Default true
		local filenameIni = getFilenamePath(getSourceFileName()) + "GeoAGR.ini"
		local NumIni = (getINISetting filenameIni "Projects" "Number") as integer
		index = 0
		for i in #{1..NumIni} where hasINISetting filenameIni "Projects" ("Name" + (i as string)) do 
		(
			NameIni = getINISetting filenameIni "Projects" ("Name" + (i as string))
			Folder = if hasINISetting filenameIni NameIni "Folder" then getINISetting filenameIni NameIni "Folder" else ""
			if Folder == dir then index = i
		)
		index
	)

	fn GetINI_Current_Project_Lowpoly dir =
	(
		setIniForceUTF16Default true
		local filenameIni = getFilenamePath(getSourceFileName()) + "GeoAGR.ini"
		local NumIni = (getINISetting filenameIni "Projects" "Number") as integer
		LowpolyIni = ""
		for i in #{1..NumIni} where hasINISetting filenameIni "Projects" ("Name" + (i as string)) do 
		(
			NameIni = getINISetting filenameIni "Projects" ("Name" + (i as string))
			Folder = if hasINISetting filenameIni NameIni "Folder" then getINISetting filenameIni NameIni "Folder" else ""
			Lowpoly_obj = if hasINISetting filenameIni NameIni "Lowpoly_obj" then getINISetting filenameIni NameIni "Lowpoly_obj" else ""
			if Folder == dir then LowpolyIni = Lowpoly_obj
		)
		LowpolyIni
	)

	fn GetINI_Current_Project_Highpoly dir =
	(
		setIniForceUTF16Default true
		local filenameIni = getFilenamePath(getSourceFileName()) + "GeoAGR.ini"
		local NumIni = (getINISetting filenameIni "Projects" "Number") as integer
		HighpolyIni = ""
		for i in #{1..NumIni} where hasINISetting filenameIni "Projects" ("Name" + (i as string)) do 
		(
			NameIni = getINISetting filenameIni "Projects" ("Name" + (i as string))
			Folder = if hasINISetting filenameIni NameIni "Folder" then getINISetting filenameIni NameIni "Folder" else ""
			Highpoly_objs = if hasINISetting filenameIni NameIni "Highpoly_objs" then getINISetting filenameIni NameIni "Highpoly_objs" else ""
			if Folder == dir then HighpolyIni = Highpoly_objs
		)
		HighpolyIni
	)

	fn GetINI_Folder n =
	(
		setIniForceUTF16Default true
		local Folder = getINISetting (getFilenamePath(getSourceFileName()) + "GeoAGR.ini") n "Folder"
		Folder
	)

	fn GetTexelDensity theMapSize =
	(
		if classof (unwrapmod = modpanel.getcurrentobject()) == unwrap_uvw do --Check the Modifier Class whether it is unwrap_uvw or not
		(
			if (faces = unwrapmod.getselectedfaces()).count > 0 do
			(
				unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom -- Get some information about the selection
				textureArea = theMapSize^2 -- Calculate the total texture area
				usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
				texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
			)
		)
		texelDensity --return value
	) 

	fn GetMetersFromGU = --Function to calculate how many "meters" in system units
	(
		local meters = case units.systemType of
		(
			#Inches: 0.0254
			#Feet: 0.3048
			#Miles: 1609.0
			#Millimeters: 0.001
			#Centimeters: 0.01
			#Meters: 1.0
			#Kilometers: 1000.0
		)
		return meters * units.SystemScale 
	)
	
	fn ConvertImageToBase64String filename =
	(
		if (doesfileexist filename) do
		(
			ConvertClass = dotNetClass "System.Convert"
			ImageClass = dotNetClass "System.Drawing.Image"
			memstream = dotnetobject "System.IO.MemoryStream"
			ImgLoaded = ImageClass.fromfile filename
			ImgLoaded.save memstream ImgLoaded.rawformat
			Base64string = ConvertClass.ToBase64String (memstream.ToArray())
			memstream.close()
			Base64String --return Base64String
		)
	)

	fn ConvertBase64StringToImage string =
	(
		ConvertClass = dotNetClass "System.Convert"
		ImageClass = dotNetClass "System.Drawing.Image"
		bytearr = ConvertClass.FromBase64String string
		memstream = dotnetobject "System.IO.MemoryStream" bytearr
		DecodedImg = ImageClass.fromstream memstream
		memstream.close()
		DecodedImg	--return DecodedImg
	)

	fn getNameFromPath path =
	(
		s = filterString path "\\"
		res = s[s.count]
		res
	)

	fn create_plane imgfilepath =
	(
		sn = getNameFromPath(imgfilepath)
		cmt = Standardmaterial() 
		cmt.name = sn
		cmt.diffuseMap = Bitmaptexture fileName:imgfilepath
		cmt.diffuseMap.coords.realWorldScale = off
		try (NitrousGraphicsManager.SetTextureSizeLimit 2048 true ) catch ()
		cmt.showInViewport = true
		img = cmt.diffuseMap.bitmap
		pp = Plane length:img.height width:img.width lengthsegs:1 widthsegs:1 name:sn --transform:(matrix3 [1,0,0] [0,0,1] [0,-1,0] [0,0,0]) isSelected:off 
		pp.realWorldMapSize = off
		pp.mat = cmt
	)

	fn doubleslash s =
	(
		s = substitutestring s "\\" "\\\\" 
		return s
	)

	fn getMaterialThumbnail mat picpath = 
	(
		local thumb = undefined
		local iGlobal = (dotnetClass "Autodesk.Max.GlobalInterface").Instance
		if iGlobal != undefined then 
		(
			local IntPtr = dotnetClass "System.IntPtr"
			local pStampSize = (dotnetclass "Autodesk.Max.PostageStampSize").Large

			local backupMat = meditMaterials[24]
			meditMaterials[24] = mat
			local matRef = iGlobal.CoreInterface.GetMtlSlot 0

			local pStamp = matRef.CreatePStamp pStampSize true
			local bytes = pStamp.Image
			local size = pStamp.Width
			thumb = bitmap size size gamma:0.45 color:(color 0 0 0 255) filename:picpath hdr:false 
		
			local step = size * 3
			for y = 1 to bytes.count by step do 
			(
				local row = for x = y to (y + step - 1) by 3 collect [bytes[x + 2], bytes[x + 1], bytes[x]]
				setpixels thumb [0, size -= 1] row
			)
			pStamp.Dispose()
			matRef.Dispose()
			meditMaterials[24] = backupMat
			save thumb quiet:true
		)
		return thumb
	)
	--display (getMaterialThumbnail (meditMaterials[1]) "C:\\pic1.png")


	fn flatten =
	(
			for sp in selection do 
			(
					--sp.wireColor = black
					if ((classof sp == SplineShape or classof sp == Line) and sp.modifiers.count == 0) do 
					(
						new_z = sp.pos.z = 0 
						for s = 1 to (numSplines sp) do ( 
							for k = 1 to (numKnots sp s) do ( 
								knt = getKnotPoint sp s k 
								in_vec = getInVec sp s k 
								out_vec = getOutVec sp s k 
								knt.z = in_vec.z = out_vec.z = new_z 
								setInVec sp s k in_vec 
								setOutVec sp s k out_vec 
								setKnotPoint sp s k knt 
								)	--end k loop 
							)	--end s loop 
						updateshape sp
						ResetXForm sp
						converttosplineshape sp
					)
					--centerpivot sp
				sp.dir=[0,0,1]
			)
	)

	fn slicepl i cut pos eu =
	(
		with redraw off
		(
			addmodifier i (sliceModifier())
			modTM = getModContextTM i i.modifiers[1]
			objTM = i.objecttransform
			i.modifiers[1].Clean = true
			i.modifiers[1].SliceFormat = 0 --plane
			i.modifiers[1].Slice_Type = cut
			i.modifiers[1].Faces___Polygons_Toggle = 2 --automatic
			--if not ctrl then 
			i.modifiers[1].slice_plane.rotation = eu 
			--else i.modifiers[1].slice_plane.rotation = rot
			i.modifiers[1].slice_plane.position = (pos * modTM * (inverse objTM)) 

		)
		/*
		--converttopoly i
		--i.deleteIsoVerts()
		--polyop.CollapseDeadStructs i
		mod_slice=sliceModifier()
		mod_slice.Slice_Type=cut
		mod_slice.slice_plane.rotation=quat 0 0 0 1
		mod_slice.slice_plane.position=[0,0,0]
		mod_slice.Faces___Polygons_Toggle=0
		pl=plane()
		pl.typeinPos=[0,0,0] 
		pl.rotation = rot --eulerangles 0 0 0
		pl.length=100
		pl.width=100
		pl.pos=pos
		addmodifier i mod_slice
		a = pl.rotation
		b = i.rotation
		c = pl.pos
		d = i.pos
		i.modifiers[1].slice_plane.controller[2].controller.value = b-a
		i.modifiers[1].slice_plane.controller[1].controller.value = c-d
		delete pl
		converttopoly i
		polyop.CollapseDeadStructs i
		--return i
		*/
	)
	
	fn slicepoly i pos eu =
	(
		with redraw off
		(
			if classof i != Editable_Poly then converttopoly i
			local faces = polyop.getFaceSelection i
			if faces.isempty then faces = #{1..polyop.getNumFaces i} 
			local plane = ray pos [eu.x, eu.y, eu.z]
			polyop.slice i faces plane
		)
	)
	
	fn getFilesRecursive root pattern =
	(
		local dir_array = GetDirectories (root + "/*")
		for d in dir_array do join dir_array (GetDirectories (d + "/*"))
		local my_files = #()
		for f in dir_array do join my_files (getFiles (f + pattern))
		my_files
	)

	fn getDirsRecursive root =
	(
		local dir_array = GetDirectories (root + "/*")
		for d in dir_array do join dir_array (GetDirectories (d + "/*"))
		dir_array
	)

	fn getDirsRecursive_pattern root pattern =
	(
		local dir_array = #()
		dir_arrays = GetDirectories (root + "/*")
		for d in dir_arrays do join dir_array (GetDirectories (d + "/*" + pattern))
		dir_array
	)
	
	fn import_objects_file arch = 
	(
		arr = #()
		myfiles = #()

		filesFBX = #()
		filesTEX = #()
		filesAll = #()
		objAll = #()
		filesFBX_CURRENT = #()
		
		myfiles = #(arch)
		--max reset file						
		resetMaxFile #noPrompt
		units.DisplayType = #metric
		units.MetricType = #meters
		units.SystemType = #meters	
		for f in myfiles where not keyboard.escPressed do 
		(
			ext = getFilenameType f
			nam = getFilenameFile f
			path = getFilenamePath f

			nam2 = nam
			dirname = path + nam + "\\"
			--print dirname
			
			makedir dirname
			filename = dirname + nam + ext
			--print filename
			
			if not doesFileExist filename then copyFile f filename
				
			--cmd = "\"C:\Program Files\7-Zip\7z.exe\"" + " x *.zip -o* -y " --" x *.* -y"
			cmd = "\"" + GetDir #maxroot + "GeoScripts\\7z.exe" + "\"" + " x *.zip -o* -y " --" x *.* -y"
			--print cmd
			HiddenDOSCommand (cmd) startpath:(dirname)
			
			filesFBX_CURRENT = getFiles (dirname + "\\" + nam + "\\" + "*.fbx")

			if filesFBX_CURRENT != undefined then
				if filesFBX_CURRENT != #() then
					for fbx in filesFBX_CURRENT where fbx != undefined do 
					(
						importFile fbx #noPrompt
						append objAll (objects as array)
					)
						
			filesFBX = (getFiles (dirname + nam + "\\" + "*.fbx"))
			filesAll = (getFiles (dirname + nam + "\\" + "*.*"))
				
			for f in filesFBX do 
			(
				ff = getFilenameFile f
				print (dirname + nam + "\\" + ff + ".fbm\\" + "*.*")
				append filesTEX (getFiles (dirname + nam + "\\" + ff + ".fbm\\" + "*.*")) --после импорта появляется новый каталог с текстурами, смотрим там
			)
			arr = #(myfiles, filesFBX, filesTEX, filesAll, objAll)
		)
		arr --#(myfiles, filesFBX, filesTEX, filesAll, objAll)
	)
	
	fn import_objects path_arc = 
	(
		myfiles = #()
		myDirs = #()	

		filesFBX = #()
		filesGeoJSON = #()
		filesPNG = #()
		filesAll = #()
		objAll = #()
		filesFBX_CURRENT = #()
		
		--myDirs = getDirsRecursive path_arc 
		myDirs = path_arc 
		print myDirs
		myfiles = getFiles (myDirs + "*.zip")

		sort myfiles
		print #(myfiles)
		max reset file
		for f in myfiles where not keyboard.escPressed do 
		(
			ext = getFilenameType f
			nam = getFilenameFile f
			path = getFilenamePath f

			nam2 = nam
			dirname = path + nam + "\\"
			print dirname
			
			makedir dirname
			filename = dirname + nam + ext
			print filename
			
			if not doesFileExist filename then copyFile f filename
				
			--cmd = "\"C:\Program Files\7-Zip\7z.exe\"" + " x *.zip -o* -y " --" x *.* -y"
			cmd = "\"" + GetDir #maxroot + "GeoScripts\\7z.exe" + "\"" + " x *.zip -o* -y " --" x *.* -y"
			print cmd
			HiddenDOSCommand (cmd) startpath:(dirname)
			
			filesFBX_CURRENT = getFiles (dirname + "\\" + nam + "\\" + "*.fbx")
			
	
			if filesFBX_CURRENT != undefined then
				if filesFBX_CURRENT != #() then
					for fbx in filesFBX_CURRENT where fbx != undefined do 
					(
						importFile fbx #noPrompt
						append objAll (objects as array)
					)
						
			append filesFBX (getFiles (dirname + "\\" + nam + "\\" + "*.fbx"))
			append filesGeoJSON (getFiles (dirname + "\\" + nam + "\\"+ "*.geojson"))
			append filesPNG (getFiles (dirname + "\\" + nam + "\\"+ "*.PNG"))
			append filesAll (getFiles (dirname + "\\" + nam + "\\"+ "*.*"))
		)
		#(myfiles, filesFBX, filesGeoJSON, filesPNG, filesAll, objAll)
	)

	fn FBX_Statictics =
	(
		stri = ""
		WindowHandle = DialogMonitorOPS.GetWindowHandle()
		controls = windows.getChildrenHWND WindowHandle --parent:#max
		--"	File Directory:	File Version:	7.4.0 File Creator:	FBX SDK/FBX Plugins version 2020.3.4 File Custom Writer:	No File Creation Time:	2025/4/30  23:31:24 File Axis Direction:	Z-up File Units:	Meters System Axis Direction:	Z-up System Units:	Meters System frame rate:	30,0 File frame rate:	30,0 File content:	5 Elements,   5 Materials,   17 Textures"
		for child in controls where findstring child[5] "File Directory:" != undefined or findstring child[5] "File Version:" != undefined do stri = (child)[5] 
		UIAccessor.PressButtonByName WindowHandle "Cancel"
		if stri != undefined then WriteAllLines (GetINI_ImageMagick() + "!.txt") stri
		--stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!!.txt") ((dotNetClass "System.Text.Encoding").UTF8)		
		true
	)
	
	fn GetFBXFileVersion theFBXFile = 
	(
		r = 0
		if theFBXFile != undefined then
		(
			theBinStream = fopen theFBXFile "r"
			--keyWord = "FBXVersion"
			--notFind = true
			--textFromBin = ""
			--fseek theBinStream 0 #seek_end
			--binEnd = ftell theBinStream 
			fseek theBinStream 116 #seek_set
			r = (ReadLong theBinStream #signed)
			FClose theBinStream
		)
		r
	)
		
/*	
	fn GetFBXFileVersion_ theFBXFile = 
	(
		local versionFloat, theBinStream, keyWord, notFind, textFromBin, binEnd
		versionFloat = 0
		if theFBXFile != undefined then
		(
			theBinStream = fopen theFBXFile "r"
			keyWord = "FBXVersion"
			notFind = true
			textFromBin = ""
			fseek theBinStream 0 #seek_end
			binEnd = ftell theBinStream 
			fseek theBinStream 0 #seek_set
			
			while (ftell theBinStream < binEnd) and notFind do
			(
				textFromBin = ReadString theBinStream -- ReadString theBinStream 
				if textFromBin == keyWord[1] then
				(
					for i = 1 to keyWord.Count - 1 do textFromBin += ReadString theBinStream as string
				)
				if keyWord == textFromBin then
				(
					versionString = ""
					for i = 1 to 4 do versionString += ReadByte theBinStream --as string
					versionFloat = versionString --as float
					notFind = false
					exit
				)
			)
			FClose theBinStream
		)
		versionFloat
	)
*/
	
	fn parse_error_symbols t = 
	(
		local p = trimleft t "_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
		p = trimright p "_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
		p
	)
	
	fn delete_only_digits t = 
	(
		local p = substitutestring t "0" ""
		p = substitutestring p "1" ""
		p = substitutestring p "2" ""
		p = substitutestring p "3" ""
		p = substitutestring p "4" ""
		p = substitutestring p "5" ""
		p = substitutestring p "6" ""
		p = substitutestring p "7" ""
		p = substitutestring p "8" ""
		p = substitutestring p "9" ""
		p
	)
	
	fn delete_only_ground t = 
	(
		local t = substitutestring t "Ground" ""
		t
	)
	
	fn delete_few_symbols t = 	
	(		
		local p = substitutestring t "'" ""
		p = substitutestring p "`" ""
		p = substitutestring p "ulicza" ""
		p = substitutestring p "Ulicza" ""	
		p = substitutestring p "ploshhad" ""
		p = substitutestring p "Ploshhad" ""	
		p = substitutestring p "bulvar" ""	
		p = substitutestring p "Bulvar" ""	
		p = substitutestring p "most" ""	
		p = substitutestring p "Most" ""	
		p = substitutestring p "№" "N"		
		p = substitutestring p "." ""
		p = substitutestring p "-" ""		
		p = substitutestring p "(" ""	
		p = substitutestring p ")" ""	
		
		p = trimleft p
		p = trimright p
		p = substitutestring p " " ""
		p
	)
	
	fn sortexcel_len arr1 arr2 = 
	(
		if arr1 != undefined and arr2 != undefined then
		(
			case of 
			(
				(arr1.count < arr2.count): 1
				(arr1.count > arr2.count): -1
				default: 0
			)
		)
		else 0
	)
	
	fn tag_getEdgeVerts obj face_index edge_index =
	(
		if classOf obj == Editable_Poly then
		(
			local verts = polyop.getFaceVerts obj face_index
			local edges = polyop.getFaceEdges obj face_index
	 
			edge_index = findItem edges edge_index
			if edge_index == edges.count then #(verts[edge_index], verts[1])
			else #(verts[edge_index], verts[edge_index+1])
		)
		else #() --"ERROR"
	)

	fn tag_getMapVert obj map_channel face_indices index =
	(
		if classOf obj == Editable_Poly then
		(
			if classof face_indices == integer then face_indices = #(face_indices)
			else face_indices = face_indices as Array
			local mesh_verts = #()
			local text_verts = #()
			for i in face_indices do
			(
				join mesh_verts (polyop.getFaceVerts obj i)
				join text_verts (polyop.getMapFace obj map_channel i)
			)
			index = findItem mesh_verts index
			polyop.getMapVert obj map_channel text_verts[index]
		)
		else undefined --"ERROR"
	)

	fn tag_setMapVert obj map_channel face_indices index vert =
	(
		if classOf obj == Editable_Poly then
		(
			if classof face_indices == integer then face_indices = #(face_indices)
			else face_indices = face_indices as Array
			local mesh_verts = #()
			local text_verts = #()
			for i in face_indices do
			(
				join mesh_verts (polyop.getFaceVerts obj i)
				join text_verts (polyop.getMapFace obj map_channel i)
			)
			index = findItem mesh_verts index
			polyop.setMapVert obj map_channel text_verts[index] vert
		)
		else undefined --"ERROR"
	)
	 
	fn tag_getVertex obj index =
	(
		if classOf obj == Editable_Poly then in coordsys world polyop.getVert obj index
		else undefined --"ERROR"
	)
	 
	fn tag_slice obj faces normal center =
	(
		if classOf obj == Editable_Poly then
		(
			local plane = ray center normal
			--for i in faces do polyop.slice obj #{i} plane
			polyop.slice obj faces plane
		)
		else undefined --"ERROR"
	)
	 
	fn tag_equal_int a b =
	(
		if a-b > 0.001 or a-b < -0.001 then false else true
	)

	fn checkMirror obj map_channel face_index =
	(
		local sum = 0
		
		if classOf obj == Editable_Poly then
		(
			local verts = polyop.getFaceVerts obj face_index
			local edges = polyop.getFaceEdges obj face_index --polyop.getFaceVerts obj face_index --polyop.getFaceEdges obj face_index
			
			for i = 1 to edges.count do
			(
				local edge_verts
				local tv1, tv2, tv3
	 
				if i == edges.count-1 then
				(
					tv1 = (tag_getMapVert obj map_channel face_index verts[i])
					tv2 = (tag_getMapVert obj map_channel face_index verts[i+1])
					tv3 = (tag_getMapVert obj map_channel face_index verts[1])
				)
				else 
				(
					if i == edges.count then
					(
						tv1 = (tag_getMapVert obj map_channel face_index verts[i])
						tv2 = (tag_getMapVert obj map_channel face_index verts[1])
						tv3 = (tag_getMapVert obj map_channel face_index verts[2])
					)
					else
					(
						tv1 = (tag_getMapVert obj map_channel face_index verts[i+0])
						tv2 = (tag_getMapVert obj map_channel face_index verts[i+1])
						tv3 = (tag_getMapVert obj map_channel face_index verts[i+2])
					)
				)
				
				local edge1_vect = normalize (tv2 - tv1)
				local edge2_vect = normalize (tv3 - tv1)
		
				-- (cross edge1_vect edge2_vect)
				sum += (cross edge1_vect edge2_vect).z
			)
		)
		
		(sum <= 0)
	)

	fn TAG objs	question =						
	(
		local alt = keyboard.altPressed 
		local map_channel = 1
		if objs.count == 0 do return -1
		
		local tag_objs = #()
		tag_objs = for o in objs where classOf o == Editable_Poly or classOf o == PolyMeshObject collect o

		if tag_objs.count == 0 do return -1
		
		local instances
		for i = 1 to tag_objs.count do
			if tag_objs[i] != #empty do
				if (InstanceMgr.GetInstances tag_objs[i] &instances) > 1 do
					for i2 = i+1 to tag_objs.count do
						for j in instances do
							if tag_objs[i2] == j do
								tag_objs[i2] = #empty
		local is_too_much = -1
		do
		(
			is_too_much = findItem tag_objs #empty
			if is_too_much != 0 do deleteItem tag_objs is_too_much
		) while is_too_much != 0

	
		-- begin loop		
		local o = 0
		for obj in tag_objs where not keyboard.escPressed do 
		(
			o += 1
			--local obj = real_obj
			-- this is a workaround for max 9, because collapseNodeTo is buggy
			--obj = editable_mesh()
			--obj.baseobject = copy real_obj.baseobject
			--local save_obj = real_obj.baseobject
			--hide real_obj
			
			--if classof obj != PolyMeshObject then convertTo obj PolyMeshObject
			converttopoly obj

			select obj
			setCommandPanelTaskMode #modify

			local facecount = obj.faces.count
			
			local FaceSel = #{}
			local FaceSel = polyop.getFaceSelection obj
			if FaceSel.isempty then FaceSel = #{1..facecount}
			
			local query = true
			if subObjectLevel != undefined then 
				if subObjectLevel == 4 or subObjectLevel == 5 then query = false
			
			if query and question then
			(
				if FaceSel.numberset < facecount then
				(
					if querybox "There are selected faces.\nUse them (YES) or ignore (NO)?" then FaceSel = polyop.getFaceSelection obj else FaceSel = #{1..facecount}
				)
			)
			
			local error_cut_faces = #{}
	 		local is_UVmapped = false
			local faces_cutplanes = #()
			faces_cutplanes[facecount] = #()

			local uvwmod = Unwrap_UVW()
			addModifier obj uvwmod
			uvwmod.setMapChannel map_channel
			uvwmod.setConstantUpdate false
			uvwmod.setShowSelectedVertices false
			--uvwmod.updateView()
			uvwmod.setTVSubObjectMode 3

			-- first test: is the object uv mapped?
			local x, y, width, height, areaUVW, areaGeom
			uvwmod.getArea #{1..facecount} &x &y &width &height &areaUVW &areaGeom
			is_UVmapped = ((x >= 0.001) and (x+width <= 0.999) and (y >= 0.001) and (y+height <= 0.999))

			local error_faces = #{}
			if not is_UVmapped do
			(
				error_faces = #{}
				for f in #{1..uvwmod.numberPolygons()} where not keyboard.escPressed do
				(
					uvwmod.getArea #{f} &x &y &width &height &areaUVW &areaGeom
					if (width < 0.00001 or height < 0.00001 or areaUVW < 0.000001) and areaGeom > 0.000001 do error_faces += #{f}
					--if (width < 0.00001 or height < 0.00001 or areaUVW < 0.00001) and areaGeom > 0.001 do error_faces += #{f}
				)
			)
			
			deleteModifier obj uvwmod

			-- First step: analyze the model and save the slice planes in an array
			setCommandPanelTaskMode #create
			
			if not is_UVmapped then
			(
				local faces_cutplanes_count = 0
				--local textures_used = 0
				
				for f = FaceSel - error_faces where not keyboard.escPressed do --#{1..facecount} - error_faces do --for f = 1 to facecount do 
				(
					-- it's likely that we need some sliceplanes for some faces
					faces_cutplanes[f] = #()

					local act_edges = polyop.getFaceEdges obj f					
					if act_edges != undefined do
					(
						local edgecount = act_edges.count
						
						edge_cutpoints_x = #() -- count is same as edgecount at the end
						edge_cutpoints_y = #()
						
						local is_mirrored = checkMirror obj map_channel f
						
						-- build two tables: one with so called x-points, the other one with y-points
						-- e.g. x-points are all at texture uv with y = ...,-1.0,0.0,1.0,2.0,...
						-- so I have to save the min value (e.g. -1.0), in min_y
						--
						-- it has to be guaranteed that the table with the x-points
						-- will be filled correctly (no gaps), so find the right pos (e.g. [3] for 1.0)
						
						-- find the minimum texture coords	
						
						local absminx = 1000000
						local absminy = 1000000
						local minx = 1000000
						local miny = 1000000
						local maxx
						local maxy
						local dir
						local tempx = (ceil(minx)) as integer
						local tempy = (ceil(miny)) as integer	
						
						for i in act_edges where not keyboard.escPressed do 
						(
							local vertices = tag_getEdgeVerts obj f i
							if vertices.count == 0 then continue 
								
							local tv1 = tag_getMapVert obj map_channel f vertices[1]
							local tv2 = tag_getMapVert obj map_channel f vertices[2]
							
							if tv1 != undefined and tv2 != undefined then
							(
								minx = if tv1.x < tv2.x then tv1.x else tv2.x
								miny = if tv1.y < tv2.y then tv1.y else tv2.y
							)
							
							absminx = if absminx < minx then absminx else minx
							absminy = if absminy < miny then absminy else miny
						)
						
						absminx = (ceil(absminx)) as integer
						absminy = (ceil(absminy)) as integer
						
						-- save cutting points for every edge
						-- those cutting points are found at every x/y-axis of texture uvs
						for i in act_edges where not keyboard.escPressed do 
						(
							local vertices = tag_getEdgeVerts obj f i
							
							local tv1 = tag_getMapVert obj map_channel f vertices[1]
							local tv2 = tag_getMapVert obj map_channel f vertices[2]
							
							if tv1 != undefined and tv2 != undefined then
							(
								tv1 = [tv1.x, tv1.y] -- convert to Point2
								tv2 = [tv2.x, tv2.y]
								dir = tv2 - tv1
								
								minx = if tv1.x < tv2.x then tv1.x else tv2.x
								maxx = if tv1.x >= tv2.x then tv1.x else tv2.x
								miny = if tv1.y < tv2.y then tv1.y else tv2.y
								maxy = if tv1.y >= tv2.y then tv1.y else tv2.y
							)
							-- the x-axes ( ... -2, -1, 0, 1, ...)
							tempx = (ceil(minx)) as integer
							while tempx < ceil(maxx) do
							(
								local new_percent = (tempx - tv1.x) / dir.x
								local new_vect = dir * new_percent
								
								-- get the cutpoint in 3d space
								local new_dir = (tag_getVertex obj vertices[2]) - (tag_getVertex obj vertices[1])
								local new_point = (tag_getVertex obj vertices[1]) + (new_dir*new_percent)
								if edge_cutpoints_x[tempx-absminx+1] == undefined do edge_cutpoints_x[tempx-absminx+1] = #()
								append edge_cutpoints_x[tempx-absminx+1] #(i, new_point, tv1.y + new_vect.y, tempx) -- edgenumber, point, texcoords
								tempx += 1
							)
							
							-- the y-axes ( ... -2, -1, 0, 1, ...)			
							tempy = (ceil(miny)) as integer
							while tempy < ceil(maxy) do 
							(
								if keyboard.escPressed then exit
								local new_percent = (tempy-tv1.y)/dir.y
								local new_vect = dir*new_percent
								
								-- get the cutpoint in 3d space
								local new_dir = (tag_getVertex obj vertices[2]) - (tag_getVertex obj vertices[1])
								local new_point = (tag_getVertex obj vertices[1]) + (new_dir*new_percent)
								
								if edge_cutpoints_y[tempy-absminy+1] == undefined do edge_cutpoints_y[tempy-absminy+1] = #()
				
								append edge_cutpoints_y[tempy-absminy+1] #(i, new_point, tv1.x + new_vect.x, tempy) -- edgenumber, coord, texcoords
								tempy += 1
							)				
						)
						
						-- get the points, get their position in 3d-space, build a sliceplane
						-- we have to check if edges cross (they shouldn't)
						-- first: for y
						for i = 1 to edge_cutpoints_y.count where not keyboard.escPressed do 
						(
							local allpoints = deepCopy edge_cutpoints_y[i]
							local points = edge_cutpoints_y[i]
							local act_point_i = 0
							
							while points.count > 1 do
							(
								if keyboard.escPressed then exit
								act_point_i += 1
								local act_edge = copy points[1][1]
								local act_point = copy points[1][2]
								local act_TC = copy points[1][3]
								local act_TC2 = copy points[1][4]
								
								-- get the first point (the active one) out of the list
								deleteItem points 1
										
								-- and test it against every other point on the same "line"
								for other_points_i = 1 to points.count where not keyboard.escPressed do 
								(
									local other_edge = points[other_points_i][1]
									local other_point = points[other_points_i][2]
									local other_TC = copy points[other_points_i][3]
									
									-- find out if other edges are crossing
									local is_near = true
									for test_points_i = 1 to allpoints.count while is_near do
									(
										if test_points_i != act_point_i and test_points_i != (act_point_i+other_points_i) do
										(
											local test_TC = allpoints[test_points_i][3]
											if act_TC < other_TC then
												if test_TC >= act_TC and test_TC <= other_TC do is_near = false
											else
												if test_TC <= act_TC and test_TC >= other_TC do is_near = false
										)
									)
									if is_near do
									(				
										-- angle between edges ...
										local verta = tag_getEdgeVerts obj f act_edge
										local verto = tag_getEdgeVerts obj f other_edge
										
										if verta.count > 0 and verto.count > 0 then
										(
											local tva1 = tag_getMapVert obj map_channel f verta[1]
											local tva2 = tag_getMapVert obj map_channel f verta[2]
											local tvo1 = tag_getMapVert obj map_channel f verto[1]
											local tvo2 = tag_getMapVert obj map_channel f verto[2]
											
											if tva1 != undefined and tva2 != undefined and tvo1 != undefined and tvo2 != undefined then
											(
												-- which one is on the left?
												local going_on = true
												if not is_mirrored then
												(
													if act_TC < other_TC then
														if (tva1.y <= tva2.y) do going_on = false
													else
														if (tvo1.y <= tvo2.y) do going_on = false
												)
												else
												(
													if act_TC < other_TC then
														if (tva1.y >= tva2.y) do going_on = false
													else
														if (tvo1.y >= tvo2.y) do going_on = false
												)
												
												if going_on do
												(
													local plane_normal = cross (polyop.getFaceNormal obj f) (other_point-act_point)
													plane_normal = normalize plane_normal
																		
													append faces_cutplanes[f] #(act_point, plane_normal, false, act_TC2) -- center, normal, is-x-axis, which axis
													faces_cutplanes_count += 1
												)
											)
										)
									)
								)
							)
						)
						
						-- the same for x
						for i = 1 to edge_cutpoints_x.count where not keyboard.escPressed do
						(
							local allpoints = deepCopy edge_cutpoints_x[i]
							local points = edge_cutpoints_x[i]
							local act_point_i = 0
							
							while points.count > 1 do
							(
								if keyboard.escPressed then exit
								act_point_i += 1
								local act_edge = copy points[1][1]
								local act_point = copy points[1][2]
								local act_TC = copy points[1][3]
								local act_TC2 = copy points[1][4]
								
								-- get the first point (the active one) out of the list
								deleteItem points 1
										
								-- and test it against every other point on the same "line"
								for other_points_i = 1 to points.count where not keyboard.escPressed do 
								(
									local other_edge = points[other_points_i][1]
									local other_point = points[other_points_i][2]
									local other_TC = points[other_points_i][3]
									
									-- find out if other edges are crossing
									local is_near = true
									for test_points_i = 1 to allpoints.count while is_near do
									(
										if test_points_i != act_point_i and test_points_i != (act_point_i+other_points_i) do
										(
											local test_TC = allpoints[test_points_i][3]
											if act_TC < other_TC then
												if test_TC >= act_TC and test_TC <= other_TC do is_near = false
											else
												if test_TC <= act_TC and test_TC >= other_TC do is_near = false
										)
									)
									
									if is_near do
									(
										-- angle between edges ...
										local verta = tag_getEdgeVerts obj f act_edge
										local verto = tag_getEdgeVerts obj f other_edge
								
										if verta.count > 0 and verto.count > 0 then
										(
											local tva1 = tag_getMapVert obj map_channel f verta[1]
											local tva2 = tag_getMapVert obj map_channel f verta[2]
											local tvo1 = tag_getMapVert obj map_channel f verto[1]
											local tvo2 = tag_getMapVert obj map_channel f verto[2]
											
											if tva1 != undefined and tva2 != undefined and tvo1 != undefined and tvo2 != undefined then
											(
												-- which one is on the left?
												local going_on = true
												if not is_mirrored then
												(
													if act_TC < other_TC then
														if (tva1.x >= tva2.x) do going_on = false
													else
														if (tvo1.x >= tvo2.x) do going_on = false
												)
												else
												(
													if act_TC < other_TC then
														if (tva1.x <= tva2.x) do going_on = false
													else
														if (tvo1.x <= tvo2.x) do going_on = false
												)
									
												if going_on do
												(
													local plane_normal = cross (polyop.getFaceNormal obj f) (other_point-act_point)
													plane_normal = normalize plane_normal
													
													append faces_cutplanes[f] #(act_point, plane_normal, true, act_TC2) -- center, normal, is-x-axis, which axis
													faces_cutplanes_count += 1
												)
											)
										)
									)
								)
							)
						)
					)
				)
				--obj.preserveUVs = true
			)
			
			obj.preserveUVs = true
			
			--slice the geometry
			local newfaces = #{}
			if not is_UVmapped do
			(
				for f = FaceSel - error_faces where not keyboard.escPressed do --for f = #{1..facecount} - error_faces do --for f = 1 to facecount do 
				(
					if faces_cutplanes[f].count > 0 then
					(
						local old_edgecount = obj.edges.count
						
						--setFaceSelection obj #(f)
						polyop.setfaceselection obj #{f}
						
						local act_verts = obj.numVerts
						
						for i = 1 to faces_cutplanes[f].count where not keyboard.escPressed do
						(
							local active_faces = polyop.getFaceSelection obj 
							
							if alt then 
							(
								for ff in active_faces do 
								(
									active_faces = polyop.getFaceSelection obj 
									local success = tag_slice obj #{ff} faces_cutplanes[f][i][2] faces_cutplanes[f][i][1]
									newfaces += polyop.getfaceselection obj
									if not success then error_cut_faces += active_faces
								)
							)
							else
							(
								local success = tag_slice obj active_faces faces_cutplanes[f][i][2] faces_cutplanes[f][i][1]
								newfaces += polyop.getfaceselection obj
								if not success then error_cut_faces += active_faces
							)
							
							local xaxis = faces_cutplanes[f][i][3]
							local tc_val = faces_cutplanes[f][i][4]
							
							for j = act_verts+1 to obj.numVerts where not keyboard.escPressed do
							(
								local tv = tag_getMapVert obj map_channel (polyop.getfaceselection obj) j
								if xaxis then tv.x = tc_val else tv.y = tc_val
								tag_setMapVert obj map_channel (polyop.getfaceselection obj) j tv
								
								--local tv = tag_getMapVert obj map_channel (getFaceSelection obj) j
								--if xaxis then tv.x = tc_val else tv.y = tc_val
								--tag_setMapVert obj map_channel (getFaceSelection obj) j tv
							)		
							act_verts = obj.numVerts
						)
					)
				)
				
			)

			setCommandPanelTaskMode #modify
			polyop.setFaceSelection obj (FaceSel + newfaces)
			
			if not error_cut_faces.isempty then messagebox "Some faces do not cut"
			
/*
			if real_obj != obj do
			(
				real_obj.baseobject = obj.baseobject
				for geo in geometry where geo.baseobject == save_obj do geo.baseobject = obj.baseobject
				delete obj
				unhide real_obj
			)
*/			
		)
		select objs
		return 1
	)
	
	fn round x = 
	(
		local x5 = x as integer
		local x6 = if x >= 0 then (x + 0.5) as integer else (x - 0.5) as integer
		local x7 = if x >= 0 then (x + 1) as integer else (x - 1) as integer	
		local x3 = if x5 == x6 then x5 else x7
		x3
	)
	
	fn dr i =
	(
		local j = i as integer
		(i - j)
	)
	
	fn trim t = 
	(
		if t != undefined then
		(
			format "% --> " t
			if t != "" then
			(
				local a = trimright t "0123456789" 
				a = trimleft a "0123456789"
				
				a = substitutestring a "0" ""
				a = substitutestring a "1" ""
				a = substitutestring a "2" ""
				a = substitutestring a "3" ""
				a = substitutestring a "4" ""
				a = substitutestring a "5" ""
				a = substitutestring a "6" ""
				a = substitutestring a "7" ""
				a = substitutestring a "8" ""
				a = substitutestring a "9" ""
				
				format "% --> " a
				if a != undefined then 
					if a != "" then 
						for i = 1 to a.count do t = substitutestring t a[i] "" 
				format "% --> " t
			)
			local s = case of
			(
				((t as integer) >= 1001 and (t as integer) <= 1100): ((t as integer) - 1000) 
				((t as integer) > 0 and (t as integer) <= 100): (t as integer)
				default: 0
			)		
			format "%\n" s			
			return (s as integer)
		)
		0
	)
	
		
	fn par pp p spn = 
	(
		--local angle = acos(dot (normalize vec_A) (normalize vec_B))
		--local paral = if angle >= abs(180 - spn) or angle <= abs(spn) then true else false  
		--local paral = if abs(dot (normalize vec_A) (normalize vec_B)) >= (1-spn) or abs(dot (normalize vec_A) (normalize vec_B)) <= spn then true else false
		--local paral = if abs(dot(normalize vec_A) (normalize vec_B)) <= 0.1 then true else false
		--local paral = if abs(dot (normalize vec_A) (normalize vec_B)) >= (1-spn) or abs(dot (normalize vec_A) (normalize vec_B)) <= spn then true else false
		local vec_A = pp[1] - p
		local vec_B = pp[2] - p
		local paral = if abs(dot (normalize vec_A) (normalize vec_B)) >= (1 - spn) then true else false
		paral	
	)
	
	fn getsize a =
	(
		local str = ""
		
		if a != undefined then
		try
		(
			local b = openBitMap a.filename 
			if b != undefined then
			(
				str += b.width as string + "x" + b.height as string
				str += if b.hasalpha then " Alpha " else " "
				close b
				free b
			)
		)
		catch(str += " ")
		str
	
	)		
	
	fn WriteFile filename stri =
	(
		local Writer = dotNetObject"System.IO.StreamWriter" filename false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-8"))
		--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("Windows-1251")) --ANSI
		--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-16LE"))
		Writer.Write(stri)
		Writer.Close()
		free Writer
		--free filename
		--free stri
	)
	
	fn TooltipWriter filenameIni controls str =
	(
		--local filenameIni = GetDir #maxroot + "\\GeoScripts\\tooltips_syssetup.ini"
		if not doesFileExist filenameIni then
		(
			local stri = str
			for i in controls.controls where isProperty i "tooltip" do 
			(
				--if findstring i.tooltip "|" != undefined then i.tooltip = (filterstring i.tooltip "|")[1]
				--if findstring i.tooltip "|" != undefined then 
				stri += i.name + "=" + (substitutestring (substitutestring (i.tooltip as string) "\n" "::" ) "\r" "") + "\n"
				--print stri
				--messageBox stri
				WriteFile filenameIni stri 
			)
			free stri
		)
	)
	
	fn TooltipReader filenameIni controls_name str state =
	(
		try
		(
			if doesFileExist filenameIni then
			(
				local tooltip = getINISetting filenameIni str controls_name
				if tooltip != undefined then
				(
					if tooltip != "" then
					(
						if findstring tooltip "|" != undefined then 
						(
							tooltip = substitutestring tooltip " | " "|"
							tooltip = substitutestring tooltip "\r" ""
							tooltip = substitutestring tooltip "::" "\n"
							tooltip = (filterstring tooltip "|")[state]
							if state == 1 then 
							(
								tooltip = substitutestring tooltip "LMB" "ЛКМ"
								tooltip = substitutestring tooltip "RMB" "ПКМ"
							)
							return tooltip
						)
					)
					else return ""
				)
				else return ""
			)
			else return ""
		)catch(return "")
		return ""
	)
	
	fn ValidTypeControl c = 
	(
		local a = false 
		
		a =	case (classof c) of
			(
				default: false
				CheckBoxControl: true
				EditTextControl: true
				ComboBoxControl: true
				ButtonControl: true
				RadioControl: true	
				LabelControl: true
				SpinnerControl: true
				ColorPickerControl: true
			)
		return a
	)

	fn get_sub_maps current_node =
	(
		local materials = #()
		local textures = #()
		local sub_maps_count = getNumSubTexmaps current_node

		for map = 1 to sub_maps_count do
		(
			local child_map = getSubTexmap current_node map
			appendIfUnique materials child_map
			/* 
			if child_map != undefined then
			(
				local sub_maps_count = getNumSubTexmaps child_map
				
				if sub_maps_count > 0 then
				(
					appendIfUnique textures child_map
					get_sub_maps child_map
				)
				else
				(
					appendIfUnique textures child_map
				)
				
			)
			*/
		)
		materials
	)
	
	fn edgesdist_ p1 p2 p3 p4 a b c d t =
	(	
		local onto = false
		if distance p1 p2 > 0 and distance p3 p4 > 0 then
		(
			if ((distance p1 p2) - (distance p1 p3) - (distance p2 p3)) >= t and ((distance p1 p2) - (distance p1 p4) - (distance p2 p4)) >= t then --точки первого отрезка полностью на втором
			(
				onto = true
				--point pos:p3 size:3 color:red
				--point pos:p4 size:3 color:red
			)
			
			if ((distance p3 p4) - (distance p1 p4) - (distance p1 p3)) >= t and ((distance p3 p4) - (distance p2 p4) - (distance p2 p3)) >= t then --точки втором отрезка полностью на первом
			(
				onto = true
				--point pos:p1 size:3 color:red
				--point pos:p2 size:3 color:red
			)
			
			if ((distance p1 p2) - (distance p1 p3) - (distance p2 p3)) >= t and ((distance p1 p4) - (distance p1 p2) - (distance p2 p4)) >= t then --одна точка на отрезке, другая на прямой дальше
			(
				onto = true
				--point pos:p3 size:3 color:red
				--point pos:p2 size:3 color:red
			)
			
			if ((distance p1 p2) - (distance p1 p4) - (distance p2 p4)) >= t and ((distance p2 p3) - (distance p1 p3) - (distance p2 p3)) >= t then --другая точка на отрезке, первая на прямой дальше
			(
				onto = true
				--point pos:p4 size:3 color:red
				--point pos:p1 size:3 color:red
			)
		)
		onto
	)
	
	fn SquareTriangle a b c = --формула герона
	(
		local p = 0
		local s = 0
		if a >= 0 and b >= 0 and c >= 0 then
		(
			local p = (a + b + c) / 2
			local s = sqrt(p * (p - a) * (p - b) * (p - c))
		)
		s
	)
	
	fn HeightTriangle a b c =
	(	
		local h = 0
		if a >= 0 and b >= 0 and c >= 0 then
		(
			local S = SquareTriangle a b c
			h = 2 * S / a --где h — высота, S — площадь, a — сторона, к которой проведена высота
		)
		h
	)
	
	fn edgesdistA p1 p2 p3 p4 mn mx =
	(
		local onto = false
		if distance p1 p2 > 0 and distance p3 p4 > 0 then
		(
			local a = (distance p1 p4) + (distance p1 p3) - (distance p3 p4)
			local b = (distance p2 p4) + (distance p2 p3) - (distance p3 p4)
			if mn <= a and a <= mx and mn <= b and b <= mx then --точки второго отрезка полностью на первом
			(			
				--format "A1=% A2=%\n" a b
				onto = true
				--point pos:p1 size:0.1 color:red
				--point pos:p2 size:0.1 color:red
			)
		)
		onto
	)		
	
	fn edgesdistA_ p1 p2 p3 p4 mn mx =
	(
		local near = false
		local h1 = HeightTriangle (distance p3 p4) (distance p1 p4) (distance p1 p3) 
		local h2 = HeightTriangle (distance p3 p4) (distance p2 p4) (distance p2 p3) 
		if mn <= h1 and h1 <= mx and mn <= h2 and h2 <= mx then near = true
		#(near, h1, h2)	
	)
	
	fn edgesdistB p1 p2 p3 p4 mn mx =
	(
		local onto = false
		if distance p1 p2 > 0 and distance p3 p4 > 0 then
		(
			local a = (distance p1 p3) + (distance p2 p3) - (distance p1 p2)
			local b = (distance p1 p4) + (distance p2 p4) - (distance p1 p2)
			if mn <= a and a <= mx and mn <= b and b <= mx then --точки первого отрезка полностью на втором
			(			
				--format "B1=% B2=%\n" a b
				onto = true
				--point pos:p3 size:0.1 color:red
				--point pos:p4 size:0.1 color:red
			)
		)
		onto
	)	
	
	fn edgesdistB_ p1 p2 p3 p4 mn mx =
	(
		local near = false
		local h1 = HeightTriangle (distance p1 p2) (distance p1 p3) (distance p2 p3) 
		local h2 = HeightTriangle (distance p1 p2) (distance p1 p4) (distance p2 p4) 
		if mn <= h1 and h1 <= mx and mn <= h2 and h2 <= mx then near = true
		#(near, h1, h2)	
	)
	
	fn edgesdistC p1 p2 p3 p4 mn mx =	
	(
		local onto = false
		if distance p1 p2 > 0 and distance p3 p4 > 0 then
		(
			local a = (distance p1 p3) + (distance p2 p3) - (distance p1 p2)
			local b = (distance p1 p2) + (distance p2 p4) - (distance p1 p4)
			if mn <= a and a <= mx and mn <= b and b <= mx then --одна точка на отрезке, другая на прямой дальше
			(
				--format "C1=% C2=%\n" a b
				onto = true
				--point pos:p3 size:0.1 color:red
				--point pos:p2 size:0.1 color:red
			)
		)
		onto
	)
	
	fn edgesdistC_ p1 p2 p3 p4 mn mx =
	(
		local near = false
		local h1 = HeightTriangle (distance p1 p2) (distance p1 p3) (distance p2 p3) 
		local h2 = HeightTriangle (distance p1 p4) (distance p1 p2) (distance p2 p4) 
		if mn <= h1 and h1 <= mx and mn <= h2 and h2 <= mx then near = true
		#(near, h1, h2)	
	)
	
	fn edgesdistD p1 p2 p3 p4 mn mx =	
	(
		local onto = false
		if distance p1 p2 > 0 and distance p3 p4 > 0 then
		(
			local a = (distance p1 p4) + (distance p2 p4) - (distance p1 p2)
			local b = (distance p1 p3) + (distance p1 p2) - (distance p2 p3)
			if mn <= a and a <= mx and mn <= b and b <= mx then --другая точка на отрезке, первая на прямой дальше
			(			
				--format "D1=% D2=%\n" a b
				onto = true
				--point pos:p4 size:0.1 color:red
				--point pos:p1 size:0.1 color:red
			)			
		)
		onto
	)

	fn edgesdistD_ p1 p2 p3 p4 mn mx =
	(
		local near = false
		local h1 = HeightTriangle (distance p1 p2) (distance p1 p4) (distance p2 p4) 
		local h2 = HeightTriangle (distance p2 p3) (distance p1 p3) (distance p1 p2) 
		if mn <= h1 and h1 <= mx and mn <= h2 and h2 <= mx then near = true
		#(near, h1, h2)	
	)
	
	fn vertvec_ s a e = 
	(
		local dir = [0,0,0]
		local ee = (polyop.getEdgesUsingVert s #{a}) - #{e}
		local vv = #{}
		for o in ee do vv += polyop.getVertsUsingEdge s #{o}
		local p = polyop.getVert s a
		local pp = for v in vv collect polyop.getVert s v
		for vec in pp do dir += p - vec   -- vec - p 
		dir = normalize dir
		dir
	)	

	fn vertvec s a = 
	(
		local dir = [0,0,0]
		local ee = polyop.getEdgesUsingVert s #{a}
		local vv = #{}
		for o in ee do vv += polyop.getVertsUsingEdge s #{o}
		local p = polyop.getVert s a
		local pp = for v in vv collect polyop.getVert s v
		for vec in pp do dir += vec - p 
		dir = normalize dir
		dir
	)		
	
	fn equation_plane x1 y1 z1 x2 y2 z2 x3 y3 z3 =
	(
		local a1 = x2 - x1
		local b1 = y2 - y1
		local c1 = z2 - z1
		local a2 = x3 - x1
		local b2 = y3 - y1
		local c2 = z3 - z1
		local a = b1 * c2 - b2 * c1
		local b = a2 * c1 - a1 * c2
		local c = a1 * b2 - b1 * a2
		local d = - a * x1 - b * y1 - c * z1
		--print ((a as string) + "x +" + (b as string) + "y +" + (c as string) + "z + " + (d as string) + " = 0")
		#(a,b,c,d)
	)
	
	fn dist_plane a b c d1 d2 =
	(
		local d = (abs(d2 - d1)) / (sqrt(a^2 + b^2 + c^2))
		d
	)
	
	fn LineLineIntersect p1 p2 p3 p4 =
	(		
		/*
		Calculate the line segment PaPb that is the shortest route between
		two lines P1P2 and P3P4. Calculate also the values of mua and mub where
		Pa = P1 + mua (P2 - P1)
		Pb = P3 + mub (P4 - P3)
		Return FALSE if no solution exists.
		*/
									
		local EPS = 0.001
		local p13, p43, p21;
		local d1343, d4321, d1321, d4343, d2121
		local numer, denom, d
		local pa, pb, mua, mub
		p13 = p1 - p3
		p43 = p4 - p3

		if ABS(p43.x) < EPS and ABS(p43.y) < EPS and ABS(p43.z) < EPS then return false
									
		p21 = p2 - p1
							
		if ABS(p21.x) < EPS and ABS(p21.y) < EPS and ABS(p21.z) < EPS then return false

		d1343 = p13.x * p43.x + p13.y * p43.y + p13.z * p43.z
		d4321 = p43.x * p21.x + p43.y * p21.y + p43.z * p21.z
		d1321 = p13.x * p21.x + p13.y * p21.y + p13.z * p21.z
		d4343 = p43.x * p43.x + p43.y * p43.y + p43.z * p43.z
		d2121 = p21.x * p21.x + p21.y * p21.y + p21.z * p21.z

		denom = d2121 * d4343 - d4321 * d4321
		if ABS(denom) < EPS then return false

		numer = (d1343 * d4321) - (d1321 * d4343)

		mua = numer / denom
		mub = (d1343 + (d4321 * mua)) / d4343

		pa = p1 + mua * p21
		pb = p3 + mub * p43
		d = distance pa pb	
		return d	
		--return #(pa,pb)
		--return true
	)

	fn intersect Pl Pr = 
	(
		/*
		Будем обозначать A,B,C - точки плоскости, X,Y - точки прямой(концы отрезка),  DotProduct - скалярное произведение,  VectorProduct - векторное произведение. O - искомое множество точек пересечения

		N = VectorProduct ( B - A, C - A )
		N = N / | N |  - нормаль к плоскости  // в принципе это можно и не делать
		V = A - X
		// расстояние до плоскости по нормали
		d = DotProduct ( N, V ) 
		W = Y - X
		// приближение к плоскости по нормали при прохождении отрезка
		e =  DotProduct ( N, W )

		if( e!=0 )
		  O = X + W * d/e;          // одна точка
		else if( d==0)
		  O =X + W * (anything)    // прямая принадлежит плоскости
		else
		  O = empty;                // прямая параллельна плоскости
	  */
		
		local O = undefined
		
		local A = Pl[1]
		local B = Pl[2]
		local C = Pl[3]
		
		local X = Pr[1]
		local Y = Pr[2]
		
		local N = normalize (cross (B - A) (C - A))
			
		local V = A - X
		local W = Y - X
			
		local d = dot N V --расстояние до плоскости по нормали
		local e = dot N W --приближение к плоскости по нормали при прохождении отрезка

		if e != 0 then O = X + W * d/e --одна точка
		if d == 0 then O = X --прямая принадлежит плоскости  O = X + W * (anything)
		
		O
	)


	fn intriangle A B C M N =
	(
		--Проверить знаки у трёх скалярных произведений нормали плоскости на векторное призведение двух векторов, 
		--которые образуют проверяемая точка M и две точки на стороне треугольника. 
		--Если все три знака совпадают - значит точка внутри трегольника ABC.
		
		--N нормаль фейса 
		
		local inside = false
		
		local MA = M - A 
		local MB = M - B
		local MC = M - C
		 
		k = dot N (cross MA MB)
		m = dot N (cross MB MC)
		n = dot N (cross MC MA)
			
		inside = if (k <= 0 and m <= 0 and n <= 0) or (k >= 0 and m >= 0 and n >= 0) then true else false
		--format "% % %\n" k m n
		
		inside
	)

	fn triangle_square a b c =
	(
		local p = (a+b+c)/2
		local s = sqrt(p*(p-a)*(p-b)*(p-c))
		s
	)

	fn inside_triangle A B C P = 
	(
		/*
		Формируются три треугольника: ABP, ACP, BCP. 
		После вычисляются их площади SABP,SACP,SBCP. 
		После этого сверяется сумма этих площадей с площадью треугольника SABC. 
		Если точка лежит на треугольнике ABC, то треугольники ABP, ACP, BCP будут просто частями треугольника ABC, 
		и сумма их площадей будет равна его площади SABC. 
		Если же точка не принадлежит треугольнику, 
		сумма площадей SABP,SACP,SBCP превысит площадь треугольника ABC.
		*/
		
		local inside = false
		
		local AB = distance A B 
		local BC = distance B C 
		local AC = distance A C 
		
		local AP = distance A P 
		local BP = distance B P 
		local CP = distance C P 
		
		local s
		local c

		inside = if (s = (triangle_square AP BP AB) + (triangle_square AP CP AC) + (triangle_square BP CP BC)) - (c = (triangle_square AB BC AC)) <= 0.01 then true else false

		--format "% % %\n" s c (s-c) 
			
		inside
	)

	fn inedge A B P =
	(
		if distance A P + distance B P - distance A B <= 0.01 then true else false
	)	

	fn intersectFaces = 
	with undo "Intersect Faces" on 
	(
		/*	  
		(
			local s = $Plane001
			local p = $Object001
			local pp = for v in #{1..polyop.getNumVerts s} collect polyop.getvert s v
			local n = polyop.getFaceNormal s 1
			local vv = for e in #{1..polyop.getNumEdges s} collect (for a in (polyop.getVertsUsingEdge p #{e}) collect polyop.getvert p a)
			for v in vv do --where (pos = intersect pp v) != undefined do 
			(
				local pos = intersect pp v
				if pos != undefined then
					if abs(pos.x) < 1000000.0 and abs(pos.y) < 1000000.0 and abs(pos.z) < 1000000.0 then
					(
						if intriangle pp[1] pp[2] pp[3] pos n then point pos:pos color:red else point pos:pos color:black
						--if inside_triangle pp[1] pp[2] pp[3] pos then point pos:pos
					)
			)
		)
		*/
		
		if selection.count > 0 then
		(
			--считается, что поли разбиты на элементы уже
			local sel = selection as array
			local pp = #()
			local points = #()	
			local ff = #()	
			for s in sel do
			(
				if classof s != Editable_Poly then convertToPoly s
				s.unhideAll #Vertex
				s.unhideAll #Face
				s.ConnectVertices vertexFlag:1

				--local ff = for f in #{1..polyop.getnumfaces s} where (polyop.getFaceArea s1 f > 0.0001) collect f --polyop.getVertsUsingFace s1 #{f}
				ff = #()
				for f in #{1..polyop.getnumfaces s} where (ss = polyop.getFaceArea s f) >= 0.00001 do
				(
					local tr = for v in polyop.getVertsUsingFace s #{f} collect polyop.getvert s v
					local lin = for e in polyop.getEdgesUsingFace s #{f} collect (for w in (polyop.getVertsUsingEdge s #{e}) collect polyop.getvert s w)
					local n = polyop.getFaceNormal s f
					append ff #(f, tr, lin, n)
				)
				append pp #(s, ff)
			)	
				
			--print pp
			for s1 in #{1..pp.count} do
			(
				local ppp = pp[s1][2] --массив выбранного объекта s1, берем данные треугольников
				local obj = pp[s1][1] --объект, который надо резать
				--print ppp
				for p in ppp do
				(
					local tr = p[2] --треугольник объекта
					local n = p[4] --нормаль треугольника
					local face = p[1] --номер фейса в объекте, который будут резать
					--print tr
					--print n
					for s2 in #{1..pp.count} where s1 != s2 do
					(
						local lll = pp[s2][2] --массив второго объекта
						local obj_ = pp[s2][1] --объект, который пересекается
						for pr in lll do --выбор массива прямымх 
						(
							local face_ = pr[1] --номер фейса, которому принадлежат эджи, чтобы знать как соединять точки
							--print pr
							for l in pr[3] do --поиск по набору прямых
							(
								--print l
								local pos = intersect tr l --получение точки пересечения прямой и плоскости
								
								if pos != undefined then
								
									if inedge l[1] l[2] pos then --проверка на принадлежность точки в эджу, она может быть продолжением него по прямой 
									--if abs(pos.x) < 1000000.0 and abs(pos.y) < 1000000.0 and abs(pos.z) < 1000000.0 then
									(
										if intriangle tr[1] tr[2] tr[3] pos n then --проверка на попадание точки в треугольник
										--if inside_triangle tr[1] tr[2] tr[3] pos then 
										(
											point pos:pos color:red size:3 
											append points #(obj, face, pos, n, face_, obj_)	
											-- объект пересечения, фейс который надо резать, точка пересечения эджа с фейсом, нормаль фейса пересечения, фейс эджа (другой объект), объект эджа						
										)	
										--else point pos:pos color:black size:3 
										
									)
							)
						)
					)
				)
			)
			print points
			/*
			for po = 1 to points.count do 
			(
				poi = points[po]
				poi_start = poi[3] 
				point_fin = poi_start
				if po < points.count then 
				(
					if points[po][4] == points[po+1][4] and points[po][5] == points[po+1][5] then point_fin = points[po+1][4]
					else point_fin = points[ (for ro = 1 to points.count where points[po][4] == points[ro][4] and points[po][5] == points[ro][5] collect ro)[1] ][3]
				)
				else point_fin = points[ (for ro = 1 to points.count where points[po][4] == points[ro][4] and points[po][5] == points[ro][5] collect ro)[1] ][3]
				
				polyop.cutFace poi[1] poi[2] poi_start point_fin poi[4]
				--polyop.cutFace <Poly poly> <int face> <point3 start> <point3 destination> <point3 projdir> node:<node=unsupplied>
			)
			*/
		)
	)
	
	fn ray_triangle_intersection orig dir v0 v1 v2 =
	(			
		--Алгоритм Моллера — Трумбора — алгоритм для определения пересечения прямой (луча) и треугольника в трёхмерном пространстве, для работы которого не требуется предварительное вычисление уравнения плоскости, содержащей треугольник
		--orig и dir задают начало и направление луча. v0, v1, v2 - вершины треугольника.
		--Функция возвращает расстояние от начала луча до точки пересечения или 0.

		local e1 = v1 - v0
		local e2 = v2 - v0

		--Вычисление вектора нормали к плоскости
		local pvec = cross dir e2
		local det = dot e1 pvec

		--Луч параллелен плоскости
		if det <= 0.0000001 and det >= -0.0000001 then return -1

		local inv_det = 1 / det
		local tvec = orig - v0
		local u = (dot tvec pvec) * inv_det
		if u < 0 or u > 1 then return 0
		local qvec = cross tvec e1
		local v = (dot dir qvec) * inv_det
		if v < 0 or (u + v) > 1 then return 0
		local w = (dot e2 qvec) * inv_det
		return w
	)
	
	fn line_proportions a b m = ([(a.x + m * b.x) / (1 + m), (a.y + m * b.y) / (1 + m), (a.z + m * b.z) / (1 + m)])

	fn qsort_area p1 p2 = 
	(
		case of 
		(
			(p1[2] < p2[2]): -1
			(p1[2] > p2[2]): 1
			default:0
		)
	)
	

/*
--try(destroyDialog ::GeoAGR)catch()
--menu
rollout GeoAGR "GeoAGR v1.0" width:500 --height:500 
(
	subrollout S_slicers "Slicers operations" width:450 height:335 --across: 2 
	subrollout S_UDIMs "UDIMs operations" width:450 height:390
	subrollout S_Obj_Spln "Objects operations" width:450  height:120
	subrollout S_UCX "UCX operations" width:450 height:80
	subrollout S_Geojson "Geojson operations" width:450 height:100
	subrollout S_File "File operations" width:450 height:30
)
*/
	
DisableWindowsGhosting = DisableProcessWindowsGhosting()
DisableWindowsGhosting.DisableProcessWindowsGhosting()	
	
try(destroyDialog ::GeoAGR)catch()
try(closeRolloutFloater GeoAGR)catch()

global GeoAGR -- = newRolloutFloater "GeoAGR v1.13.18" 300 700 
global RulesCheck_lowpoly
global RulesCheck_highpoly
global syssetup
global UDIMs
global slicers
global Obj_Spln
global Obj_tools
global UCX
global Geojson
global File
global Docker

GeoAGR = newRolloutFloater "GeoAGR v1.13.40" 300 700 

rollout RulesCheck_lowpoly "Rules Check for Lowpoly Models" autoLayoutOnResize:true height:300
(	
	--button ui_btn_test "\x2714" 
	--label  ui_lbl_test "\x2716"

	radiobuttons rdo_check_lowpoly labels: #("Check Archive", "Check All Scene", "Check Selection in Scene") columns:1 rows:3 default:1 align:#left across:2 offset:[0,0] enabled:false tooltip:""
	button btn_get_path_lowpoly_rules_check "Open Archive with Models" align:#left tooltip:"Open Archive with LowPoly Models to Check Rules"
	edittext edt_lowpoly_rules_check_path "" text:"" labelOnTop:false bold:true width:260 fieldWidth:260 readonly:false offset:[0,0] tooltip:"Path to Folder with LowPoly Models"
	button btn_lowpoly_rules_check "Start Check Rules" align:#left across:3 tooltip:"пока не все правила сделаны ..."
	button btn_lowpoly_checkers_on "Check All" offset:[25,0] tooltip:""
	button btn_lowpoly_checkers_off "UnCheck All" align:#right tooltip:""
	progressBar pb_lowpoly "" width:260 height:10 tooltip:"Checking progress"
	label lbl_lowpoly_progress "" align:#left style_sunkenedge:false width:260 tooltip:"Press ESC to CANCEL check"

		checkbox chk_rules_lowpoly_table_1_All "Таблица 1. Общие требования к архивам" checked:true offset:[0,0] align:#left tooltip:"Таблица 1. «Общие технические требования к архиву данных по трехмерным модели»"
		checkbox chk_rules_lowpoly_table_1_1 "1.Требования к форматам предоставления" checked:true offset:[0,0] align:#left tooltip:"1.Требования к форматам предоставления моделей" 
		
		checkbox chk_rules_lowpoly_table_1_1_1 "1.1. FBX 7.4 (FBX 2014) binary" checked:true offset:[20,0] align:#left tooltip:"1.1. Трехмерные цифровые модели должны предоставляться заявителем в универсальном обменном формате FBX версии 7.4 (FBX 2014) бинарного типа." 
		checkbox chk_rules_lowpoly_table_1_1_2 "1.2. вредоносные программы" checked:true offset:[20,0] tooltip:"1.2. Предоставляемые модели не должны содержать вредоносных программ или частей кода." 
		checkbox chk_rules_lowpoly_table_1_1_3 "1.3. лицензионная версия 3ds max" checked:true offset:[20,0] tooltip:"1.3. Предоставляемые модели должны создаваться с применением лицензионных версий программного обеспечения." 
		checkbox chk_rules_lowpoly_table_1_1_4 "1.4. соответствие визуализации" checked:true offset:[20,0] tooltip:"1.4. Предоставленная трехмерная модель должна соответствовать визуализации и графическим материалам, представленных в рамках предпроектного архитектурного решения (буклета, эскизного проекта) и проектной документации." 

		checkbox chk_rules_lowpoly_table_1_2 "2. Требования к единицам измерения" checked:true offset:[0,10] align:#left tooltip:"2. Требования к единицам измерения"
		checkbox chk_rules_lowpoly_table_1_2_1 "2.1. Система координат - метры" checked:true offset:[20,0] tooltip:"2.1. Система отображения координат должна быть метрическая: одна условная единица измерения соответствует одному метру." 
		
		checkbox chk_rules_lowpoly_table_1_3 "3. Требование к переменной Address" checked:true offset:[0,10] align:#left tooltip:"3. Требование к содержанию переменной Address"
		checkbox chk_rules_lowpoly_table_1_3_1 "3.1. сокращения адреса, нет точек" checked:true offset:[20,0] tooltip:"3.1. Рекомендовано использование сокращений адресообразующих элементов, вместо полного описания согласно Приказу Министерства финансов Российской Федерации от 5 ноября 2015 г. № 171н «Об утверждении Перечня элементов планировочной структуры, элементов улично-дорожной сети, элементов объектов адресации, типов зданий (сооружений), помещений, используемых в качестве реквизитов адреса, и Правил сокращенного наименования адресообразующих элементов». Точка в конце сокращенных слов не ставится.\nзамечание: Название элемента дорожной сети не должно разделяться нижним подчеркиванием, а должно быть записано слитно, при этом каждое новое слово пишется с большой буквы."
		checkbox chk_rules_lowpoly_table_1_3_2 "3.2. адрес латиницей через «_»" checked:true offset:[20,0] tooltip:"3.2. Адресообразующие элементы должны задаваться исключительно латиницей (английским алфавитом), цифрами и символом нижнего подчеркивания («_»). Другие спецсимволы, включая пробел, недопустимы и заменяются символом нижнего подчеркивания («_»)."
		checkbox chk_rules_lowpoly_table_1_3_3 "3.3. разделение «_» цифр и букв" checked:true offset:[20,0] tooltip:"3.3. Адресообразующие элементы разделяются нижним подчеркиванием. Числовые и буквенные знаки отделяются нижним подчеркиванием друг от друга." 
		checkbox chk_rules_lowpoly_table_1_3_4 "3.4. заглавные буквы в словах" checked:true offset:[20,0] tooltip:"3.4. Каждое новое слово начинается с заглавной буквы." 
		checkbox chk_rules_lowpoly_table_1_3_5 "3.5. слово «улица» опускается" checked:true offset:[20,0] tooltip:"3.5. В названиях элементов улично-дорожной сети опускается только слово «улица»." 
		checkbox chk_rules_lowpoly_table_1_3_6 "3.6. кадастровый номер - нет «:»" checked:true offset:[20,0] tooltip:"3.6. Если объект не имеет точного строительного/почтового адреса,..., то в переменную Address указывается кадастровый номер объекта, символ «:» заменяется на «_».\nНапример: 77:02:0015007:4157   77_02_0015007_4157   77:02:0015007:4157, корпус 7   77_02_0015007_4157_К_7\n«Положение ... кадастровых номеров ...», ... №967-РМ от 15.03.2017\n3.1. Кадастровый номер имеет иерархическую структуру ..\nА-Б-В1В2-Г-Д-Е, где:\nА -  номер субъекта Российской Федерации из перечня кодов, утвержденных приказом Госкомзема от 19.09.96 N 102 - 77 - двухзначное число, задающее номер (код) г.Москвы\nБ - номер кадастровой зоны города - двухзначное число (на первом этапе соответствует границам административных округов : \n01-ЦАО, 02-СВАО, 03-ВАО, 04-ЮВАО, 05-ЮАО, 06-ЮЗАО, 07-ЗАО, 08-СЗАО, 09-САО, 10-г.Зеленоград)\nВ1В2 - иерархический составной номер кадастрового квартала, который включает в себя : \nВ1 - двухзначное число, задающее номер кадастрового массива внутри кадастровой зоны\nВ2 - трехзначное число, задающее номер кадастрового квартала внутри массива...\nГ - трехзначное число, задающее номер земельного участка в пределах кадастрового квартала...\nД - «n-разрядное» число, задающее номер здания или сооружения...\nЕ - четырехзначное число, задающее номер жилого или нежилого помещения в здании...\n«-» - разделитель составных частей кадастрового номера."

		checkbox chk_rules_lowpoly_table_2_All "Таблица 2. Требования к НПМ моделям" checked:true offset:[0,10] align:#left tooltip:"Таблица 2 «Технические требования к цифровым трехмерным моделям архитектурно­градостроительных решений объектов капитального строительства»"
		checkbox chk_rules_lowpoly_table_2_1 "1. Требования к архиву, составу, структуре" checked:true offset:[0,0] tooltip:"Требования к файлу архива, к файлам, к структуре данных"
		checkbox chk_rules_lowpoly_table_2_1_1 "1.1. архив ZIP < 1 Gb" checked:true offset:[20,0] tooltip:"1.1. Максимальный размер файла архива - 1 Гб" 
		checkbox chk_rules_lowpoly_table_2_1_2 "1.2. число файлов в архиве: 2..21 FBX" checked:true offset:[20,0] tooltip:"1.2. В состав файла архива входит от 2 до 21 файлов формата FBX (рисунок 2): один файл благоустройства и до 20 файлов формата FBX трехмерных моделей проекта ОКС." 
		checkbox chk_rules_lowpoly_table_2_1_3 "1.3. мусор в составе архива" checked:true offset:[20,0] tooltip:"1.3. В состав файлов формата FBX не должно входить пустых объектов, не содержащих в себе точек, полигонов или граней, анимаций, дефор??аций, камер, звуков, костей, дополнительных	слоев,	ключей	анимации,вспомогательных объектов, не относящихся к проектному решению, подробных внутренних конструкций, подземных и внутренних коммуникаций, людей, транспорта и пр." 
		checkbox chk_rules_lowpoly_table_2_1_4 "1.4. состав FBX бл-ва геометрии, наборы т-р" checked:true offset:[20,0] tooltip:"1.4. В состав файла формата FBX благоустройства, помимо их текстурных наборов (до 22 шт.), входит 5 отдельных объектов геометрии:" 
		checkbox chk_rules_lowpoly_table_2_1_4_1 "1.4.1 геометрия бл-ва: <20 тек. наборов" checked:true offset:[20,0] tooltip:"• геометрия благоустройства (максимум 20 текстурных наборов);"
		checkbox chk_rules_lowpoly_table_2_1_4_2 "1.4.2 полупрозрачные детали бл-ва: нет" checked:true offset:[20,0] tooltip:"• геометрия полупрозрачных деталей благоустройства (при наличии) (без текстурных наборов);"
		checkbox chk_rules_lowpoly_table_2_1_4_3 "1.4.3 геометрия элементов бл-ва: 1 набор" checked:true offset:[20,0] tooltip:"• геометрия отдельных элементов благоустройства (МАФ, мачты освещения и пр.) (1 текстурный набор);"
		checkbox chk_rules_lowpoly_table_2_1_4_4 "1.4.4 полупрозрачные детали эл-в бл-ва: нет" checked:true offset:[20,0] tooltip:" • геометрия полупрозрачных деталей элементов благоустройства (при наличии) (без текстурных наборов);"
		checkbox chk_rules_lowpoly_table_2_1_4_5 "1.4.5 геометрия растительности: 1 набор" checked:true offset:[20,0] tooltip:"• геометрия растительности, которая включает в себя всю растительность на сцене (1 текстурный набор)."
		checkbox chk_rules_lowpoly_table_2_1_5 "1.5. наличие благоустройства" checked:true offset:[20,0] tooltip:"1.5. Файлы благоустройства - неотъемлемая часть АГР и являются обязательными к исполнению" 
		checkbox chk_rules_lowpoly_table_2_1_6 "1.6. все ОКС и эл-ты бл-ва есть в ВПМ и НПМ" checked:true offset:[20,0] tooltip:"1.6. Файлы благоустройства, а также все ОКС проекта АГР должны быть реализованы в полной мере и одинаково как для высокополигональной модели, так и для низкополигональной. Это касается, в том числе, и МАФ, озеленения, столбов освещения и пр." 

		checkbox chk_rules_lowpoly_table_2_2 "2. Требования к разделению ОКС на файлы" checked:true offset:[0,10] align:#left tooltip:"2. Требования к разделению модели ОКС на отдельные файлы формата FBX"
		checkbox chk_rules_lowpoly_table_2_2_1 "2.1. разделение модели, число" checked:true offset:[20,0] tooltip:"2.1. Разделение модели на несколько (не более 20) файлов формата FBX допустимо только при превышении количества треугольных полигонов в составе одного файла формата FBX (см.п.3.7)." 
		checkbox chk_rules_lowpoly_table_2_2_2 "2.2. разделение по зданиям" checked:true offset:[20,0] tooltip:"2.2. Разделение может осуществляться исключительно по группам или одиночным неделимым единицам: отдельностоящим зданиям, секциям, корпусам, строениям, стилобатам." 
		checkbox chk_rules_lowpoly_table_2_2_3 "2.3. разделение на полупр. детали" checked:true offset:[20,0] tooltip:"2.3. При разделении ОКС на несколько файлов формата FBX соответственно разделяются и полупрозрачные детали. " 
		checkbox chk_rules_lowpoly_table_2_2_4 "2.4. нумерация в наименованиях" checked:true offset:[20,0] tooltip:"2.4. При разделении ОКС на несколько файлов формата FBX нумерация в наименованиях не обнуляется в каждом файле формата FBX, а является сквозной в рамках всего АГР." 

		checkbox chk_rules_lowpoly_table_2_3 "3. Требования к объектам геометрии" checked:true offset:[0,10] align:#left tooltip:"3. Требования к объектам геометрии"
		checkbox chk_rules_lowpoly_table_2_3_1 "3.1. минимальное количество тр-ков" checked:true offset:[20,0] tooltip:"3.1. Для описания силуэта (формы) объекта использовать минимально возможное количество треугольных полигонов (рисунок 4), кроме случаев, необходимых для оптимальной UV-развертки." 
		checkbox chk_rules_lowpoly_table_2_3_2 "3.2. общий файл для разных деталей" checked:true offset:[20,0] tooltip:"3.2. Объекты геометрии и полупрозрачные детали, принадлежащие единой модели, должны компоноваться в общем файле формата FBX." 
		checkbox chk_rules_lowpoly_table_2_3_3 "3.3. отдельный файл для бл-ва" checked:true offset:[20,0] tooltip:"3.3. Благоустройство, его элементы и элементы растительности должны быть сформированы в отдельный файл формата FBX (рисунок 2)." 
		checkbox chk_rules_lowpoly_table_2_3_4 "3.4. края выдавлены вниз > 1м" checked:true offset:[20,0] tooltip:"3.4. Полигоны по периметру объекта геометрии благоустройства должны быть выдавлены вниз на расстояние не менее 1 метра." 
		checkbox chk_rules_lowpoly_table_2_3_5 "3.5. иерархические связи и группы" checked:true offset:[20,0] tooltip:"3.5. Объекты геометрии не должны иметь иерархических связей между собой, групп и т.д." 
		checkbox chk_rules_lowpoly_table_2_3_6 "3.6. предельное число тр-ков" checked:true offset:[20,0] tooltip:"3.6. Предельное допустимое количество треугольных полигонов модели ОКС в рамках одного файла формата FBX - 150 000, для благоустройства, его элементов и элементов растительности в сумме - 180 000." 
		checkbox chk_rules_lowpoly_table_2_3_7 "3.7. задвойки, пересечения, прочее" checked:true offset:[20,0] tooltip:"3.7. Объекты геометрии не должны содержать:\n• дубликатов и самопересечений вершин, ребер и полигонов (погрешность расстояния 0,002 м);\n• изолированных вершин, ребер и полигонов;\n• отрезков нулевой длины;" 
		checkbox chk_rules_lowpoly_table_2_3_8 "3.8. нормали объектов наружу" checked:true offset:[20,0] tooltip:"3.8. Нормали объектов, видимых с условной точки наблюдения, должны быть направлены в сторону наблюдателя." 
		checkbox chk_rules_lowpoly_table_2_3_9 "3.9. мелкие и декоративные эл-ты" checked:true offset:[20,0] tooltip:"3.9. Незначительные конструктивные и декоративные элементы, не влияющие на общий облик объекта моделирования, отображаются с помощью изображения на текстурном атласе." 
		checkbox chk_rules_lowpoly_table_2_3_10 "3.10. отступ сонаправленных полигонов" checked:true offset:[20,0] tooltip:"3.10. Для упразднения дефектов отображения сонаправленных полигонов, перекрывающих друг друга, расстояние между ними должно составлять не менее 5 мм и не более 2 см." 
		checkbox chk_rules_lowpoly_table_2_3_11 "3.11. толщина полупрозрачных дет." checked:true offset:[20,0] tooltip:"3.11. Полупрозрачные детали оконного типа, кроме ограждений, не должны иметь толщину." 
		checkbox chk_rules_lowpoly_table_2_3_12 "3.12. триангуляция объектов" checked:true offset:[20,0] tooltip:"3.12. Объекты геометрии должны быть триангулированы перед экспортом в файл формата FBX." 
		checkbox chk_rules_lowpoly_table_2_3_13 "3.13. интерьеры за прозрачными окнами" checked:true offset:[20,0] tooltip:"3.13. Основные внутренние конструкции здания (стены, потолок, пол) должны присутствовать в упрощенном виде только в той части здания, где они могут просматриваться сквозь полупрозрачные детали (рисунок 1а)." 
		checkbox chk_rules_lowpoly_table_2_3_14 "3.14. односторонние полигоны с прозр." checked:true offset:[20,0] tooltip:"3.14. Полигоны, для которых используется карта прозрачности, должны оставаться односторонними." 
		checkbox chk_rules_lowpoly_table_2_3_15 "3.15. визуальные дефекты" checked:true offset:[20,0] tooltip:"3.15. В моделях не должно быть визуальных дефектов: при осмотре объекта в условии ограничений, наложенных камерой или каким-либо другим способом, в поле зрения наблюдателя не должно быть физически отсутствующих полигонов, это не касается зон, которые не просматриваются ни под каким углом." 
		checkbox chk_rules_lowpoly_table_2_3_16 "3.16. трансформации модели сброшены" checked:true offset:[20,0] tooltip:"3.16. Все трансформации модели должны быть сброшены (применены)." 
		checkbox chk_rules_lowpoly_table_2_3_17 "3.17. группы сглаживания" checked:true offset:[20,0] tooltip:"3.17. Группы сглаживания определяет проектировщик согласно проекту и расставляет их только по полигонам." 

		checkbox chk_rules_lowpoly_table_2_4 "4. Требования к материалам" checked:true offset:[0,10] align:#left tooltip:"4. Требования к материалам"
		checkbox chk_rules_lowpoly_table_2_4_1 "4.1. стандартные материалы" checked:true offset:[20,0] tooltip:"4.1. Материалы не должны быть созданы при помощи сторонних движков рендера (VRay, Octane, Corona, Arnold и прочего ПО для визуализации изображений высокого качества, а также Physical Material, Blend)."
		checkbox chk_rules_lowpoly_table_2_4_2 "4.2. материал полупрозрачных деталей" checked:true offset:[20,0] tooltip:"4.2. Материал полупрозрачных деталей не должен содержать в себе текстурных карт."
		checkbox chk_rules_lowpoly_table_2_4_3 "4.3. цвет полупрозрачных деталей" checked:true offset:[20,0] tooltip:"4.3. Цвет материала полупрозрачных деталей задается исполнителем через настройку параметров материала (рисунок 16)." 
		checkbox chk_rules_lowpoly_table_2_4_4 "4.4. свойства и фактура мат-ов" checked:true offset:[20,0] tooltip:"4.4. Свойства и фактура материалов, при необходимости, передаются дополнительными текстурными картами." 
		checkbox chk_rules_lowpoly_table_2_4_5 "4.5. кол-во материалов и наборов" checked:true offset:[20,0] tooltip:"4.5. Количество материалов (кроме материалов полупрозрачных деталей) соответствует количеству текстурных наборов." 
		checkbox chk_rules_lowpoly_table_2_4_6 "4.6. кол-во полупрозрачных мат-ов" checked:true offset:[20,0] tooltip:"4.6. Количество материалов для полупрозрачных деталей не должно превышать 7." 

		checkbox chk_rules_lowpoly_table_2_5 "5. Требования к текстурным картам" checked:true offset:[0,10] align:#left tooltip:"5. Требования к текстурным картам (типы текстур)"
		checkbox chk_rules_lowpoly_table_2_5_1 "5.1. текстурные карты PNG" checked:true offset:[20,0] tooltip:"5.1. Текстурные карты должны предоставляться в виде текстурных атласов в формате PNG и быть включены в файл формата FBX (рисунок 5)."
		checkbox chk_rules_lowpoly_table_2_5_2 "5.2. допустимые размеры карт" checked:true offset:[20,0] tooltip:"5.2. Допустимы следующие размеры текстурных карт: 128x128, 256x256, 512x512, 1024x1024, 2048x2048 пикселей, максимальный размер текстурной карты, помимо условия подпункта (см.п.5.11), 2048x2048 пикселей"
		checkbox chk_rules_lowpoly_table_2_5_3 "5.3. отступ в 8 пикселей" checked:true offset:[20,0] tooltip:"5.3. Рекомендуется выдерживать текстурный отступ в 8 пикселей."
		checkbox chk_rules_lowpoly_table_2_5_4 "5.4. соотношение сторон 1:1" checked:true offset:[20,0] tooltip:"5.4. Соотношение сторон текстурной карты должно быть строго 1:1."
		checkbox chk_rules_lowpoly_table_2_5_5 "5.5. альфа-канал запрещен" checked:true offset:[20,0] tooltip:"5.5. Альфа-канал запрещен к использованию."
		checkbox chk_rules_lowpoly_table_2_5_6 "5.6. состав карт 5 типов" checked:true offset:[20,0] tooltip:"5.6. Текстурный набор исполнитель формирует самостоятельно, исходя из своих потребностей и в соответствии с требованиями данного документа. Максимально возможный набор текстур для объекта геометрии состоит из карт: диффузного цвета, нормалей, прозрачности, карты шероховатости и металличности. Последние две используются обязательно в паре (рисунок 6)."
		checkbox chk_rules_lowpoly_table_2_5_7 "5.7. одинаковый размер в наборе" checked:true offset:[20,0] tooltip:"5.7. Все текстурные карты в рамках одного текстурного набора должны иметь одинаковый размер."
		checkbox chk_rules_lowpoly_table_2_5_8 "5.8. карты непрозрачного стекла" checked:true offset:[20,0] tooltip:"5.8. Параметры набора текстурных карт непрозрачного стекла: месторасположе??ие стекол представить на картах диффузного цвета и картах металличности белым цветом, на карте шероховатости - черным, карта прозрачности отсутствует, либо текстурные координаты, соответствующие положению полигона оконных стекол, заполняются исключительно белым цветом."
		checkbox chk_rules_lowpoly_table_2_5_9 "5.9. на каждый ОКС по 1 набору карт" checked:true offset:[20,0] tooltip:"5.9. На каждый ОКС в составе модели АГР необходимо использовать по одному текстурному набору."
		checkbox chk_rules_lowpoly_table_2_5_10 "5.10. макс кол-во текстур бл-ва" checked:true offset:[20,0] tooltip:"5.10. Максимальное количество текстур для файлов благоустройства - 20, их количество также регулируется требованием к плотности текстуры."
		checkbox chk_rules_lowpoly_table_2_5_11 "5.11. набор текстур эл-тов бл-ва" checked:true offset:[20,0] tooltip:"5.11. При текстурировании элементов благоустройства, выполненных в виде полигональных объектов (с проработкой геометрии в рамках требований к максимальному количеству полигонов) необходимо использовать один текстурный набор на все элементы, размером не более 512x512 пикселей."
		checkbox chk_rules_lowpoly_table_2_5_12 "5.12. набор текстур раст-ти" checked:true offset:[20,0] tooltip:"5.12. При текстурировании элементов растительности необходимо использовать один текстурный набор карт на ??се элементы, размером не более 2048x2048 пикселей. В текстурный ??абор должны входить в обязательном порядке карты диффузного цвета и, при необходимости, карты прозрачности."

		checkbox chk_rules_lowpoly_table_2_6 "6. Требования к ??ло??н??сти текстуры" checked:true offset:[0,10] align:#left tooltip:"6.Требования к плотности текстуры"
		checkbox chk_rules_lowpoly_table_2_6_1 "6.1. плотности карт Ground" checked:true offset:[20,0] tooltip:"6.1. Требования к плотности текстурных карт распространяются только на поверхности рельефа в границах участка территории: плотность текстур должна быть не меньше 10 пикселей на кв. мет??, что при текстуре 2048x2048 соответствует квадрату со сторонами 204 на 204 метров, но не более 40 пикселей на к??. метр (рисунок 7, рисунок 8)."
		checkbox chk_rules_lowpoly_table_2_6_2 "6.2. плотности карт ост??льного" checked:true offset:[20,0] tooltip:"6.2. Требования к плотности текстурных карт не распространяются на полигоны, опущенные вниз под землю по периметру модели благоустройства согласно пункту 3.4 настоящих требований, а также на геометрии растительности, ОКС и элементов благоустройства."

		checkbox chk_rules_lowpoly_table_2_7 "7. Требования к объектам геометрии стекла" checked:true offset:[0,10] align:#left tooltip:"7. Требования к отображению объектов геометрии стекла/светопрозрачных конструкций\nОтображение стекла явля????тся обязательным при его наличии и может быть выполнено двумя способами в одной модели, оба способа отображения стекла можно совмещать в одном проекте:"
		checkbox chk_rules_lowpoly_table_2_7_1 "7.1. текстурные карты стекла" checked:true offset:[20,0] tooltip:"7.1. В случае использования текстурных карт стекло не выделяют в отдельный объект геометрии и в обязательным порядке используют текстурные карты шерохов??тости и металличности, согласно пунктам 5.6, 5.8;"
		checkbox chk_rules_lowpoly_table_2_7_2 "7.2. полупрозрачное стекло" checked:true offset:[20,0] tooltip:"7.2. В случае полупрозрачности стекло выделяют в отдельный объект геометрии и назначают специальный материал согласно пунктам 4.2, 4.3 настоящих требований."		
		
		checkbox chk_rules_lowpoly_table_2_8 "8. Требования к точке отсчета и углам поворота" checked:true offset:[0,10] align:#left tooltip:"8. Требования к точке отсчета и углам поворота объекта геометрии"
		checkbox chk_rules_lowpoly_table_2_8_1 "8.1. углы поворота всех объектов" checked:true offset:[20,0] tooltip:"8.1. Углы поворота всех объектов геометрии после применения (сброса) трансформаци???? должны соответствовать углам поворота ОКС в плане проектного решения."
		checkbox chk_rules_lowpoly_table_2_8_2 "8.2. система координат МСК" checked:true offset:[20,0] tooltip:"8.2. Все объекты геометрии должны иметь координатную привязку в Московской системе координат и высот согласно проектному ??ешению."
		checkbox chk_rules_lowpoly_table_2_8_3 "8.3. произвольная система координат" checked:true offset:[20,0] tooltip:"8.3. Не допускается использование произвольной (условной) системы координат или неполного координатного описания (отсутствие значений высот)."		

		checkbox chk_rules_lowpoly_table_2_9 "9. Требования к суффиксам в наименованиях" checked:true offset:[0,10] align:#left tooltip:"9. Требования к написанию суффиксов в наименованиях"
		checkbox chk_rules_lowpoly_table_2_9_1 "9.1. Суффиксы имен объектов, мат-ов" checked:true offset:[20,0] tooltip:"9.1. Суффиксы применяются к наименованиям файлов, объектов геометрии, материалов и текстур с целью определения/построения иерархии в обязательном порядке:\n1. В наименовании объектов геометрии обозначают принадлежность к:\n_Main ОКС (кроме полупрозрачных деталей)\n_MainGlass полупрозрачным деталям ОКС\n_Ground благоустройству	(кроме полупрозрачных деталей)\n_GroundGlass полупрозрачным	деталям благоустройства\n_GroundEl элементам благоустройства: МАФ, мачтам освещения и пр. (кроме полупрозрачных элементов)"		
		checkbox chk_rules_lowpoly_table_2_9_2 "9.2. Суффиксы имен карт" checked:true offset:[20,0] tooltip:"9.2. В наименовании текстурных карт обозначают принадлежность к картам:\n_d диффузного цвета\n_n нормалей\n_o прозрачности\n_m металличности\n_r шероховатости"	

		checkbox chk_rules_lowpoly_table_2_10 "10. Требования к именам" checked:true offset:[0,10] align:#left tooltip:"10. Требования к наименованиям файлов, геометрий, текстур и материалов"
		checkbox chk_rules_lowpoly_table_2_10_1 "10.1. длина имен везде < 254 символа" checked:true offset:[20,0] tooltip:"10.1. Длина наименования, включая адрес и все суффиксы, постфиксы и префиксы, не должна превышать значения в 254 символа."
		checkbox chk_rules_lowpoly_table_2_10_2 "10.2. символы и спецсимволы в именах" checked:true offset:[20,0] tooltip:"10.2. Наименования должны задаваться исключительно латиницей (английским алфавитом), цифрами и символом нижнего подчеркивания («_»), использование других спецсимволов, включая пробел, недопустимо."
		checkbox chk_rules_lowpoly_table_2_10_3 "10.3. порядок именования для FBX" checked:true offset:[20,0] tooltip:"10.3. Порядок наименования."
		checkbox chk_rules_lowpoly_table_2_10_3_1 "10.3.1 ХХХХ код ОМК ТЕ Москвы в FBX" checked:true offset:[20,0] tooltip:"10.3.1. Файл архива именуется согласно схеме пpeфикc_Address: 0313_ProezdNansena_ZU_8.zip 0313_77_02_0015007_4157_Vld_15.zip - где префикс - четырехзначный код, определяемый согласно общемосковскому классификатору территориальных единиц Москвы"
		checkbox chk_rules_lowpoly_table_2_10_3_2 "10.3.2 суффиксы имен файла FBX" checked:true offset:[20,0] tooltip:"10.3.2. Файл формата FBX именуется согласно схемам, вне зависимости от разделения на отдельные файлы формата FBX: - для ОКС пpeфикc_Address_нoмep, где номер - это порядковый номер fbx, как части АГР в рамках проекта, двухзначное число от 01 до 20, назначаемое с шагом в единицу, строго последовательно и без пропусков, в порядке возрастания. Если FBX один, то его порядковый номер «01» 0313_ProezdNansena_ZU_8_01.fbx 0313_ProezdNansena_ZU_8_02.fbx 0313_77_02_0015007_4157_Vld_l5_01.fbx - для благоустройства префикс_Address_Ground 0313_ProezdNansena_ZU_8_Ground.fbx 0313_77_02_0015007_4157_Vld_15_Ground.fbx"
		checkbox chk_rules_lowpoly_table_2_10_3_3 "10.3.3 суффиксы имен объектов в FBX" checked:true offset:[20,0] tooltip:"10.3.3. Объекты геометрии именуется согласно схемам, вне зависимости от разделения на отдельные файлы формата FBX: - для ОКС SM_Address_HOMep_Main, где номер - это порядковый номер ОКС во всем проекте, а не в конкретном FBX-файле, при разделении АГР на части, трехзначное число от 001 до 020, назначаемое с шагом в единицу, строго последовательно и без пропусков, в порядке возрастания, например:SM_ProezdNansena_ZU_8_001_Main\nSM_Address номер MainGlass - для полупрозрачных деталей ОКС, например: SM_ProezdNansena_ZU_8_001_MainGlass\n— для благоустройства SM_Address_Ground: SM_ProezdNansena_ZU_8_Ground\n— для полупрозрачных деталей благоустройства SM адрес GroundGlass, SM_ProezdNansena_ZU_8_GroundGlass\n- для элементов благоустройства SM_Address_GroundEl, SM_ProezdNansena_ZU_8_GroundEl\n- для полупрозрачных деталей элементов благоустройства SM_Address_GroundElGlass, SM_ProezdNansena_ZU_8_GroundElGlass\n- для растительности SM_Address_Flora, SM_ProezdNansena_ZU_8_Flora"		
		checkbox chk_rules_lowpoly_table_2_10_3_4 "10.3.4 суффиксы имен текстур в FBX" checked:true offset:[20,0] tooltip:"10.3.4. Текстуры именуются согласно схемам:\n	в названиях текстур, через нижнее подчеркивание, с соблюдением следующего порядка пишется: префикс «Т», адрес (для благоустройства, его элементов и растительности) или адрес номер (для ОКС), соответствующий объектам геометрии суффикс, соответствующий текстурным картам суффикс, постфикс SlotNumber — порядковый номер материала, к которому применяется текстурная карта (задается исполнителем, последовательно, начиная с единицы). Если материал единственный в рамках одного файла, то его порядковый номер равен «1», - Для моделей, вне зависимости от разделения на отдельные файлы формата FBX\nT_Address_нoмep_CyффикcГeoмeтpии_CyффиксТекстурныхК??рт_SlotNumber\nT_ProezdNansena_ZU_8_001_Main_d_1\nT_ProezdNansena_ZU_8_002_Main_d_1\n- для благоустройства, его элементов и растительности\nT_Address_CyффикcГеометрии_СуффиксТекстурныхКарт_SlotNumber\nT_ProezdNansena_ZU_8_Ground_d_1.png\nT_ProezdNansena_ZU_8_GroundEl_d_1.png\nT_ProezdNansena_ZU_8_GroundEl_m_1.png\nT_ProezdNansena_ZU_8_GroundEl_r_1.png\nТ_ProezdNansena_ZU_8_Flora_d_1.png\nТ_ProezdNansena_ZU_8_Flora_o_1.png"
		checkbox chk_rules_lowpoly_table_2_10_3_5 "10.3.5 суффиксы имен мат-лов в FBX" checked:true offset:[20,0] tooltip:"10.3.5. Материалы именуются согласно схемам: материалы за исключением материалов полупрозрачных деталей, следует называть тем же именем, что и соответствующую ему текстуру, при этом для текстур используется префикс «Т», а для материалов — префикс «М». Суффикс текстурных карт в названии материалов опускается\nМ_ProezdNansena_ZU_8_001_Main_1\nМ_ProezdNansena_ZU_8_002_Main_1\nМ_ProezdNansena_ZU_8_Main_1\nМ_ProezdNansena_ZU_8_Main_2\nМ_ProezdNansena_ZU_8_Ground_1\nМ_ProezdNansena_ZU_8_GroundEl_1\nМ_ProezdNansena_ZU_8_Flora_1\nдля полупрозрачных деталей M_Glass_HOMep, где номер - это порядковый номер материала от 01 до 07 для полупрозрачной детали в рамках проекта, материалы полупрозрачных деталей носят одинаковое название\nM_Glass_01\nM_Glass_02"
	
	mapped fn check_on e = e.checked = true
	mapped fn check_off e = e.checked = false
	
	on btn_lowpoly_checkers_on pressed do
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "_table_" != undefined collect i
		check_on arr
	)
		
	on btn_lowpoly_checkers_off pressed do
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "_table_" != undefined collect i
		check_off arr		
	)
	
	on chk_rules_lowpoly_table_1_All changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_1_" != undefined collect i
		if arg then check_on arr else check_off arr
	)
	
	on chk_rules_lowpoly_table_2_All changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_" != undefined collect i
		if arg then check_on arr else check_off arr
	) 
	
	on chk_rules_lowpoly_table_1_1 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_1_1" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_1_2 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_1_2" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_1_3 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_1_3" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_2_1 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_1" != undefined collect i
		if arg then check_on arr else check_off arr
	)	

	on chk_rules_lowpoly_table_2_2 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_2" != undefined collect i
		if arg then check_on arr else check_off arr
	)		
	
	on chk_rules_lowpoly_table_2_3 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_3" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_2_4 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_4" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_2_5 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_5" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_2_6 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_6" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_2_7 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_7" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_2_8 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_8" != undefined collect i
		if arg then check_on arr else check_off arr
	)	

	on chk_rules_lowpoly_table_2_9 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_9" != undefined collect i
		if arg then check_on arr else check_off arr
	)	

	on chk_rules_lowpoly_table_2_10 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_10" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on btn_get_path_lowpoly_rules_check pressed do
	(
		--source = (getSavePath caption:"Select Folder with ZIP archive(es)" initialDir: maxFilePath)
		source = getOpenFileName "Select Archive ZIP File archive" types: "ZIP|*.zip|ALL|*.*" 
		print source
		if source != undefined then
		(
			if doesFileExist source then edt_lowpoly_rules_check_path.text = source --+ "\\"
			else edt_lowpoly_rules_check_path.text = ""
		)
		else edt_lowpoly_rules_check_path.text = ""
	)
	
	on btn_lowpoly_rules_check pressed do
	(
		pb_lowpoly.value = 0
		
		case rdo_check_lowpoly.state of
		(
			1:
			(
				if edt_lowpoly_rules_check_path.text != "" then
				(					
					err = ""					
					
					chks = #()
					chks = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "_table_" != undefined and i.checked collect i
					arr = #()
					if chks.count > 0 then arr = if edt_lowpoly_rules_check_path.text != "" then import_objects_file edt_lowpoly_rules_check_path.text else #()
					print #(arr)
					
					--print #(chks)
					if chks.count > 0 and arr.count > 0 then
					for i in #{1..chks.count} do
					(
						pb_lowpoly.value = (i as float) / (chks.count as float) * 100
						lbl_lowpoly_progress.text = chks[i].text
						--RulesCheck_lowpoly.scrollPos = 0
						case chks[i].name of
						(
							"chk_rules_lowpoly_table_1_All": (err += "\x2714 ;Таблица 1. Общие требования к архивам;\n")
							"chk_rules_lowpoly_table_1_1": (err += "\x2714 ;1.Требования к форматам предоставления;\n")
							
							"chk_rules_lowpoly_table_1_1_1": --"1.1. FBX 7.4 (FBX 2014) binary" 
							(
								for f in arr[2] do --#(myfiles, filesFBX, filesTEX, filesAll, objAll)
								(
									--print f
									k = false
									v = 0
									
									in_file = openFile f mode:"rt" 
									if in_file != undefined then
									(
										k = if skipToString in_file "Kaydara FBX Binary" != undefined then true else false
									)
									close in_file
									free in_file
									
									if k then
									(
										if (v = GetFBXFileVersion f) as string == "7400" then () --err += "\x2714 ;1.1.1.; " + (getfilenamefile f) + ": FBX binary файл правильной версии FBX 7.4 2014-2015\n"
										else err += "\x2716 ;1.1.1.;" + (getfilenamefile f) + ": FBX binary файл не правильной версии " + v as string + " \n"
									)
									else err += "\x2716 ;1.1.1.;" + (getfilenamefile f) + ": не FBX binary файл\n"
								)
								--The first 27 bytes contain the header.
								--Bytes 0 - 20: Kaydara FBX Binary  \x00 (file-magic, with 2 spaces at the end, then a NULL terminator).
								--Bytes 21 - 22: [0x1A, 0x00] (unknown but all observed files show these bytes).
								--Bytes 23 - 26: unsigned int, the version number. 7300 for version 7.3 for example.
							)

							"chk_rules_lowpoly_table_1_1_2": () --(err += "\x2714 ;1.1.2.; поиск вредоносных программ в теле FBX не проводился\n" ) --"1.2. вредоносные программы" 
							"chk_rules_lowpoly_table_1_1_3": () --(err += "\x2714 ;1.1.3.; проверки лицензионной версии ПО не проводилось\n" ) --"1.3. лицензионная версия 3ds max" 
							"chk_rules_lowpoly_table_1_1_4": () --(err += "\x2714 ;1.1.4.; соответствие визуализации не устанавливалось\n") --"1.4. соответствие визуализации" 

							"chk_rules_lowpoly_table_1_2": (err += "\x2714 ;2.Требования к единицам измерения;\n") 
							"chk_rules_lowpoly_table_1_2_1": --"2.1. Система координат - метры" 
							(
								--FbxImporter 
								stri = ""
								sys = ""
								for f in arr[2] do
								(
									DialogMonitorOPS.unRegisterNotification id:#eye
									dialogMonitorOps.enabled = true
									DialogMonitorOPS.RegisterNotification FBX_Statictics id:#eye
									importFile f using:FbxImporter --importFile "C:\\Temporary Files\\Elghansa\\Untitled2.fbx" using:FbxImporter
									dialogMonitorOPS.UnRegisterNotification id:#eye
									dialogMonitorOps.enabled = false	
									
									stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!.txt") ((dotNetClass "System.Text.Encoding").UTF8)	
									if stri != undefined then 
									(
										for str in stri where findstring str "File Units:" != undefined do sys = trimleft (trimright (filterstring str ":")[2])
									)
									if sys == "Meters" then () --err += "\x2714 ;1.2.1.; " + (getfilenamefile f) + ": системные единицы метры\n"
									else  err += "\x2716 ;1.2.1.; " + (getfilenamefile f) + ": системные единицы не метры\n"
								)
							)
							
							"chk_rules_lowpoly_table_1_3": (err += "\x2714 ;3.Требование к переменной Address;\n") 
							"chk_rules_lowpoly_table_1_3_1": --"3.1. поиск неправильных сокращений адреса, нет точек" 
							(
								--проверка недопустимых символов
								t = parse_error_symbols (getfilenamefile edt_lowpoly_rules_check_path.text)
								if t != "" then 
								(
									if findstring t "." != undefined then err += "\x2716 ;1.3.1.; " + (getfilenamefile edt_lowpoly_rules_check_path.text) + ": имя файла архива ZIP содержит недопустимые символы точки «.»\n"
									--пишется в 1_3_2 else err += "\x2716 ;1.3.1.; " + (getfilenamefile edt_lowpoly_rules_check_path.text) + ": имя файла архива ZIP содержит недопустимые символы\n"
								)
								--пишется в 1_3_2 else err += "\x2714 ;1.3.1.; " + (getfilenamefile edt_lowpoly_rules_check_path.text) + ": имя файла архива ZIP не содержит недопустимые символы\n"

								for f in arr[2] do 
								(
									t = parse_error_symbols (getfilenamefile f)
									if t != "" then 
									(
										if findstring t "." != undefined then err += "\x2716 ;1.3.1.; " + (getfilenamefile f) + ": имя файла FBX содержит недопустимые символы точки «.»\n"
										--пишется в 1_3_2 else err += "\x2716 ;1.3.1.; " + (getfilenamefile f) + ": имя файла FBX содержит недопустимые символы\n"
									)
									--пишется в 1_3_2 else err += "\x2714 ;1.3.1.; " + (getfilenamefile f) + ": имя файла FBX не содержит недопустимые символы\n"					
								)

								excel_file1 = GetDir #maxroot + "GeoScripts\\abbr3.csv" --для проверки сокращений в имени архива в поле адреса
								excel_file2 = GetDir #maxroot + "GeoScripts\\abbr4.csv" --для проверки сокращений в имени архива в поле строений
								stri_arr1 = #()
								stri1 = #()
								stri_long1 = #()
								stri_arr2 = #()
								stri2 = #()
								stri_long2 = #()
								stri_arr1 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file1 ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "файл abbr3.csv не найден или не открывается")
								stri_arr2 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file2 ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "файл abbr4.csv не найден или не открывается")

								--print #(stri_arr)
	
								if stri_arr1.count > 0 do 
								(
									for i in #{1..stri_arr1.count} do append stri1 (filterstring stri_arr1[i] ";")[2] 
									for i in #{1..stri_arr1.count} do append stri_long1 (translit (filterstring stri_arr1[i] ";")[1])
									qsort stri1 sortexcel_len --сортировка по длинне строк, длинные в начале, чтобы потом заменять
									qsort stri_long1 sortexcel_len --сортировка по длинне строк, длинные в начале, чтобы потом заменять										
								)
								
								if stri_arr2.count > 0 do 
								(
									for i in #{1..stri_arr2.count} do append stri2 (filterstring stri_arr2[i] ";")[2] 
									for i in #{1..stri_arr2.count} do append stri_long2 (translit (filterstring stri_arr2[i] ";")[1])
									qsort stri2 sortexcel_len --сортировка по длинне строк, длинные в начале, чтобы потом заменять
									qsort stri_long2 sortexcel_len --сортировка по длинне строк, длинные в начале, чтобы потом заменять										
								)

								--print #(stri)	
								--print (stri_long)									
				
								excel_file_ul = GetDir #maxroot + "GeoScripts\\ul5.csv" --для проверки существующих названий улиц
								excel_file_pos = GetDir #maxroot + "GeoScripts\\ul4.csv" --для проверки существующих названий поселений
								stri_arr3 = #()
								stri_arr4 = #()
								stri_arr3 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file_ul ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "файл ul5.csv не найден или не открывается")
								stri_arr4 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file_pos ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "файл ul4.csv не найден или не открывается")

								stri_ul = #()
								stri_ul_full = #()
								stri_pos = #()
								stri_pos_pre = #()
								--print #(stri_arr)
								if stri_arr3.count > 0 do 
								(
									for i in #{1..stri_arr3.count} do append stri_ul_full (filterstring stri_arr3[i] ";")[3] 
									for i in #{1..stri_arr3.count} do append stri_ul (filterstring stri_arr3[i] ";")[4] 
									--print (stri_ul)	
									--for s1 in #{1..stri_ul.count} where stri_ul[s1] != undefined do
									--(
									--	for s2 in #{1..stri_long.count} where stri_long[s2] != undefined do 
									--	(
									--		stri_ul[s1] = substitutestring stri_ul[s1] stri_long[s2] ""
									--		stri_ul[s1] = substitutestring stri_ul[s1] (tolower stri_long[s2]) ""
									--	)
									--	stri_ul[s1] = delete_few_symbols stri_ul[s1]
									--)
									--qsort stri_ul sortexcel_len --сортировка по длинне строк, длинные в начале, чтобы потом заменять
									--print (stri_ul)		
								)
								if stri_arr4.count > 0 do 
								(
									for i in #{1..stri_arr4.count} do append stri_pos_pre (filterstring stri_arr4[i] ";")[2] 
									for i in #{1..stri_arr4.count} do append stri_pos (filterstring stri_arr4[i] ";")[3] 
								)
								
								--проверки в имени архива
								t = getfilenamefile edt_lowpoly_rules_check_path.text
								--if t != translit t then err += "\x2716 ;1.3.1.; " + t + ": имя файла архива ZIP содержит недопустимые символы не в транслите\n"

								if findstring t "_" != undefined then --err += "\x2716 ;1.3.1.; " + t + ": имя файла архива ZIP не содержит символы разделения «_»\n"
								(
									tt = #()
									tt_ini = #()
									tt = filterstring t "_"
									tt_ini = filterstring t "_"
									if tt.count > 1 then
									(
										for t1 in #{1..tt.count} do
										(		
											tt[t1][1] = toupper tt[t1][1]  
											--if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования, каждое слово должно начинаться с заглавной буквы: " + tt_ini[t1] + "\n"
										)
										--print #(tt)	
				
										--проверка первых цифр, их должно быть 4 и это цифры
										if delete_only_digits tt[1] != "" and tt[1].count != 4 then err += "\x2716 ;1.3.1.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования, первый элемент должен быть в виде четырёх цифр района по «ОМК ТЕ»: " + tt[1] + "\n"
										
										--проверка если цифры вперемешку с буквами
										for t1 in #{1..tt.count} do
										(		
											tt[t1] = delete_only_digits tt[t1] 
											--if tt[t1] != "" and tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, цифры отделяются от других элементов адреса подчеркиванием: " + tt_ini[t1] + "\n"
										)
										--print #(tt)
										
										--проверка если есть несокращенные названия элементов адреса
										for t1 in #{1..tt.count} where tt[t1] != "" do
										(		
											for t2 in #{1..stri_long1.count} do tt[t1] = substitutestring tt[t1] stri_long1[t2] "" --подставляем полный список эл-тов адреса
											if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, не сокращены элементы адреса: " + tt_ini[t1] + "\n"
										)
										--print #(tt)	
										
										--проверка существующих названий улиц и поселков
										for t1 in #{1..tt.count} where tt[t1] != "" and t1 <= 2 do
										(		
											for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul_full[t2] "" --подставляем полный список улиц
											for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] ("Pos" + stri_pos[t2]) "" --подставляем полный список поселков
											for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] (stri_pos_pre[t2] + stri_pos[t2]) "" --подставляем полный список поселков

											for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul[t2] "" --подставляем полный список улиц
											for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] stri_pos[t2] "" --подставляем полный список поселков
		
											if tt[t1] == tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, название не входит в Официальный «Общемосковский классификатор улиц Москвы» (ОМК 001—2013): " + tt_ini[t1] + "\n"
										)
										--print #(tt)

										-- Название улицы не должно разделяться нижним подчеркиванием, а должно быть записано слитно, при этом каждое новое слово пишется с большой буквы.
										for t1 in #{1..tt.count} where tt[t1] != "" do
										(		
											for t2 in #{1..stri1.count} do tt[t1] = substitutestring tt[t1] stri1[t2] "" --подставляем список сокращений эл-тов адреса
											if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, не должно быть разделения элементов адреса в: " + tt_ini[t1] + " или, возможно, неправильно именованы элементы адреса, название элемента адреса не должно разделяться нижним подчеркиванием, а должно быть записано слитно, при этом каждое новое слово пишется с большой буквы \n"											
										)
										--print #(tt)

										-- последующие теги
										for t1 in #{1..tt.count} where tt[t1] != "" do
										(		
											for t2 in #{1..stri2.count} do tt[t1] = substitutestring tt[t1] stri2[t2] "" --подставляем список сокращений эл-тов адреса
											if tt[t1] == "D" or tolower tt[t1] == "dom" then err += "\x2716 ;1.3.1.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, сокращение D как «дом» опускается: " + tt_ini[t1] + " \n"											
											if tt[t1] == "Uch" then err += "\x2716 ;1.3.1.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, «Uch» желательно заменить на «ZU»: " + tt_ini[t1] + " \n"											
											if tt[t1] == tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, сокращение элемента адреса не входит в список: " + tt_ini[t1] + " \n"											
										)
										--print #(tt)										
									)
								)
								
								for f in arr[2] do 
								(
									t = getfilenamefile f
									--if t != translit t then err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX содержит недопустимые символы не в транслите\n"
									if findstring t "_" != undefined then --err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX не содержит символы разделения «_»\n"
									(
										tt = #()
										ttt = #()
										tt_ini = #()
										tt = filterstring t "_"
										tt_ini = filterstring t "_"
										if tt.count > 1 then
										(
											for t1 in #{1..tt.count} do
											(		
												tt[t1][1] = toupper tt[t1][1]  
												--if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX возможно содержит ошибки именования, каждое слово должно начинаться с заглавной буквы: " + tt_ini[t1] + "\n"
											)
											--print #(tt)												
											
											--проверка первых цифр, их должно быть 4 и это цифры
											if delete_only_digits tt[1] != "" and tt[1].count != 4 then err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX возможно содержит ошибки именования, первый элемент должен быть в виде четырёх цифр района по «ОМК ТЕ»: " + tt[1] + "\n"
	
											for t1 in #{1..tt.count} do --предварительно удаляем то чего не надо проверять
											(
												tt[t1] = delete_only_ground tt[t1] 
												tt_ini[t1] = delete_only_ground tt_ini[t1] 
											)
											--print #(tt)
										
											--проверка если цифры вперемешку с буквами
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(	
												tt[t1] = delete_only_digits tt[t1] 
												if tt[t1] != "" and tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, цифры отделяются от других элементов адреса подчеркиванием: " + tt_ini[t1] + "\n"
											)
											--print #(tt)
											
											/*
											--проверка существующих названий улиц
											for t1 in #{1..tt.count} where tt[t1] != "" and t1 <= 2 do
											(		
												for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul[t2] "" --подставляем полный список улиц
												if tt[t1] == tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, название не входит в Официальный «Общемосковский классификатор улиц Москвы» (ОМК 001—2013): " + tt_ini[t1] + "\n"
											)
											--print #(tt)
											
											--проверка если есть несокращенные названия элементов адреса
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(		
												for t2 in #{1..stri_long.count} do tt[t1] = substitutestring tt[t1] stri_long[t2] "" --подставляем полный список эл-тов адреса
												if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, не сокращены элементы адреса: " + tt_ini[t1] + "\n"
											)
											--print #(tt)

											-- Название улицы не должно разделяться нижним подчеркиванием, а должно быть записано слитно, при этом каждое новое слово пишется с большой буквы.
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(		
												for t2 in #{1..stri.count} do tt[t1] = substitutestring tt[t1] stri[t2] "" --подставляем список сокращений эл-тов адреса
												if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, не должно быть разделения элементов адреса в: " + tt_ini[t1] + " или, возможно, неправильно именованы элементы адреса, название элемента адреса не должно разделяться нижним подчеркиванием, а должно быть записано слитно, при этом каждое новое слово пишется с большой буквы \n"											
											)
											--print #(tt)
											*/

											--проверка если есть несокращенные названия элементов адреса
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(		
												for t2 in #{1..stri_long1.count} do tt[t1] = substitutestring tt[t1] stri_long1[t2] "" --подставляем полный список эл-тов адреса
												if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ":имя файла FBX возможно содержит ошибки именования в адресе, не сокращены элементы адреса: " + tt_ini[t1] + "\n"
											)
											--print #(tt)	
										
											--проверка существующих названий улиц и поселков
											for t1 in #{1..tt.count} where tt[t1] != "" and t1 <= 2 do
											(		
												for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul_full[t2] "" --подставляем полный список улиц
												for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] ("Pos" + stri_pos[t2]) "" --подставляем полный список поселков
												for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] (stri_pos_pre[t2] + stri_pos[t2]) "" --подставляем полный список поселков

												for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul[t2] "" --подставляем полный список улиц
												for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] stri_pos[t2] "" --подставляем полный список поселков
			
												if tt[t1] == tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, название не входит в Официальный «Общемосковский классификатор улиц Москвы» (ОМК 001—2013): " + tt_ini[t1] + "\n"
											)
											--print #(tt)

											-- Название улицы не должно разделяться нижним подчеркиванием, а должно быть записано слитно, при этом каждое новое слово пишется с большой буквы.
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(		
												for t2 in #{1..stri1.count} do tt[t1] = substitutestring tt[t1] stri1[t2] "" --подставляем список сокращений эл-тов адреса
												if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, не должно быть разделения элементов адреса в: " + tt_ini[t1] + " или, возможно, неправильно именованы элементы адреса, название элемента адреса не должно разделяться нижним подчеркиванием, а должно быть записано слитно, при этом каждое новое слово пишется с большой буквы \n"											
											)
											--print #(tt)		

											-- последующие теги
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(		
												for t2 in #{1..stri2.count} do tt[t1] = substitutestring tt[t1] stri2[t2] "" --подставляем список сокращений эл-тов адреса
												if tt[t1] == "D" or tolower tt[t1] == "dom" then err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, сокращение D как «дом» опускается: " + tt_ini[t1] + " \n"											
												if tt[t1] == "Uch" then err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, «Uch» желательно заменить на «ZU»: " + tt_ini[t1] + " \n"											
												if tt[t1] == tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, сокращение элемента адреса не входит в список: " + tt_ini[t1] + " \n"											
											)
											--print #(tt)												
										)
									)
								)
							) 

							"chk_rules_lowpoly_table_1_3_2": --"3.2. адрес латиницей через «_», спецсимволы заменяются и недопустимы " 
							(
								--проверка недопустимых символов
								t = parse_error_symbols (getfilenamefile edt_lowpoly_rules_check_path.text)
								if t != "" then err += "\x2716 ;1.3.2.; " + (getfilenamefile edt_lowpoly_rules_check_path.text) + ": имя файла архива ZIP содержит недопустимые символы\n"
								--else err += "\x2714 ;1.3.2.; " + (getfilenamefile edt_lowpoly_rules_check_path.text) + ": имя файла архива ZIP не содержит недопустимые символы\n"

								for f in arr[2] do 
								(
									t = parse_error_symbols (getfilenamefile f)
									if t != "" then err += "\x2716 ;1.3.2.; " + (getfilenamefile f) + ": имя файла FBX содержит недопустимые символы\n"
									--else err += "\x2714 ;1.3.2.; " + (getfilenamefile f) + ": имя файла FBX не содержит недопустимые символы\n"					
								)
								
								--проверки транлитерации
								t = getfilenamefile edt_lowpoly_rules_check_path.text
								if t != translit t then err += "\x2716 ;1.3.2.; " + t + ": имя файла архива ZIP содержит недопустимые символы не в транслите\n"
								if findstring t "_" == undefined then err += "\x2716 ;1.3.2.; " + t + ": имя файла архива ZIP не содержит символы разделения «_»\n"
								if findstring t " " != undefined then err += "\x2716 ;1.3.2.; " + t + ": имя файла архива ZIP содержит символы « »\n"

								
								for f in arr[2] do 
								(
									t = getfilenamefile f
									if t != translit t then err += "\x2716 ;1.3.2.; " + t + ": имя файла FBX содержит недопустимые символы не в транслите\n"
									if findstring t "_" == undefined then err += "\x2716 ;1.3.2.; " + t + ": имя файла FBX не содержит символы разделения «_»\n"
									if findstring t " " != undefined then err += "\x2716 ;1.3.2.; " + t + ": имя файла FBX содержит символы « »\n"										
								)	
							)
							
							"chk_rules_lowpoly_table_1_3_3": --"3.3. разделение подчеркиванием, цифры и буквы отдельно"
							(
								--проверки в имени архива
								t = getfilenamefile edt_lowpoly_rules_check_path.text

								if findstring t "_" != undefined then 
								(
									tt = #()
									ttt = #()
									tt_ini = #()
									tt = filterstring t "_"
									tt_ini = filterstring t "_"
									if tt.count > 1 then
									(
										--проверка если цифры вперемешку с буквами
										for t1 in #{1..tt.count} do
										(		
											tt[t1] = delete_only_digits tt[t1] 
											if tt[t1] != "" and tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.3.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, цифры отделяются от других элементов адреса подчеркиванием: " + tt_ini[t1] + "\n"
										)
										--print #(tt)		
									)
								)	
								
								--проверки в имени fbx
								for f in arr[2] do 
								(
									t = getfilenamefile f
									if findstring t "_" != undefined then 
									(
										tt = #()
										ttt = #()
										tt_ini = #()
										tt = filterstring t "_"
										tt_ini = filterstring t "_"
										if tt.count > 1 then
										(
											--проверка если цифры вперемешку с буквами
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(	
												tt[t1] = delete_only_digits tt[t1] 
												if tt[t1] != "" and tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.3.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, цифры отделяются от других элементов адреса подчеркиванием: " + tt_ini[t1] + "\n"
											)
											--print #(tt)
										)
									)
								)
							)
							
							"chk_rules_lowpoly_table_1_3_4": --"3.4. заглавные буквы в начале" 
							(
								--проверки в имени архива
								t = getfilenamefile edt_lowpoly_rules_check_path.text

								if findstring t "_" != undefined then 
								(
									tt = #()
									tt_ini = #()
									tt = filterstring t "_"
									tt_ini = filterstring t "_"
									if tt.count > 1 then
									(
										for t1 in #{1..tt.count} do
										(		
											tt[t1][1] = toupper tt[t1][1]  
											if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.4.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, каждое слово должно начинаться с заглавной буквы: " + tt_ini[t1] + "\n"
										)
										--print #(tt)		
									)
								)	
								
								--проверки в имени fbx
								for f in arr[2] do 
								(
									t = getfilenamefile f
									if findstring t "_" != undefined then 
									(
										tt = #()
										tt_ini = #()
										tt = filterstring t "_"
										tt_ini = filterstring t "_"
										if tt.count > 1 then
										(
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(	
												tt[t1][1] = toupper tt[t1][1] 
												if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.4.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, каждое слово должно начинаться с заглавной буквы: " + tt_ini[t1] + "\n"
											)
											--print #(tt)
										)
									)
								)								
							)
							
							"chk_rules_lowpoly_table_1_3_5": --"3.5. слово «улица» опускается"
							(
								--проверки в имени архива
								t = getfilenamefile edt_lowpoly_rules_check_path.text
								
								if t != substitutestring t "Ul" "" then err += "\x2716 ;1.3.5.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, слово «Ul» опускается в названии\n"
								if t != substitutestring t "Ulitsa" "" or t != substitutestring t "ulitsa" "" or t != substitutestring t "Ulicza" "" or t != substitutestring t "ulicza" "" or t != substitutestring t "Ulitza" "" or t != substitutestring t "ulitza" "" then err += "\x2716 ;1.3.5.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, слово «улица» в транслите опускается в названии\n"
								
								--проверки в имени fbx
								for f in arr[2] do 
								(
									t = getfilenamefile f
									if t != substitutestring t "Ul" "" then err += "\x2716 ;1.3.5.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, слово «Ul» опускается в названии\n"
									if t != substitutestring t "Ulitsa" "" or t != substitutestring t "ulitsa" "" or t != substitutestring t "Ulicza" "" or t != substitutestring t "ulicza" "" or t != substitutestring t "Ulitza" "" or t != substitutestring t "ulitza" "" then err += "\x2716 ;1.3.5.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, слово «улица» в транслите опускается в названии\n"
								)																
							)
							
							"chk_rules_lowpoly_table_1_3_6": --"3.6. кадастровый номер - нет «:»" 
							(
								--А-Б-В1В2-Г-Д-Е, 
								--А=77 - двухзначное число, 
								--Б - двухзначное число 
								--В1 - двухзначное число
								--В2 - трехзначное число
								--Г - трехзначное число
								--Д - «n-разрядное» число, задающее номер здания или сооружения
								--Е - четырехзначное число, задающее номер жилого или нежилого помещения в здании...
								
								--проверки в имени архива
								t = getfilenamefile edt_lowpoly_rules_check_path.text	
								if findstring t ":" != undefined then err += "\x2716 ;1.3.6.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, при указании кадастрового номера цифры отделяются от других элементов адреса подчеркиванием\n"
									
								if findstring t "_" != undefined then 
								(
									tt = #()
									tt = filterstring t "_"
									if tt.count >= 5 then
									(
										--проверка на кадастровый номер
										for t1 in #{2..5} where (for t2 in #{2..5} where delete_only_digits tt[t2] == "" collect tt[t2]).count == 4 do
										(
											if t1 == 2 and tt[t1].count != 2 and tt[t1] != "77" then err += "\x2716 ;1.3.6.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, в кадастровом номере ошибка: " + tt[t1] + "\n"
											if t1 == 3 and tt[t1].count != 2 then err += "\x2716 ;1.3.6.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, в кадастровом номере ошибка: " + tt[t1] + "\n"
											if t1 == 4 and tt[t1].count != 5 then err += "\x2716 ;1.3.6.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, в кадастровом номере ошибка: " + tt[t1] + "\n"
											if t1 == 5 and tt[t1].count != 3 then err += "\x2716 ;1.3.6.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, в кадастровом номере ошибка: " + tt[t1] + "\n"
										)
										--print #(tt)		
									)
								)	

								--проверки в имени fbx
								for f in arr[2] do 
								(
									t = getfilenamefile f
									if findstring t ":" != undefined then err += "\x2716 ;1.3.6.; " + t + ": имя файла FBX возможно содержит ошибки именования в адресе, при указании кадастрового номера цифры отделяются от других элементов адреса подчеркиванием\n"
									--проверка на кадастровый номер
									if findstring t "_" != undefined then 
									(
										tt = #()
										tt = filterstring t "_"
										if tt.count >= 5 then
										(
											for t1 in #{2..5} where (for t2 in #{2..5} where delete_only_digits tt[t2] == "" collect tt[t2]).count == 4 do
											(
												if t1 == 2 and tt[t1].count != 2 and tt[t1] != "77" then err += "\x2716 ;1.3.6.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, в кадастровом номере ошибка: " + tt[t1] + "\n"
												if t1 == 3 and tt[t1].count != 2 then err += "\x2716 ;1.3.6.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, в кадастровом номере ошибка: " + tt[t1] + "\n"
												if t1 == 4 and tt[t1].count != 5 then err += "\x2716 ;1.3.6.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, в кадастровом номере ошибка: " + tt[t1] + "\n"
												if t1 == 5 and tt[t1].count != 3 then err += "\x2716 ;1.3.6.; " + t + ": имя файла архива ZIP возможно содержит ошибки именования в адресе, в кадастровом номере ошибка: " + tt[t1] + "\n"
											)
										)
									)	
								)								
							)
							
							"chk_rules_lowpoly_table_2_All": (err += "\x2714 ;Таблица 2. Требования к НПМ моделям;\n")
							"chk_rules_lowpoly_table_2_1": (err += "\x2714 ;1. Требования к архиву, составу, структуре;\n")						

							"chk_rules_lowpoly_table_2_1_1": 
							(
								if (local p = ((GetFileSize edt_lowpoly_rules_check_path.text)/1024/1024/1024)) > 1.0 then err += "\x2716 ;2.1.1.; размер архива ZIP : " + p as string + "Gb > 1Gb \n" 
							) --else err += "\x2714 ;2.1.1.; размер архива ZIP : " + p as string + "Gb < 1Gb \n") --"1.1. архив ZIP < 1 Gb" 
							
							"chk_rules_lowpoly_table_2_1_2": --#(myfiles, filesFBX, filesTEX, filesAll, objAll) "1.2. число файлов в архиве: 2..21 FBX"
							(
								if arr[2].count > 21 and arr[2].count < 2 then err += "\x2716 ;2.1.2.; число файлов FBX в архиве не в диапазоне [2..21]: " + arr[2].count as string + "\n"
								local gr = 0
								local oks = 0
								for f in arr[2] do 
								(
									if findstring (getfilenamefile f) "_Ground" != undefined then gr += 1
									if findstring (getfilenamefile f) "_Ground" == undefined then oks += 1
								)
								if gr > 1 or oks == 0 then err += "\x2716 ;2.1.2.; состав файлов FBX в архиве не правильный, должен быть один файл благоустройства FBX и до 20 файлов формата FBX трехмерных моделей проекта ОКС\n"
							)
							
							"chk_rules_lowpoly_table_2_1_3": --"1.3. мусор в составе архива" 
							(
								 --#(myfiles, filesFBX, filesTEX, filesAll, objAll)
								--print arr[5]
								if LayerManager.count > 1 then err += "\x2716 ;2.1.3.; В составе файлов формата FBX не должно быть дополнительных слоев\n"
							
								for o in (arr[5][arr[5].count]) do
								(
									print o.name
									if superClassOf o != GeometryClass then err += "\x2716 ;2.1.3.; В состав файлов формата FBX не должны входить объекты кл??сса: " + o.name + " " + (superClassOf o) as string + " \n"
									else
									(
										converttopoly o
										if polyop.getNumVerts o == 0 or polyop.getNumEdges o == 0 or polyop.getNumFaces o == 0 then err += "\x2716 ;2.1.3.; В состав файлов формата FBX не должны входить пустые объекты, не содержащие в себе точек, полигонов или граней\n"
										if (o.position.x_position.controller.keys.count >= 1) or (o.position.y_position.controller.keys.count >= 1) or (o.position.z_position.controller.keys.count >= 1) or (o.rotation.x_rotation.controller.keys.count >= 1) or (o.rotation.y_rotation.controller.keys.count >= 1) or (o.rotation.z_rotation.controller.keys.count >= 1) or (o.scale.keys.count >= 1) then err += "\x2716 ;2.1.3.; В состав файлов формата FBX не должны входить объекты, содержащие в себе точекне содержащих в себе анимации, ключи анимации\n"
										
										local aa = #("Circle", "Box", "Shape", "Line", "Sphere", "Plane")
										if (for a in aa where findstring o.name a != undefined collect o.name).count > 0 then err += "\x2716 ;2.1.3.; В состав файлов формата FBX не должны входить вспомогательные объекты, не относящихся к проектному решению: " + o.name + "\n"
										
										local bb = #("Stacy", "People", "Humano", "_posed_", "RP_", "rp_", "Man", "Girl", "Women", "DAZ")
										if (for a in bb where findstring o.name a != undefined collect o.name).count > 0 then err += "\x2716 ;2.1.3.; В состав файлов формата FBX не должны входить модели людей: " + o.name + "\n"

										local cc = #("Car", "Audi", "Mersedes", "Toyota", "Haval", "Avto")
										if (for a in cc where findstring o.name a != undefined collect o.name).count > 0 then err += "\x2716 ;2.1.3.; В состав файлов формата FBX не должны входить модели транспорта: " + o.name + "\n"

										local dd = #("UCX_", "USX_")
										if (for a in dd where findstring o.name a != undefined collect o.name).count > 0 then err += "\x2716 ;2.1.3.; В состав файлов формата FBX для НПМ не должны входить модели UCX: " + o.name + "\n"

										local ee = #("_Glass") 
										if (for a in ee where findstring o.name a != undefined collect o.name).count > 0 then err += "\x2716 ;2.1.3.; В состав файлов формата FBX для НПМ не должны входить модели _Glass, надо именовать _MainGlass, _GroundGlass, _GroundElGlass, именование _Glass допускается для ВПМ: " + o.name + "\n"

										--?не содержащих звуков
										--?подробных внутренних конструкций 
										--?подземных и внутренних коммуникаций
										
										--удаление
										--deleteKeys objects #allKeys
										--if LayerManager.count >1 then
										--(
										--	DelLayer = LayerManager.getLayerFromName "0"
										--	for obj in objects do DelLayer.addnode obj
										--	for id = LayerManager.count - 1 to 1 by -1 do
										--	(
										--		layer = LayerManager.getLayer id
										--		contains_nodes = LayerManager.doesLayerHierarchyContainNodes layer.name
										--		if not contains_nodes then deleted = LayerManager.deleteLayerByName layer.name
										--	)
										--)		
									)
								)
							)
							
							"chk_rules_lowpoly_table_2_1_4": --"1.4. состав FBX бл-ва геометрии, наборы т-р" "1.4. В состав файла формата FBX благоустройства, помимо их текстурных наборов (до 22 шт.), входит 5 отдельных объектов геометрии:" 
							(	
								local gr = #()
								local gr_gl = #()
								local gr_el = #()
								local gr_el_gl = #()
								local gr_flora = #()
								local oks = #()
								local oks_gl = #()
								
								local all_texes = #()
								if arr[3].count > 0 then
								(
									for a in arr[3] do 
										for b in a do append all_texes b
								)
								else err += "\x2716 ;2.1.4.; В файле модели FBX нет текстур, нужно пересохранить файл FBX с текстурами, назначенными у материалов, как Embed Media\n"
								if all_texes.count == 0 then err += "\x2716 ;2.1.4.; В файле модели FBX нет текстур, нужно пересохранить файл FBX с текстурами, назначенными у материалов, как Embed Media\n"

								for o in (arr[5][arr[5].count]) do
								(
									--print o.name
									case of
									(
										(findstring o.name "_GroundElGlass" != undefined): append gr_el_gl o
										(findstring o.name "_GroundEl" != undefined): append gr_el o	
										(findstring o.name "_GroundGlass" != undefined): append gr_gl o
										(findstring o.name "_Ground" != undefined): append gr o
										(findstring o.name "_Flora" != undefined): append gr_flora o
										(findstring o.name "_MainGlass" != undefined): append oks_gl o
										(findstring o.name "_Main" != undefined): append oks o
									)
								)
								
								if chk_rules_lowpoly_table_2_1_4_1.checked then -- "1.4.1 геометрия благоустройства (максимум 20 текстурных наборов);"
								if gr.count != 0 then 
								(
									--print #(gr)
									for g in gr do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined and findstring (getfilenamefile t) "GroundEl" == undefined and findstring (getfilenamefile t) "GroundGlass" == undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4.1.; В файле модели FBX нет материала у объекта Ground\n"
										if maps.count != tex.count then 
										(
											err += "\x2716 ;2.1.4.1; В файле модели FBX число карт у материала Ground не соответстует числу сохраненных текстур\n"
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count >= 20 then err += "\x2716 ;2.1.4.1.; В файле модели FBX геометрия благоустройства должна иметь максимум 20 текстурных наборов\n"
										if maps.count == 0 then err += "\x2716 ;2.1.4.1.; В файле модели FBX не назначены карты в слоты материала Ground\n"
										if tex.count == 0 then err += "\x2716 ;2.1.4.1.; В файле модели FBX не сохранены карты Ground\n"
									)
								)
								
								if chk_rules_lowpoly_table_2_1_4_3.checked then -- "1.4.3 геометрия отдельных элементов благоустройства (МАФ, мачты освещения и пр.) (1 текстурный набор);"
								if gr_el.count != 0 then 
								(
									--print #(gr_el)
									for g in gr_el do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined and findstring (getfilenamefile t) "GroundElGlass" == undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4.3.; В файле модели FBX нет материала у объекта GroundEl\n"
										if maps.count != tex.count then 
										(
											err += "\x2716 ;2.1.4.3; В файле модели FBX число карт у материала GroundEl не соответстует числу сохраненных текстур\n"
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count > 1 then err += "\x2716 ;2.1.4.3.; В файле модели FBX геометрия благоустройства GroundEl должна иметь максимум 1 текстурный набор\n"
										if maps.count == 0 then err += "\x2716 ;2.1.4.3.; В файле модели FBX не назначены карты в слоты материала GroundEl\n"
										if tex.count == 0 then err += "\x2716 ;2.1.4.3.; В файле модели FBX не сохранены карты GroundEl\n"

									)									
								)

								if chk_rules_lowpoly_table_2_1_4_5.checked then --"1.4.5 геометрия растительности, которая включает в себя всю растительность на сцене (1 текстурный набор)."
								if gr_flora.count != 0 then 
								(
									--print #(gr_flora)
									for g in gr_flora do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4.5.; В файле модели FBX нет материала у объекта Flora\n"
										if maps.count != tex.count then 
										(
											err += "\x2716 ;2.1.4.5; В файле модели FBX число карт у материала Flora не соответстует числу сохраненных текстур\n"
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count > 1 then err += "\x2716 ;2.1.4.5.; В файле модели FBX геометрия благоустройства Flora должна иметь максимум 1 текстурный набор\n"
										if maps.count == 0 then err += "\x2716 ;2.1.4.5.; В файле модели FBX не назначены карты в слоты материала Flora\n"
										if tex.count == 0 then err += "\x2716 ;2.1.4.5.; В файле модели FBX не сохранены карты Flora\n"
									)
								)
								
								if oks.count != 0 then 
								(
									--print #(oks)
									for g in oks do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined and findstring (getfilenamefile t) "Ground" == undefined and findstring (getfilenamefile t) "Glass" == undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4; Дополнительно. В файле модели FBX нет материала у объекта Main\n"
										if maps.count != tex.count then 
										(
											err += "\x2716 ;2.1.4.; Дополнительно. В файле модели FBX число карт у материала Main: " + g.name + " не соответстует числу сохраненных текстур\n"
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count > 1 then err += "\x2716 ;2.1.4.; Дополнительно. В файле модели FBX геометрия Main: " + g.name + "одного ОКС должна иметь максимум 1 текстурный набор\n"
										if maps.count == 0 then err += "\x2716 ;2.1.4.; Дополнительно. В файле модели FBX не назначены карты в слоты материала Main: " + g.name + "\n"
										if tex.count == 0 then err += "\x2716 ;2.1.4.; Дополнительно. В файле модели FBX не сохранены карты Main: " + g.name + "\n"
									)									
								)
								
								if oks_gl.count != 0 then 
								(
									--print #(oks_gl)
									for g in oks_gl do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4.; Дополнительно. В файле модели FBX нет материала у объекта MainGlass\n"
										if maps.count != tex.count then 
										(
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count > 0 then err += "\x2716 ;2.1.4.; Дополнительно. В файле модели FBX геометрия MainGlass не должна иметь текстурных наборов\n"
										if maps.count != 0 then err += "\x2716 ;2.1.4.; Дополнительно. В файле модели FBX не должны быть карты в слотах материала MainGlass\n"
										if tex.count != 0 then err += "\x2716 ;2.1.4.; Дополнительно. В файле модели FBX не должно быть карт у MainGlass\n"
									)
								)
								
								if chk_rules_lowpoly_table_2_1_4_4.checked then --"1.4.4 геометрия полупрозрачных деталей элементов благоустройства (при наличии) (без текстурных наборов);"
								if gr_el_gl.count != 0 then 
								(
									--print #(gr_el_gl)
									for g in gr_el_gl do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4.4.; В файле модели FBX нет материала у объекта GroundElGlass\n"
										if maps.count != tex.count then 
										(
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count > 0 then err += "\x2716 ;2.1.4.4.; В файле модели FBX геометрия благоустройства GroundElGlass не должна иметь текстурных наборов\n"
										if maps.count != 0 then err += "\x2716 ;2.1.4.4.; В файле модели FBX не должны быть карты в слотах материала GroundElGlass\n"
										if tex.count != 0 then err += "\x2716 ;2.1.4.4.; В файле модели FBX не должно быть карт у GroundElGlass\n"
									)
								)
								
								if chk_rules_lowpoly_table_2_1_4_2.checked then -- "1.4.2 геометрия полупрозрачных деталей благоустройства (при наличии) (без текстурных наборов);"
								if gr_gl.count != 0 then 	
								(
									--print #(gr_gl)
									for g in gr_gl do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4.2.; В файле модели FBX нет материала у объекта GroundGlass\n"
										if maps.count != tex.count then 
										(
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count > 0 then err += "\x2716 ;2.1.4.2.; В файле модели FBX геометрия благоустройства GroundGlass не должна иметь текстурных наборов\n"
										if maps.count != 0 then err += "\x2716 ;2.1.4.2.; В файле модели FBX не должны быть карты в слотах материала GroundGlass\n"
										if tex.count != 0 then err += "\x2716 ;2.1.4.2.; В файле модели FBX не должно быть карт у GroundGlass\n"
									)
								)
							)								
							
							"chk_rules_lowpoly_table_2_1_5": --"1.5. наличие благоустройства" 
							(
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" != undefined collect (getfilenamefile f)).count != 1 then err += "\x2716 ;2.1.5.; Файлы благоустройства - неотъемлемая часть АГР и являются обязательными к исполнению\n"
							)
							
							"chk_rules_lowpoly_table_2_1_6": --"1.6. все ОКС и эл-ты бл-ва есть в ВПМ и НПМ" 
							(
								--_Main ОКС (кроме полупрозрачных деталей)
								--_MainGlass полупрозрачным деталям ОКС
								--_Ground благоустройству	(кроме полупрозрачных деталей)
								--_GroundGlass полупрозрачным	деталям благоустройства
								--_GroundEl элементам благоустройства: МАФ, мачтам освещения и пр. (кроме полупрозрачных элементов)
								--_GroundElGlass полупрозрачным	элементам благоустройства
								--_Flora растительности

								local gr = 0
								local gr_gl = 0
								local gr_el = 0
								local gr_el_gl = 0
								local gr_flora = 0
								local oks = 0
								local oks_gl = 0
								
								for o in (arr[5][arr[5].count]) do
								(
									--print o.name
									case of
									(
										(findstring o.name "_GroundElGlass" != undefined): gr_el_gl += 1
										(findstring o.name "_GroundEl" != undefined): gr_el += 1	
										(findstring o.name "_GroundGlass" != undefined): gr_gl += 1
										(findstring o.name "_Ground" != undefined): gr += 1
										(findstring o.name "_Flora" != undefined): gr_flora += 1
										(findstring o.name "_MainGlass" != undefined): oks_gl += 1
										(findstring o.name "_Main" != undefined): oks += 1
									)
								)
								if gr == 0 then err += "\x2716 ;2.1.6.; нет модели Ground, модель благоустройства проекта АГР должна быть реализована\n"
								if gr_el == 0 then err += "\x2716 ;2.1.6.; нет модели GroundEl, модель благоустройства проекта АГР должна быть реализована в полной мере. Это касается, в том числе, МАФ, столбов освещения и пр.\n"
								if gr_flora == 0 then err += "\x2716 ;2.1.6.; нет модели Flora, модель благоустройства проекта АГР должна быть реализована в полной мере. Это касается, в том числе, озеленения\n"
								if oks == 0 then err += "\x2716 ;2.1.6.; нет моделей Main, все ОКС проекта АГР должны быть реализованы в полной мере\n"
								if oks_gl == 0 then err += "\x2716 ;2.1.6.; нет модели MainGlass\n"
								if gr_el_gl == 0 then err += "\x2716 ;2.1.6.; нет модели GroundElGlass\n"
								if gr_gl == 0 then err += "\x2716 ;2.1.6.; нет модели GroundGlass\n"	
							)
							
							"chk_rules_lowpoly_table_2_2": (err += "\x2714 ;2. Требования к разделению ОКС на файлы;\n") -- "2. Требования к разделению ОКС на файлы" 
							"chk_rules_lowpoly_table_2_2_1":  -- "2.1. разделение модели, число" "2.1. Разделение модели на несколько (не более 20) файлов формата FBX допустимо только при превышении количества треугольных полигонов в составе одного файла формата FBX (см.п.3.7)." 
							(
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" == undefined collect (getfilenamefile f)).count > 1 then err += "\x2716 ;2.2.1.; Разделение модели на несколько файлов формата FBX допустимо только при превышении количества треугольных полигонов в составе одного файла формата FBX.\n"
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" == undefined collect (getfilenamefile f)).count > 20 then err += "\x2716 ;2.2.1.; Разделение модели на число файлов формата FBX больше 20шт недопустимо.\n"
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" != undefined collect (getfilenamefile f)).count > 1 then err += "\x2716 ;2.2.1.; Разделение модели благоустройства на несколько файлов формата FBX недопустимо.\n"
							)
							
							"chk_rules_lowpoly_table_2_2_2": -- "2.2. разделение по зданиям" "2.2. Разделение может осуществляться исключительно по группам или одиночным неделимым единицам: отдельностоящим зданиям, секциям, корпусам, строениям, стилобатам." 
							(
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" == undefined collect (getfilenamefile f)).count > 1 then err += "\x2716 ;2.2.2.; Разделение модели на несколько файлов формата FBX может осуществляться исключительно по группам или одиночным неделимым единицам: отдельностоящим зданиям, секциям, корпусам, строениям, стилобатам.\n"
							)
							
							"chk_rules_lowpoly_table_2_2_3": -- "2.3. разделение на полупр. детали" "2.3. При разделении ОКС на несколько файлов формата FBX соответственно разделяются и полупрозрачные детали. " 
							(
								local q_main = #()
								local q_main_glass = #()
								
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" == undefined collect (getfilenamefile f)).count > 1 then 
								(
									for oo in arr[5] do
									(
										q_main = #()
										q_main_glass = #()
										for o in oo where findstring (tolower o.name) "_ground" == undefined do 
										(
											if findstring (tolower o.name) "_mainglass" != undefined then append q_main_glass o.name
											if findstring (tolower o.name) "_main" != undefined and findstring (tolower o.name) "glass" == undefined then append q_main o.name	
										)
										if q_main_glass.count != q_main.count then err += "\x2716 ;2.2.3.; При разделении ОКС на несколько файлов формата FBX соответственно разделяются и полупрозрачные детали.\n"
									)										
								)
							) 

							"chk_rules_lowpoly_table_2_2_4": -- "2.4. нумерация в наименованиях" "2.4. При разделении ОКС на несколько файлов формата FBX нумерация в наименованиях не обнуляется в каждом файле формата FBX, а является сквозной в рамках всего АГР." 
							(
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" == undefined collect (getfilenamefile f)).count > 1 then 
								(
									local aa = #()
									local bb = #()
									for o in (arr[5][arr[5].count]) where findstring o.name "Main" != undefined do
									(
										local a = (filterstring o.name "_")[(filterstring o.name "_").count - 1]
										append aa a
										appendifunique bb a
									)		
									if aa.count != bb.count then err += "\x2716 ;2.2.4.; При разделении ОКС на несколько файлов формата FBX нумерация в наименованиях не обнуляется в каждом файле формата FBX, а является сквозной в рамках всего АГР.\n"
								)
							)
							
							"chk_rules_lowpoly_table_2_3": (err += "\x2714 ;3. Требования к объектам геометрии;\n") --"3. Требования к объектам геометрии"
							"chk_rules_lowpoly_table_2_3_1": -- "3.1. минимальное количество тр-ков" "3.1. Для описания силуэта (формы) объекта использовать минимально возможное количество треугольных полигонов (рисунок 4), кроме случаев, необходимых для оптимальной UV-развертки." 
							(
								err += " ;2.3.1.; Для описания силуэта (формы) объекта использовать минимально возможное количество треугольных полигонов, кроме случаев, необходимых для оптимальной UV-развертки.\n"
								--нужно придумать норму плотности сетки, чтобы на плоскостях не было много вершин и эджей, было большое расстояние между ними на плоскости
							)
							
							"chk_rules_lowpoly_table_2_3_2": -- "3.2. общий файл для разных деталей" "3.2. Объекты геометрии и полупрозрачные детали, принадлежащие единой модели, должны компоноваться в общем файле формата FBX." 
							(
								local q_main = #()
								local q_main_glass = #()
								
								for oo in arr[5] do
								(
									q_main = #()
									q_main_glass = #()
									for o in oo where findstring (tolower o.name) "_ground" == undefined do 
									(
										if findstring (tolower o.name) "_mainglass" != undefined then append q_main_glass (substitutestring o.name "_MainGlass" "")
										if findstring (tolower o.name) "_main" != undefined and findstring (tolower o.name) "glass" == undefined then append q_main (substitutestring o.name "_Main" "")		
									)
									if q_main_glass.count == q_main.count and q_main_glass.count > 0 and q_main.count > 0 then 
									(
										for q in #{1..q_main_glass.count} where q_main_glass[q] != q_main[q] do err += "\x2716 ;2.3.2.; Объекты геометрии и полупрозрачные детали, принадлежащие единой модели, должны компоноваться в общем файле формата FBX: " + q_main_glass[q] " - " q_main[q] + "\n"
									)											
									else err += "\x2716 ;2.3.2.; Объекты геометрии и полупрозрачные детали, принадлежащие единой модели, должны компоноваться в общем файле формата FBX.\n"
								)										
							)					

							"chk_rules_lowpoly_table_2_3_3": -- "3.3. отдельный файл для бл-ва" "3.3. Благоустройство, его элементы и элементы растительности должны быть сформированы в отдельный файл формата FBX (рисунок 2)." 
							(
								local qq = #()
								for oo in arr[5] do
								(
									q = 0
									for o in oo where findstring (tolower o.name) "_ground" != undefined do 
									(
										case of
										(
											(findstring o.name "_GroundElGlass" != undefined): q += 1
											(findstring o.name "_GroundEl" != undefined): q += 1	
											(findstring o.name "_GroundGlass" != undefined): q += 1
											(findstring o.name "_Ground" != undefined): q += 1
											(findstring o.name "_Flora" != undefined): q += 1
										)
									)
									append qq q
								)
								if qq.count > 0 then
								(
									if (for s in qq where s > 0 collect s).count > 1 then err += "\x2716 ;2.3.3.; Благоустройство, его элементы и элементы растительности должны быть сформированы в отдельный файл формата FBX.\n"
								)
								else err += "\x2716 ;2.3.3.; Благоустройство, его элементы и элементы растительности должны быть сформированы в отдельный файл формата FBX.\n"
							)
								
							"chk_rules_lowpoly_table_2_3_4": -- "3.4. края выдавлены вниз > 1м" "3.4. Полигоны по периметру объекта геометрии благоустройства должны быть выдавлены вниз на расстояние не менее 1 метра." 
							(
								--выделение эджей по периметру, искать открытые эджи - они внизу, смотреть сплайн из них по высоте больше метра
								local numedges = #{}
								local vv = #{}
								local pp = #()
								local zz = #()
								
								for o in (arr[5][arr[5].count]) where findstring (tolower o.name) "_ground" != undefined and findstring (tolower o.name) "glass" == undefined and findstring (tolower o.name) "_groundel" == undefined do
								(
									--print o.name
									converttopoly o
									numedges = getConvexEdges o true 30 false false
									if not numedges.isempty then
									(
										vv = polyop.getVertsUsingEdge o numedges
										pp = for v in vv collect (polyop.getVert o v)
										for p1 in pp do
											for p2 in pp where p1 != p2 and abs(p1.x - p2.x) < 0.1 and abs(p1.y - p2.y) < 0.1 do append zz (abs(p1.z - p2.z))
										--print #(vv)
										--print #(pp)		
										--print #(zz)
										--print #(numedges)			
										--print "here"
										if zz.count > 0 then 
										(
											--print (amax zz)
											if (amax zz) <= 1.0 then err += "\x2716 ;2.3.4.; Полигоны по периметру объекта геометрии благоустройства должны быть выдавлены вниз на расстояние не менее 1 метра: " + o.name + ", сейчас: " + (amax zz) as string + "\n"
										)
										else err += "\x2716 ;2.3.4.; Полигоны по периметру объекта геометрии благоустройства должны быть выдавлены вниз на расстояние не менее 1 метра: " + o.name + "\n"
									)
									else err += "\x2716 ;2.3.4.; Полигоны по периметру объекта геометрии благоустройства должны быть выдавлены вниз на расстояние не менее 1 метра: " + o.name + "\n"
								)
							) 

							"chk_rules_lowpoly_table_2_3_5": -- "3.5. иерархические связи и группы" "3.5. Объекты геометрии не должны иметь иерархических связей между собой, групп и т.д." 
							(
								for o in (arr[5][arr[5].count]) where o.parent != undefined do err += "\x2716 ;2.3.5.; Объекты геометрии не должны иметь иерархических связей между собой, групп и т.д." + o.name + "\n"
							) 
							
							"chk_rules_lowpoly_table_2_3_6": -- "3.6. предельное число тр-ков" "3.6. Предельное допустимое количество треугольных полигонов модели ОКС в рамках одного файла формата FBX - 150 000, для благоустройства, его элементов и элементов растительности в сумме - 180 000." 
							(
								local num = 0
								local used = #()
								for o in #{1..arr[2].count} where findstring (getfilenamefile arr[2][o]) "_Ground" == undefined do
								(					
									num = 0
									for a in arr[5][o] where findItem used a == 0 do 
									(
										append used a
										converttopoly a
										num += polyop.getNumFaces a
									)	
									if num > 150000 then err += "\x2716 ;2.3.6.; Предельное допустимое количество треугольных полигонов модели ОКС в рамках одного файла формата FBX - 150 000: " + getfilenamefile arr[2][o] + "\n"
								)
								for o in #{1..arr[2].count} where findstring (getfilenamefile arr[2][o]) "_Ground" != undefined do
								(					
									num = 0
									for a in arr[5][o] where findItem used a == 0 do 
									(
										append used a
										converttopoly a
										num += polyop.getNumFaces a
									)	
									if num > 180000 then err += "\x2716 ;2.3.6.; Предельное допустимое количество треугольных полигонов модели для благоустройства, его элементов и элементов растительности в сумме - 180 000 " + getfilenamefile arr[2][o] + "\n"
								)
							) 
							
							"chk_rules_lowpoly_table_2_3_7": -- "3.7. задвойки, пересечения, прочее" "3.7. Объекты геометрии не должны содержать:\n• дубликатов и самопересечений вершин, ребер и полигонов (погрешность расстояния 0,002 м);\n• изолированных вершин, ребер и полигонов;\n• отрезков нулевой длины;" 
							(			
								for o in (arr[5][arr[5].count])	where (polyOp.getNumVerts o) > 0 or not keyboard.escPressed do
								(
									convertToPoly o
									local selverts = #{1..(polyOp.getNumVerts o)}
									local maximum_range = 0.002
									local verts_near = #{}
									
									for v1 in selverts where not keyboard.escPressed do
									(
										local p1 = polyop.getvert o v1	
										for v2 in selverts where v1 < v2 do
										(
											local p2 = polyop.getvert o v2
											local d = distance p1 p2
											if d <= maximum_range then verts_near += #{v1,v2}
										)
									)
									--print #(verts_near)
									if not verts_near.isempty then err += "\x2716 ;2.3.7.; Объекты геометрии не должны содержать: дубликатов и самопересечений вершин, погрешность расстояния 0,002м: " + o.name + ", число задвоенных вершин: " + verts_near.numberset as string + "\n"
								)
								
								/*
								for o in (arr[5][arr[5].count])	where (polyOp.getNumEdges o) > 0 do
								(
									convertToPoly o
									local seledges = #{1..(polyOp.getNumEdges o)}
									local edges_parallel = #{}
									local vv1 = #{}
									local vv2 = #{}
									local pp1 = #()
									local pp2 = #()									
									
									for e1 in seledges do
									(
										vv1 += polyop.getVertsUsingEdge o #{e1}
										pp1 = for v in vv1 collect (polyop.getVert o v)
										for e2 in seledges where e1 < e2 do
										(
											vv2 += polyop.getVertsUsingEdge o #{e2}
											pp2 = for v in vv2 collect (polyop.getVert o v)
											angle = acos (dot (normalize (pp1[1] - pp1[2])) (normalize (pp2[1] - pp2[2]))) 				
											if angle >= abs(180 - 0.001) or angle <= abs(0.001) then edges_parallel += #{e1, e2} 
										)
									)
								)
								*/
								
								for o in (arr[5][arr[5].count])	where (polyOp.getNumFaces o) > 0 or not keyboard.escPressed do
								(
									convertToPoly o
									local er1 = #()
									local er2 = #()
									local er3 = #()
									local selfaces = #{1..(polyOp.getNumFaces o)}
									local minimum_range = 0.0
									local maximum_range = 0.002

									local do_verts = false -- true
									local near_perpendicular = 0.01 
									
									local invert_face = false
									local direction = 1.0
									er1 = get_hits o selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular
				
									polyop.flipNormals o selfaces
									
									direction = -1.0
									invert_face = false
									er2 = get_hits o selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular
									
									polyop.flipNormals o selfaces
				
									invert_face = true
									direction = -1.0
									er3 = get_hits o selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular
					
									if er1.count > 0 then err += "\x2716 ;2.3.7.; Объекты геометрии не должны содержать дубликатов и самопересечений полигонов, погрешность расстояния 0,002м: " + o.name + ", число задвоенных полигонов с нормалями, смотрящими друг на друга: " + er1.count as string + "\n"
									if er2.count > 0 then err += "\x2716 ;2.3.7.; Объекты геометрии не должны содержать дубликатов и самопересечений полигонов, погрешность расстояния 0,002м: " + o.name + ", число задвоенных полигонов с разнонаправленными нормалями: " + er2.count as string + "\n"
									if er3.count > 0 then err += "\x2716 ;2.3.7.; Объекты геометрии не должны содержать дубликатов и самопересечений полигонов, погрешность расстояния 0,002м: " + o.name + ", число задвоенных полигонов с сонаправленными нормалями: " + er3.count as string + "\n"
								)
								
								for o in (arr[5][arr[5].count])	where (polyOp.getNumVerts o) == 0 or (polyOp.getNumFaces o) == 0 do err += "\x2716 ;2.3.7.; Объекты геометрии без вершин или полигонов: " + o.name + "\n"
								
								for o in (arr[5][arr[5].count])	where ((polyOp.getNumVerts o) > 0 and (polyOp.getNumFaces o) > 0) or not keyboard.escPressed do 
								(
									convertToPoly o
									local numverts = polyOp.getNumVerts o
									local numfaces = polyOp.getNumFaces o
									polyop.deleteIsoVerts o
									polyop.CollapseDeadStructs o
									local numverts_after = polyOp.getNumVerts o
									local numfaces_after = polyOp.getNumFaces o
									if (numverts - numverts_after) != 0 or (numfaces - numfaces_after) != 0 then err += "\x2716 ;2.3.7.; Объекты геометрии не должны содержать изолированных вершин, ребер и полигонов: " + o.name + ", число изолированных вершин: " + (numverts - numverts_after) as string + ", число изолированных полигонов: " + (numfaces - numfaces_after) as string + "\n"
								)
							) 
							
							"chk_rules_lowpoly_table_2_3_8": -- "3.8. нормали объектов наружу" "3.8. Нормали объектов, видимых с условной точки наблюдения, должны быть направлены в сторону наблюдателя." 
							(
								err += " ;2.3.8.; Нормали объектов, видимых с условной точки наблюдения, должны быть направлены в сторону наблюдателя.\n"
							) 
							
							"chk_rules_lowpoly_table_2_3_9": -- "3.9. мелкие и декоративные эл-ты" "3.9. Незначительные конструктивные и декоративные элементы, не влияющие на общий облик объекта моделирования, отображаются с помощью изображения на текстурном атласе." 
							(
								err += " ;2.3.9.; Незначительные конструктивные и декоративные элементы, не влияющие на общий облик объекта моделирования, отображаются с помощью изображения на текстурном атласе.\n"
								--найти близкие точки, если их сгусток, то выводить сообщение
							) 
														
							"chk_rules_lowpoly_table_2_3_10": -- "3.10. отступ сонаправленных полигонов" "3.10. Для упразднения дефектов отображения сонаправленных полигонов, перекрывающих друг друга, расстояние между ними должно составлять не менее 5 мм и не более 2 см." 
							(
								for o in (arr[5][arr[5].count])	where (polyOp.getNumFaces o) > 0 or not keyboard.escPressed do
								(
									convertToPoly o
									local er1 = #()
									local er2 = #()

									local selfaces = #{1..(polyOp.getNumFaces o)}
									--local minimum_range = 0.005
									--local maximum_range = 0.02
									local minimum_range = 0.0
									local maximum_range = 0.005

									local do_verts = false -- true
									local near_perpendicular = 0.01 

									polyop.flipNormals o selfaces
									
									direction = -1.0
									invert_face = false
									er1 = get_hits o selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular
									
									minimum_range = 0.02
									maximum_range = 0.03
									er2 = get_hits o selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular
									
									polyop.flipNormals o selfaces

									if er1.count > 0 then err += "\x2716 ;2.3.10.; Для упразднения дефектов отображения сонаправленных полигонов, перекрывающих друг друга, расстояние между н????ми должно составлять не менее 5 мм: " + o.name + ", число полигонов: " + er1.count as string + "\n"
									if er2.count > 0 then err += "\x2716 ;2.3.10.; Для упразднения дефектов отображения сонаправленных полигонов, перекрывающих друг друга, расстояние между ними должно составлять не более 2 см: " + o.name + ", число полигонов: " + er2.count as string + "\n"
								)
							) 
							
							"chk_rules_lowpoly_table_2_3_11": -- "3.11. толщина полупрозрачных дет." "3.11. Полупрозрачные детали оконного типа, кроме ограждений, не должны иметь толщину." 
							(
								--есть ли бордер у элементов стекла
								for o in (arr[5][arr[5].count]) where findstring (tolower o.name) "glass" != undefined do 
								(
									converttopoly o
									if (polyop.getOpenEdges o).isempty then err += "\x2716 ;2.3.11.; Полупрозрачные детали оконного типа, кроме ограждений, не должны иметь толщину: " + o.name + "\n"
								)	
							) 
							
							"chk_rules_lowpoly_table_2_3_12": -- "3.12. триангуляция объектов" "3.12. Объекты геометрии должны быть триангулированы перед экспортом в файл формата FBX." 
							(
								--триангулировать всё и сравнить число до и после
								local num_copy = 0
								local num = 0
								local num_area_zero = 0
								for o in (arr[5][arr[5].count]) where not keyboard.escPressed do
								(
									num_copy = 0
									num = 0									
									converttopoly o
									num = polyop.getNumFaces o
									for s in #{1..num} where polyop.getFaceArea o s <= 0.00001 do num_area_zero += 1
									oo = copy o
									select oo
									max modify mode
									subObjectLevel = 1
									oo.unhideAll #Vertex
									oo.unhideAll #Face
									max select all 
									oo.ConnectVertices vertexFlag:1
									subObjectLevel = 0
									num_copy = polyop.getNumFaces oo
									delete oo
									if num_area_zero > 0 then err += "\x2716 ;2.3.12.; Объекты геометрии содержат полигоны нулевой площади: " + o.name + ", плохо триангулированы: " + num_area_zero as string + "\n"
									if num_copy != num then err += "\x2716 ;2.3.12.; Объекты геометрии должны быть триангулированы перед экспортом в файл формата FBX: " + o.name + ", недотриангулированных полигонов: " + (num_copy - num) as string + " \n"
								)
							) 
							
							"chk_rules_lowpoly_table_2_3_13": -- "3.13. интерьеры за прозрачными окнами" "3.13. Основные внутренние конструкции здания (стены, потолок, пол) должны присутствовать в упрощенном виде только в той части здания, где они могут просматриваться сквозь полупрозрачные детали." 
							(
								err += " ;2.3.13.; Основные внутренние конструкции здания (стены, потолок, пол) должны присутствовать в упрощенном виде только в той части здания, где они могут просматриваться сквозь полупрозрачные детали.\n"
							) 
							
							"chk_rules_lowpoly_table_2_3_14": -- "3.14. односторонние полигоны с прозр." "3.14. Полигоны, для которых используется карта прозрачности, должны оставаться односторонними." 
							(
								--есть ли прострел насквозь у полигонов с картой прозрачности, не понятно пока как выделять такие полигоны
								--искать есть ли карта прозрачности в слоте
								local maps = #()
								for o in (arr[5][arr[5].count]) where o.material != undefined do
								(
									local maps = usedMaps o.material
									if maps.count > 0 then 
										for m in maps where findstring m "_o_" != undefined do err += " ;2.3.14.; Полигоны, для которых используется карта прозрачности, должны оставаться односторонними: " + o.name + "\n"
								)
							)
							
							"chk_rules_lowpoly_table_2_3_15": -- "3.15. визуальные дефекты" "3.15. В моделях не должно быть визуальных дефектов: при осмотре объекта в условии ограничений, наложенных камерой или каким-либо другим способом, в поле зрения наблюдателя не должно быть физически отсутствующих полигонов, это не касается зон, которые не просматриваются ни под каким углом." 
							(
								--пока неизвестно как это смотреть, только лучами простреливать по сфере, если насквозь, значит дыра
								err += " ;2.3.15.; В моделях не должно быть визуальных дефектов: при осмотре объекта в условии ограничений, наложенных камерой или каким-либо другим способом, в поле зрения наблюдателя не должно быть физически отсутствующих полигонов, это не касается зон, которые не просматриваются ни под каким углом.\n"
							) 
							
							"chk_rules_lowpoly_table_2_3_16": -- "3.16. трансформации модели сброшены" "3.16. Все трансформации модели должны быть сброшены (применены)." 
							(
								for o in (arr[5][arr[5].count]) where o.scale != [1,1,1] do err += "\x2716 ;2.3.16.; Все трансформации модели должны быть сброшены (применены): " + o.name + "\n"
								for o in (arr[5][arr[5].count]) where o.rotation.x_rotation != 0.0 or o.rotation.y_rotation != 0.0 or o.rotation.z_rotation != 0.0 do err += "\x2716 ;2.3.16.; Все трансформации модели должны быть сброшены (применены): " + o.name + "\n"
							) 
							
							"chk_rules_lowpoly_table_2_3_17": -- "3.17. группы сглаживания" "3.17. Группы сглаживания определяет проектировщик согласно проекту и расставляет их только по полигонам." 
							(
								local facesSG = #()
								for o in (arr[5][arr[5].count]) do
								(
									facesSG = for face in #{1..(polyop.getnumfaces o)} collect polyop.getFaceSmoothGroup o face
									if facesSG.count > 0 then
									(
										if (for ff in facesSG where ff != 0 collect ff).count == 0 then err += "\x2716 ;2.3.17.; Группы сглаживания определяет проектировщик согласно проекту и расставляет их только по полигонам: " + o.name + "\n" 
									)
									else err += "\x2716 ;2.3.17.; Группы сглаживания определяет проектировщик согласно проекту и расставляет их только по полигонам.\n"
								)
							) 

							"chk_rules_lowpoly_table_2_4": (err += "\x2714 ;4. Требования к материалам;\n")  -- "4. Требования к материалам"
							"chk_rules_lowpoly_table_2_4_1": -- "4.1. стандартные материалы" "4.1. Материалы не должны быть созданы при помощи сторонних движков рендера (VRay, Octane, Corona, Arnold и прочего ПО для визуализации изображений высокого качества, а также Physical Material, Blend)."
							(
								for o in (arr[5][arr[5].count]) where o.material != undefined do
								(	
									local m = o.material
									case classof m of
									(
										--Blend: CoronaLegacyMtl: CoronaPhysicalMtl: Physical_Material: Multimaterial: 
										default: (err += "\x2716 ;2.4.1.; У объекта: " + o.name + " материал типа " + (classof m) as string + ", а материалы не должны быть созданы при помощи сторонних движков рендера (VRay, Octane, Corona, Arnold, а также Physical Material, Blend).\n")
										Physical_Material: (err += " ;2.4.1.; У объекта: " + o.name + " материал типа " + (classof m) as string + ", такой тип материала присваивается всем объектам при импорте FBX файла по умолчанию, в этом нет ошибки, если экспорт делался в материал типа StandartMaterial\n")
										Standardmaterial: () --ничего не выводить, что всё хорошо
										Multimaterial: 
										(
											err += " ;2.4.1.; У объекта: " + o.name + " материал типа " + (classof m) as string + ", такой материал используют только когда не хватает одного материала и делают несколько наборов материалов.\n"
											for id in #{1..m.numsubs} where m.materialList[id] != undefined do
											(
												sub_m = m.materialList[id]
												case classof sub_m of
												(
													Standardmaterial: () --ничего не выводить, что всё хорошо
													default: (err += "\x2716 ;2.4.1.; У объекта: " + o.name + " субматериал типа " + (classof sub_m) as string + ", а материалы не должны быть созданы при помощи сторонних движков рендера (VRay, Octane, Corona, Arnold, а также Physical Material, Blend).\n")
												)
											)
										)
									)
								)
							
								for o in (arr[5][arr[5].count]) do 
								(
									--for tmap in (getClassInstances BitmapTexture target:o asTrackViewPick:off) do 
									for tmap in (getClassInstances CoronaBitmap target:o asTrackViewPick:off) do err += "\x2716 ;2.4.1.; У объекта: " + o.name + " материал карты типа CoronaBitmap, а материалы не должны быть созданы при помощи сторонних движков рендера.\n"
									for tmap in (getClassInstances CoronaNormal target:o asTrackViewPick:off) do err += "\x2716 ;2.4.1.; У объекта: " + o.name + " материал карты типа CoronaNormal, а материалы не должны быть созданы при помощи сторонних движков рендера.\n"
								)

								for o in (arr[5][arr[5].count]) where o.material == undefined do err += "\x2716 ;2.4.1.; У объекта: " + o.name + " отсутствует материал.\n"

								/*
								(
									mats = #()
									for matClass in material.classes do
									(
										for m in (getclassinstances matClass processAllAnimatables:true processChildren:true) do append mats m
									)
									print mats
								)
								*/	
							)
							
							"chk_rules_lowpoly_table_2_4_2": -- "4.2. материал полупрозрачных деталей" "4.2. Материал полупрозрачных деталей не должен содержать в себе текстурных карт."
							(
								for o in (arr[5][arr[5].count]) where o.material != undefined and findstring (tolower o.name) "glass" != undefined do 
								(
									local maps = #()
									maps = usedMaps o.material
									if maps.count > 0 then err += "\x2716 ;2.4.2.; У объекта: " + o.name + ", материал полупрозрачных деталей не должен содержать в себе текстурных карт.\n"
								)	
							)
							
							"chk_rules_lowpoly_table_2_4_3": -- "4.3. цвет полупрозрачных деталей" "4.3. Цвет материала полупрозрачных деталей задается исполнителем через настройку параметров материала (рисунок 16)." 
							(
								for o in (arr[5][arr[5].count]) where findstring (tolower o.name) "glass" != undefined do
								(
									if o.material == undefined then err += "\x2716 ;2.4.3.; У объекта: " + o.name + ", нет материала, а цвет материала полупрозрачных деталей задается исполнителем через настройку параметров материала.\n"
									if o.material != undefined then	
									(
										if classof o.material != Standardmaterial then err += "\x2716 ;2.4.3.; У объекта: " + o.name + " не тот тип материала, нужен тип Standardmaterial, цвет материала полупрозрачных деталей задается исполнителем через настройку параметров материала.\n"
									)
								)	
							)
							
							"chk_rules_lowpoly_table_2_4_4": -- "4.4. свойства и фактура мат-ов" "4.4. Свойства и фактура материалов, при необходимости, передаются дополнительными текстурными картами." 
							(
								for o in (arr[5][arr[5].count]) where o.material != undefined and findstring (tolower o.name) "glass" == undefined do 
								(
									local maps = #()
									maps = usedMaps o.material
									if maps.count == 0 then err += "\x2716 ;2.4.4.; У объекта: " + o.name + ", свойства и фактура материалов, передаются дополнительными текстурными картами.\n"
								)
							)

							"chk_rules_lowpoly_table_2_4_5": -- "4.5. кол-во материалов и наборов" "4.5. Количество материалов (кроме материалов полупрозрачных деталей) соответствует количеству текстурных наборов." 
							(
								local mats = undefined 
								local mats_maps = #()	
								local mats_count = 0
								local file_texes = #()								
								local all_file_texes = #()	
								local file_texes_nabor = #()
								local file_texes_nabor_count = 0
								local mats_maps_nabor = #()
								local mats_maps_nabor_count = 0
								
								if arr[3].count > 0 then
								(
									for a in arr[3] do 
										for b in a do append all_file_texes b
								)		
								
								for o in (arr[5][arr[5].count]) where findstring (tolower o.name) "glass" == undefined do --#(o.name, o.material)
								(
									mats = o.material
									if o.material != undefined then 
									(
										mats_maps = usedMaps o.material
										case classof mats of
										(
											default: mats_count = 1
											Multimaterial: 
											(
												for id in #{1..m.numsubs} where mats.materialList[id] != undefined do
												(
													case classof mats.materialList[id] of
													(
														default: mats_count += 1
													)
												)
											)
										)								
									)
									
									file_texes = for t in all_file_texes where findstring (getfilenamefile t) (substitutestring o.name "SM_" "T_") != undefined and findstring (getfilenamefile t) "Glass" == undefined collect (getfilenamefile t)

									for t in file_texes do appendIfUnique file_texes_nabor ((filterstring t "_")[(filterstring t "_").count])
									for t in mats_maps do appendIfUnique mats_maps_nabor ((filterstring (getfilenamefile t) "_")[(filterstring (getfilenamefile t) "_").count])

									file_texes_nabor_count = (for n in file_texes_nabor where delete_only_digits n == "" collect n).count 
									mats_maps_nabor_count = (for n in mats_maps_nabor where delete_only_digits n == "" collect n).count

									if file_texes_nabor_count != mats_maps_nabor_count or file_texes_nabor_count != mats_count then err += "\x2716 ;2.4.5.; У объекта: " + o.name + ", количество материалов (кроме материалов полупрозрачных деталей) не соответствует количеству текстурных наборов.\n"
									--print file_texes_nabor_count
									--print mats_maps_nabor_count
									--print mats_count
									--print #(file_texes)
									--print #(mats_maps)
									--print #(file_texes_nabor)
									--print #(mats_maps_nabor)
								)

							)
							
							"chk_rules_lowpoly_table_2_4_6": -- "4.6. кол-во полупрозрачных мат-ов" "4.6. Количество материалов для полупрозрачных деталей не должно превышать 7." 
							(
								for o in (arr[5][arr[5].count]) where o.material != undefined and findstring (tolower o.name) "glass" != undefined do
								(
									case classof o.material of
									(
										Multimaterial: 
										(
											if (for id in #{1..o.material.numsubs} collect id).count > 7 then err += "\x2716 ;2.4.6.; У объекта: " + o.name + " количество материалов для полупрозрачных деталей не должно превышать 7.\n"
											if (for id in #{1..o.material.numsubs} collect id).count < 2 then err += "\x2716 ;2.4.6.; У объекта: " + o.name + " для полупрозрачных деталей используется " + (classof o.material) as string + " количество слотов в нем мало, надо использовать простой Standardmaterial.\n"
										)
										
										Standardmaterial: () --всё хорошо, один материал
										default: (err += "\x2716 ;2.4.6.; У объекта: " + o.name + " несколько материалов для полупрозрачных деталей надо реализовать через Multimaterial с Standardmaterial в слотах, но не больше 7.\n")
									)
								)
							)
							
							"chk_rules_lowpoly_table_2_5": (err += "\x2714 ;5. Требования к текстурным картам;\n") --"5. Требования к текстурным картам" 
							"chk_rules_lowpoly_table_2_5_1": () -- "5.1. текстурные карты PNG" checked:true offset:[20,0] tooltip:"5.1. Текстурные карты должны предоставляться в виде текстурных атласов в формате PNG и быть включены в файл формата FBX (рисунок 5)."
							"chk_rules_lowpoly_table_2_5_2": () -- "5.2. допустимые размеры карт" checked:true offset:[20,0] tooltip:"5.2. Допустим?? следующие размеры текстурных карт: 128x128, 256x256, 512x512, 1024x1024, 2048x2048 пикселей, максимальный размер текстурной карты, помимо условия подпункта (см.п.5.11), 2048x2048 пикселей"
							"chk_rules_lowpoly_table_2_5_3": () -- "5.3. отступ в 8 пикселей" checked:true offset:[20,0] tooltip:"5.3. Рекомендуется выдерживать текстурный отступ в 8 пикселей."
							"chk_rules_lowpoly_table_2_5_4": () -- "5.4. соотношение сторон 1:1" checked:true offset:[20,0] tooltip:"5.4. Соотношение сторон текстурной карты должно быть строго 1:1."
							"chk_rules_lowpoly_table_2_5_5": () -- "5.5. альфа-канал запрещен" checked:true offset:[20,0] tooltip:"5.5. Альфа-канал запрещен к использованию."
							"chk_rules_lowpoly_table_2_5_6": () -- "5.6. состав карт 5 типов" checked:true offset:[20,0] tooltip:"5.6. Текстурный набор исполнитель формирует самостоятельно, исходя из своих потребностей и в соответствии с требованиями данного документа. Максимально возможный набор текстур для объекта геометрии состоит из карт: диффу??ного цвета, нормалей, прозрачности, карты шероховатости и металличности. Последние две используются обязательно в паре (рисунок 6)."
							"chk_rules_lowpoly_table_2_5_7": () -- "5.7. одинаковый разме?? в наборе" checked:true offset:[20,0] tooltip:"5.7. Все текстурные карты в рамках одного текстурного набора должны иметь одинаковый размер."
							"chk_rules_lowpoly_table_2_5_8": () -- "5.8. карты непрозрачного стекла" checked:true offset:[20,0] tooltip:"5.8. Параметры набора текстурных карт непрозрачного стекла: месторасположение стекол представить на картах диффузного цвета и картах металличности белым цветом, на ??арте ш??рохо??атости - черным, карта прозрачности отсутствует, либо текстурные координаты, соответствующие положению полигона оконных стекол, заполняются исключительно белым цветом."
							"chk_rules_lowpoly_table_2_5_9": () -- "5.9. на каждый ОКС по 1 набору карт" checked:true offset:[20,0] tooltip:"5.9. На каждый ОКС в составе модели АГР необходимо использовать по одному текстурному набору."
							"chk_rules_lowpoly_table_2_5_10": () -- "5.10. макс кол-во текстур бл-ва" checked:true offset:[20,0] tooltip:"5.10. Максимальное количество текстур для файлов благоустройства - 20, их количество также регулируется требованием к плотности текстуры."
							"chk_rules_lowpoly_table_2_5_11": () -- "5.11. набор тексту?? эл-тов бл-ва" checked:true offset:[20,0] tooltip:"5.11. При текстурировании элементов благоустройства, выполненных в виде полигональных объектов (с проработкой геометрии в рамках требований к максимальному количеству полигонов) необходимо использовать один текстурный набор на все элементы, размером не более 512x512 пикселей."
							"chk_rules_lowpoly_table_2_5_12": () -- "5.12. набор текстур раст-ти" checked:true offset:[20,0] tooltip:"5.12. При текстурировании элементов растительности необходимо использовать один текстурный набор карт на все элементы, размером не более 2048x2048 пикселей. В текстурный набор должны входить в обязательном порядке карты диффузного цвета и, при необходимости, карты прозрачности."

							"chk_rules_lowpoly_table_2_6": (err += "\x2714 ;6. Требования к плотности текстуры;\n") -- "6. Требования к плотности текстуры"
							"chk_rules_lowpoly_table_2_6_1": () -- "6.1. плотности карт Ground" checked:true offset:[20,0] tooltip:"6.1. Требования к плотности текстурных карт распространяются только на поверхности рельефа в границах участка территории: плотность текстур должна быть не меньше 10 пикселей на кв. метр, что при текстуре 2048x2048 соответствует квадрату со сторонами 204 на 204 метров, но не более 40 пикселей на кв. метр (рисунок 7, рисунок 8)."
							"chk_rules_lowpoly_table_2_6_2": () -- "6.2. плотности карт остального" checked:true offset:[20,0] tooltip:"6.2. Требования к плотности текстурных карт не распространяются на полигоны, опущенные вниз под землю по периметру модели благоустройства согласно пункту 3.4 настоящих требований, а также на геометрии растительности, ОКС и элементов благоустройства."

							"chk_rules_lowpoly_table_2_7": (err += "\x2714 ;7. Требования к объектам геометрии стекла;\n") -- "7. Требования к объектам геометрии стекла" 
							"chk_rules_lowpoly_table_2_7_1": () -- "7.1. текстурные карты стекла" checked:true offset:[20,0] tooltip:"7.1. В случае использования текстурных карт стекло не выделяют в отдельный объект геометрии и в обязательным порядке используют текстурные карты шероховатости и металличности, согласно пунктам 5.6, 5.8;"
							"chk_rules_lowpoly_table_2_7_2": () -- "7.2. полупрозрачное стекло" checked:true offset:[20,0] tooltip:"7.2. В случае полупрозрачности стекло выделяют в отдельный объект геометрии и назначают специальный материал согласно пунктам 4.2, 4.3 настоящих требований."		
							
							"chk_rules_lowpoly_table_2_8": (err += "\x2714 ;8. Требования к точке отсчета и углам поворота;\n") -- "8. Требования к точке отсчета и углам поворота"  
							"chk_rules_lowpoly_table_2_8_1": () -- "8.1. углы поворота всех объектов" "8.1. Углы поворота всех объектов геометрии после применения (сброса) трансформации должны соответствовать углам поворота ОКС в плане проектного решения."
							"chk_rules_lowpoly_table_2_8_2": () -- "8.2. система координат МСК" "8.2. Все объекты геометрии должны иметь координатную привязку в Московской системе координат и высот согласно проектному решению."
							"chk_rules_lowpoly_table_2_8_3": () -- "8.3. произвольная система координат" "8.3. Не допускается использование произвольной (условной) системы координат или неполного координатного описания (отсутствие значений высот)."		

							"chk_rules_lowpoly_table_2_9": (err += "\x2714 ;9. Требования к суффиксам в наименованиях;\n") -- "9. Требования к суффиксам в наименованиях"
							"chk_rules_lowpoly_table_2_9_1": () -- "9.1. Суффиксы имен объектов, мат-ов" "9.1. Суффиксы применяются к наименованиям файлов, объектов геометрии, материалов и текстур с целью определения/построения иерархии в обязательном порядке:\n1. В наименовании объектов геометрии обозначают принадлежность к:\n_Main ОКС (кроме полупрозрачных деталей)\n_MainGlass полупр??????зрачным деталям ОКС\n_Ground благоустройству (кроме полупрозрачных деталей)\n_GroundGlass полупрозрачным деталям благоустройства\n_GroundEl элементам благоустройства: МАФ, мачтам освещения и пр. (кроме полупрозрачных элементов)"		
							"chk_rules_lowpoly_table_2_9_2": () -- "9.2. Суффиксы имен карт" "9.2. В наименовании текстурных карт обозначают принадлежность к картам:\n_d диффузного цвета\n_n нормалей\n_o прозрачности\n_m металличности\n_r шероховатости"	

							"chk_rules_lowpoly_table_2_10": (err += "\x2714 ;10. Требования к именам;\n") -- "10. Требования к именам"
							"chk_rules_lowpoly_table_2_10_1": --#(myfiles, filesFBX, filesTEX, filesAll, objAll) "10.1. длина имен везде < 254 символа" "10.1. Длина наименования, включая адрес и все суффиксы, постфиксы и префиксы, не должна превышать значения в 254 символа."
							(
								cou = 0
								for f in arr[1] where (getfilenamefile f).count > 254 do err += "\x2716 ;2.10.1.; Длина наименования архива ZIP, включая адрес и все суффиксы, постфиксы и префиксы, не должна превышать значения в 254 символа\n"
								for f in arr[2] where (getfilenamefile f).count > 254 do err += "\x2716 ;2.10.1.; Длина наименования файла FBX, включая адрес и все суффиксы, постфиксы и префиксы, не должна превышать значения в 254 символа: " + (getfilenamefile f) + "\n"
								for a = #{1..arr[3].count} do
								(
									str = getfilenamefile arr[2][a]
									if (cou = (for f in arr[3][a] where (getfilenamefile f).count > 254 collect (getfilenamefile f)).count) > 0 then err += "\x2716 ;2.10.1.; Длина наименования файлов PNG, включая адрес и все суффиксы, постфиксы и префиксы, не должна пр??вышать значения в 254 символа, число файлов с нарушением: " + str + " " + cou as string + "\n"
								)	
								for f in arr[5][arr[5].count] where f.name.count > 254 do err += "\x2716 ;2.10.1.; Длина наименования объектов геометрии, включая адрес и все суффиксы, постфиксы и префиксы, не должна превышать значения в 254 символа: " + f.name + "\n"
							)
							
							"chk_rules_lowpoly_table_2_10_2": -- "10.2. символы и спецсимволы в именах" "10.2. Наименования должны задаваться исключительно латиницей (английским алфавитом), цифрами и символом нижнего подчеркивания («_»), использование других спецсимволов, включая пробел, недопустимо."
							(
								--проверка недопустимых символов
								for f in arr[1] do
								(
									t = parse_error_symbols (getfilenamefile f)
									if t != "" then err += "\x2716 ;2.10.2.; " + (getfilenamefile f) + ": имя файла архива ZIP содержит недопустимые символы\n"
								)
								
								for f in arr[2] do 
								(
									t = parse_error_symbols (getfilenamefile f)
									if t != "" then err += "\x2716 ;2.10.2.; " + (getfilenamefile f) + ": имя файла FBX содержит недопустимые символы\n"
								)
								
								for f in arr[2] do 
								(
									t = parse_error_symbols (getfilenamefile f)
									if t != "" then err += "\x2716 ;2.10.2.; " + (getfilenamefile f) + ": имя файла FBX содержит недопустимые символы\n"
								)								
								
								for a = #{1..arr[3].count} do
								(
									str = getfilenamefile arr[2][a]
									for f in arr[3][a] where parse_error_symbols (getfilenamefile f) != "" do err += "\x2716 ;2.10.2.; имя файла PNG содержит недопустимые символы: " + str + " " + (getfilenamefile f) + "\n"
								)	
						
								for f in arr[5][arr[5].count] where parse_error_symbols f.name != "" do err += "\x2716 ;2.10.2.; имя объекта геометрии содержит недопустимые символы: " + f.name + "\n"
								
								--проверки транлитерации
								for f in arr[1] do
								(
									t = getfilenamefile f
									if t != translit t then err += "\x2716 ;2.10.2.; " + t + ": имя файла архива ZIP содержит недопустимые символы не в транслите\n"
									if findstring t "_" == undefined then err += "\x2716 ;2.10.2.; " + t + ": имя файла архива ZIP не содержит символы разделения «_»\n"
									if findstring t " " != undefined then err += "\x2716 ;2.10.2.; " + t + ": имя файла архива ZIP содержит символы « »\n"
								)
								
								for f in arr[2] do 
								(
									t = getfilenamefile f
									if t != translit t then err += "\x2716 ;2.10.2.; " + t + ": имя файла FBX содержит недопустимые символы не в транслите\n"
									if findstring t "_" == undefined then err += "\x2716 ;2.10.2.; " + t + ": имя файла FBX не содержит символы разделения «_»\n"
									if findstring t " " != undefined then err += "\x2716 ;2.10.2.; " + t + ": имя файла FBX содержит символы « »\n"										
								)	

								for a = #{1..arr[3].count} do
								(
									str = getfilenamefile arr[2][a]
									for f in arr[3][a] where (getfilenamefile f) != translit (getfilenamefile f) do err += "\x2716 ;2.10.2.; имя файла PNG содержит недопустимые символы не в транслите: " + str + " " + (getfilenamefile f) + "\n"
									for f in arr[3][a] where findstring (getfilenamefile f) "_" == undefined do err += "\x2716 ;2.10.2.; имя файла PNG не содержит символы разделения «_»: " + str + " " + (getfilenamefile f) + "\n"
									for f in arr[3][a] where findstring (getfilenamefile f) " " != undefined do err += "\x2716 ;2.10.2.; имя файла PNG содержит недопустимые символы « »: " + str + " " + (getfilenamefile f) + "\n"
								)	
						
								for f in arr[5][arr[5].count] where f.name != translit f.name do err += "\x2716 ;2.10.2.; имя объекта геометрии содержит недопустимые символы: " + f.name + "\n"
								for f in arr[5][arr[5].count] where findstring f.name "_" == undefined do err += "\x2716 ;2.10.2.; имя объекта геометрии не содержит символы разделения «_»: " + f.name + "\n"
								for f in arr[5][arr[5].count] where findstring f.name " " != undefined do err += "\x2716 ;2.10.2.; имя объекта геометрии содержит недопустимые символы « »: " + f.name + "\n"
							)
							
							"chk_rules_lowpoly_table_2_10_3": -- "10.3. порядок именования для FBX" 
							(
								
							)
							
							"chk_rules_lowpoly_table_2_10_3_1": -- "10.3.1 ХХХХ код ОМК ТЕ Москвы в FBX" "10.3.1. Файл архива именуется согласно схеме пpeфикc_Address: 0313_ProezdNansena_ZU_8.zip 0313_77_02_0015007_4157_Vld_15.zip - где префикс - четырехзначный код, определяемый согласно общемосковскому классификатору территориальных единиц Москвы"
							(
								
							)
							
							"chk_rules_lowpoly_table_2_10_3_2": -- "10.3.2 суффиксы имен файла FBX" "10.3.2. Файл формата FBX именуется согласно схемам, вне зависимости от разделения на отдельные файлы формата FBX: - для ОКС пpeфикc_Address_нoмep, где номер - это порядковый номер fbx, как части АГР в рамках проекта, двухзначное число от 01 до 20, назначаемое с шагом в единицу, строго последовательно и без пропусков, в порядке возрастания. Если FBX один, то его порядковый номер «01» 0313_ProezdNansena_ZU_8_01.fbx 0313_ProezdNansena_ZU_8_02.fbx 0313_77_02_0015007_4157_Vld_l5_01.fbx - для благоустройства префикс_Address_Ground 0313_ProezdNansena_ZU_8_Ground.fbx 0313_77_02_0015007_4157_Vld_15_Ground.fbx"
							(
								
							)
							
							"chk_rules_lowpoly_table_2_10_3_3": -- "10.3.3 суффиксы имен объектов в FBX" "10.3.3. Объекты геометрии именуется согласно схемам, вне зависимости от разделения на отдельные файлы формата FBX: - для ОКС SM_Address_HOMep_Main, где номер - это порядковый номер ОКС во всем проекте, а не в конкретном FBX-файле, при разделении АГР на части, трехзначное число от 001 до 020, назначаемое с шагом в единицу, строго последовательно и без пропусков, в порядке возрастания, например:SM_ProezdNansena_ZU_8_001_Main\nSM_Address номер MainGlass - для полупрозрачных деталей ОКС, например: SM_ProezdNansena_ZU_8_001_MainGlass\n— для благоустройства SM_Address_Ground: SM_ProezdNansena_ZU_8_Ground\n— для полупрозрачных деталей благоустройства SM адрес GroundGlass, SM_ProezdNansena_ZU_8_GroundGlass\n- для элементов благоустройства SM_Address_GroundEl, SM_ProezdNansena_ZU_8_GroundEl\n- для полупрозрачных деталей элементов благоустройства SM_Address_GroundElGlass, SM_ProezdNansena_ZU_8_GroundElGlass\n- для растительности SM_Address_Flora, SM_ProezdNansena_ZU_8_Flora"		
							(
								
							)
							
							"chk_rules_lowpoly_table_2_10_3_4": -- "10.3.4 суффиксы имен текстур в FBX" "10.3.4. Текстуры именуются согласно схемам:\nв названиях текстур, через нижнее подчеркивание, с соблюдением следующего порядка пишет??я: префикс «Т», адрес (для благоустройства, е??о элементов и растительности) или адрес номер (для ОКС), соответствующий объектам геометрии суффикс, соответствующий текстурным картам суффикс, постфикс SlotNumber — порядковый номер материала, к которому применяется текстурная карта (задается исполнителем, последовательно, начиная с единицы). Если материал единственный в рамках одного файла, то его порядковый номер равен «1», - Для моделей, вне зависимости от разделения на отдельные файлы формата FBX\nT_Address_нoмep_CyффикcГeoмeтpии_CyффиксТекстурныхКарт_SlotNumber\nT_ProezdNansena_ZU_8_001_Main_d_1\nT_ProezdNansena_ZU_8_002_Main_d_1\n- для благоустройства, его элементов и растительности\nT_Address_CyффикcГеометрии_СуффиксТекстурныхКарт_SlotNumber\nT_ProezdNansena_ZU_8_Ground_d_1.png\nT_ProezdNansena_ZU_8_GroundEl_d_1.png\nT_ProezdNansena_ZU_8_GroundEl_m_1.png\nT_ProezdNansena_ZU_8_GroundEl_r_1.png\nТ_ProezdNansena_ZU_8_Flora_d_1.png\nТ_ProezdNansena_ZU_8_Flora_o_1.png"
							(
								
							)
							
							"chk_rules_lowpoly_table_2_10_3_5": -- "10.3.5 суффиксы имен мат-лов в FBX" "10.3.5. Материалы именуются согласно схемам: материалы за исключением материалов полупрозрачных деталей, следует называть тем же именем, что и соответствующую ему текстуру, при этом для текстур используется префикс «Т», а для материалов — префикс «М». Суффикс текстурных карт в названии материалов опускается\nМ_ProezdNansena_ZU_8_001_Main_1\nМ_ ProezdNansena_ZU_8_002_Main_1\nМ_ ProezdNansena_ZU_8_Main_1\nМ_ ProezdNansena_ZU_8_Main_2\nМ_ ProezdNansena_ZU_8_Ground_1\nМ_ ProezdNansena_ZU_8_GroundEl_1\nМ_ ProezdNansena_ZU_8_Flora_1\nдля полупрозрачных деталей M_Glass_Hомер, где номер - это порядковый номер материала от 01 до 07 для полупрозрачной детали в рамках проекта, материалы полупрозрачных деталей носят одинаковое название\nM_Glass_01\nM_Glass_02"
							(
								
							)
						)
					)
					err += "\n;Проверка окончена;\n"	
					--excel_file = GetDir #maxroot +"\\GeoScripts\\Reports\\" + (getfilenamefile edt_lowpoly_rules_check_path.text) + "_report_lowpoly.csv" 
					--time_str = ""
					time_str = localTime --getLocalTime() 
					--for ti in tim do time_str += ti	as string + "_"
					time_str = substitutestring time_str "\\" "_"
					time_str = substitutestring time_str ":" "_"
					time_str = substitutestring time_str " " "_"
					time_str = substitutestring time_str "." "_"
					excel_file = getfilenamepath edt_lowpoly_rules_check_path.text + getfilenamefile edt_lowpoly_rules_check_path.text + "_report_lowpoly_" + time_str + ".csv" 
					lbl_lowpoly_progress.text = ""
					--ss = substitutestring err ";" ""
					--messagebox ss
					
					--print err
					global dirs_select = #()
					stroke = #()
					stroke = filterstring err "\n" splitEmptyTokens:true
					
					dirs_select = for i in stroke collect (if (filterstring i ";" splitEmptyTokens:true).count == 0 then #(" "," "," ") else (filterstring i ";" splitEmptyTokens:true))
					print dirs_select
					
					if err != undefined then WriteAllLines excel_file err 
						
					try(destroyDialog ::report_lowpoly)catch()
					rollout report_lowpoly "Lowpoly Models Errors Report" 
					(
						fn autoResizeColumn lv columns: = 
						(
							vScrollWidth = 21 -- vertical scrollbar width
							for c = 0 to columns-1 do
							(
								lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
								vScrollWidth += lv.Columns.Item[c].Width
							) 
							vScrollWidth
						)
						
						fn PopulateList lv dirs_select =
						(
							lv.Items.Clear()
							lv.view = (dotNetClass "system.windows.forms.view").details
							lv.HideSelection = true 
							lv.HeaderStyle = (dotNetClass "System.Windows.Forms.ColumnHeaderStyle").clickable
							--lv.height = 390
							lv.FullRowSelect = true    
							lv.MultiSelect = false --true    
							lv.AllowColumnReorder = true
							lv.GridLines = true
							lv.checkBoxes = false --true 
							lv.Scrollable = true
							lv.ShowItemToolTips = true
							columnsAr = #("   ", "Table rule number                                               ", "Error Comment                                                                                                                                  ")
							lv.columns.Clear()
							for i = 1 to 3 do lv.columns.add columnsAr[i] 0	
							lv.width = autoResizeColumn lv columns:3
							--lv.width = 800
							lv.Update()
							
							rows = #()
							for t = 1 to dirs_select.count do
							(
								li = dotNetObject "System.Windows.Forms.ListViewItem" (dirs_select[t][1])
								li.UseItemStyleForSubItems = true
								li.subitems.add dirs_select[t][2]
								li.subitems.add dirs_select[t][3]
								append rows li
							)
							lv.items.addRange rows
							--lv.Update()
							lv.width = 990
							--lv.width = autoResizeColumn lv columns:3
							lv.Update()
						)
						
						dotNetControl lv "ListView" pos:[5,5] width:990 height:400
						label lbl_message "This report already saved near ZIP archive as CSV file"
						button btnCopyClp "Copy to Clipboard" offset:[0,0] across:4 tooltip:""
						button btnPasteClp "Paste from Clipboard" offset:[0,0] tooltip:""
						button btnGetScreen "Make Screen" offset:[0,0] tooltip:""	
						button btnDelScreen "Delete Screen" offset:[0,0] tooltip:""	
						button btnExportPDF "Export to PDF" offset:[0,0] across:3 tooltip:""		
						button btnExportCSV "Export to CSV" offset:[0,0] tooltip:""							
						button btnClose "Close" align:#right tooltip:"Close dialog"

						on report_lowpoly open do
						(  
							PopulateList lv dirs_select
						)
						
						on lv MouseDown arg do
						(
						)

						on lv MouseHover arg do 
						(
							--print "MouseHover"
							--ScrollToBottom 
							--listView.setSelection (int position) --Если вы хотите перейти прямо к нужной позиции в списке, ??росто используйте
							--listView.smoothScrollToPosition (int position) --и если вы хотите плавно перейти к нужной позиции в listView, просто используйте
							--if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
							--(
							--	val = hitNode.index + 1
							--	dirs_select[val][3]
							--)                

						)
				
						on lv MouseLeave arg do 
						(
							--scroll_down = false
							--print "MouseLeave"
						)
				
						on btnClose pressed do
						(
							try(destroyDialog ::report_lowpoly)catch()
						)	
					)
					createDialog report_lowpoly width:1000 height:500 style:#(#style_titlebar, #style_border, #style_sysmenu, #style_resizing)		

				)
				else
				(
					messagebox "No file specified"
				)
			)
			
			2:
			(
				
			)
			
			3:
			(
				--print #(RulesCheck_lowpoly.Controls)
			)

		)			
	)
)
addRollout RulesCheck_lowpoly GeoAGR rolledup:true

rollout RulesCheck_highpoly "Rules Check for HighPoly Models" autoLayoutOnResize:true
(	
	radiobuttons rdo_check_highpoly labels: #("Check Folder", "Check Current Scene", "Check Selection in Scene") columns:1 rows:3 default:3 align:#left offset:[0,0] across:2 enabled:false tooltip:""
	button btn_get_path_highpoly_rules_check "Open Folder with Models" align:#left enabled:false tooltip:"Open Folder with HighPoly Models to Check Rules"
	button btn_highpoly_rules_check "Start Check Rules" align:#left across:3 enabled:false tooltip:"Работаю над этим..."
	button btn_highpoly_checkers_on "Check All" offset:[25,0] tooltip:""
	button btn_highpoly_checkers_off "UnCheck All" align:#right tooltip:""	
	edittext edt_highpoly_rules_check_path "" text:"" labelOnTop:false bold:true width:260 fieldWidth:260 readonly:false offset:[0,0] tooltip:"Path to Folder with HighPoly Models"
	progressBar pb_highpoly "" width:260 height:10 tooltip:"Checking progress" 
	label lbl_highpoly_progress "" align:#left style_sunkenedge:false width:260 tooltip:"Press ESC to CANCEL check"
	
		checkbox chk_rules_highpoly_table_1_All "Таблица 1. Требования к ВПМ архивам общие" checked:true offset:[0,0] align:#left tooltip:"Таблица 1 «Общие технические требования к архиву данных по трехмерным модели»"
		checkbox chk_rules_highpoly_table_1_1 "Требования к форматам моделей" checked:true offset:[0,0] align:#left tooltip:"1. Требования к форматам предоставления моделей"
		checkbox chk_rules_highpoly_table_1_1_1 "1.1. FBX 7.4 (FBX 2014) binary" checked:true offset:[20,0] tooltip:"1.1. Трехмерные цифровые модели должны предоставляться заявителем в универсальном обменном формате FBX версии 7.4 (FBX 2014) бинарного типа;"
		checkbox chk_rules_highpoly_table_1_1_2 "1.2. вредоносные программы" checked:true offset:[20,0] tooltip:"1.2. Предоставляемые модели не должны содержать вредоносных программ или частей кода;"
		checkbox chk_rules_highpoly_table_1_1_3 "1.3. лицензионная версия 3ds max" checked:true offset:[20,0] tooltip:"1.3. Предоставляемые модели должны создаваться с применением лицензионных версий программного обеспечения."
		checkbox chk_rules_highpoly_table_1_1_4 "1.4. соответствие визуализации" checked:true offset:[20,0] tooltip:"1.4. Предоставленная трехмерная модель должна соответствовать визуализации и графическим материалам, представленных в рамках предпроектного архитектурного решения (буклета, эскизного проекта) и проектной документации."

		checkbox chk_rules_highpoly_table_1_2 "2. Требования к единицам измерения" checked:true offset:[0,10] align:#left tooltip:"2. Требования к единицам измерения"
		checkbox chk_rules_highpoly_table_1_2_1 "2.1. cистема координат - метры" checked:true offset:[20,0] tooltip:"2.1. Система отображения координат должна быть метрическая: одна условная единица измерения соответствует одному метру."
	
		checkbox chk_rules_highpoly_table_1_3 "3. Требования к переменной Address" checked:true offset:[0,10] align:#left tooltip:"3. Требование к содержанию переменной Address"
		checkbox chk_rules_highpoly_table_1_3_1 "3.1. сокращения адреса, нет точек" checked:true offset:[20,0] tooltip:"3.1. Рекомендовано использование сокращений адресообразующих элементов вместо полного описания, например, согласно Приказу Министерства финансов Российской Федерации от 5 ноября 2015 г. № 171н «Об утверждении Перечня элементов планировочной структуры, элементов улично-дорожной сети, элементов объектов адресации, типов зданий (сооружений), помещений, используемых в качестве реквизитов адреса, и Правил сокращенного наименования адресообразующих элементов». Точка в конце сокращенных слов не ставится."
		checkbox chk_rules_highpoly_table_1_3_2 "3.2. адрес латиницей через «_»" checked:true offset:[20,0] tooltip:"3.2. Адресообразующие элементы должны задаваться исключительно латиницей (английским алфавитом), цифрами и символом нижнего подчеркивания («_»). Другие спецсимволы, включая пробел, недопустимы и заменяются символом нижнего подчеркивания («_»)."
		checkbox chk_rules_highpoly_table_1_3_3 "3.3. разделение подчеркиванием" checked:true offset:[20,0] tooltip:"3.3. Адресообразующие элементы разделяются нижним подчеркиванием. Числовые и буквенные знаки отделяются нижним подчеркиванием друг от друга."
		checkbox chk_rules_highpoly_table_1_3_4 "3.4. заглавные буквы в начале" checked:true offset:[20,0] tooltip:"3.4. Каждое новое слово начинается с заглавной буквы."
		checkbox chk_rules_highpoly_table_1_3_5 "3.5. слово «улица» опускается" checked:true offset:[20,0] tooltip:"3.5. В названиях элементов улично-дорожной сети опускается только слово «улица». Например:\nул. Дубининская, вл. 67/1\nDubininskaya_Vl_67_1\nПроезд Нансена, уч. 8 ProezdNansena_Uch_8"
		checkbox chk_rules_highpoly_table_1_3_6 "3.6. кадастровый номер - нет «:»" checked:true offset:[20,0] tooltip:"3.6. Если объект не имеет точного строительного/почтового адреса, то в переменную Address указывается кадастровый номер объекта, символ «:» заменяется на «_». Например: 77:02:0015007:4157 77_02_0015007_4157\n77:02:0015007:4157, корпус 7 77_02_0015007_4157_K_7"
		checkbox chk_rules_highpoly_table_1_3_7 "3.7. уникальный индекс отдельных ОКС" checked:true offset:[20,0] tooltip:"3.7. У отдельно стоящих зданий или строений после наименования адреса/кадастрового номера необходимо добавлять уникальный индекс в формате «number», где number — это трехзначное число, начиная с 001 и далее строго по порядку со значением шага равным единице. Например:\nПроезд Нансена, уч. 8\nProezdNansena_Uch_8_001\n77:02:0015007:4157\n77_02_0015007_4157_001"

		checkbox chk_rules_highpoly_table_2_All "" checked:true offset:[0,10] across:2 align:#left tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2 "Таблица 2. Технические требования к архиву" offset:[0,10] align:#right style_sunkenedge:false tooltip:"Таблица 2 «Технические требования к архиву данных по трехмерным моделям»"
		checkbox chk_rules_highpoly_table_2_1 "" checked:true offset:[0,0] across:2 align:#left tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_1 "1. Требования к архиву, составу, структуре" align:#right style_sunkenedge:false tooltip:"1. Требования к файлу архива, размерам и количеству файлов, структуре данных"
		checkbox chk_rules_highpoly_table_2_1_1 "1.1. архивы ZIP < 500MB" checked:true offset:[20,0] tooltip:"1.1. Модель проекта АГР должна передаваться в виде файлов формата ZIP размером до 500 мегабайт."
		checkbox chk_rules_highpoly_table_2_1_2 "1.2. содержание ZIP файлов, ограничения" checked:true offset:[20,0] tooltip:"1.2. Файл формата ZIP модели должен содержать:\n• файл формата FBX\n• файл формата FBX модели освещения (при наличии в проекте)\n• файл формата GEOJSON\n•3-2100 файлов формата PNG"
		checkbox chk_rules_highpoly_table_2_1_3 "1.3. раздельные ОКС - отдельные модели" checked:true offset:[20,0] tooltip:"1.3. Каждое отдельно стоящее стро??ние с одним адресом - отдельная модель."
		checkbox chk_rules_highpoly_table_2_1_4 "1.4. разные адреса ОКС - отдельные модели" checked:true offset:[20,0] tooltip:"1.4. Каждое строение (корпуса, стилобаты) с уникальным адресом - отдельная модель."
		checkbox chk_rules_highpoly_table_2_1_5 "1.5. благоустройство - отдельная модель" checked:true offset:[20,0] tooltip:"1.5. Файлы благоустройства земельного участка со всеми его элементами и растительностью (Ground) - отдельная модель."
		checkbox chk_rules_highpoly_table_2_1_6 "1.6. наличие благоустройства" checked:true offset:[20,0] tooltip:"1.6. Файлы благоустройства земельного участка - неотъемлемая часть АГР и является обязательной к исполнению."
		checkbox chk_rules_highpoly_table_2_1_7 "1.7. все ОКС и эл-ты бл-ва есть в ВПМ и НПМ" checked:true offset:[20,0] tooltip:"1.7. Файлы благоустройства земельного участка, а также все ОКС проекта должны быть реализованы в полной мере и одинаково как для высокополигональной модели, так и для низкополигональной. Это касается, в том числе, и МАФ, озеленения, столбов освещения и пр."		

		checkbox chk_rules_highpoly_table_2_2 "" checked:true offset:[0,10] across:2 align:#left tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_2 "2. Требования к файлу GEOJSON" offset:[0,10] align:#right style_sunkenedge:false tooltip:"2. Требования к описательному файлу JSON"
		checkbox chk_rules_highpoly_table_2_2_1 "2.1. соответствие структуре GEOJSON" checked:true offset:[20,0] tooltip:"2.1. Файл GEOJSON должен быть заполнен строго в соответствии со структурой, синтаксисом, именами и описаниями полей, примеры заполнения которых указаны в Приложении 3 к настоящему распоряжению."
		checkbox chk_rules_highpoly_table_2_2_2 "2.2. содержание строки адреса" checked:true offset:[20,0] tooltip:"2.2. В строку адреса в GEOJSON прописываются дополнительно сведения о корпусах (секциях, строениях) из спецификации буклета или другого источника проектной информации для каждого отдельно нарезанного корпуса, при отсутствии таковых, например у стилобатов, никакие дополнительные правки в адрес не вносятся."
		checkbox chk_rules_highpoly_table_2_2_3 "2.3. замена кавычек апострофом" checked:true offset:[20,0] tooltip:"2.3. При заполнении значения полей, где требуется внести название, например, организации, в кавычках, вместо них необходимо использовать апостроф."
		checkbox chk_rules_highpoly_table_2_2_4 "2.4. вариации данных в полях" checked:true offset:[20,0] tooltip:"2.4. При необходимости внести вариацию данных в поля «okrug», «rajon», «developer», «designer», «cadNum», например, несколько кадастровых номеров участка, они записываются через запятую, в рамках одного поля и одной пары кавычек: дополнительные кавычки не ставятся. В остальных полях вариативность данных не предусмотрена."
		checkbox chk_rules_highpoly_table_2_2_5 "2.5. изменение и дублирование полей" checked:true offset:[20,0] tooltip:"2.5. Допустимо вносить изменения только в значение полей. Сами поля изменять, дублировать и некорректно записывать запрещено."
		checkbox chk_rules_highpoly_table_2_2_6 "2.6. заполнение всех полей" checked:true offset:[20,0] tooltip:"2.6. Все поля, кроме поля «other», должны быть заполнены."
		checkbox chk_rules_highpoly_table_2_2_7 "2.7. файл в кодировке UTF-8" checked:true offset:[20,0] tooltip:"2.7. Файл формируется и предоставляется в кодировке UTF-8."		
		checkbox chk_rules_highpoly_table_2_2_8 "2.8. поля в группе «features»" checked:true offset:[20,0] tooltip:"2.8. Каждое отдельное поле в группе «features» состоит из двух частей: имени поля и его описания. Каждая часть поля помещается в кавычки и отделяется друг от друга двоеточием, (см. приложение 7, рис. 7.1)"		
		
		checkbox chk_rules_highpoly_table_2_3 "" checked:true offset:[0,10] across:2 align:#left tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_3 "3. Требования к сцене и объектам геометрии" offset:[0,10] align:#right style_sunkenedge:false tooltip:"3. Требования к сцене и объектам геометрии"
		checkbox chk_rules_highpoly_table_2_3_1 "3.1. мусор внутри FBX" checked:true offset:[20,0] tooltip:"3.1. На сцене внутри FBX с геометрией ОКС или благоустройства не должно быть лишних объектов, не относящихся к сдаваемой модели (прим, камеры, пустые объекты, пустая геометрия, подземные и внутренние коммуникации, объекты геометрии, не относящиеся к проекту АГР, такие как, например, персонажи, автомобили, животные и т.д.)."
		checkbox chk_rules_highpoly_table_2_3_2 "3.2. все модели в слое 0 (default)" checked:true offset:[20,0] tooltip:"3.2. Все объекты в сцене должны быть расположены в едином слое (коллекции), создаваемом по умолчанию."
		checkbox chk_rules_highpoly_table_2_3_3 "3.3. нет других слоёв" checked:true offset:[20,0] tooltip:"3.3. На сцене не должно быть боле?? одного слоя (коллекции)"
		checkbox chk_rules_highpoly_table_2_3_4 "3.4. оптимальное количество треугольников" checked:true offset:[20,0] tooltip:"3.4. Для описания силуэта (формы) объекта использовать оптимальное количество треугольных полигонов, кроме случаев, необходимых для оптимальной UV-развертки."
		checkbox chk_rules_highpoly_table_2_3_5 "3.5. светопрозрачные конструкции отдельно" checked:true offset:[20,0] tooltip:"3.5. Светопрозрачные конструкции должны быть выполнены отдельным от ОКС, которому принадлежат, объектом геометрии."
		checkbox chk_rules_highpoly_table_2_3_6 "3.6. ОКС и его Glass в одном FBX" checked:true offset:[20,0] tooltip:"3.6. Объекты геометрии и объекты геометрии со свойством прозрачности, принадлежащие единой модели, должны компоноваться в общий файл формата FBX."
		checkbox chk_rules_highpoly_table_2_3_7 "3.7. бл-во, эл-ты, раст-ть в 1 модели и в FBX" checked:true offset:[20,0] tooltip:"3.7. Благоустройство, элементы благоустройства и элементы растительности должны быть объединены в один объект геометрии и сформированы в отдельный файл формата FBX."
		checkbox chk_rules_highpoly_table_2_3_8 "3.8. полигоны по периметру ОКС выдавлены" checked:true offset:[20,0] tooltip:"3.8. Полигоны по периметру объекта геометрии ОКС должны быть выдавлены вниз на глубину, достаточную для погружения этих полигонов внутрь геометрии благоустройства."		
		checkbox chk_rules_highpoly_table_2_3_9 "3.9. края выдавлены вниз >1м, заглушки-цвет" checked:true offset:[20,0] tooltip:"3.9. По периметру объекта геометрии благоустройства полигоны должны быть выдавлены вниз на расстояние не менее 1 метра с использованием текстурных заглушек обобщенного цвета полигонов, из которых происходило выдавливание (см. приложение 5)."
		checkbox chk_rules_highpoly_table_2_3_10 "3.10. иерархические связи и группы" checked:true offset:[20,0] tooltip:"3.10. Объекты геометрии не должны иметь иерархических связей между собой, групп и т.д."
		checkbox chk_rules_highpoly_table_2_3_11 "3.11. единая геометрия эл-ов окон и фасадов" checked:true offset:[20,0] tooltip:"3.11. Рекомендуется использование единой геометрии для элементов окон (за исключением объектов со свойством прозрачности) и фасадов."
		checkbox chk_rules_highpoly_table_2_3_12 "3.12. предельное кол-во тр-ков 2000 000 FBX" checked:true offset:[20,0] tooltip:"3.12. Предельное количество треугольных полигонов всех объектов геометрии модели, не включая объекты геометрии коллизии, в рамках одного файла формата FBX — 2 000 000."
		checkbox chk_rules_highpoly_table_2_3_13 "3.13. задвойки, нулёвки, анимация" checked:true offset:[20,0] tooltip:"3.13. Объекты геометрии не должны содержать:\n• дубликатов и самопересечений ребер и полигонов (погрешность расстояния 0,002 м);\n• изолированных вершин, ребер и полигонов;\n• отрезков нулевой длины;\n• ключей анимации;\n• дополнительных модификаторов."
		checkbox chk_rules_highpoly_table_2_3_14 "3.14. интерьеры за окнами" checked:true offset:[20,0] tooltip:"3.14. Интерьеры, согласно проектной документации, должны быть заменены сплошными стенами и перекрытиями. Сложные по форме, а также, невидимые зрителю снаружи здания внутренние стены должны быть удалены."
		checkbox chk_rules_highpoly_table_2_3_15 "3.15. отступ сонаправленных полигонов" checked:true offset:[20,0] tooltip:"3.15. Для упразднения дефектов отображения со-направленных полигонов, перекрывающих друг друга, расстояние между ними должно составлять не менее 5 мм и не более 2 см."
		checkbox chk_rules_highpoly_table_2_3_16 "3.16. группы сглаживания" checked:true offset:[20,0] tooltip:"3.16. Группы сглаживания определяет проектировщик согласно проектному решению и расставляет их только по полигонам (см. приложение 4)."
		checkbox chk_rules_highpoly_table_2_3_17 "3.17. визуальные дефекты" checked:true offset:[20,0] tooltip:"3.17. В моделях не должно быть визуальных дефектов: при осмотре объекта, в условии ограничений, наложенных коллизией, в поле зрения наблюдателя не должно быть физически отсутствующих полигонов, за исключением зон, непросматривающихся ни под каким углом (в том числе через объекты со свойством прозрачности)."
		checkbox chk_rules_highpoly_table_2_3_18 "3.18. растительность: ствол, пл-сти с альфой" checked:true offset:[20,0] tooltip:"3.18. Растительность должна быть выполнена реалистично, стилизации недопустимы. Рекомендуется, при наличии, моделировать ствол, основные крупные ветви, а мелкие веточки с листьями воссоздавать плоскостями с текстурной картой с альфа-каналом."
		checkbox chk_rules_highpoly_table_2_3_19 "3.19. триангуляция объектов" checked:true offset:[20,0] tooltip:"3.19. Объекты геометрии должны быть триангулированы перед экспортом в файл формата FBX."
		checkbox chk_rules_highpoly_table_2_3_20 "3.20. нормали объектов наружу" checked:true offset:[20,0] tooltip:"3.20. Нормали объектов, видимых с условной точки наблюдения, должны быть направлены в сторону наблюдателя."
		checkbox chk_rules_highpoly_table_2_3_21 "3.21. трансформации модели сброшены" checked:true offset:[20,0] tooltip:"3.21. Все трансформации модели должны быть сброшены (применены)."
		checkbox chk_rules_highpoly_table_2_3_22 "3.22. закрытые дворики под открытым небом" checked:true offset:[20,0] tooltip:"3.22. Закрытые дворики под открытым небом, ниши и прочие пограничные пространства являются частью благоустройства, в связи с чем все их элементы (урны, столики и стулья уличного кафе, клумбы и пр.), предусмотренные проектом, сохраняются. (см. Приложение 8)"

		checkbox chk_rules_highpoly_table_2_4 "" checked:true offset:[0,10] across:2 align:#left tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_4 "4. Требования к материалам" offset:[0,10] align:#right style_sunkenedge:false tooltip:"4. Требования к материалам"
		checkbox chk_rules_highpoly_table_2_4_1 "4.1. стандартные материалы" checked:true offset:[20,0] tooltip:"4.1. Материалы не должны быть созданы при помощи сторонних движков рендера (VRay, Octane, Corona, Arnold и прочего ПО для визуализации изображений высокого качества), а также не допустимы к использованию сложные, нестандартные, не базовые шейдеры, такие как Physical Material, Blend."
		checkbox chk_rules_highpoly_table_2_4_2 "4.2. материал полупрозрачных деталей" checked:true offset:[20,0] tooltip:"4.2. Материал полупрозрачных деталей не должен содержать в себе текстурных карт."
		checkbox chk_rules_highpoly_table_2_4_3 "4.3. нет путей в матах к текстурным картам" checked:true offset:[20,0] tooltip:"4.3. Все пути к текстурным картам в материалах должны быть удалены."
		checkbox chk_rules_highpoly_table_2_4_4 "4.4. объекты геометрии Main >100 UDIM-карт" checked:true offset:[20,0] tooltip:"4.4. Если к объектам геометрии Main требуется применение более 100 UDIM-карт, то назначается дополнительный(-ые) материал(-ы) (до семи штук). Каждый материал должен иметь свой SlotNumber начиная с единицы и далее строго по порядку с шагом равным единице."
		checkbox chk_rules_highpoly_table_2_4_5 "4.5. группировка мат-ов Glass и их объектов" checked:true offset:[20,0] tooltip:"4.5. Недопустимо:\n• группировать материалы *_MainGlass и *_Main или *_GroundGlass и *_Ground в рамках одного родительского материала;\n• разделять материалы Main по слотам при количестве текстурных карт менее 100."
		checkbox chk_rules_highpoly_table_2_4_6 "4.6. требования к светопрозрачным объектам" checked:true offset:[20,0] tooltip:"4.6. Требования к светопрозрачным объектам геометрии описаны в п.8 данной таблицы."
		checkbox chk_rules_highpoly_table_2_4_7 "4.7. максимальное кол-во мат-ов на 1 объект" checked:true offset:[20,0] tooltip:"4.7. Максимальное количество материалов на один объект геометрии - 7 шт."

		checkbox chk_rules_highpoly_table_2_5 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_5 "5. Требования к текстурам, UV-развертке" offset:[0,10] align:#right style_sunkenedge:false tooltip:"5. Требования к текстурным картам (типы текстур), UV-развертке, текстурным заглушкам"
		checkbox chk_rules_highpoly_table_2_5_1 "5.1. требования к текстурам" checked:true offset:[20,0] tooltip:"5.1. Требования к текстурным картам (типы текстур)"
		checkbox chk_rules_highpoly_table_2_5_1_1 "5.1.1. PNG отдельно от FBX, не embedded" checked:true offset:[20,0] tooltip:"5.1.1. Текстурные карты не должны быть интегрированы в файл формата FBX и должны предоставляться в формате PNG отдельно от файла формата FBX."
		checkbox chk_rules_highpoly_table_2_5_1_2 "5.1.2. допустимые размеры текстур" checked:true offset:[20,0] tooltip:"5.1.2. Допустимы следующие размеры текстурных карт: 256x256 (применительно к текстурным заглушкам), 2048x2048, 4096x4096 пикселей."
		checkbox chk_rules_highpoly_table_2_5_1_3 "5.1.3. разные размеры текстур в наборе" checked:true offset:[20,0] tooltip:"5.1.3. В рамках одного текстурного набора не разрешается использование нескольких размеров текстурных карт, исключение - текстурные заглушки."
		checkbox chk_rules_highpoly_table_2_5_1_4 "5.1.4. типы текстурных карт" checked:true offset:[20,0] tooltip:"5.1.4. Типы текстурных карт:"
		checkbox chk_rules_highpoly_table_2_5_1_4_1 "5.1.4.1. обязательный набор" checked:true offset:[20,0] tooltip:"5.1.4.1. Обязательный набор: карта диффузного цвета, карта ERM, карта нормалей."
		checkbox chk_rules_highpoly_table_2_5_1_4_2 "5.1.4.2. необязательный набор" checked:true offset:[20,0] tooltip:"5.1.4.2. Необязательно: карта прозрачности, закодированная в Альфа-канал текстурной карты диффузного цвета."
		checkbox chk_rules_highpoly_table_2_5_1_5 "5.1.5. отступ в UDIM >32 пикселей" checked:true offset:[20,0] tooltip:"5.1.5. Если у островов, расположенных в рамке одной UDIM-плитки, должны быть уникальные текстуры, то они должны иметь текстурный отступ, то есть заходить за края UV-острова, для которого создается текстура, не менее чем на 32 пикселей (рекомендован отступ до бесконечности). UV-отступ не должен пересекаться с другими UV-отступами и островами."
		checkbox chk_rules_highpoly_table_2_5_1_6 "5.1.6. в ERM нет альфа канала" checked:true offset:[20,0] tooltip:"5.1.6. Текстурные карты ERM и нормалей должны предоставляться строго без Альфа-канала."
		checkbox chk_rules_highpoly_table_2_5_1_7 "5.1.7. в Normal правильные цвета" checked:true offset:[20,0] tooltip:"5.1.7. Текстурные карты Normal должны быть подготовле??ы в соответствии с API DirectX."
		checkbox chk_rules_highpoly_table_2_5_1_8 "5.1.8. нет неиспользуемых текстур" checked:true offset:[20,0] tooltip:"5.1.8. Каждая текстурная карта архива должна проецироваться хотя бы на один полигон геометрии (неиспользуемых текстурных карт быть не должно)."
	
		checkbox chk_rules_highpoly_table_2_5_2 "5.2. требования к UV-развертке" checked:true offset:[20,0] tooltip:"5.2. Требования к UV-развертке."
		checkbox chk_rules_highpoly_table_2_5_2_1 "5.2.1 для *_Main и *_Ground:" checked:true offset:[20,0] tooltip:"5.2.1. Для объектов геометрии фасадов *_Main и благоустройства *_Ground:"
		checkbox chk_rules_highpoly_table_2_5_2_1_1 "5.2.1.1. UV-развертка выполнена по UDIM" checked:true offset:[20,0] tooltip:"5.2.1.1. UV-развертка выполняется исключительно по технологии UDIM."
		checkbox chk_rules_highpoly_table_2_5_2_1_2 "5.2.1.2. разделение геометрии на UDIM" checked:true offset:[20,0] tooltip:"5.2.1.2. Геометрию, выходящую по размерам за пределы одной UDIM-плитки, при условии соответствия требованиям к плотности пикселей, необходимо разделять, а повторяющиеся или подобные острова развертки необходимо размещать методом наложения."
		checkbox chk_rules_highpoly_table_2_5_2_1_3 "5.2.1.3. заполнение UDIM-плиток" checked:true offset:[20,0] tooltip:"5.2.1.3. UDIM-плитки заполняются, начиная с 1001, строго последовательно, без пропусков в нумерационном ряду UDIM по схеме 10 на 10 (см. приложение 1, Рисунок 1.2)."
		checkbox chk_rules_highpoly_table_2_5_2_1_4 "5.2.1.4. единственный канал UV-развертки" checked:true offset:[20,0] tooltip:"5.2.1.4. UV-развертка геометрии по технологии UDIM выполняется в единственном экземпляре и только на один канал."
		checkbox chk_rules_highpoly_table_2_5_2_1_5 "5.2.1.5. острова UV-развертки не зеркальные" checked:true offset:[20,0] tooltip:"5.2.1.5. Острова UV-развертки по технологии UDIM не должны быть отражены зеркально."
		checkbox chk_rules_highpoly_table_2_5_2_1_6 "5.2.1.6. нет заступов в UV-развертке за UDIM" checked:true offset:[20,0] tooltip:"5.2.1.6. При UV-развертке по технологии UDIM недопустимо выносить UV-острова за границы UDIM-плиток (UV-острова не должны принадлежать сразу нескольким UDIM-плиткам)."
		checkbox chk_rules_highpoly_table_2_5_2_1_7 "5.2.1.7. отступы UV-развертки внутри UDIM" checked:true offset:[20,0] tooltip:"5.2.1.7. Острова UV-развертки внутри UDIM-плитки необходимо размещать с соблюдением отступа от границ UDIM-плитки;"
		checkbox chk_rules_highpoly_table_2_5_2_1_8 "5.2.1.8. образование видимых несостыковок" checked:true offset:[20,0] tooltip:"5.2.1.8. При выполнении UV-развертки по технологии UDIM, избегать образования видимых швов, сдвигов и несостыковок рисунка между текстурными картами на итоговой визуализации."
		checkbox chk_rules_highpoly_table_2_5_2_2 "5.2.2. для *_MainGlass и *_GroundGlass:" checked:true offset:[20,0] tooltip:"5.2.2. Для объектов геометрии со свойством прозрачности *_MainGlass, *_GroundGlass:"
		checkbox chk_rules_highpoly_table_2_5_2_2_1 "5.2.2.1. вся UV-развертка внутри 1001 UDIM" checked:true offset:[20,0] tooltip:"5.2.2.1. UV-развертку всей геометрии элементов со свойством прозрачности необходимо производить в пределах 1001 UDIM-плитки с максимальным заполнением и соблюдением отступа от границ UDIM-плитки. Допускается наложение UV-островов друг на друга (см. приложение 6, рис. 6.1);"
		checkbox chk_rules_highpoly_table_2_5_2_2_2 "5.2.2.2. выдерживание масштаба UV-островов" checked:true offset:[20,0] tooltip:"5.2.2.2. необходимо выдерживать масштаб UV-островов геометрии элементов со свойством прозрачности;"
		checkbox chk_rules_highpoly_table_2_5_2_2_3 "5.2.2.3. сохранение ориентации UV-островов" checked:true offset:[20,0] tooltip:"5.2.2.3. необходимо сохранять ориентацию UV-островов среди элементов со свойством прозрачности исходя из того, что верх оконных стекол должен быть повернут в сторону координат U:0 V:1;"
		checkbox chk_rules_highpoly_table_2_5_2_2_4 "5.2.2.4. нет деформации UV-островов" checked:true offset:[20,0] tooltip:"5.2.2.4. деформация UV-островов недопустима;"
		checkbox chk_rules_highpoly_table_2_5_2_2_5 "5.2.2.5. совместная развертка стекол окон" checked:true offset:[20,0] tooltip:"5.2.2.5. если окна относятся к единой логической конструкции (прим, эркер) или расположены настолько близко друг к ДРУГУ, что подразумевают единую оконную композицию конкретной комнаты, то их рекомендуется разворачивать совместно, с сохранением пропорционального расстояния между ними (см. приложение 6, рис. 6.2);"
		checkbox chk_rules_highpoly_table_2_5_2_2_6 "5.2.2.6. нет UV-развертки у UCX коллизий" checked:true offset:[20,0] tooltip:"5.2.2.6. UV-развертка не применяется к объектам геометрии коллизии."

		checkbox chk_rules_highpoly_table_2_5_3 "5.3. требования к текстурным заглушкам" checked:true offset:[20,0] tooltip:"5.3. Требования к текстурным заглушкам."
		checkbox chk_rules_highpoly_table_2_5_3_1 "5.3.1. разрешение 256x256 пикселей" checked:true offset:[20,0] tooltip:"5.3.1. Разрешение текстурной заглушки должно быть равно 256x256 пикселей."
		checkbox chk_rules_highpoly_table_2_5_3_2 "5.3.2. использование совместно в наборе" checked:true offset:[20,0] tooltip:"5.3.2. В рамках одной UDIM-развертки допускается использовать в текстурном наборе заглушки совместно с текстурами обычного размера."
		checkbox chk_rules_highpoly_table_2_5_3_3 "5.3.3. заглушки без альфа­канала" checked:true offset:[20,0] tooltip:"5.3.3. Текстурные заглушки должны быть строго без альфа­канала."
		checkbox chk_rules_highpoly_table_2_5_3_4 "5.3.4. заглушки заполнены одним цветом" checked:true offset:[20,0] tooltip:"5.3.4. Текстурные заглушки должны быть заполнены единственным цветом, являющимся средним значением цветов заменяемой текстуры."
		checkbox chk_rules_highpoly_table_2_5_3_5 "5.3.5. использование заглушек" checked:true offset:[20,0] tooltip:"5.3.5. Текстурные заглушки допустимо использовать только на поверхностях, не имеющих четко выраженных фактур или в случае, если фактура воссоздана геометрией, например, на гладких поверхностях, хромированных деталях, а также текстурные заглушки запрещено использовать на мраморных, кирпичных, плиточных и пр. текстурах."

		checkbox chk_rules_highpoly_table_2_6 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_6 "6. Требования к плотности текселей" offset:[0,10] align:#right style_sunkenedge:false tooltip:"6. Требования к Плотности текстуры (плотности текселей)"
		checkbox chk_rules_highpoly_table_2_6_1 "6.1. границы плотности текселей: 512..1706" checked:true offset:[20,0] tooltip:"6.1. Нижняя и верхняя границы плотности пикселя на метр 512­1706 высчитывается по формуле: Плотность текстуры = длина стороны текстуры в пикселях (4096 или 2048) / длину или ширину полигона в метрах в мировой координатной системе. Например:"
		checkbox chk_rules_highpoly_table_2_6_1_1 "6.1.1 границы для текстуры 4096" checked:true offset:[20,0] tooltip:"6.1.1. Для текстуры 4096 множество квадратов со сторонами от 7,8 м до 2,5 м будут вписываться в диапазон плотности от 525 рх/т до 1638 рх/т соответственно."
		checkbox chk_rules_highpoly_table_2_6_1_2 "6.1.2 границы для текстуры 2048" checked:true offset:[20,0] tooltip:"6.1.2. Для текстуры 2048 множество квадратов со сторонами от 3,9 м до 1,3 м будут вписываться в диапазон плотности от 525 рх/т до 1575 рх/т соответственно."
		checkbox chk_rules_highpoly_table_2_6_2 "6.2. плотность с альфа каналом" checked:true offset:[20,0] tooltip:"6.2. Для текстурных карт, использующих Альфа-канал, рекомендуется большая плотность из представленного диапазона."
		checkbox chk_rules_highpoly_table_2_6_3 "6.3. требование к плотности для заглушек" checked:true offset:[20,0] tooltip:"6.3. В случае, когда весь (это важно) текстурный набор конкретной UDIM-плитки исполнен текстурными заглушками 256*256 рх требования плотности текстур к этой UDIM-плитке не предъявляются, в обратном случае (при совместном использовании заглушек и обычных текстур) плотность пикселя необходимо соблюсти."
		
		checkbox chk_rules_highpoly_table_2_7 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_7 "7. Требования к запеканию объектов" offset:[0,10] align:#right style_sunkenedge:false tooltip:"7. Требования к запеканию объектов геометрии в текстуру"
		checkbox chk_rules_highpoly_table_2_7_1 "7.1. запекание мелких элементов" checked:true offset:[20,0] tooltip:"7.1. Декоративные элементы, мелкие детали, вдавленные или выступающие за основную геометрию здания до 5 см, запекаются в текстуру. Исключение: бордюрные выступы."

		checkbox chk_rules_highpoly_table_2_8 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_8 "8. Требования к отображению стекла" offset:[0,10] align:#right style_sunkenedge:false tooltip:"8. Требования к отображению объектов геометрии стекла/светопрозрачных конструкций. Отображение стекла является обязательным при его наличии и должно соответствовать требованиям:"
		checkbox chk_rules_highpoly_table_2_8_1 "8.1. единый объект со спец. материалом" checked:true offset:[20,0] tooltip:"8.1. все элементы со свойством прозрачности одной модели должны быть объединены в единый объект геометрии с назначением специального материала согласно пунктам (см. п.3.6) и развертки, но не текстурные карты."
		checkbox chk_rules_highpoly_table_2_8_2 "8.2. с разными свойствами - разные маты" checked:true offset:[20,0] tooltip:"8.2. Светопрозрачные конструкции с разными свойствами должны иметь разные материалы, но не более 7 штук."
		checkbox chk_rules_highpoly_table_2_8_3 "8.3. для ограждений и окон отдельные маты" checked:true offset:[20,0] tooltip:"8.3. На элементы со свойством прозрачности окон, балконных дверей и витрин необходимо назначать отдельный материал, даже если он визуально не отличается от остальных подобных элементов здания, например, ограждений;"
		checkbox chk_rules_highpoly_table_2_8_4 "8.4. несквозные интерьеры - окна без толщин" checked:true offset:[20,0] tooltip:"8.4. Светопрозрачные конструкции окон, ведущих в помещение с замкнутым пространством, не должны иметь толщины."	

		checkbox chk_rules_highpoly_table_2_9 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_9 "9. Требования к точке отсчета и повороту" offset:[0,10] align:#right style_sunkenedge:false tooltip:"9. Требования к точке отсчета и плановому повороту"
		checkbox chk_rules_highpoly_table_2_9_1 "9.1. углы поворота соответствуют планам" checked:true offset:[20,0] tooltip:"9.1. Углы поворота всех объектов геометрии должны соответствовать углам поворота в плане проектного решения."
		checkbox chk_rules_highpoly_table_2_9_2 "9.2. есть общая точка в GEOJSON" checked:true offset:[20,0] tooltip:"9.2. Общее содержимое отдельного файла в формате FBX имеет свою точку отсчета и собственное описание в соответствующем ему файле формата GEOJSON."
		checkbox chk_rules_highpoly_table_2_9_3 "9.3. pivot в нуле координат у всех объектов" checked:true offset:[20,0] tooltip:"9.3. Точка отсчета объекта относительно мировых координат редактора должна быть расположена строго в нуле по всем осям."
		checkbox chk_rules_highpoly_table_2_9_4 "9.4. pivot ОКСов и бл-ва в геом.центре" checked:true offset:[20,0] tooltip:"9.4. Точка отсчета ОКС или благоустройства должна быть расположена в примерном геометрическом центре модели по осям «X» и «У», а по оси «Z» должна соответствовать нулевой отметке проекта."
		checkbox chk_rules_highpoly_table_2_9_5 "9.5. одинаковый pivot для всех внутри FBX" checked:true offset:[20,0] tooltip:"9.5. Точки отсчета (pivot), всех моделей внутри файла формата FBX, должны иметь одинаковые координаты, т.е. относительно модели стекол ОКС или благоустройства точка отсчета расположена в тех же координатах, что и сам ОКС или благоустройство соответственно."
		checkbox chk_rules_highpoly_table_2_9_6 "9.6. pivot для разделения на корпуса" checked:true offset:[20,0] tooltip:"9.6. В случае разделения строения по корпусам, точка отсчета по оси «Z» соответствует нулевой отметке проекта, если часть строения пересекается с выше озвученной отметкой, в обратном случае точке пересечения разделенных частей строения."
		checkbox chk_rules_highpoly_table_2_9_7 "9.7. произвольные точки отсчета коллизий" checked:true offset:[20,0] tooltip:"9.7. Расположение точек отсчета коллизии не имеет значения."
		
		checkbox chk_rules_highpoly_table_2_10"" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_10 "10. Требования к наименованиям" offset:[0,10] align:#right style_sunkenedge:false tooltip:"10. Требования к наименованиям файлов, геометрий, текстур и материалов"
		checkbox chk_rules_highpoly_table_2_10_1 "10.1. длина наименования < 254 символа" checked:true offset:[20,0] tooltip:"10.1. Длина наименования, включая адрес и все суффиксы, постфиксы и префиксы, не должна превышать значения в 254 символа."
		checkbox chk_rules_highpoly_table_2_10_2 "10.2. латиница и цифры в именах" checked:true offset:[20,0] tooltip:"10.2. Наименования должны задаваться исключительно латиницей (английским алфавитом), цифрами и символом нижнего подчеркивания («_»). Другие спецсимволы, включая пробел, недопустимы и заменяются символом нижнего подчеркивания («_»). Каждое новое слово в наименовании, в том числе в пределах адресообразующего элемента, начинается с заглавной буквы."
		checkbox chk_rules_highpoly_table_2_10_3 "10.3. разделение элементов «_»" checked:true offset:[20,0] tooltip:"10.3. Каждый адресообразующий элемент, суффикс\префикс, а также числовые и буквенные знаки отделяются друг от друга символом нижнего подчеркивания («_»)."
		checkbox chk_rules_highpoly_table_2_10_4 "10.4. порядок наименования" checked:true offset:[20,0] tooltip:"10.4. Порядок наименования."		
		checkbox chk_rules_highpoly_table_2_10_4_1 "10.4.1. именование файлов FBX" checked:true offset:[20,0] tooltip:"10.4.1. Файл формата FBX именуется согласно схемам (файлы GEOJSON и ZIP архивы полностью повторяют маски наименования FBX для ОКС и благоустройства):\n- для ОКС SM_Address SM_ProezdNansena_Uch_8.fbx\n- для благоустройства SM_Address_Ground SM_ProezdNansena_Uch_8_Ground.geojson\n- для источников освещения фасадов здания SM_Address_Light SM_ProezdNansena_Uch_8_Light.fbx\n- для источников освещения благоустройства SM_Address_Ground_Light SM_ProezdNansena_Uch_8_Ground_Light.fbx"
		checkbox chk_rules_highpoly_table_2_10_4_2 "10.4.2. именование объектов геометрии" checked:true offset:[20,0] tooltip:"10.4.2. Объекты геометрии именуются согласно схемам:\n- для благоустройства SM_Address_Ground SM_ProezdNansena_Uch_8_Ground\n- для светопрозрачных конструкций благоустройства SM_Address_GroundGlass SM_ProezdNansena_Uch_8_GroundGlass\n- для строения SM_Address_Main SM_ProezdNansena_Uch_8_Main\n- для светопрозрачных конструкций строения (если таковые присутствуют) SM_Address_MainGlass SM_ProezdNansena_Uch_8_MainGlass\n- для коллизии строений UCX_SM_Address_Main_Number, Number - порядковый номер элемента коллизии, число от 001 до 999. UCX_SM_ProezdNansena_Uch_8_Main_001\n- для коллизии благоустройства UCX_SM_Address_Ground_Number, Number - порядковый номер элемента коллизии, число от 001 до 999. UCX_SM_ProezdNansena_Uch_8_Ground_001"
		checkbox chk_rules_highpoly_table_2_10_4_3 "10.4.3. именование текстур " checked:true offset:[20,0] tooltip:"10.4.3. Текстуры именуются согласно схемам:\nнаименование файла PNG должно соответствовать (см. приложение 2)\n- для строений T_Address_TypeTexture_SlotNumber.NomerUDIM T_ProezdNansena_Uch_8_Diffuse_1.1001.png\n- для благоустройства T_Address_Ground_TypeTexture_SlotNumber.NomerUDIM T_ProezdNansena_Uch_8_Ground_Diffuse_1.1001.png"
		checkbox chk_rules_highpoly_table_2_10_4_4 "10.4.4. именование материалов файла FBX" checked:true offset:[20,0] tooltip:"10.4.4. Материалы в рамках файла формата FBX именуются гласно схемам:\n- для материалов благоустройства M_Address_Ground_SlotNumber M_ProezdNansena_Uch_8_Ground_1\n- для светопрозрачных материалов благоустройства M_Address_GroundGlass_SlotNumber M_ProezdNansena_Uch_8_GroundGlass_1\n- для непрозрачных материалов строений M_Address_Main_SlotNumber M_ProezdNansena_Uch_8_Main_1\n- для светопрозрачных материалов строений M_Address_MainGlass_SlotNumber M_ProezdNansena_Uch_8_MainGlass_1"
		checkbox chk_rules_highpoly_table_2_10_4_5 "10.4.5. именование источников света ОКС" checked:true offset:[20,0] tooltip:"10.4.5. Наименования источников освещения фасадов ОКС должны соответствовать схемам:\n- для всенаправленных точечных источников Address_Omni_Number, Number - порядковый номер источника освещения данного типа, число от 001 до 050, ProezdNansena_Uch_8_Omni_001\n- для направленных прожекторов с коническим потоком лучей Address_Spot_Number, Number - порядковый номер источника освещения данного типа, число от 001 до 050, ProezdNansena_Uch_8_Spot_001\n- для корневого элемента источников освещения Address_Root ProezdN ansena_Uch_8_Root"
		checkbox chk_rules_highpoly_table_2_10_4_6 "10.4.6. именование источников света бл-ва" checked:true offset:[20,0] tooltip:"10.4.6. Наименования источников освещения благоустройства должны соответствовать схемам:\n- для всенаправленных точечных источников Address_Ground_Omni_Number, где Number - порядковый номер источника освещения данного типа, число от 001 до 050, ProezdNansena_Uch_8_Ground_Omni_001\n- для направленных прожекторов с коническим потоком лучей Address_Ground_Spot_Number, Number - порядковый номер источника освещения данного типа, число от 001 до 050, ProezdNansena_Uch_8_Ground_Spot_001\n- для корневого элемента источников освещения Address_Ground_Root ProezdNansena_Uch_8_Ground_Root"		

		checkbox chk_rules_highpoly_table_2_11 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_11 "11. Требования к написанию суффиксов" offset:[0,10] align:#right style_sunkenedge:false tooltip:"11. Требования к написанию суффиксов	в наименованиях"
		checkbox chk_rules_highpoly_table_2_11_1 "11.1. применение суффиксов в именованиях" checked:true offset:[20,0] tooltip:"11.1. Суффиксы применяются к наименованиям файлов, объектов геометрии, материалам и текстур с целью определения/построения иерархии в обязательном порядке в наименовании обозначают принадлежность к:\nSM_ объекту геометрии или модели, файлам формата FBX, ZIP, GEOJSON.\nT_ текстурам\nM_ материалу\n_SlotNumber имеет числовой вид от 1 до 7 и показывает информацию о порядковом номере материала, который задал пользователь, применяется к материалам и текстурам, служит для автоматического поиска пар: материал и текстурный набор\n_Main объекту геометрии или материалу ОКС, кроме светопрозрачных конструкций\n_MainGlass объекту геометрии или материалу светопрозрачных конструкций или элементов ОКС\n_Ground объекту геометрии или материалу элементов благоустройства\n_GroundGlass объекту геометрии или материалу светопрозрачных конструкций или элементов благоустройства\nNumberUDIM текстурам, имеет численный вид и показывает информацию о номере UV-плитки, для которой выполнена текстура\nUCX_ объекту геометрии коллизии, выполненной объектом типа «Mesh» (далее «редактируемый каркас»)\n_Omni всенаправленным точечным источникам освещения\n_Spot направленным	источникам освещения типа «прожектор»\n_Root корневому	элементу всех источников освещения\n_Light Файлу формата FBX источников освещения\n_TypeTexture_ суффикс, дающий информацию о типе текстуры, каждое слово в нем начинается с прописного символа и продолжается строчными, кроме аббревиатур, применяется только к текстурам\nДопустимые суффиксы и их написание:\nDiffuse цветовая карта\nERM Е - карта светимости, R - карта шероховатости, М - карта металличности\nNormal карта нормалей"

		checkbox chk_rules_highpoly_table_2_12 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_12 "12. Требования к сквозным отверстиям" offset:[0,10] align:#right style_sunkenedge:false tooltip:"12. Требования к элементам, содержащим сквозные отверстия или сложные вырезы"
		checkbox chk_rules_highpoly_table_2_12_1 "12.1. отверстия реализованы ч\б картой" checked:true offset:[20,0] tooltip:"12.1. Отверстия или вырезы необходимо реализовать черно­белой текстурной картой в целочисленном диапазоне 0-255, где диапазоны от 0 до 127 - пустота/невидимая часть, а от 128 до 255 - заполненное/видимое пространство."
		checkbox chk_rules_highpoly_table_2_12_2 "12.2. карта отверстий в альфа-канале" checked:true offset:[20,0] tooltip:"12.2. Текстурную карту отверстий или вырезов необходимо запекать в альфа-канал текстурной карты диффузного цвета."
		checkbox chk_rules_highpoly_table_2_12_3 "12.3. полигоны продублированы на 0,002м" checked:true offset:[20,0] tooltip:"12.3. Полигоны, на которые назначена текстурная карта с прозрачностью, в том случае, если они просматриваются с обеих сторон, должны быть продублированы с равномерным для всех точек смещением в локальном направлении полигона на 0,002 метра и поворотом нормали в противоположную сторону."
		
		checkbox chk_rules_highpoly_table_2_13 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_13 "13. Требования к геометрии коллизии" offset:[0,10] align:#right style_sunkenedge:false tooltip:"13. Требования к геометрии коллизии"
		checkbox chk_rules_highpoly_table_2_13_1 "13.1. массив объектов convex, не concave" checked:true offset:[20,0] tooltip:"13.1. Геометрия коллизии - это массив объектов (см. приложение 7, рис.7.1), каждый из которых должен быть выпуклый, замкнутый, не содержать в себе отверстия (см. приложение 7, рис.7.2) и назван согласно вышеописанной маске (см. п/п 4 п.п. Зд, Зе)."
		checkbox chk_rules_highpoly_table_2_13_2 "13.2. для каждого ОКС и поверхности бл-ва" checked:true offset:[20,0] tooltip:"13.2. Геометрия коллизии строится исключительно для объектов геометрии благоустройства (наземные части: МАФ, элементы освещения и растительность в ней не учитываются) и исключительно для каждого ОКС."
		checkbox chk_rules_highpoly_table_2_13_3 "13.3. каждый файл FBX с коллизиями" checked:true offset:[20,0] tooltip:"13.3. Каждый файл формата FBX должен иметь свою геометрию коллизии, кроме файлов FBX с освещением."
		checkbox chk_rules_highpoly_table_2_13_4 "13.4. нет пересечений, зазор 0,01..0,02м" checked:true offset:[20,0] tooltip:"13.4. Обязательно строить геометрии коллизий так, чтобы они не пересекались между собой. Зазор между смежными геометриями коллизий рекомендуется делать 0,02 - 1 см."
		checkbox chk_rules_highpoly_table_2_13_5 "13.5. массив повторяет очертания геометрии" checked:true offset:[20,0] tooltip:"13.5. Массив коллизий строений должен повторять очертания одноименной геометрии и их светопрозрачных конструкций (кроме заборов), и массив коллизий геометрии благоустройства также соответствует геометрии благоустройства с их светопрозрачными конструкциями, с соблюдением иных требований данного ТЗ."
		checkbox chk_rules_highpoly_table_2_13_6 "13.6. допуск в отступах от формы объекта" checked:true offset:[20,0] tooltip:"13.6. Геометрия коллизии должна точно повторять форму объекта геометрии, которому она принадлежит, допуск в отступах от формы объекта геометрии для геометрии коллизии:"		
		checkbox chk_rules_highpoly_table_2_13_6_1 "13.6.1. для бл-ва, по периметру <0,1м" checked:true offset:[20,0] tooltip:"13.6.1. благоустройства, особенно по периметру - 10 см;"
		checkbox chk_rules_highpoly_table_2_13_6_2 "13.6.2. ОКС на нижних этажах <0,3м" checked:true offset:[20,0] tooltip:"13.6.2. ОКС на нижних этажах, куда, без применения спецсредств, может подойти гипотетический пешеход - 30 см. Чаще всего это первые этажи, стилобаты или вторые этажи, к которым прилегают мосты и площадки;"
		checkbox chk_rules_highpoly_table_2_13_6_3 "13.6.3. остальной геометрии ОКС <1м" checked:true offset:[20,0] tooltip:"13.6.3. остальной геометрии ОКС - 1м."
		checkbox chk_rules_highpoly_table_2_13_7 "13.7. коллизии без материалов" checked:true offset:[20,0] tooltip:"13.7. Геометрия коллизии не должна содержать слоты материалов."
		checkbox chk_rules_highpoly_table_2_13_8 "13.8. особеености учета коллизий" checked:true offset:[20,0] tooltip:"13.8. Арки, внутренние дворы (колодцы), большие выступы на фасаде, объемные архитектурные элементы должны быть учтены и также входить в объем геометрии коллизии."
		checkbox chk_rules_highpoly_table_2_13_9 "13.9. лестницы формы усеченной пирамиды" checked:true offset:[20,0] tooltip:"13.9. Лестницы у входных групп должны иметь форму усеченной пирамиды."
		checkbox chk_rules_highpoly_table_2_13_10 "13.10. допустимое кол-во треугольников 5%" checked:true offset:[20,0] tooltip:"13.10. Количество треугольников, входящих в состав геометрии коллизии, рассчитывается по формуле: Количество треугольников модели х 0,05 = Допустимое максимальное число треугольников геометрии коллизии, за исключением моделей	менее 50000	треугольников. Например: Количество треугольников модели, очертания которой повторяет геометрии коллизии равно 1 243 374. То есть 1 243 374 х 0,05 = 62 168,7, допустимое максимальное число треугольников для геометрии коллизии 62 169 (любую дробную часть можно округлить до целых единиц в пользу увеличения числа)."
		checkbox chk_rules_highpoly_table_2_13_11 "13.11. для моделей c <50000, кол-во <15000" checked:true offset:[20,0] tooltip:"13.11. Для моделей, состоящих из менее, чем 50000 треугольных полигонов, применяется формула: Допустимое максимальное число треугольных полигонов геометрии коллизии = 15000 треугольных полигонов."
		checkbox chk_rules_highpoly_table_2_13_12 "13.12. ограничение сверх 2млн полигонов " checked:true offset:[20,0] tooltip:"13.12. Ограничение количества треугольных полигонов на модель не распространяется на геометрии коллизии. То есть, если количество треугольных полигонов модели составляет максимальные 2 млн треугольных полигонов, то количество треугольных полигонов геометрии коллизии может дополнительно составлять до 100000 треугольных полигонов."				
		checkbox chk_rules_highpoly_table_2_13_13 "13.13. масштабирование геометрии коллизии" checked:true offset:[20,0] tooltip:"13.13. Масштабирование геометрии коллизии должно быть идентично масштабированию модели, очертания которой он повторяет."				
		
		checkbox chk_rules_highpoly_table_2_14 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_14 "14. Требования к элементам освещения (ДЭО)" offset:[0,10] align:#right style_sunkenedge:false tooltip:"14. Требования к декоративным элементам освещения (ДЭО)"
		checkbox chk_rules_highpoly_table_2_14_1 "14.1. ERM для передачи эффекта свечения" checked:true offset:[20,0] tooltip:"14.1. Текстурная карта ERM используется для передачи эффекта свечения поверхности (неоновые вывески, светодиодные ленты, световые дорожки, поверхности источников освещения)"
		checkbox chk_rules_highpoly_table_2_14_2 "14.2. ERM не самостоятельный источник" checked:true offset:[20,0] tooltip:"14.2. Текстурная карта ERM не может быть использована в качестве самостоятельного источника освещения."
		checkbox chk_rules_highpoly_table_2_14_3 "14.3. Emissive сила свечения в ERM" checked:true offset:[20,0] tooltip:"14.3. Карта Emissive задает только силу свечения, так как она добавляется в красный канал карты ERM и хранить информацию в градациях серого."
		checkbox chk_rules_highpoly_table_2_14_4 "14.4. света нет, Emissive черный" checked:true offset:[20,0] tooltip:"14.4. В случае отсутствия светящихся поверхностей, карта Emissive задается черным цветом."
		checkbox chk_rules_highpoly_table_2_14_5 "14.5. Цвет ДЭО  в диффузе" checked:true offset:[20,0] tooltip:"14.5. Цвет ДЭО задается в тех же текстурных координатах, в текстурной карте диффузного цвета"		

		checkbox chk_rules_highpoly_table_2_15 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_15 "15.  Требования к архитектурному освещению" offset:[0,10] align:#right style_sunkenedge:false tooltip:"15. Требования к архитектурному освещению фасадов зданий	и благоустройства (световой дизайн)"
		checkbox chk_rules_highpoly_table_2_15_1 "15.1. файлы светового дизайна" checked:true offset:[20,0] tooltip:"1. Файлы для передачи светового дизайна формируются только в том случае, если проект подразумевает его наличие. Приоритетно добавление источников освещения в случае, когда лучи света влияют на визуальное отображение других объектов в сцене, через их подсветку или затенение:\n• декоративной точечной подсветки фасада здания;\n• элементов уличного освещения;\n• декоративных источников света."
		checkbox chk_rules_highpoly_table_2_15_2 "15.2. превышение лимита источников света" checked:true offset:[20,0] tooltip:"2. При превышении лимита источников освещения допускается использование источников освещения только на наиболее заметных участках модели."
		checkbox chk_rules_highpoly_table_2_15_3 "15.3. в FBX <50 источников освещения" checked:true offset:[20,0] tooltip:"3. Файл формата FBX с источниками освещения не должен содержать более 50 источников освещения."
		checkbox chk_rules_highpoly_table_2_15_4 "15.4. наличие моделей для источников" checked:true offset:[20,0] tooltip:"4. В случае наличия в проекте светового дизайна в рамках создаваемых трехмерных моделей ОКС или благоустройства необходимо отобразить внешний вид осветительного оборудования. Светящиеся элементы на таких объектах геометрии передаются с помощью карт ERM, а световой поток при помощи источников освещения, не входящих в состав вышеупомянутых трехмерных моделей."
		checkbox chk_rules_highpoly_table_2_15_5 "15.5. наличие файла FBX с источниками света" checked:true offset:[20,0] tooltip:"5. Источники освещения предоставляются в отдельном файле формата FBX версии 7.4 (FBX2014) бинарного типа для каждого проекта ОКС и каждого проекта благоустройства отдельно в составе соответствующего ZIP-архива."
		checkbox chk_rules_highpoly_table_2_15_6 "15.6. допустимые виды источников света" checked:true offset:[20,0] tooltip:"6. Источником освещения может быть только точечный всенаправленный или конический нацеленный прожектор."
		checkbox chk_rules_highpoly_table_2_15_7 "15.7. допустимые типы источников света" checked:true offset:[20,0] tooltip:"7. Используются только базовые источники освещения, не относящиеся к сторонним или продвинутым движкам рендера."
		checkbox chk_rules_highpoly_table_2_15_8 "15.8. допустимые параметры источников св." checked:true offset:[20,0] tooltip:"8. У источников освещения должны быть настроены только цвет света и его сила. Дальность распространения необходимо отключать."
		checkbox chk_rules_highpoly_table_2_15_9 "15.9. иерархия объектов источников света" checked:true offset:[20,0] tooltip:"9. Вся система источников освещения представляет собой иерархию объектов, где все источники освещения привязаны к корневому элементу, являющемуся вспомогательным пустым объектом."
		checkbox chk_rules_highpoly_table_2_15_10 "15.10. положение ист. и корневого объекта" checked:true offset:[20,0] tooltip:"10. Источники освещения должны быть расставлены и повернуты относительно освещаемого объекта так, чтобы верно передать концепцию светового рисунка, а их корневой элемент обязательно должен располагаться своей точкой отсчета строго в точке отсчета выше обозначенного объекта (согласно требованиям п/п 14 п.п. 3 в нулевых мировых координатах, как и сам объект)."
		checkbox chk_rules_highpoly_table_2_15_11 "15.11. рекомендация на кол-во ист. <10шт" checked:true offset:[20,0] tooltip:"11. Рекомендовано использовать не более 10 источников освещения на одну трехмерную модель ОКС или благоустройства."
	
		checkbox chk_rules_highpoly_table_3_All "" checked:true offset:[0,10] across:2 align:#left tooltip:"Check to check" 
		label lbl_rules_highpoly_table_3 "Таблица 3. Основные допущения, ограничения" offset:[0,10] align:#right style_sunkenedge:false tooltip:"Таблица 3. «Основные допущения и ограничения к трехмерным моделям»"
		checkbox chk_rules_highpoly_table_3_1 "1. размер модели с текстурами <500Mb" checked:true offset:[20,0] tooltip:"1. Размер модели.\nТребования по размеру модели одного здания/корпуса/благоустройства (Ground) совместно с невстроенными текстурами 500 МБ.\nПримечание: В состав указанных 500 МБ входит суммарный объем памяти, требуемый для хранения модели одного здания/корпуса/ благоустройства (геометрия объекта + объекты геометрии его светопрозрачных конструкций + геометрии его коллизий), а также всех текстурных карт."
		checkbox chk_rules_highpoly_table_3_2 "2. количество треугольников в FBX <2млн" checked:true offset:[20,0] tooltip:"2. Количество треугольных полигонов. Требование к количеству полигонов на всю геометрию в рамках одного файла FBX - до 2 млн. треугольных полигонов."
		checkbox chk_rules_highpoly_table_3_3 "3. количество материал??в <7" checked:true offset:[20,0] tooltip:"3. Количество материалов. Требование к количеству материалов на одну геометрию здания, стекла - не более 7 шт. на каждое."
		checkbox chk_rules_highpoly_table_3_4 "4. детализация моделей" checked:true offset:[20,0] tooltip:"4. Детализация моделей. Скрытые объекты должны быть удалены из проекта (коммуникации, инженерные слои, внутрикомнатные двери и т.п.). Объекты, которые не относятся к зданию или благоустройству, так же должны быть удалены из проекта (автомобили, люди, системы частиц и т.д.)"
		checkbox chk_rules_highpoly_table_3_5 "5. толщина стен зданий >0,1м" checked:true offset:[20,0] tooltip:"5. Стены объектов. Толщина стен зданий минимум 10 см."

	mapped fn check_on e = e.checked = true
	mapped fn check_off e = e.checked = false
	
	on btn_highpoly_checkers_on pressed do
	(
		arr = for i in RulesCheck_highpoly.Controls where classof i == CheckBoxControl and findstring i.name "_table_" != undefined collect i
		check_on arr
	)
		
	on btn_highpoly_checkers_off pressed do
	(
		arr = for i in RulesCheck_highpoly.Controls where classof i == CheckBoxControl and findstring i.name "_table_" != undefined collect i
		check_off arr		
	)
)
addRollout RulesCheck_highpoly GeoAGR rolledup:true


rollout syssetup "System Setup" autoLayoutOnResize:true
(
	button btn_set_meters "Set Meters" align:#left across:3 tooltip:"Установить метры как системные единицы и установить метры как единицы отображения | Set Meters as system units and as system display units"
	button btn_set_alpha "Gamma 1.0" offset:[0,0] tooltip:"Установить системную гамму в 1.0 для отображения текстур и цветов, влияет на выбор отображения цветов в цветовых палитрах, лучше для удобства моделирования | Gamma to 1.0 of textures and colors, affects color selectors, better for modeling usability"
	button btn_set_alpha_two "Gamma 2.2" align:#right offset:[0,0] tooltip:"Установить системную гамму в 2.2 для отображения текстур и цветов, влияет на выбор отображения цветов в цветовых палитрах, лучше для удобства визуализации | Gamma to 2.2 of textures and colors, affects color selectors, better for VIZ rendering"
	button btn_set_standart_render_settings "Standart Render" across:3 align:#left offset:[0,0] tooltip:"Установить движок рендеринга Standart, лучше для удобства моделирования | Set main render engine to Standart, better for modeling usability"
	button btn_set_corona_render_settings "Corona Render" offset:[20,0] tooltip:"Установить движок рендеринга Corona Render, лучше для удобства визуализации | Set main render engine to Corona Render, better for VIZ rendering"
	button btn_set_mats "Mats" align:#right tooltip:"Перезагрузить материалы сцены с правильной гаммой и картами нормалей | Reload materials with right gamma and normal mapping"	
	radiobuttons rdo_lang labels: #("Подсказки на Русско-московском диалекте", "English tooltips") columns:1 rows:2 default:1 align:#left offset:[0,0] tooltip:"Подсказки на Русско-московском диалекте | English tooltips"

	
	on rdo_lang changed state do
	(
		setIniForceUTF16Default true
		
		--TooltipWriter (GetDir #maxroot + "\\GeoScripts\\tooltips_syssetup.ini") syssetup "[syssetup]\n"
		--TooltipWriter (GetDir #maxroot + "\\GeoScripts\\tooltips_slicers.ini") slicers "[slicers]\n"
		--TooltipWriter (GetDir #maxroot + "\\GeoScripts\\tooltips_UDIMs.ini") UDIMs "[UDIMs]\n"
		
		for i in syssetup.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_syssetup.ini") i.name "syssetup" state)
		for i in slicers.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_slicers.ini") i.name "slicers" state)
		for i in UDIMs.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_UDIMs.ini") i.name "UDIMs" state)
		for i in Geojson.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_Geojson.ini") i.name "Geojson" state)
		for i in UCX.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_UCX.ini") i.name "UCX" state)
		for i in Obj_Spln.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_objs.ini") i.name "Obj_Spln" state)
		for i in Obj_tools.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_tools.ini") i.name "Obj_tools" state)
		for i in File.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_files.ini") i.name "File" state)
		for i in Docker.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_Docker.ini") i.name "Docker" state)

		/*
		local filenameIni = GetDir #maxroot + "\\GeoScripts\\tooltips_syssetup.ini"
		if not doesFileExist filenameIni then
		(
			local stri = "[syssetup]\n"
			for i in syssetup.controls where isProperty i "tooltip" do 
				--if findstring i.tooltip "|" != undefined then 
					stri += i.name + "=" + (substitutestring (substitutestring (i.tooltip) "\n" "::" ) "\r" "") + "\n"
			--print stri
			
			--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("Windows-1251")) --ANSI
			--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-16LE"))
			local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-8"))
			Writer.Write(stri)
			Writer.Close()
			free Writer
			free filenameIni
			free stri
		)
		
		local filenameIni = GetDir #maxroot + "\\GeoScripts\\tooltips_slicers.ini"
		if not doesFileExist filenameIni then
		(
			local stri = "[slicers]\n"
			for i in slicers.controls where isProperty i "tooltip" do 
				--if findstring i.tooltip "|" != undefined then 
					stri += i.name + "=" + (substitutestring (substitutestring (i.tooltip) "\n" "::" ) "\r" "") + "\n"
			--print stri
			
			--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("Windows-1251")) --ANSI
			--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-16LE"))
			local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-8"))
			Writer.Write(stri)
			Writer.Close()
			free Writer
			free filenameIni
			free stri
		)
*/		
/*
		try
		(
			for i in syssetup.controls where isProperty i "tooltip" do 
			(
				local tooltip = getINISetting (GetDir #maxroot + "\\GeoScripts\\tooltips_slicers.ini") "syssetup" i.name
				if tooltip != undefined then
					if tooltip != "" then
						if findstring tooltip "|" != undefined then 
						(
							tooltip = substitutestring tooltip " | " "|"
							i.tooltip = (filterstring (substitutestring tooltip "::" "\n") "|")[state]
						)
			)	
		)catch()
		
		try
		(
			for i in slicers.controls where isProperty i "tooltip" do 
			(
				local tooltip = getINISetting (GetDir #maxroot + "\\GeoScripts\\tooltips_slicers.ini") "slicers" i.name
				if tooltip != undefined then
					if tooltip != "" then
						if findstring tooltip "|" != undefined then 
						(
							substitutestring tooltip " | " "|"
							i.tooltip = (filterstring (substitutestring tooltip "::" "\n") "|")[state]
						)
			)	
		)catch()
*/		
	)

	on syssetup open do 
	(
		setIniForceUTF16Default true
		for i in syssetup.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_syssetup.ini") i.name "syssetup" 1)
	
		/*
		local filenameIni = GetDir #maxroot + "\\GeoScripts\\tooltips_syssetup.ini"
		if doesFileExist filenameIni then deleteFile filenameIni
		
		try
		(
			for i in syssetup.controls where isProperty i "tooltip" do (setINISetting filenameIni "syssetup" i.name (substitutestring (replace_LF_with_CRLF (replace_CRLF_with_LF i.tooltip)) "\n" "@" ))
		)catch()
			
		try
		(
			for i in syssetup.controls where isProperty i "tooltip" do 
			(
				local tooltip = getINISetting filenameIni "syssetup" i.name
				if tooltip != undefined then
					if tooltip != "" then
						if findstring tooltip "|" != undefined then 
							i.tooltip = (filterstring (substitutestring tooltip "@" "\n") "|")[1]
			)
		)catch()
		*/
	)

	on btn_set_mats pressed do 
	(
		for i in selection do 
		(
			for tmap in (getClassInstances BitmapTexture target:i asTrackViewPick:off) do 
			(
				--for r in (refs.dependents tmap immediateOnly:true) where try(classof r == CoronaNormal)catch(false) do appendIfUnique temp_arr r
				try(tmap.bitmap = openBitmap tmap.bitmap.filename gamma:2.2)catch()
			)
			for tmap in (getClassInstances CoronaBitmap target:i asTrackViewPick:off) do 
			(
				--for r in (refs.dependents tmap immediateOnly:true) where try(classof r == CoronaNormal)catch(false) do appendIfUnique temp_arr r
				try(tmap.gamma = 2.2)catch()
			)
			for tmap in (getClassInstances CoronaNormal target:i asTrackViewPick:off) do
			(
				try
				(
					tmap.addGamma = true
					if classof tmap.normalMap == BitmapTexture then tmap.normalMap.bitmap = openBitmap tmap.normalMap.bitmap.filename gamma:2.2
					if classof tmap.normalMap == CoronaBitmap then tmap.normalMap.gamma = 2.2
				)catch()
			)
		)
	)

	on btn_set_mats rightclick do 
	(
		for i in selection do 
		(
			for tmap in (getClassInstances BitmapTexture target:i asTrackViewPick:off) do 
			(
				--for r in (refs.dependents tmap immediateOnly:true) where try(classof r == CoronaNormal)catch(false) do appendIfUnique temp_arr r
				try(tmap.bitmap = openBitmap tmap.bitmap.filename gamma:1.0)catch()
			)
			for tmap in (getClassInstances CoronaBitmap target:i asTrackViewPick:off) do 
			(
				--for r in (refs.dependents tmap immediateOnly:true) where try(classof r == CoronaNormal)catch(false) do appendIfUnique temp_arr r
				try(tmap.gamma = 1.0)catch()
			)
			for tmap in (getClassInstances CoronaNormal target:i asTrackViewPick:off) do
			(
				try
				(
					tmap.addGamma = true
					if classof tmap.normalMap == BitmapTexture then tmap.normalMap.bitmap = openBitmap tmap.normalMap.bitmap.filename gamma:1.0
					if classof tmap.normalMap == CoronaBitmap then tmap.normalMap.gamma = 1.0
				)catch()
			)
		)
	)
	
	on btn_set_meters pressed do
	(
		units.DisplayType = #metric
		units.MetricType = #meters
		units.SystemType = #meters
	)
	
	on btn_set_alpha pressed do
	(
		if ((maxversion())[1] / 1000) - 2 + 2000 >= 2025 then ColorPipelineMgr.mode = #gamma 
		else 
		(
			IDisplayGamma.colorCorrectionMode = #gamma 	
			IDisplayGamma.colorCorrectionPrefMode = #gamma
		)		
		FileInGamma = 1.0
		FileOutGamma = 1.0
		displayGamma = 1.0
	)

	on btn_set_alpha_two pressed do
	(
		if ((maxversion())[1] / 1000) - 2 + 2000 >= 2025 then ColorPipelineMgr.mode = #gamma 
		else 
		(
			IDisplayGamma.colorCorrectionMode = #gamma 	
			IDisplayGamma.colorCorrectionPrefMode = #gamma
		)		
		FileInGamma = 2.2
		FileOutGamma = 2.2
		displayGamma = 2.2
	)
	
	on btn_set_standart_render_settings pressed do
	(
		renderSceneDialog.close()
		for rnd in 1 to (rendererClass.classes).count where matchPattern ((rendererClass.classes)[rnd] as string) pattern:"Default_Scanline_Renderer" do Renderers.Production = RendererClass.Classes[rnd]()
		for rnd in 1 to (rendererClass.classes).count where matchPattern ((rendererClass.classes)[rnd] as string) pattern:"Default_Scanline_Renderer" do renderers.activeShade = RendererClass.Classes[rnd]()
	)
	
	on btn_set_corona_render_settings pressed do
	(
		renderSceneDialog.close()
		if Renderers.Production != "Corona:Corona" then for rnd in 1 to (rendererClass.classes).count where matchPattern ((rendererClass.classes)[rnd] as string) pattern:"Corona" do Renderers.Production = RendererClass.Classes[rnd]()
		--for rnd in 1 to (rendererClass.classes).count where matchPattern ((rendererClass.classes)[rnd] as string) pattern:"CoronaRenderer" do Renderers.Production = RendererClass.Classes[rnd]()
	)
)

rollout slicers "Slicers" autoLayoutOnResize:true
(
	radiobuttons rdo_mods labels: #("Slice Modifiers", "Poly Slicers") columns:2 rows:1 default:1 align:#center offset:[0,0] tooltip:"Использовать метод нарезки: добавлять модификаторы slice или использовать операцию нарезки в editable poly | Use slicing method: add slice modifiers or use slice operations with editable poly"
	group "Slicer Distances Parameters"
	(
		spinner spn_gor_X "X interval" range:[0.001, 10000.0, 5.0] fieldWidth:35 align:#left across:3 tooltip:"Установить расстояние между резами по оси X | Set distance between slices about X axis"
		checkbox chk_gor_side_x "From other side" checked:false offset:[5,0] width:100 tooltip:"Начинать нарезку относительно оси X с другой стороны объекта, используя текущий отступ | Begin slice about X axis from other side of object, using current offset" 
		spinner spn_gor_Xoffset "Offset" range:[0.0, 10000.0, 0.2] offset:[0,0] fieldWidth:30 align:#right tooltip:"Установить для объекта отступ для первого реза | Set the offset for the first slice for the object"
		checkbox chk_gor_Xfuses "Make fuses" checked:false across:2 align:#right offset:[50,0] tooltip:"Делать парные нарезы для каждого интервала, используя установленный размер промежутка | Make two slices for each one interval by selected distance between of two slices" 
		spinner spn_gor_Xfuses "" range:[0.001, 10000.0, 0.01] enabled:chk_gor_Xfuses.checked align:#right fieldWidth:40 tooltip:"Размер промежутка для парных нарезов | Distance between pair slices"
		
		spinner spn_gor_Y "Y interval" range:[0.001, 10000.0, 5.0] fieldWidth:35 align:#left across:3 tooltip:"Установить расстояние между резами по оси Y | Set distance between slices about Y axis"
		checkbox chk_gor_side_y "From other side" checked:false offset:[5,0] tooltip:"Начинать нарезку относительно оси Y с другой стороны объекта, используя текущий отступ | Begin slice about Y axis from other side of object, using current offset" 
		spinner spn_gor_Yoffset "Offset" range:[0.0, 10000.0, 0.2] fieldWidth:30 offset:[0,0] tooltip:"Установить для объекта отступ для первого реза | Set the offset for the first slice for the object"
		checkbox chk_gor_Yfuses "Make fuses" checked:false across:2 align:#right offset:[50,0] tooltip:"Делать парные нарезы для каждого интервала, используя установленный размер промежутка | Make two slices for each one interval by selected distance between of two slices" 
		spinner spn_gor_Yfuses "" range:[0.001, 10000.0, 0.01] enabled:chk_gor_Yfuses.checked align:#right fieldWidth:40 tooltip:"Размер промежутка для парных нарезов | Distance between pair slices"		
		
		spinner spn_vert_Z "Z interval" range:[0.001, 10000.0, 1.1] fieldWidth:35 align:#left across:3 tooltip:"Установить расстояние между резами по оси Z | Set distance between slices about Z axis"
		checkbox chk_vert_side_z "From other side" checked:false offset:[5,0] width:100 tooltip:"Начинать нарезку относительно оси Z с другой стороны объекта, используя текущий отступ | Begin slice about Z axis from other side of object, using current offset" 	
		spinner spn_vert_Zoffset "Offset" range:[0.0, 10000.0, 0.2] fieldWidth:30 offset:[0,0] tooltip:"Установить для объекта отступ для первого реза | Set the offset for the first slice for the object"
		checkbox chk_vert_Zfuses "Make fuses" checked:false across:2 align:#right offset:[50,0] tooltip:"Делать парные нарезы для каждого интервала, используя установленный размер промежутка | Make two slices for each one interval by selected distance between of two slices" 
		spinner spn_vert_Zfuses "" range:[0.001, 10000.0, 0.01] enabled:chk_vert_Zfuses.checked align:#right fieldWidth:40 tooltip:"Размер промежутка для парных нарезов | Distance between pair slices"
	)
	group "Slicer plane angles"
	(	
		radiobuttons rdo_angles labels: #("Ground(Top)/Reseted", "Walls(Front-Back)", "Walls(Left-Right)", "Custom") columns:2 rows:2 default:1 align:#left offset:[0,0] tooltip:"Предварительно заданные углы для срезов по направлению просмотра, для каждой оси-направления матрицы срезов используются три угла для ориентации плоскости среза | Preseted angles for slices by view or viewport direction, for each axis-direction of slicing array uses three angles to orient slice plane"

		checkbox chk_x "For X axis slices" checked:true align:#left across:4 offset:[-5,0] tooltip:"Если этот флажок установлен, используйте эту ось для создания срезов по оси X с выбранными выше параметрами | Use this axis when checked, make slices for X axis with selected options above" 
		spinner spn_eu_xx "X" range:[0.0, 360.0, 0.0] align:#right fieldWidth:35 offset:[20,0] tooltip:"Три угла для ориентации плоскости реза | Three angles to orient slice plane"
		spinner spn_eu_yx "Y" range:[0.0, 360.0, 90.0] align:#right fieldWidth:35 offset:[10,0] tooltip:"Три угла для ориентации плоскости реза | Three angles to orient slice plane"
		spinner spn_eu_zx "Z" range:[0.0, 360.0, 90.0] align:#right fieldWidth:35 tooltip:"Три угла для ориентации плоскости реза | Three angles to orient slice plane"
		
		checkbox chk_y "For Y axis slices" checked:true align:#left across:4 offset:[-5,0] tooltip:"Если этот флажок установлен, испол??зуйте эту ось для со??дания срезов по оси Y с выбранными выше параметрами | Use this axis when checked, make slices for Y axis with selected options above" 
		spinner spn_eu_xy "X" range:[0.0, 360.0, 90.0] align:#right fieldWidth:35 offset:[20,0] tooltip:"Три угла для ориентации плоскости реза | Three angles to orient slice plane"
		spinner spn_eu_yy "Y" range:[0.0, 360.0, 0.0] align:#right fieldWidth:35 offset:[10,0] tooltip:"Три угла для ориентации плоскости реза | Three angles to orient slice plane"
		spinner spn_eu_zy "Z" range:[0.0, 360.0, 90.0] align:#right fieldWidth:35 tooltip:"Три угла для ориентации плоскости реза | Three angles to orient slice plane"
		
		checkbox chk_z "For Z axis slices" checked:false align:#left across:4 offset:[-5,0] tooltip:"Если этот флажок установлен, используйте эту ось для создания срезов по оси Z с выбранными выше параметрами | Use this axis when checked, make slices for Z axis with selected options above"
		spinner spn_eu_xz "X" range:[0.0, 360.0, 0.0] align:#right fieldWidth:35 offset:[20,0] enabled:chk_z.checked tooltip:"Три угла для ориентации плоскости реза | Three angles to orient slice plane"
		spinner spn_eu_yz "Y" range:[0.0, 360.0, 0.0] align:#right fieldWidth:35 offset:[10,0] enabled:chk_z.checked tooltip:"Три угла для ориентации плоскости реза | Three angles to orient slice plane"
		spinner spn_eu_zz "Z" range:[0.0, 360.0, 0.0] align:#right fieldWidth:35 enabled:chk_z.checked tooltip:"Три угла для ориентации плоскости реза | Three angles to orient slice plane"
	)
	group "Slicer Tools"
	(		
		button btn_slice "Slice to Axises" width:260 align:#left tooltip:"LMB: Добавить матрицу модификаторов Slice или сделать срезы методом QuickSlice в Editable_Poly | LMB: Add matrix of Slice Modifiers or QuickSlice as Editable_Poly"

		button btn_delete "Delete Slices" across:3 width:80 align:#left tooltip:"Удалить все модификаторы среза из стека выбранного объекта | Remove all Slice modifiers from stack of selected object"
		button btn_slice_copy "Copy Slice Modifier" width:100 offset:[5,0] tooltip:"Скопировать самый верхний модификатор Slice с текущим смещением по выбранным выше ??сям | Copy abovest Slice Modifier with current offset by selected above Axises"
		spinner spn_slice_copy_offset "Offset" range:[-100000.0, 100000.0, 1.09] fieldWidth:35 offset:[0,0] align:#right fieldWidth:40 tooltip:"Смещение между копируемыми модификаторами среза | Offset between Slice Modifiers to be copied"

		button btn_conv "Convert to Poly" across:3 width:80 align:#left tooltip:"Простое преобразование выделенных объектов в Editable poly | Simple convert selected objects to Editable poly"
		button btn_remove "Remove Verts" tooltip:"Используйте выделение EDGE-BORDER, для работы только с ними!\nLMB: Удалить лишние вершины после модификаторов Slice\nRMB: Удалить лишние вершины после ShapeMerge\nRMB+CTRL: Удалить лишние вертикальные ребра после ShapeMerge\nALT: только выбрать ошибочные вершины | Use EDGE or BORDER selection for affect only for them!\nLMB: Try to Remove two-edged error vertices after Slice modifiers, using all object or only for EDGE-BORDER selection\nRMB: Try to Remove two-edged error vertices after ShapeMerge, EDGE-BORDER selection preffered\nRMB+CTRL: Try to Remove vertical error edges from BORDER selection, after ShapeMerge\nALT: Select errors only, do not remove anything"
		spinner spn_remove "Treshold" range:[0.0, 180.0, 0.01] scale:0.01 fieldWidth:30 type:#float align:#right tooltip:"Пороговый угол для удаления вершин | Treshold angle to remove verts"
	)
	group "Slicer for texels density cut"
	(	
		button btn_guess_slice "Guess Slices" width:70 across:3 align:#left tooltip:"LMB: Уст??новить расстояния между ср??зами под плотность текселей, при условии ??сли тексель полностью заполняет UDIM!\n\nRMB: Подсчитать плотность результирующего текселя по расстоянию между срезами по оси Z, RMB+CTRL: по оси Y, RMB:ALT: по оси X | LMB: Set slices distances by target texel density. The UV Texel should be the same only if it completely fills the UDIM!\n\nRMB: Count result texel density from slicers distance by Z axis, RMB+CTRL: by Y axis, RMB:ALT: by X axis."
		dropdownlist ddl_texture_size "" items:#("256", "512", "1024", "2048", "4096") selection:5 width:52 fieldWidth:52 offset:[-10,0] tooltip:"Размеры текстуры:\n256*256 пикселей,\n512*512 пикселей,\n1024*1024 пикселей,\n2048*2048 пикселей,\n4096*4096 пикселей | Texture dimensions:\n256*256 pixels,\n512*512 pixels,\n1024*1024 pixels,\n2048*2048 pixels,\n4096*4096 pixels" 
		spinner spn_guess_slice "Target density" range:[0.001, 100000.0, 1380.0] scale:0.1 type:#float offset:[0,0] fieldWidth:45 width:70 align:#right tooltip:"Значение плотности текселей из диапазона [512..1706]\nЕсли каждый тексель будет полностью заполнять UDIM | Target texels density value [512..1706].\nIf each texel will fully fill UDIM"
	)
	group "Object unwrap UVW UDIM auto slicer"
	(	
		button btn_uv_cut_pressed "" width:1 height:1 across:2 align:#left tooltip:""
		button btn_uv_cut "Auto UDIM UV Grid Slicer" width:260 align:#right tooltip:"LMB: Автонарезка по сетке = по границам UVWmap = по всем UDIM = по границам текстуры\nможет работать c выделенными гранями\nLMB+CTRL: не сглаживать UVW по W\nRMB: Метод №2\nRMB+CTRL: Не удалять ошибочные вершины\nRMB+ALT: Не выполнять VertexWeld | LMB: Auto Slice objects for every UDIM grid (by Friedrich Hanisch 3d-io), may work with face selection, be sure UVs larger than UDIM\nLMB+CTRL: Do not flatten W in UVW\nRMB: Use Method #2, alternative\nRMB+CTRL: Don't Remove bad Verts\nRMB+ALT: Don't Vertex Weld"
	)
	
	on slicers open do 
	(
		for i in slicers.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_slicers.ini") i.name "slicers" 1)

		/*
		--setIniForceUTF16Default true
		--local filenameIni = GetDir #maxroot + "\\GeoScripts\\tooltips_slicers.ini"
		--if doesFileExist filenameIni then deleteFile filenameIni
			
		--local stri = "[slicers]\n"
		--for i in slicers.controls where isProperty i "tooltip" do stri += i.name + "=" + (substitutestring (substitutestring (i.tooltip) "\n" "::" ) "\r" "") + "\n"
		--print stri
		
			--Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("Windows-1251")) --ANSI
			--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-16LE"))
		--	local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-8"))
		--	Writer.Write(stri)
		--	Writer.Close()
		--	free Writer
			--free filenameIni
			--free stri

		try
		(
			for i in slicers.controls where isProperty i "tooltip" do (setINISetting filenameIni "slicers" i.name (substitutestring (substitutestring (i.tooltip) "\n" "::" ) "\r" ""))
		)catch()
		
		
		try
		(
			for i in slicers.controls where isProperty i "tooltip" do 
			(
				local tooltip = getINISetting filenameIni "slicers" i.name
				if tooltip != undefined then
					if tooltip != "" then
						if findstring tooltip "|" != undefined then 
							i.tooltip = (filterstring (substitutestring tooltip "::" "\n") "|")[1]
			)
		)catch()
		*/
	)	
	
	on chk_gor_Xfuses changed arg do spn_gor_Xfuses.enabled = chk_gor_Xfuses.checked 
	on chk_gor_Yfuses changed arg do spn_gor_Yfuses.enabled = chk_gor_Yfuses.checked 	
	on chk_vert_Zfuses changed arg do spn_vert_Zfuses.enabled = chk_vert_Zfuses.checked 
		
	on chk_x changed arg do (spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked; rdo_angles.state = 4)
	on chk_y changed arg do (spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked; rdo_angles.state = 4)
	on chk_z changed arg do (spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked; rdo_angles.state = 4)
	
	on rdo_mods changed st do 
	(
		case st of
		(		
			1: case rdo_angles.state of
			(
				1: --top
				(
					spn_eu_xx.value = 0.0
					spn_eu_yx.value = 90.0
					spn_eu_zx.value = 90.0
					
					spn_eu_xy.value = 90.0
					spn_eu_yy.value = 0.0
					spn_eu_zy.value = 90.0
					
					spn_eu_xz.value = 0.0
					spn_eu_yz.value = 0.0
					spn_eu_zz.value = 0.0
					
					chk_x.checked = true
					chk_y.checked = true
					chk_z.checked = false
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
					
				)
				2: --front-back
				(
					spn_eu_xx.value = 0.0
					spn_eu_yx.value = 90.0
					spn_eu_zx.value = 90.0
					
					spn_eu_xy.value = 0.0
					spn_eu_yy.value = 0.0
					spn_eu_zy.value = 90.0
					
					spn_eu_xz.value = 0.0
					spn_eu_yz.value = 0.0
					spn_eu_zz.value = 0.0
					
					chk_x.checked = true
					chk_y.checked = false
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)	
				3: --left-right
				(
					spn_eu_xx.value = 0.0
					spn_eu_yx.value = 0.0
					spn_eu_zx.value = 90.0
					
					spn_eu_xy.value = 90.0
					spn_eu_yy.value = 0.0
					spn_eu_zy.value = 90.0
					
					spn_eu_xz.value = 0.0
					spn_eu_yz.value = 0.0
					spn_eu_zz.value = 0.0
					
					chk_x.checked = false
					chk_y.checked = true
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)
			)
			
			2: case rdo_angles.state of
			(
				1: --top
				(
					spn_eu_xx.value = (x_axis).x
					spn_eu_yx.value = (x_axis).y
					spn_eu_zx.value = (x_axis).z
					
					spn_eu_xy.value = (y_axis).x
					spn_eu_yy.value = (y_axis).y
					spn_eu_zy.value = (y_axis).z
					
					spn_eu_xz.value = (z_axis).x
					spn_eu_yz.value = (z_axis).y
					spn_eu_zz.value = (z_axis).z
					
					chk_x.checked = true
					chk_y.checked = true
					chk_z.checked = false
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
					
				)
				2: --front-back
				(
					spn_eu_xx.value = (x_axis).x
					spn_eu_yx.value = (x_axis).y
					spn_eu_zx.value = (x_axis).z
					
					spn_eu_xy.value = (y_axis).x
					spn_eu_yy.value = (y_axis).y
					spn_eu_zy.value = (y_axis).z
					
					spn_eu_xz.value = (z_axis).x
					spn_eu_yz.value = (z_axis).y
					spn_eu_zz.value = (z_axis).z
					
					chk_x.checked = true
					chk_y.checked = false
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)	
				3: --left-right
				(
					spn_eu_xx.value = (x_axis).x
					spn_eu_yx.value = (x_axis).y
					spn_eu_zx.value = (x_axis).z
					
					spn_eu_xy.value = (y_axis).x
					spn_eu_yy.value = (y_axis).y
					spn_eu_zy.value = (y_axis).z
					
					spn_eu_xz.value = (z_axis).x
					spn_eu_yz.value = (z_axis).y
					spn_eu_zz.value = (z_axis).z
					
					chk_x.checked = false
					chk_y.checked = true
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)
			)
		)		
	)
	
	on rdo_angles changed state do
	(
		case rdo_mods.state of
		(		
			1: case state of
			(
				1: --top
				(
					spn_eu_xx.value = 0.0
					spn_eu_yx.value = 90.0
					spn_eu_zx.value = 90.0
					
					spn_eu_xy.value = 90.0
					spn_eu_yy.value = 0.0
					spn_eu_zy.value = 90.0
					
					spn_eu_xz.value = 0.0
					spn_eu_yz.value = 0.0
					spn_eu_zz.value = 0.0
					
					chk_x.checked = true
					chk_y.checked = true
					chk_z.checked = false
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
					
				)
				2: --front-back
				(
					spn_eu_xx.value = 0.0
					spn_eu_yx.value = 90.0
					spn_eu_zx.value = 90.0
					
					spn_eu_xy.value = 0.0
					spn_eu_yy.value = 0.0
					spn_eu_zy.value = 90.0
					
					spn_eu_xz.value = 0.0
					spn_eu_yz.value = 0.0
					spn_eu_zz.value = 0.0
					
					chk_x.checked = true
					chk_y.checked = false
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)	
				3: --left-right
				(
					spn_eu_xx.value = 0.0
					spn_eu_yx.value = 0.0
					spn_eu_zx.value = 90.0
					
					spn_eu_xy.value = 90.0
					spn_eu_yy.value = 0.0
					spn_eu_zy.value = 90.0
					
					spn_eu_xz.value = 0.0
					spn_eu_yz.value = 0.0
					spn_eu_zz.value = 0.0
					
					chk_x.checked = false
					chk_y.checked = true
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)
			)
			
			2: case state of
			(
				1: --top
				(
					spn_eu_xx.value = (x_axis).x
					spn_eu_yx.value = (x_axis).y
					spn_eu_zx.value = (x_axis).z
					
					spn_eu_xy.value = (y_axis).x
					spn_eu_yy.value = (y_axis).y
					spn_eu_zy.value = (y_axis).z
					
					spn_eu_xz.value = (z_axis).x
					spn_eu_yz.value = (z_axis).y
					spn_eu_zz.value = (z_axis).z
					
					chk_x.checked = true
					chk_y.checked = true
					chk_z.checked = false
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
					
				)
				2: --front-back
				(
					spn_eu_xx.value = (x_axis).x
					spn_eu_yx.value = (x_axis).y
					spn_eu_zx.value = (x_axis).z
					
					spn_eu_xy.value = (y_axis).x
					spn_eu_yy.value = (y_axis).y
					spn_eu_zy.value = (y_axis).z
					
					spn_eu_xz.value = (z_axis).x
					spn_eu_yz.value = (z_axis).y
					spn_eu_zz.value = (z_axis).z
					
					chk_x.checked = true
					chk_y.checked = false
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)	
				3: --left-right
				(
					spn_eu_xx.value = (x_axis).x
					spn_eu_yx.value = (x_axis).y
					spn_eu_zx.value = (x_axis).z
					
					spn_eu_xy.value = (y_axis).x
					spn_eu_yy.value = (y_axis).y
					spn_eu_zy.value = (y_axis).z
					
					spn_eu_xz.value = (z_axis).x
					spn_eu_yz.value = (z_axis).y
					spn_eu_zz.value = (z_axis).z
					
					chk_x.checked = false
					chk_y.checked = true
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)
			)
		)
	)	
	
	on btn_uv_cut rightclick do with redraw off with undo "UDIM Slicer" on 
	(
		if selection.count == 1 then
		(		
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			btn_uv_cut_pressed.pressed()
			
			i = selection[1]	
			max modify mode
			
			if not alt then 
			(
				converttopoly i
				addmodifier i (VertexWeld threshold: 0.001)	
				converttopoly i
			)
				
			if not ctrl then 
			(
				converttopoly i
				max modify mode
				--panel_mode = getCommandPanelTaskMode()
				--sub_level = subObjectLevel
				thePoly = i --selection[1] 
				--max create mode 
				numEdges = polyop.getNumEdges thePoly
				numVerts = polyop.getNumVerts thePoly
				Edges_sel = polyop.getEdgeSelection thePoly
				Verts_Err = #{}
				Verts = #{1..numVerts} 

				--for v in Verts where (nEdges = thePoly.GetVertexEdgeCount v) == 2 do 
				for v in Verts where (nEdges = polyop.getEdgesUsingVert thePoly v).numberset == 2 do
				(
					if keyboard.escPressed then exit
					vv = #{} --набор вершин из парных эджей
					for e in nEdges do vv += polyop.getVertsUsingEdge thePoly #{e} --набираем из парных вершин в общий набор вершин
					vv -= #{v} --исключаем из набора общую вершину
					p1 = polyop.getVert thePoly v --считаем точку в общей вершине
					pp = for w in vv collect polyop.getVert thePoly w --считаем еще две точки от других вершин
					if p1 != undefined and pp[1] != undefined and pp[2] != undefined then
					(
						local v1 = p1 - pp[1]
						local v2 = p1 - pp[2]
						angle = acos (dot (normalize v1) (normalize v2) )
						if angle >= abs(180 - 0.1) or angle <= abs(0.1) then Verts_Err += #{v} --если угол между векторами, исходящими из одной точки, развернутый и == 180 градусов, то это и есть ошибка - висячая вершина; также, если вектора направлены друг к другу из разных точек; также, если направлены в одну сторону из разных точек, тогда угол равен 0 --if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
					)
				)

				if Verts_Err.numberset > 0 then
				(
					polyop.setVertSelection thePoly Verts_Err
					thePoly.Remove selLevel:#Vertex flag:1 --polyop.deleteEdges thePoly vert_edges delIsoVerts:true
				)
				--setCommandPanelTaskMode panel_mode
				--if sub_level != undefined then subObjectLevel = sub_level
			)	
			
			addmodifier i (Unwrap_UVW())	
		)				
	)
	
	on btn_uv_cut_pressed pressed do -- with redraw off with undo "UDIM Slicer" on 
	(
		if selection.count == 1 then
		(
			--ctrl = keyboard.controlPressed
			--alt = keyboard.altPressed
			
			max modify mode
			i = selection[1]
			converttopoly i
			subObjectLevel = 0
					
			local minUV_x
			local minUV_y
			local UV_width
			local UV_height
			local areaUVW
			local areaGeom
			local faces = #{}
			local do_part = false		
			
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(
				--unwrapmod.getArea #{1..unwrapmod.numberPolygons()} &minUV_x &minUV_y &UV_width &UV_height &areaUVW &areaGeom
				faces = unwrapmod.getselectedfaces()
				if faces.isempty then 
				(
					do_part = false
					faces = #{1..unwrapmod.numberPolygons()}
				)					
				else 
				(
					do_part = true
					--faces = #{1..unwrapmod.numberPolygons()}
				)
				unwrapmod.getArea faces &minUV_x &minUV_y &UV_width &UV_height &areaUVW &areaGeom
				converttopoly i
			)
			
			max create mode
		
			ChannelInfo.ClearChannel i 9 
			ChannelInfo.ClearChannel i 8 
			ChannelInfo.ClearChannel i 7
			ChannelInfo.ClearChannel i 6 
			ChannelInfo.ClearChannel i 5 
			ChannelInfo.ClearChannel i 4 
			ChannelInfo.ClearChannel i 3
			ChannelInfo.ClearChannel i 2
			
			converttopoly i
			
			ChannelInfo.AddChannel i --добавляем новый канал 2
			ChannelInfo.CopyChannel i 1 0 -- копируем геометрию второго канала
			ChannelInfo.PasteChannel i 1 2 --вставляем геометрию второго канала (получается этим резервируем форму геометрии в канал развертки, чтобы потом оттуда ее востановить уже разрезанную)

			ChannelInfo.CopyChannel i 3 1 -- копируем развертку первого канала 
			ChannelInfo.PasteChannel i 1 0 --вставляем развертку в геометрию  
			
			converttopoly i

			local c = i
			local faces_poly = #{}
			faces_poly = polyop.getFaceSelection i 
			local faces_del = #{}
			faces_del = #{1..polyop.getnumfaces c} - faces_poly
			
			if not faces_poly.isempty then 
			(
				--polyop.detachFaces i faces asNode:true delete:false --name:"Test" node:c 
				--c = maxOps.getNodeByHandle (amax (for o in objects collect i.inode.handle))
				c = snapshot i
				converttopoly c
				
				polyop.deleteFaces c faces_del delIsoVerts:true 
				resetxform c
				converttopoly c
			)
			else
			(
				c = snapshot i
				converttopoly c
				resetxform c
				converttopoly c
			)
				
			local xmin = c.min.x
			local xmax = c.max.x
			local ymin = c.min.y
			local ymax = c.max.y
			delete c
			free c
			
			local xt = minUV_x - ((minUV_x as integer) as float) 
			local yt = minUV_y - ((minUV_y as integer) as float) 	
			
			--format "xmin=% xmax=% minUV_x=% xt=%\n" xmin xmax minUV_x xt
			--format "minX=% maxX=%\n" (xmin - minUV_x - 1) (xmax - minUV_x + 1)
			--format "ymin=% ymax=% minUV_y=% yt=%\n" ymin ymax minUV_y yt
			--format "minY=% maxY=%\n" (ymin - minUV_y - 1) (ymax - minUV_y + 1)
			
			select i
			converttopoly i
			max modify mode
			if do_part then subObjectLevel = 4
				
			for xcut = (xmin - xt - 1) to (xmax - xt + 1) by 1 where not keyboard.escPressed do with redraw off --нарезаем по целым числам развертки x, работает только нарезка по mesh
			(
				modPanel.addModToSelection(sliceModifier())
				--addmodifier i (sliceModifier())
				local modTM = getModContextTM i i.modifiers[1]
				local objTM = i.objecttransform
				i.modifiers[1].Clean = true
				i.modifiers[1].SliceFormat = 0 --plane
				i.modifiers[1].Slice_Type = 0
				i.modifiers[1].Faces___Polygons_Toggle = 0 --mesh
				i.modifiers[1].slice_plane.rotation = eulerangles 0 90 90
				i.modifiers[1].slice_plane.position = ([xcut, i.center.y, i.center.z] * modTM * (inverse objTM)) 
				if i.modifiers.count > 10 then 
				(
					converttopoly i
					if do_part then subObjectLevel = 4
				)
			)
			
			converttopoly i
			if do_part then subObjectLevel = 4
			for ycut = (ymin - yt - 1) to (ymax - yt + 1) by 1 where not keyboard.escPressed do with redraw off --нарезаем по целым числам развертки y, работает только нарезка по mesh
			(
				modPanel.addModToSelection(sliceModifier()) 
				--addmodifier i (sliceModifier())
				local modTM = getModContextTM i i.modifiers[1]
				local objTM = i.objecttransform
				i.modifiers[1].Clean = true
				i.modifiers[1].SliceFormat = 0 --plane
				i.modifiers[1].Slice_Type = 0
				i.modifiers[1].Faces___Polygons_Toggle = 0 --mesh
				i.modifiers[1].slice_plane.rotation = eulerangles 90 0 90
				i.modifiers[1].slice_plane.position = ([i.center.x, ycut, i.center.z] * modTM * (inverse objTM)) 
				if i.modifiers.count > 10 then
				(
					converttopoly i
					if do_part then subObjectLevel = 4
				)
			)

			addmodifier i (edit_poly()) --добавляем мод, чтобы конвертировать из mesh в poly, иначе не видна развертка в канале
			
			converttopoly i
			max create mode
				
			ChannelInfo.CopyChannel i 3 2 --копируем развертку второго канала
			ChannelInfo.PasteChannel i 1 0 --вставляем геометрию в пер??ый канал (получается сохраненный канал с формой геометрии вставляем в канал геометрии, но он уже разрезан)

			ChannelInfo.ClearChannel i 2 
			ChannelInfo.ClearChannel i 3	
				
			--надо почистить вершины разрезки
			converttopoly i
			max hold
	
			/*	
			--local j = sphere radius:1.0 pos:i.pos rotation:i.rotation scale:i.scale name:i.name material:i.material
			--converttopoly j
			
			--polyop.deleteFaces j #all delIsoVerts:true
			--polyop.attach j i
			--polyop.CollapseDeadStructs j
				
			--i = j
			--free j
							
			--converttopoly i	
			--select i
			*/

/*
			max modify mode
			
			if not alt then 
			(
				converttopoly i
				addmodifier i (VertexWeld threshold: 0.001)	
				converttopoly i
			)
				
			if not ctrl then 
			(
				converttopoly i
				max modify mode
				--panel_mode = getCommandPanelTaskMode()
				--sub_level = subObjectLevel
				thePoly = i --selection[1] 
				--max create mode 
				numEdges = polyop.getNumEdges thePoly
				numVerts = polyop.getNumVerts thePoly
				Edges_sel = polyop.getEdgeSelection thePoly
				Verts_Err = #{}
				Verts = #{1..numVerts} 

				--for v in Verts where (nEdges = thePoly.GetVertexEdgeCount v) == 2 do 
				for v in Verts where (nEdges = polyop.getEdgesUsingVert thePoly v).numberset == 2 do
				(
					if keyboard.escPressed then exit
					vv = #{} --набор вершин из парных эджей
					for e in nEdges do vv += polyop.getVertsUsingEdge thePoly #{e} --набираем из парных вершин в общий набор вершин
					vv -= #{v} --исключаем из набора общую вершину
					p1 = polyop.getVert thePoly v --считаем точку в общей вершине
					pp = for w in vv collect polyop.getVert thePoly w --считаем еще две точки от других вершин
					if p1 != undefined and pp[1] != undefined and pp[2] != undefined then
					(
						local v1 = p1 - pp[1]
						local v2 = p1 - pp[2]
						angle = acos (dot (normalize v1) (normalize v2) )
						if angle >= abs(180 - 0.1) or angle <= abs(0.1) then Verts_Err += #{v} --если угол между векторами, исходящими из одной точки, развернутый и == 180 градусов, то это и есть ошибка - висячая вершина; также, если вектора направлены друг к другу из разных точек; также, если направлены в одну сторону из разных точек, тогда угол равен 0 --if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
					)
				)

				if Verts_Err.numberset > 0 then
				(
					polyop.setVertSelection thePoly Verts_Err
					thePoly.Remove selLevel:#Vertex flag:1 --polyop.deleteEdges thePoly vert_edges delIsoVerts:true
				)
				--setCommandPanelTaskMode panel_mode
				--if sub_level != undefined then subObjectLevel = sub_level
			)			
			addmodifier i (Unwrap_UVW())
*/			
		)
		else messageBox ("Select single object")
		
		/*
		ChannelInfo.CopyChannel sel <integer>channelType <integer>channel Copies the specified channel of specified channel type in the supplied node. 
		Possible channelType values are: 
		1 - Geometry 
		2 - Selection 
		3 - Map 
		*/
	)
	
	on btn_uv_cut pressed do with redraw off with undo "UDIM Slicer" on 
	(
		sel = selection as array
		if not keyboard.controlPressed then 
		(
			for i in sel do 
			(
				udims.btn_bricks_flatten.pressed()
				converttopoly i
			)
		)
		TAG sel true
	)
	
	on btn_guess_slice pressed do
	(
		theMapSize = case (ddl_texture_size.selection as integer) of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)
		spn_gor_X.value = spn_gor_Y.value = spn_vert_Z.value = theMapSize/spn_guess_slice.value
	)
	
	on btn_guess_slice rightclick do
	(
		theMapSize = case (ddl_texture_size.selection as integer) of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)
		case of
		(
			(keyboard.altPressed): spn_guess_slice.value = theMapSize/spn_gor_X.value
			(keyboard.controlPressed): spn_guess_slice.value = theMapSize/spn_gor_Y.value
			default: spn_guess_slice.value = theMapSize/spn_vert_Z.value
		)	
	)
	
	on btn_slice_copy pressed do with undo "Copy Slice Modifier" on with redraw off  
	(
		for s in selection where s.modifiers.count > 0 do
		(
			if s.modifiers[1].name == "Slice" then
			(
			addmodifier s (copy s.modifiers[1])
			/*
			modPanel.addModToSelection(sliceModifier()) 
			modTM = getModContextTM selection[1] selection[1].modifiers[1]
			objTM = selection[1].objecttransform
			selection[1].modifiers[1].Clean = true
			selection[1].modifiers[1].SliceFormat = selection[1].modifiers[2].SliceFormat
			selection[1].modifiers[1].Slice_Type = selection[1].modifiers[2].Slice_Type
			selection[1].modifiers[1].Faces___Polygons_Toggle = selection[1].modifiers[2].Faces___Polygons_Toggle
			selection[1].modifiers[1].slice_plane.rotation = selection[1].modifiers[2].slice_plane.rotation
			selection[1].modifiers[1].slice_plane.position = selection[1].modifiers[2].slice_plane.position
			[0,0,0] * modTM * (inverse objTM)) 
			*/
				objTM = s.objecttransform
				modTM = getModContextTM s s.modifiers[1]
				print objTM
				print modTM
				if chk_x.checked then s.modifiers[1].slice_plane.position.x += spn_slice_copy_offset.value --selection[1].modifiers[1].slice_plane.position += [spn_slice_copy_offset.value,0,0] * modTM * (inverse objTM)
				if chk_y.checked then s.modifiers[1].slice_plane.position.y += spn_slice_copy_offset.value --[0,spn_slice_copy_offset.value,0] * modTM * (inverse objTM)
				if chk_z.checked then s.modifiers[1].slice_plane.position.z += spn_slice_copy_offset.value --[0,0,spn_slice_copy_offset.value] * modTM * (inverse objTM)
			)
		)
	)
	
	on btn_delete pressed do with undo "Delete Slice Modifiers" on with redraw off 
	(
		for s in selection do
			while (try(s.modifiers[1].name == "Slice")catch(false)) do
			(
				try(deletemodifier s 1)catch()
				if s.modifiers.count == 0 then exit
			)
	)
	
	on btn_slice pressed do with undo "Slices" on with redraw off 
	(
		--ctrl = keyboard.controlpressed
		sel = selection
		
		if rdo_mods.state == 2 then
		(
			for i in sel where not keyboard.escPressed do
			(
				if chk_x.checked then -- x axis
				(
					if chk_gor_Xfuses.checked then
					(
						if chk_gor_side_x.checked then
						(
							for s = i.max.x - spn_gor_Xoffset.value + (spn_gor_Xfuses.value / 2) to i.min.x by -spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepoly i [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
								slicepoly i [s - spn_gor_Xfuses.value, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)	
						)	
						else
						(
							for s = i.min.x + spn_gor_Xoffset.value - (spn_gor_Xfuses.value / 2) to i.max.x by spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepoly i [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
								slicepoly i [s + spn_gor_Xfuses.value, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)							
						)
					)
					else
					(
						if chk_gor_side_x.checked then
						(
							for s = i.max.x - spn_gor_Xoffset.value to i.min.x by -spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepoly i [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)
						)
						else
						(
							for s = i.min.x + spn_gor_Xoffset.value to i.max.x by spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepoly i [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)						
						)
					)

				)
				
				if chk_y.checked then -- y axis
				(
					if chk_gor_Yfuses.checked then
					(
						if chk_gor_side_y.checked then
						(
							for s = i.max.y - spn_gor_Yoffset.value + (spn_gor_Yfuses.value / 2) to i.min.y by -spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
								slicepoly i [i.center.x, s - spn_gor_Yfuses.value, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)	
						)
						else
						(
							for s = i.min.y + spn_gor_Yoffset.value - (spn_gor_Yfuses.value / 2) to i.max.y by spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
								slicepoly i [i.center.x, s + spn_gor_Yfuses.value, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)							
						)
					)
					else
					(
						if chk_gor_side_y.checked then
						(
							for s = i.max.y - spn_gor_Yoffset.value to i.min.y by -spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)
						)
						else
						(
							for s = i.min.y + spn_gor_Yoffset.value to i.max.y by spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)						
						)
					)

				)	
				
				if chk_z.checked then -- z axis 
				(
					if chk_vert_Zfuses.checked then
					(
						if chk_vert_side_Z.checked then
						(
							for s = i.max.z - spn_vert_Zoffset.value + (spn_vert_Zfuses.value / 2) to i.min.z by -spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
								slicepoly i [i.center.x, i.center.y, s - spn_vert_Zfuses.value] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)	
						)
						else	
						(
							for s = i.min.z + spn_vert_Zoffset.value - (spn_vert_Zfuses.value / 2) to i.max.z by spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
								slicepoly i [i.center.x, i.center.y, s + spn_vert_Zfuses.value] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)	
						)	
					)
					else
					(
						if chk_vert_side_Z.checked then
						(
							for s = i.max.z - spn_vert_Zoffset.value to i.min.z by -spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed  do
							(
								slicepoly i [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)
						)
						else
						(
							for s = i.min.z + spn_vert_Zoffset.value to i.max.z by spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)						
						)
					)
				)	
		
			)
		)
		else
		(
			for i in sel where not keyboard.escPressed do
			(
				if chk_x.checked then -- x axis
				(
					if chk_gor_Xfuses.checked then
					(
						if chk_gor_side_x.checked then
						(
							for s = i.max.x - spn_gor_Xoffset.value + (spn_gor_Xfuses.value / 2) to i.min.x by -spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepl i 0 [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
								slicepl i 0 [s - spn_gor_Xfuses.value, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)	
						)	
						else
						(
							for s = i.min.x + spn_gor_Xoffset.value - (spn_gor_Xfuses.value / 2) to i.max.x by spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepl i 0 [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
								slicepl i 0 [s + spn_gor_Xfuses.value, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)							
						)
					)
					else
					(
						if chk_gor_side_x.checked then
						(
							for s = i.max.x - spn_gor_Xoffset.value to i.min.x by -spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepl i 0 [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)
						)
						else
						(
							for s = i.min.x + spn_gor_Xoffset.value to i.max.x by spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepl i 0 [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)						
						)
					)

				)
				
				if chk_y.checked then -- y axis
				(
					if chk_gor_Yfuses.checked then
					(
						if chk_gor_side_y.checked then
						(
							for s = i.max.y - spn_gor_Yoffset.value + (spn_gor_Yfuses.value / 2) to i.min.y by -spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
								slicepl i 0 [i.center.x, s - spn_gor_Yfuses.value, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)	
						)
						else
						(
							for s = i.min.y + spn_gor_Yoffset.value - (spn_gor_Yfuses.value / 2) to i.max.y by spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
								slicepl i 0 [i.center.x, s + spn_gor_Yfuses.value, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)							
						)
					)
					else
					(
						if chk_gor_side_y.checked then
						(
							for s = i.max.y - spn_gor_Yoffset.value to i.min.y by -spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)
						)
						else
						(
							for s = i.min.y + spn_gor_Yoffset.value to i.max.y by spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)						
						)
					)

				)	
				
				if chk_z.checked then -- z axis 
				(
					if chk_vert_Zfuses.checked then
					(
						if chk_vert_side_Z.checked then
						(
							for s = i.max.z - spn_vert_Zoffset.value + (spn_vert_Zfuses.value / 2) to i.min.z by -spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
								slicepl i 0 [i.center.x, i.center.y, s - spn_vert_Zfuses.value] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)	
						)
						else	
						(
							for s = i.min.z + spn_vert_Zoffset.value - (spn_vert_Zfuses.value / 2) to i.max.z by spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
								slicepl i 0 [i.center.x, i.center.y, s + spn_vert_Zfuses.value] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)	
						)	
					)
					else
					(
						if chk_vert_side_Z.checked then
						(
							for s = i.max.z - spn_vert_Zoffset.value to i.min.z by -spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed  do
							(
								slicepl i 0 [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)
						)
						else
						(
							for s = i.min.z + spn_vert_Zoffset.value to i.max.z by spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)						
						)
					)
				)	
		
			)
		)
	)
	
	on btn_conv pressed do with undo "Convert to poly" on with redraw off
	(
		for i in selection do converttopoly i
	)
	
	on btn_remove pressed do undo "Remove Error-Verts" on with redraw off
	(
		for sel in selection do
		(
			if classof sel == editable_poly then
			(
			/*
			thePoly = selection[1] 
			max modify mode --switch to modify panel  
			modPanel.setCurrentObject selection[1].baseobject --set the base object as current level:
			subObjectLevel = 1 --set sub-object level to vertex level
			numVerts = (polyop.getNumVerts thePoly) --get the total vertex count
			for v = numVerts to 1 by -1 do --loop backwards from the last to the first vertex
			(
				nVerts = (polyop.getEdgesUsingVert thePoly v) as array  --get the edges using the vertex to check the count
				if nVerts.count == 2 do --if only two edges found, then
				(
					edge1verts = (polyop.getVertsUsingEdge thePoly nVerts[1]) as array --get the verts of the first egde
					vector1 = (polyop.getVert thePoly edge1verts[1]) - (polyop.getVert thePoly edge1verts[2])  --calculate the vector defined by the two vertices in the first edge
					edge2verts = (polyop.getVertsUsingEdge thePoly nVerts[2] as array) --get the verts of the second edge
					vector2 = (polyop.getVert thePoly edge2verts[1]) - (polyop.getVert thePoly edge2verts[2]) --calculate the vector defined by the two vertices in the second edge
					angle = acos (dot (normalize vector1) (normalize vector2)) --calculate the angle between the two normalized vectors
					--print angle
					
					if angle >= abs(180-spn_remove.value) or angle <= abs(spn_remove.value) do --если угол между векторами, исходящими из одной точки, развернутый и == 180 градусов, то это и есть ошибка - висячая вершина; также, если вектора направлены друг к другу из разных точек; также, если направлены в одну сторону из разных точек, тогда угол равен 0 --if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
					(
						select thePoly.verts[v]--then select the current vertex
						thePoly.EditablePoly.buttonOp #Remove --and hit the remove button
					)
				)--end if
			)--end v loop
			*/
			
				ctrl = keyboard.controlPressed
				alt = keyboard.altPressed
				panel_mode = getCommandPanelTaskMode()
				sub_level = subObjectLevel
				thePoly = sel --selection[1] 
				max create mode 
				numEdges = polyop.getNumEdges thePoly
				numVerts = polyop.getNumVerts thePoly
				Edges_sel = polyop.getEdgeSelection thePoly
				Verts = #{}
				Verts_Err = #{}
				
				--если есть выделение границ, то используем это для ускорения поиска
				if Edges_sel.isempty then
				(
					Verts = #{1..numVerts} 
				)
				else 
				(
					if querybox ("Selected edges found,\nuse them as borders for searching?\nUsual press NO.") then
						for e in Edges_sel do Verts += polyop.getVertsUsingEdge thePoly #{e}
					else Verts = #{1..numVerts} 
				)
				spn = spn_remove.value
				cou = Verts.count
				--Verts_ = for v in Verts where (polyop.getEdgesUsingVert thePoly v).numberset == 2 collect v
				--for v in Verts where (nEdges = thePoly.GetVertexEdgeCount v) == 2 do 
				for v in Verts where (nEdges = polyop.getEdgesUsingVert thePoly v).numberset == 2 do
				(
					if keyboard.escPressed then exit
					vv = #{} --набор вершин из парных эджей
					for e in nEdges do vv += polyop.getVertsUsingEdge thePoly #{e} --набираем из парных вершин в общий набор вершин
					vv -= #{v} --исключаем из набора общую вершину
					p1 = polyop.getVert thePoly v --считаем точку в общей вершине
					pp = for w in vv collect polyop.getVert thePoly w --считаем еще две точки от других вершин
					if p1 != undefined and pp[1] != undefined and pp[2] != undefined then
					(
						local v1 = p1 - pp[1]
						local v2 = p1 - pp[2]
						angle = acos (dot (normalize v1) (normalize v2))		
						if angle >= abs(180 - spn) or angle <= abs(spn) then Verts_Err += #{v} --если угол между векторами, исходящими из одной точки, развернутый и == 180 градусов, то это и есть ошибка - висячая вершина; также, если вектора направлены друг к другу из разных точек; также, если направлены в одну сторону из разных точек, тогда угол равен 0 --if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
					)
				)
				if Verts_Err.numberset > 0 then
				(
					polyop.setVertSelection thePoly Verts_Err
					if not alt then thePoly.Remove selLevel:#Vertex flag:1 --polyop.deleteEdges thePoly vert_edges delIsoVerts:true
				)
				setCommandPanelTaskMode panel_mode
				if sub_level != undefined then subObjectLevel = sub_level
			)
			else Messagebox ("Selected object is not an Editable Poly!")
		)
	)	
	
	on btn_remove rightclick do undo "Remove Error-Verts" on with redraw off
	(
		for sel in selection do
		(
			if classof sel == editable_poly then
			(
				ctrl = keyboard.controlPressed
				alt = keyboard.altPressed
				panel_mode = getCommandPanelTaskMode()
				sub_level = subObjectLevel
				if ctrl then -- вариант с опущенными вниз границами, созданы вертикальные ребра
				(
					t = 0.01 --порог отклонения по вертикальной оси
					thePoly = sel --selection[1] 
					max create mode 
					numEdges = polyop.getNumEdges thePoly
					numVerts = polyop.getNumVerts thePoly
					Edges_sel = #{1..numEdges}
					vert_edges = #{}
					top_edges = #{}
					top_vert = 1
					for e in Edges_sel do 
					(
						vv = polyop.getVertsUsingEdge thePoly #{e}
						pp = for v in vv collect polyop.getVert thePoly v
						--print #(pp)
						if abs (pp[1].x - pp[2].x) <= t and abs (pp[1].y - pp[2].y) <= t then 
						(   
							edges = polyop.getEdgesUsingVert thePoly vv
							if edges.numberset < 6 then 
							(
								vv_ = vv as array
								if pp[1].z < pp[2].z then
								(
									top_edges = polyop.getEdgesUsingVert thePoly vv_[2]
									top_vert = vv_[2]
								)
								else
								(
									top_edges = polyop.getEdgesUsingVert thePoly vv_[1]
									top_vert = vv_[1]
								)
								point_top_vert = polyop.getVert thePoly top_vert
								ppp = #{}
								for ee in top_edges do join ppp (polyop.getVertsUsingEdge thePoly #{ee})
								ppp -= vv

								point_plane = for p in ppp collect polyop.getVert thePoly p
								
								if point_top_vert != undefined and point_plane[1] != undefined and point_plane[2] != undefined then 
								(
									vec1 = point_top_vert - [point_plane[1].x, point_plane[1].y, point_top_vert.z]
									vec2 = point_top_vert - [point_plane[2].x, point_plane[2].y, point_top_vert.z]
								
									angle = acos (dot (normalize vec1) (normalize vec2))

									if angle >= abs(180 - spn_remove.value) or angle <= abs(spn_remove.value) then vert_edges += #{e}
								)
							)
						)
					)
					--print #(vert_edges)
					if vert_edges.numberset > 0 then
					(		
						polyop.setEdgeSelection thePoly vert_edges
						if not alt then thePoly.Remove selLevel:#Edge flag:1 --polyop.deleteEdges thePoly vert_edges delIsoVerts:true
					)
				)
				else --удаление вершин по проекции на горизонтальную плоскость
				(
					thePoly = sel --selection[1] 
					max create mode 
					numEdges = polyop.getNumEdges thePoly
					numVerts = polyop.getNumVerts thePoly
					Edges_sel = polyop.getEdgeSelection thePoly
					Verts = #{}
					Verts_Err = #{}
					if Edges_sel.numberset == 0 then
					(
						Verts = #{1..numVerts} 
					)
					else 
					(
						if querybox ("Selected edges found,\nuse them as borders for searching?") then
							for e in Edges_sel do join Verts (polyop.getVertsUsingEdge thePoly #{e})
						else Verts = #{1..numVerts} 
					)
					
					for v in Verts do
					(
						nEdges = polyop.getEdgesUsingVert thePoly v 
						if nEdges.numberset == 2 then 
						(
							vv = #{} --набор вершин из парных эджей
							for e in nEdges do vv += polyop.getVertsUsingEdge thePoly #{e}
							vv -= #{v} --исключаем из набора общую вершину
							p1 = polyop.getVert thePoly v --считаем точку в общей вершине
							pp = for w in vv collect polyop.getVert thePoly w --считаем еще две точки от других вершин
							--print #(pp)
							if p1 != undefined and pp[1] != undefined and pp[2] != undefined then
							(
								vec1 = p1 - [pp[1].x, pp[1].y, p1.z]
								vec2 = p1 - [pp[2].x, pp[2].y, p1.z]
								angle = acos (dot (normalize vec1) (normalize vec2))			
								if angle >= abs(180 - spn_remove.value) or angle <= abs(spn_remove.value) then Verts_Err += #{v} --если угол между векторами, исходящими из одной точки, развернутый и == 180 градусов, то это и есть ошибка - висячая вершина; также, если вектора направлены друг к другу из разных точек; также, если направлены в одну сторону из разных точек, тогда угол равен 0 --if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
							)
						)
					)
					if Verts_Err.numberset > 0 then
					(
						polyop.setVertSelection thePoly Verts_Err
						if not alt then thePoly.Remove selLevel:#Vertex flag:1 --polyop.deleteEdges thePoly vert_edges delIsoVerts:true
					)
				)
				setCommandPanelTaskMode panel_mode
				if sub_level != undefined then subObjectLevel = sub_level
			)
			else Messagebox ("Selected object is not an Editable Poly!")
		)
	)	
)

rollout UDIMs "UDIMs operations" autoLayoutOnResize:true
(
	group "Make Multi-Material from UDIMs and its textures"
	(
		edittext edt_material_object_number "Object" text:"001" fieldwidth:50 across:4 align:#left tooltip:"Суффикс имени объекта 001,002,003 или Ground | Object 001,002,003 or Ground"
		dropdownlist ddl_material_object_number "" items:#("","001","002","003","004","005","Ground","GroundEl","Flora") selection:2 width:75 offset:[25,0] tooltip:"Суффикс объекта 001,002,003 или Ground | Object 001,002,003 or Ground"
 		edittext edt_material_mat_number "" text:"1" fieldwidth:20 offset:[35,0] tooltip:"Редкий в использовании, номер материала в названии текстуры 1,2,3,..,7 | Rare, Material number in texture name 1,2,3,..,7"
		edittext edt_multimat_count "Count" text:"" fieldwidth:30 readonly:true align:#right offset:[0,0] tooltip:"Число найденных материалов по маске в текущей папке | The number of found by mask files in the current folder" --style_sunkenedge:true 	

		button btn_rename "Rename Textures\Objs&Mats" across:2 align:#left tooltip:"Переименовать\nLMB: файлы PNG в текущем каталоге\nCTRL+LMB: Все типы файлов\nRMB: Выбранные объекты\nRMB+CTRL: Все материалы сцены\nRMB+ALT: Пути к материалам выбранных объектов | Rename\nLMB: PNG files in current directory\nCTRL+LMB: All type of files\nRMB: Selected Objects\nRMB+CTRL: All scene Materials\nRMB+ALT: Materials Paths of selected objects"
		button btn_multimat_read "Check files" align:#right offset:[0,0] tooltip:"Проверить имена файлов в текущем каталоге и подсчитать их количество | Check filenames of files in current directory and count quantity"
			
		edittext edt_tex_find "To Find" text:"SM_" across:2 align:#left offset:[-5,0] tooltip:"Найти | To Find"
		edittext edt_tex_rename "To Rename" text:"T_" align:#right offset:[5,0] tooltip:"Заменить | To Rename"

		radiobuttons rdo_type_mat labels: #("Standart","Physical") default:1 columns:2 rows:1 offset:[0,0] across:3 align:#left tooltip:"Standart Material (Legacy) больше подходит для Unreal Engine\nPhysical Material - для Autodesk FBX Viewer | Standart Material (Legacy) more suitable for Unreal Engine\nPhysical Material - for Autodesk FBX Viewer"
		button btn_singlemat "Material LP" width:65 offset:[30,0] tooltip:"LMB: Создать материал для НПМ из файлов по маске\nCTRL+LMB: получить маску из названия выбранного объекта | LMB: Make Material for Lowpoly model from files by filter mask\nCTRL+LMB: get mask from selected object name"
		button btn_multimat "Multimat HP" width:65 offset:[0,0] align:#right tooltip:"LMB: Создать Multimat для ВПМ из файлов по маске\nCTRL+LMB: получить маску из имени выбранного объекта\nRMB: Добавить MultiTile карту в стол displace 1-го Multimat материала для отображения всех текстур в редакторе развертки | LMB: Make Multimat for Highpoly model from files by filter mask\nCTRL+LMB: get mask from selected object name\nRMB: Add a MultiTile map to the displace slot of the 1st Multimat material to display all textures in the UVW Editor"
	)	
	group "Path"
	(	
		button btn_get_multimat_path "Get Current Path" across:3 align:#left offset:[0,0] tooltip:"Получить путь сохраненной папки сцены и добавить указанную подпапку | Get path from currently saved scene folder and add specified subfolder"
		button btn_get_multimat_folder "Select Path" offset:[0,0] tooltip:"Выбрать путь в диалоговом окне стандартного выбора папки | Select path via standart selection folder dialog"
		button btn_open_multimat_path "Show Folder" offset:[0,0] align:#right tooltip: "Открыть текущий путь и показать папку в файловом браузере | Open current path in browser and show folder"

		radiobuttons rdo_path labels: #("Maps\\","Images\\","Custom") default:1 columns:3 rows:1 across:2 align:#left offset:[0,-1]
		edittext edt_path_end "" text:("") fieldWidth:80 align:#right offset:[5,0]	

		edittext edt_multimat_path "" text:(maxFilePath + "Maps\\") align:#left bold:true fieldWidth:260 --text:"E:\\Projects\\Maxim3\\Images\\"
		
		label lbl_multimat_path "Search mask:" width:260 align:#left style_sunkenedge:false 	
	)	

	group "Textures maker for UDIMs"
	(	
		radiobuttons rdo_tex labels: #("256","512","1024","2048","4096") default:5 columns:5 rows:1 align:#left tooltip:"Размер текстуры, которая будет сгенерирована | Dimension of texture to be generated"
		button btn_name_from_sel "Get Name" width:55 offset:[35,0] align:#left across:3 tooltip:"Скопировать имя текущего выбранного объекта | Copy name of current selected object"
		button btn_name_to_sel "Set Name" width:55 offset:[-10,0] tooltip:"Вставить название текущего выбранного объекта | Paste name of current selected object"
		spinner spn_tex_udim "UDIM number" range:[1001, 1100, 1001] type:#integer fieldWidth:35 offset:[0,0] align:#right tooltip:"UDIM - номер текстуры, которая будет сгенерирована, индекс добавляется к названию текстуры | UDIM number of texture to be generated, index adds to name texture"
		
		edittext edt_object_name "Object " text:"SM_GolevskiyPrd_3_Ground" labelOnTop:true bold:true width:260 fieldWidth:260 readonly:false offset:[0,-20] tooltip:"Имя, взятое из названия выбранного объекта | Name taken from selected object name"

		colorpicker color_diffuse "" color:[200,200,200] alpha:false modal:false title: "Diffuse color" across:4 offset:[50,0] align:#left tooltip:"Цвет заливки для заглушки Diffuse | Diffuse color"
		button btn_color_diffuse_ral "RAL Select" offset:[40,0] tooltip:"Создать диалоговое окно выбора цвета RAL | Create RAL color selector Dialog"		
		button btn_make_tex_diffuse "Make" offset:[40,0] tooltip:"LMB: Создать текстуру с помощью цвета заливки\nRMB: Отобразить сохраненную текстуру | LMB: Make texture with fill color\nRMB: Display saved texture"
		button btn_open_tex_diffuse "Set" align:#right offset:[0,0] tooltip:"LMB: Открыть файловый браузер, чтобы выбрать, переименовать и изменить размер текстуры\nRMB: Просмотреть файл в папке | LMB: Open file browser to select, rename and resize texture\nRMB: View file in folder"
		edittext edt_tex_diffuse_name "Diffuse " text:"T_GolevskiyPrd_3_Ground_Diffuse_1.1001.png" labelOnTop:true width:260 fieldWidth:260 readonly:true offset:[0,-20] tooltip:"Название текстуры Diffuse, сгенерированное из названия объекта | Diffuse texture name generated from object name"

		colorpicker color_erm "" color:[0,255,0] alpha:false modal:false title:"R-emission(0 nolight);G-rougness(0 gloss,255 matt);B-metallness(0 no reflect,255 mirror)" across:3 offset:[50,0] align:#left tooltip:"Цвет заливки для заглушки ERM, R-излучение (0 нет света); G-шероховатость (0 глянц??вая, 255 матовая); B-металличность (0 без отражения, 255 зеркало) | R-emission (0 no light); G-rougness (0 gloss, 255 matt); B-metallness (0 no reflect, 255 mirror)"
		button btn_make_tex_erm "Make" offset:[75,0] tooltip:"LMB: Создать текстуру с помощью цвета заливки\nRMB: Отобразить сохраненную текстуру | LMB: Make texture with fill color\nRMB: Display saved texture"
		button btn_open_tex_erm "Set" align:#right tooltip:"LMB: Открыть файловый браузер, чтобы выбрать, переименовать и изменить размер текстуры\nRMB: Просмотреть файл в папке | LMB: Open file browser to select, rename and resize texture\nRMB: View file in folder"
		edittext edt_tex_erm_name "ERM" text:"T_GolevskiyPrd_3_Ground_ERM_1.1001.png" labelOnTop:true width:260 fieldWidth:260 readonly:true offset:[0,-20] tooltip:"Название текстуры ERM, сгенерированное на основе имени объекта | ERM texture name generated from object name"
	
		colorpicker color_normal "" color:[128,128,255] alpha:false modal:false title:"Normal color, neutral:[128,128,255]" across:3 offset:[50,0] align:#left tooltip:"Цвет заливки для заглушки Normal, нейтральный: [128,128,255] | Normal color, neutral:[128,128,255]"
		button btn_make_tex_normal "Make" offset:[75,0] tooltip:"LMB: Создать текстуру с помощью цвета заливки\nRMB: Отобразить сохраненную текстуру | LMB: Make texture with fill color\nRMB: Display saved texture"
		button btn_open_tex_normal "Set" align:#right tooltip:"LMB: Открыть файловый браузер, чтобы выбрать, переименовать и изменить размер текстуры\nRMB: Просмотреть файл в папке | LMB: Open file browser to select, rename and resize texture\nRMB: View file in folder"
		edittext edt_tex_normal_name "Normal" text:"T_GolevskiyPrd_3_Ground_Normal_1.1001.png" labelOnTop:true width:260 fieldWidth:260 readonly:true offset:[0,-20] tooltip:"Название текстуры Normal, сгенерированное на основе имени объекта | Normal texture name generated from object name"
		--button btn_make_all_tex "Make All" align:#right	
		
		edittext edt_object_addr "Adress " text:"" labelOnTop:true width:260 fieldWidth:260 readonly:false offset:[0,0] tooltip:""
		button btn_check_copy "Copy" across:4 align:#left tooltip:"Скопировать имя в буфер обмена из адресной строки | Copy name to Clipboard from adress-line"
		button btn_check_paste "Paste" offset:[-37,0] tooltip:"Вставить имя из буфера обмена в адресную строку | Paste name from Clipboard to adress-line"
		button btn_check_names "Check Adress" offset:[-40,0] tooltip:"Проверить адрес на соответствие правилам и показать ошибки, рекомендации к исправлению | Check adress with rules and show errors and recomendations"
		button btn_Streets_List "Open Streets List" align:#right tooltip:"Создать новый диалог со списком московских улиц для выбора улицы или названия из списка | Create new dialog with Moscow streets list to select from"
	)
	group "Tables"
	(	
		button btn_multimat_table "Browser Tex..." width:78 across:3 align:#left tooltip:"Создать диалоговое окно с превью текстур и разверток для поиска ошибок с текстурами и UDIM | Create Dialog to findout mistakes with textures and UDIMs"
		button btn_alpha_remove "Format & Alpha Tex..." width:110 offset:[10,0] tooltip:"Создать диалоговое окно со списком текстур и их параметрами для поиска ошибок с альфа-каналом и глубиной текстур в битах | Create Dialog to findout mistakes with alpha-channel and bit-depth of textures"
		button btn_count_colors "Colors Tex..." width:70 align:#right tooltip:"Создать диалоговое окно со списком текстур и их параметрами для поиска ошибок с количеством цветов в текстурах | Create Dialog to findout mistakes with colors quantity of textures"
	
		button btn_count_texel "Texels Density UDIMs..." width:150 across:2 align:#left offset:[0,0] tooltip:"Создать диалоговое окно для работы с плотностями текселей выбранного объекта | Create Dialog to work with texels densities of selected object"
		button btn_count_area "Areas Poly..." width:110 align:#right tooltip:"Создать диалоговое окно для работы над ошибками полигонов выбранного объекта | Create Dialog to work with polygons errors of selected object"
	)
	group "Materials, IDs, Textures and UDIMs"
	(
		button btn_ids_as_udims "UDIMs\x2192IDs" across:4 width:65 align:#left offset:[0,0] tooltip:"LMB: Установить ID для всех островов в соответствии с номером UDIMs, это необходимо для создания Multimat\nLMB+CTRL: Другой метод | Set IDs to all islands according to UDIMs number, need for Multimat\nLMB+CTRL: Alternate method"
		button btn_udims_as_ids "IDs\x2192UDIMs" width:65 offset:[8,0] tooltip:"LMB: Разместить все острова по UDIMS согласно их ID\nLMB+CTRL: не масштабировать, а только разложить без смещения | LMB: Fits all islands in UDIMS by IDs\nLMB+CTRL: Do not rescale, but only place without offset"
		spinner spn_bricks_unwrap_sc2 "" range:[0.0, 100.0, 0.95] offset:[-10,0] type:#float fieldWidth:36 width:36 tooltip:"Масштабировать UDIM до значения [0-1] | Scale to UDIM value [0-1]"
		button btn_render_mat "Render Material" width:80 offset:[0,0] align:#right tooltip:"LMB: Отрендерить каналы VIZ Multimaterial выбранного объекта в текстуры и сохранить по текущему пути\n\nRMB: Отрендерить VIZ Multimaterial выбранного объекта в UDIM текстуры, собрать из них Diffuse, Normal, ERM и сохранить по текущему пути | LMB: Render channels of VIZ Multimaterial of selected object to textures and put to current path\n\nRMB: Render VIZ Multimaterial of selected object to UDIM textures, make Diffuse, Normal, ERM and put to current path"

		button btn_Condense "Condense" offset:[0,0] across:4 align:#left tooltip:"LMB: Сократить Multimaterial до числа используемых в объекте ID, создает новые объект и материал. После можно нажать кнопку IDs to UDIMS | LMB: Condense MultiMaterial and Object's IDs, makes new object and material. After press IDs to UDIMS"
		button btn_id_roll "IDs Roll" offset:[-5,0] tooltip:"LMB: Сдвинуть ID в объекте на указанное число, обычно требуется освободить первый ID для процедуры рендеринга в текстуру | LMB: Rolls IDs of object to specified number, usually need to free first ID for Render To Texture Procedure"
		spinner spn_id_roll "ID offset" range:[-100, 100, 1] scale:1 type:#integer fieldwidth:25 width:30 offset:[50,0] tooltip:""
		button btn_editor " Editor... " align:#right tooltip:"LMB: Создать диалоговое окно для создания текстур Opacity и ERM\nRMB: Создать диалоговое окно для редактирования текстур под развертку UVW и смешивания текстур | LMB: Create Dialog for creation Opacity and ERM textures\nRMB: Create Dialog to Edit textures and UVWs"
	)		
	group "UDIMs Unwrap HighPoly"
	(
		button btn_bricks_unwrap_pressed "" width:1 height:1 across:5 align:#left tooltip:""
		button btn_bricks_unwrap_rightclick "" width:1 height:1 offset:[0,2] align:#left tooltip:""
		button btn_bricks_unwrap "Unwrap Tiles" width:100 offset:[-104,0] align:#left tooltip:"LMB: Собрать все части развертки в один UDIM, работает c отдельными лоскутами развертки, можно использовать разные методы или полностью автоматически\nRMB: Собрать развертку скоростным методом, используя текущее выделение граней | LMB: Unwrap Tiles to one UDIM, may work with different methods or fully automatical\nRMB: Make packing with speed method, use current FACES selection"
		button btn_poly_to_edges_selector "Faces to Edges" offset:[-38,0] width:80 tooltip:"LMB: Перенос выделенных FACES на параллельные EDGES из EDITABLE POLY в новый модификатор UVW UNWRAP, который необходим для разбивки ребер на тексельные острова\nLMB+CTRL: Перенос выделенных FACES на EDGES с триангулированным объектом | LMB: Transfer selected FACES to parallel EDGES from EDITABLE POLY to new UVW UNWRAP modifier, need for breaking edges for texels islands.\nLMB+CTRL: Transfer selected FACES to EDGES with triangulated object"
		button btn_bricks_flatten "W Flatten UVW" offset:[0,0] width:80 align:#right tooltip:"Свести все лоскуты развертки к нулю по оси W | Flatten UVW texels to zero in W-Axiz"

		--spinner spn_bricks_unwrap_udim "UDIM" range:[1001, 1100, 1001] offset:[0,0] enabled:false type:#integer width:30 fieldWidth:30 align:#right tooltip:"Move result to selected tile"
	
		button btn_bricks_unwrap_new "Unwrap Landscape" width:100 across:3 align:#left tooltip:"LMB: Собрать все части развертки в один UDIM, работает с островами развертки\nLMB+CTRL: Собрать развертку с выделением ребер в триангулированной модели\nRMB: Собрать развертку скоростным методом, используя текущее выделение ребер\nВыбрать EDGES ребра или-и FACES и нажмите кнопку | LMB: Make Landscape Unwrap packing to UDIM with selection of parallel edges\nLMB+CTRL: Make packing with EDGES selection in triangulated model\nRMB: Make packing with speed method, use current edges selection\nSelect EDGES or-and FACES and press button"
		button btn_edges_selector "Select Edges" offset:[10,0] width:80 tooltip:"LMB: Выбрать параллельные ребра в EDITABLE POLY объекте, нужно когда выделение потеряно после Slice\nRMB: Выбрать 'правильные' ребра в триангулированном EDITABLE POLY объекте | LMB: Select parallel edges in EDITABLE POLY object, need if lost selection after Slice modifiers\nRMB: Select 'good' edges in triangulated EDITABLE POLY object"
		button btn_transfer_edges "Transfer Edges" offset:[0,0] width:80 align:#right tooltip:"Трансфер выбранных ребер из EDITABLE POLY в новый модификатор развертки UVW UNWRAP, необходимо для разделения ребер у тексельных островов | Transfer selected EDGES from EDITABLE POLY to new UVW UNWRAP modifier, need for breaking edges for texels islands"

		button btn_bricks_unwrap_get_num "Get Texel" width:60 offset:[0,0] enabled:false align:#left across:3 tooltip:"Выбрать один тексель из выделения, этот тексель будет основным для разбивки других текселей, он должен быть выше и шире, чем любой другой | Get single texel from selection, this texel will be main to tile other texels, it should be higher and wider than anyone"
		spinner spn_bricks_unwrap_num "Num" range:[1, 10000000, 1] offset:[-35,2] type:#integer fieldWidth:40 enabled:false tooltip:"Выбранный тексель для укладки | To be selected texel for tiling"
		radiobuttons rdo_unwrap_method labels: #("Centers","\x21D6","\x21D7","Integers","\x21D9","\x21D8") offsets:#([0,0], [0,0], [-30,0], [0,0], [0,0], [-30,0]) default:5 columns:3 rows:2 offset:[65,0] align:#right tooltip:"Использовать для перемещения углы текселей ul: верх-левый, ur: верх-правый, dl: вниз-левый, dr: вниз-правый\nCenter: перемещать центры островов к центрам UDIM\nIntegers: перемещать округленное положение островов к центрам UDIM | Corners, ul: up-left, ur: up-right, dl: down-left, dr: down-right.\nTiles using corners by maximum dimension of texel island, usually produce better results of tiling small parts\nCenters: Tiles by moving via centers of islands to centers of UDIMs\nIntegers: Tiles by moving via centers of islands by integer parts in UDIMs"

		button btn_bricks_unwrap_get_island "Get Island" width:60 offset:[0,-10] enabled:false align:#left across:4 tooltip:"Выбрать остров текселей из выделенных, этот остров будет основным для укладки других текселей, он должен быть выше и шире всех остальных | Get texels island from selection, this island will be main to tile other texels, it should be higher and wider than anyone"
		label lbl_bricks_unwrap_get_island "#{}" width:70 align:#left height:16 offset:[0,-8] style_sunkenedge:true enabled:false tooltip:"Выбранные тексели EDITABLE POLY для укладки | To be selected texels or polys for tiling"
		checkbox chk_bricks_unwrap_treshold "Treshold" checked:true offset:[25,0] tooltip:"Использовать порог для размещения текселей | Use treshhold for placing texels"
		spinner spn_bricks_unwrap_treshold "" range:[-1, 1, 0.05] align:#right offset:[0,0] type:#float fieldWidth:30 tooltip:""

		checkbox chk_unwrap_texel_or_poly "Find maxi texel / island" checked:true align:#left across:3 offset:[0,0] tooltip:"Искать тексель (или остров) с максимальными размерами, необходимо для определения масштаба | Find texel (or texels island) with maximum dimensions, need to findout Scale"
		checkbox chk_bricks_unwrap_unfold "Unfold" checked:false offset:[70,0] tooltip:"Сделать новую развертку для всех текселей вместо использования существующей развертки | Use new UNFOLD to all texels instead of using existing mapping"
		checkbox chk_bricks_unwrap_pack "Pack" checked:false offset:[0,0] align:#right tooltip:"Ставить сначала основной тексель\остров как можно ближе в UDIM, это приблизит другие тексели\острова, но уничтожит начальное смещение в текстуре | Set main texel\island to UDIM as much close as possible, this will pack closer other texels\islands, but destroy initial offset in texture"

		checkbox chk_bricks_unwrap_scale "Scale Texels" checked:false align:#left across:4 offset:[0,0] tooltip:"Использовать масштабирование текселей, чтобы вписать их в UDIM целиком; уничтожает начальное смещение в текстуре | Use scale texels to fit in UDIMs,\ndestroys initial offset in texture"
		checkbox chk_bricks_unwrap_width "Width" checked:true offset:[25,0] tooltip:"Использовать ширину для изменения масштаба текселей | Use width to rescale texels to fit in UDIMs"
		checkbox chk_bricks_unwrap_height "Height" checked:true offset:[20,0] tooltip:"Использовать высоту для изменения масштаба текселей | Use height to rescale texels to fit in UDIMs"
		checkbox chk_bricks_unwrap_redo "Move" checked:true align:#right offset:[0,0] tooltip:"Переместить в конце пропущенные тексели в первый UDIM | After all job done, try to move missed texels to first UDIM"
	
		checkbox chk_bricks_unwrap_cut "UDIM UV Slicer" checked:false align:#left across:4 offset:[0,0] tooltip:"Автоматическая нарезка объекта по сетке для каждого UDIM, метод №1. Использует POLY срезы, автор Фридрих Ханиш, friedrich@3d-io.com\nУбедитесь, что у вас есть UV-острова размером более одного UDIM | Auto Slice object for every UDIM Grid of UV texels, Method #1: uses Poly Slices, by Friedrich Hanisch, friedrich@3d-io.com\nBe sure you have UV islands larger than one UDIM"
		checkbox chk_bricks_unwrap_cut2 "#2" checked:false offset:[40,0] tooltip:"Автоматическая нарезка объекта по сетке для каждого UDIM, метод №2. Убедитесь, что у вас нет развертки в координате W у UVW, не делает разрез вдоль W координаты. Убедитесь, что у вас есть UV-острова размером более одного UDIM. Необходимо удалить плохие вершины и выполнить сварку вершин | Auto Slice object for every UDIM Grid of UV texels, Method #2\nBe sure, you do not have unwrap in W coordinate of UVW, its do not cut along W.\nBe sure you have UV islands larger than one UDIM\nYou should after Remove bad Verts and do Vertex Weld"
		checkbox chk_bricks_unwrap_rescale "Density" checked:false offset:[15,0] tooltip:"Изменить масштаб выбранных текселей до целевой плотности текселя (см. ниже), уничтожив начальное смещение в текстуре | Also Rescale selected texels to Target Texels Density (see lower), destroys initial offset in texture"
		checkbox chk_bricks_unwrap_undo "Undo Off" checked:false align:#right offset:[10,0] tooltip:"Отключить буфер отмены во время работы для экономии памяти. Можно удалить модификатор Unwrap UVW, чтобы отменить результат | Turn Undo buffer Off during operation for memory saving. Delete Unwrap UVW modifier to undo result"

		button btn_Udim_Rescale "ReScale Density" width:80 across:3 align:#left tooltip:"LMB: Масштабирование до целевой плотности текселей: взять среднее значение из всех плотностей выделенных текселей и отмасштабировать UV-развертку до целевой плотности текселей\nПодробнее см. в меню Texels Density UDIMs | LMB: Rescale UV unwrap to target texels density: take a middle value of all densities of selection and rescales UV unwrap to target texels density\nSee more in dialog: Texels Density UDIMs"
		dropdownlist ddl_texture_Rescale_size "" items:#("256", "512", "1024", "2048", "4096") selection:5 width:52 fieldWidth:52 offset:[-5,0] tooltip:"Размеры текстуры:\n256*256 пикселей,\n512*512 пикселей,\n1024*1024 пикселей,\nдопустимое значение: 2048*2048 пикселей,\nдопустимое значение: 4096*4096 пикселей | Texture dimensions:\n256*256 pixels,\n512*512 pixels,\n1024*1024 pixels,\nvalid: 2048*2048 pixels,\nvalid: 4096*4096 pixels" 
		spinner spn_Udim_Rescale_Density "Target density" range:[0.001, 100000.0, 1380.0] scale:0.1 type:#float offset:[0,0] fieldWidth:45 width:60 align:#right tooltip:"Целевое значение плотности текселей [512..1706] | Target texels density value [512..1706]"

		button btn_unwrap_windows "Unwrap Windows" width:100 across:3 align:#left offset:[0,10] tooltip:"Развернуть все окна в один UDIM с одинаковой плотностью текселей\nЛучший результат при ручном повороте на параллельную ось | Unwrap all windows to single UDIM with equal texel density\nBetter result with manual rotation to parallel axis"
		spinner spn_unwrap_windows "Sash" range:[0.001, 1000.0, 1.0] scale:0.1 type:#float fieldWidth:35 width:110 offset:[-25,10] tooltip:"Расстояние для поиска оконных стекол, стекла ближе указанного расстояния, обрабатываются как кластер | Distance range to search windows glasses, near distance treats as single cluster"
		spinner spn_unwrap_windows_rotation_acc "Accuracy" range:[0.0, 360.0, 1.0] scale:0.1 type:#float fieldWidth:35 width:110 align:#right offset:[0,10] tooltip:"Точность шага вращения | Accuracy of rotation step"

		checkbox chk_unwrap_windows_rotation "Rotate UV" checked:true offset:[0,0] across:3 align:#left tooltip:"Повернуть UVW карту к окну | Rotate UVW map to window"
		checkbox chk_unwrap_windows_align "Align" checked:false offset:[40,0] tooltip:"Выровнить UVW карту к окну | Align UVW map to window"
		checkbox chk_unwrap_windows_flatten "Flatten" checked:true offset:[0,0] align:#right tooltip:"Сгладить развертку UVW по оси W | Flatten UVW in W-axis"
	)
	group "UDIMs Unwrap LowPoly"
	(	
		dropdownlist ddl_size_atlas "" items: #("256","512","1024","2048","4096") selection:4 width:60 fieldWidth:60 across:3 tooltip:"Размер текстуры для низкополигонального атласа: подходящие размеры - 256, 512, 1024, 2048, а 4096 только для тестирования | Texture size for lowpoly atlas:\ngood - 256, 512, 1024, 2048\nfor testing only - 4096"
		button btn_unwrap_lowpoly_from_material "Unwrap to Atlas" width:90 align:#left offset:[-20,0] tooltip:"LMB: Собрать все текстуры и развертки выбранных объектов в общий атлас НПМ. Предварительно можно нажать Multisub HP\nLMB+CTRL: Большие заглушки\nLMB+ALT: Масштабировать в диапазон плотности [10..40]\nLMB+Shift: Фильтрация Lancos | LMB: Collect all textures from selected objects and all UDIMs to 5 Lowpoly Atlases\nMay press Render Material or Multisub HP before\nLMB+CTRL: Large 256x256 textures\nLMB+ALT: Fit densites range [10..40]\nLMB+Shift: Use Lancos resize filter"
		--button btn_MakePlanes "Make Planes" width:70 across:2 offset:[0,0] tooltip:"Make lowpoly planes around selected plants objects"
		button btn_MakeLowpolyPlant "Make LowPoly Tree" width:100 align:#right tooltip:"Сделать низкополигональное дерево из высокополигонального дерева | Make lowpoly tree from highpoly tree"		
	)		
	group "UDIMs Transforms"
	(	
		button btn_UdimLeft "UDIM\x2190" width:48 across:6 align:#left tooltip:"Переместить выделенные тексели в ЛЕВЫЙ UDIM | Move selected texels to LEFT UDIM"
		button btn_UdimRight "UDIM\x2192" width:48 offset:[11,0] tooltip:"Переместить выделенные тексели в ПРАВЫЙ UDIM | Move selected texels to RIGHT UDIM"
		button btn_UdimUp "UDIM\x2191" width:48 offset:[16,0] tooltip:"Переместить выделенные тексели в ВЕРХНИЙ UDIM | Move selected texels to UP UDIM"
		button btn_UdimDown "UDIM\x2193" width:48 offset:[20,0] tooltip:"Переместить выделенные тексели в НИЖНИЙ UDIM | Move selected texels to DOWN UDIM"
		button btn_UdimRotate "\x27F2" width:20 offset:[15,0] tooltip:"LMB: Повернуть остров и ориентировать его вертикально по самому длинному краю\nLMB+CTRL: по второму по длине краю, полезно при триангуляции\nLMB+ALT: ориентировать горизонтально | LMB: Rotate island and orient it vertical by longest edge\nLMB+CTRL: by second longest edge, useful if triangulated\nLMB+ALT: orient horizontal"
		button btn_UdimMove "Move" width:40 offset:[0,0] align:#right tooltip:"LMB: Переместить выделенные тексели в центр первого UDIM\nLMB+ALT: Переместить выделенные тексели островами\nLMB+CTRL: Переместить выделенные тексели по отдельности с разрывом\nRMB: Разложить выделенные острова со смещением по UDIM | LMB: Move selected texels to first's UDIM center\nLMB+ALT: Move selected texels by islands\nLMB+CTRL: Move selected texels individualy with break\nRMB: Arrange the selected islands with an offsets in UDIM"
		button btn_UdimScale "Scale To" offset:[0,0] across:5 align:#left tooltip:"LMB: Найти масштаб относительно размера UDIM по самому большому выделенному текселю, отмасштабировать выбранные тексели\nLMB+CTRL: Масштабировать выбранные острова как самый большой остров\nLMB+ALT: Масштабировать отдельные острова, чтобы они соответствовали друг другу\nLMB+CTRL+ALT: Масштабировать все выбранные острова до размера самого большого острова | LMB: Find Scale relative to UDIM size from largest texel of selection, Scale selected texels.\nLMB+CTRL: Scale selected as largest island\nLMB+ALT: Scale selected individual by islands to fit each other\nLMB+CTRL+ALT: Scale all selected to size of largest island"
		spinner spn_bricks_unwrap_sc "" range:[0.0, 100.0, 0.95] offset:[15,0] type:#float fieldWidth:40 width:40 tooltip:"Масштабировать UDIM до значения [0-1] | Scale to UDIM value [0-1]"
		button btn_UdimFit "Fit To" offset:[5,0] width:40 tooltip:"LMB: Вместить выбранные тексели в первый UDIM\nLMB+CTRL: Вместить в ближайший UDIM\nLMB+ALT: Вместить все карты в текущем ID материала\nОтметить Tex\Mat, чтобы подогнать текстуру\материал\n\nRMB: Подогнать текстуру к UV острову | LMB: Fit selected texels to first UDIM\nLMB+CTRL: Fit to UDIM with center of selection\nLMB+ALT: Fits all textures in current Mat ID\n\nCheck Tex\Mat to also FIT Texture\Material\n\nRMB: Fit texture to UV island"
		checkbox chk_UdimFit "Tex\Mat" checked:false offset:[0,0] tooltip:"После подгонки, также изменить масштаб текстуры или всех текстур в материале для этого UDIM | After FITing Texels to UDIM, also rescale Texture\All Textures in Material for this UDIM"
		button btn_UdimFitMat "Fit Mat" align:#right width:40 offset:[0,0] tooltip:"LMB: Вместить выбранные тексели в ближайшие к ним UDIMы с учетом множителя отступа согласно ID, переразмерить все текстуры в мультиматериале под развертку по ID\nLMB+CTRL: собрать все ID в первом UDIM | LMB: Fit the selected texels into the nearest UDIMs with offset multiplier according IDs, and resize all textures in the Multimaterial according to IDs\nLMB+CTRL: collect all IDs in the first UDIM"
	)
	
	on UDIMs open do
	(
		btn_name_from_sel.pressed()
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png"
		
		for i in UDIMs.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_UDIMs.ini") i.name "UDIMs" 1)
	)
	
	on chk_bricks_unwrap_cut changed arg do
	(
		if arg then chk_bricks_unwrap_cut2.checked = false
	)		
	
	on chk_bricks_unwrap_cut2 changed arg do
	(
		if arg then chk_bricks_unwrap_cut.checked = false
	)		
	
	on edt_object_name changed arg do
	(
		edt_tex_diffuse_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_Diffuse_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_diffuse_name.text = (substitutestring edt_tex_diffuse_name.text "_Main" "")
		edt_tex_normal_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_Normal_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_normal_name.text = (substitutestring edt_tex_normal_name.text "_Main" "")
		edt_tex_erm_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_ERM_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_erm_name.text = (substitutestring edt_tex_erm_name.text "_Main" "")
			
		edt_object_addr.text = (substitutestring edt_object_name.text "SM_" "")
		tt = filterstring edt_object_name.text "_"
		if tt.count > 1 then
		(
			edt_object_addr.text = ""
			for t = 1 to tt.count do 
			(
				if tt[t] == "SM" or tt[t] == "M" or tt[t] == "T" then continue
				if (for t1 = 1 to tt.count where tt[t1] == "77" collect tt[t1]).count == 0  and tt[t] == "001" or tt[t] == "002" or tt[t] == "003" or tt[t] == "004" or tt[t] == "005" then continue	
				if tt[t] == "Main" then continue
				if tt[t] == "Ground" then continue
				if tt[t] == "GroundEl" then continue						
				if tt[t] == "Flora" then continue
				if tt[t] == "Glass" or tt[t] == "MainGlass" or tt[t] == "GroundGlass" or tt[t] == "GroundElGlass" then continue	
				if edt_object_addr.text != "" then edt_object_addr.text += "_"
				edt_object_addr.text += tt[t]
			)
		)
	)
	
	on edt_object_name entered arg do
	(
		edt_tex_diffuse_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_Diffuse_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_diffuse_name.text = (substitutestring edt_tex_diffuse_name.text "_Main" "")
		edt_tex_normal_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_Normal_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_normal_name.text = (substitutestring edt_tex_normal_name.text "_Main" "")
		edt_tex_erm_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_ERM_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_erm_name.text = (substitutestring edt_tex_erm_name.text "_Main" "")
			
		edt_object_addr.text = (substitutestring edt_object_name.text "SM_" "")
		tt = filterstring edt_object_name.text "_"
		if tt.count > 1 then
		(
			edt_object_addr.text = ""
			for t = 1 to tt.count do 
			(
				if tt[t] == "SM" or tt[t] == "M" or tt[t] == "T" then continue
				if (for t1 = 1 to tt.count where tt[t1] == "77" collect tt[t1]).count == 0  and tt[t] == "001" or tt[t] == "002" or tt[t] == "003" or tt[t] == "004" or tt[t] == "005" then continue	
				if tt[t] == "Main" then continue
				if tt[t] == "Ground" then continue
				if tt[t] == "GroundEl" then continue						
				if tt[t] == "Flora" then continue
				if tt[t] == "Glass" or tt[t] == "MainGlass" or tt[t] == "GroundGlass" or tt[t] == "GroundElGlass" then continue	
				if edt_object_addr.text != "" then edt_object_addr.text += "_"
				edt_object_addr.text += tt[t]
			)
		)
	)	

	on edt_object_addr changed arg do
	(
		--print arg
		local stri 
		local tt = #()
		stri = trimright (trimleft arg (parse_error_symbols arg)) (parse_error_symbols arg)
		stri = substituteString stri " " ""
		stri = substituteString stri "\\" ""
		stri = substituteString stri "." ""
		stri = substituteString stri "," ""	
		stri = substituteString stri "(" ""			
		stri = substituteString stri ")" ""			
		while findstring stri "__" != undefined do stri = substituteString stri "__" "_"	
		--stri = trimright stri "_"
		--stri = trimleft stri "_"
		
		local obj = edt_object_name.text
		local str = ""
		for i = 1 to stri.count do 
		(
			case of 
			(
				(i == 1): str += toupper stri[i]
				(i > 1): if stri[i-1] == "_" then str += toupper stri[i] else str += stri[i]
				--default: str += stri[i]
			)
		)
		stri = str	

		tt = #()
		if obj != "" then tt = filterstring obj "_" splitEmptyTokens:true			
		if tt.count > 0 then
		(
			obj = "SM_" + stri + "_"
			for t = 1 to tt.count do 
			(
				case of
				(
					--(tt[t] == "SM" or tt[t] == "M" or tt[t] == "T" ): (obj += "SM_" + stri + "_")
					(delete_only_digits tt[t] == "" ): (if findstring stri tt[t] == undefined then obj += tt[t]; if obj != "" then obj += "_")
					(tt[t] == "Main" ): (obj += tt[t])
					(tt[t] == "Ground" ): (obj += tt[t])
					(tt[t] == "GroundEl" ): (obj += tt[t])					
					(tt[t] == "Flora" ): (obj += tt[t])
					(tt[t] == "Glass" or tt[t] == "MainGlass" or tt[t] == "GroundGlass" or tt[t] == "GroundElGlass" ): (obj += tt[t])	
					default: continue --edt_object_name.text += edt_object_addr.text
				)
			)
		)	
		while findstring obj "__" != undefined do obj = substituteString obj "__" "_"
		
		edt_tex_diffuse_name.text = (substitutestring obj "SM_" "T_") + "_Diffuse_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_diffuse_name.text = (substitutestring edt_tex_diffuse_name.text "_Main" "")
		edt_tex_normal_name.text = (substitutestring obj "SM_" "T_") + "_Normal_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_normal_name.text = (substitutestring edt_tex_normal_name.text "_Main" "")
		edt_tex_erm_name.text = (substitutestring obj "SM_" "T_") + "_ERM_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_erm_name.text = (substitutestring edt_tex_erm_name.text "_Main" "")

		edt_object_name.text = if obj != "" then obj else stri
		edt_object_addr.text = stri
	)

	on edt_object_addr entered arg do
	(
		--print arg
		local stri 
		local tt = #()
		stri = trimright (trimleft arg (parse_error_symbols arg)) (parse_error_symbols arg)
		stri = substituteString stri " " ""
		stri = substituteString stri "\\" ""
		stri = substituteString stri "." ""
		stri = substituteString stri "," ""	
		stri = substituteString stri "(" ""			
		stri = substituteString stri ")" ""			
		while findstring stri "__" != undefined do stri = substituteString stri "__" "_"	
		stri = trimright stri "_"
		stri = trimleft stri "_"
		
		local obj = edt_object_name.text
		local str = ""
		for i = 1 to stri.count do 
		(
			case of 
			(
				(i == 1): str += toupper stri[i]
				(i > 1): if stri[i-1] == "_" then str += toupper stri[i] else str += stri[i]
				--default: str += stri[i]
			)
		)
		stri = str	

		tt = #()
		if obj != "" then tt = filterstring obj "_" splitEmptyTokens:true			
		if tt.count > 0 then
		(
			obj = "SM_" + stri + "_"
			for t = 1 to tt.count do 
			(
				case of
				(
					--(tt[t] == "SM" or tt[t] == "M" or tt[t] == "T" ): (obj += "SM_" + stri + "_")
					(delete_only_digits tt[t] == "" ): (if findstring stri tt[t] == undefined then obj += tt[t]; if obj != "" then obj += "_")
					(tt[t] == "Main" ): (obj += tt[t])
					(tt[t] == "Ground" ): (obj += tt[t])
					(tt[t] == "GroundEl" ): (obj += tt[t])					
					(tt[t] == "Flora" ): (obj += tt[t])
					(tt[t] == "Glass" or tt[t] == "MainGlass" or tt[t] == "GroundGlass" or tt[t] == "GroundElGlass" ): (obj += tt[t])	
					default: continue --edt_object_name.text += edt_object_addr.text
				)
			)
		)	
		while findstring obj "__" != undefined do obj = substituteString obj "__" "_"
		
		edt_tex_diffuse_name.text = (substitutestring obj "SM_" "T_") + "_Diffuse_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_diffuse_name.text = (substitutestring edt_tex_diffuse_name.text "_Main" "")
		edt_tex_normal_name.text = (substitutestring obj "SM_" "T_") + "_Normal_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_normal_name.text = (substitutestring edt_tex_normal_name.text "_Main" "")
		edt_tex_erm_name.text = (substitutestring obj "SM_" "T_") + "_ERM_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_erm_name.text = (substitutestring edt_tex_erm_name.text "_Main" "")

		edt_object_name.text = if obj != "" then obj else stri
		edt_object_addr.text = stri
	)	
	
	on edt_material_object_number changed arg do 
	(
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + arg as string + "*Diffuse*" + edt_material_mat_number.text + "*.png"
	)
	
	on edt_material_object_number entered arg do 
	(
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + arg as string + "*Diffuse*" + edt_material_mat_number.text + "*.png"
	)
	
	on edt_path_end changed arg do 
	(
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png"
	)
	
	on edt_path_end entered arg do 
	(
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png"
	)

	on edt_material_mat_number changed arg do 
	(
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + arg as string + "*.png"
	)
	
	on edt_material_mat_number entered arg do 
	(
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + arg as string + "*.png"
	)
		
	on rdo_path changed state do 
	(
		case rdo_path.state of
		(
			1: edt_multimat_path.text = maxFilePath + "Maps\\"
			2: edt_multimat_path.text = maxFilePath + "Images\\"
			3: edt_multimat_path.text = maxFilePath + edt_path_end.text + "\\"
		)
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png"		
	)
	
	on ddl_material_object_number selected txt do 
	(
		edt_material_object_number.text = ddl_material_object_number.items[txt] as string
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png"		
	)

	on chk_unwrap_texel_or_poly changed state do 
	(
		case state of
		(
			true:
			(
				lbl_bricks_unwrap_get_island.enabled = false
				btn_bricks_unwrap_get_island.enabled = false
				spn_bricks_unwrap_num.enabled = false
				btn_bricks_unwrap_get_num.enabled = false
			)
			false:
			(
				--lbl_bricks_unwrap_get_island.enabled = true
				--btn_bricks_unwrap_get_island.enabled = true
				spn_bricks_unwrap_num.enabled = true
				btn_bricks_unwrap_get_num.enabled = true				
			)
		)
	)
	
	on btn_name_to_sel pressed do
	(
		if selection.count > 0 then 
			for i in selection do i.name = edt_object_name.text
	)
	
	on btn_check_copy pressed do
	(
		setclipboardText edt_object_addr.text
	)
	
	on btn_check_paste pressed do
	(
		edt_object_addr.text = getclipboardText()
	)
	
	on btn_check_names pressed do
	(
		local err = ""
		local adr = edt_object_addr.text
		--проверка недопустимых символов
		t = parse_error_symbols adr
		if t != "" then 
		(
			if findstring t "." != undefined then err += "\x2716 " + adr + ": адрес содержит недопустимые символы точки «.»\n"
			else err += "\x2716 " + adr + ": адрес содержит недопустимые символы\n"
		)
		else err += "\x2714 " + adr + ": адрес не содержит недопустимые символы\n"

		excel_file1 = GetDir #maxroot + "GeoScripts\\abbr3.csv" --для проверки сокращений в имени архива в поле адреса
		excel_file2 = GetDir #maxroot + "GeoScripts\\abbr4.csv" --для проверки сокращений в имени архива в поле строений
		stri_arr1 = #()
		stri1 = #()
		stri_long1 = #()
		stri_arr2 = #()
		stri2 = #()
		stri_long2 = #()
		stri_arr1 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file1 ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "файл abbr3.csv не найден или не открывается")
		stri_arr2 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file2 ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "файл abbr4.csv не найден или не открывается")
	
		if stri_arr1.count > 0 do 
		(
			for i in #{1..stri_arr1.count} do append stri1 (filterstring stri_arr1[i] ";")[2] 
			for i in #{1..stri_arr1.count} do append stri_long1 (translit (filterstring stri_arr1[i] ";")[1])
			qsort stri1 sortexcel_len --сортировка по длинне строк, длинные в начале, чтобы потом заменять
			qsort stri_long1 sortexcel_len --сортировка по длинне строк, длинные в начале, чтобы потом заменять										
		)
								
		if stri_arr2.count > 0 do 
		(
			for i in #{1..stri_arr2.count} do append stri2 (filterstring stri_arr2[i] ";")[2] 
			for i in #{1..stri_arr2.count} do append stri_long2 (translit (filterstring stri_arr2[i] ";")[1])
			qsort stri2 sortexcel_len --сортировка по длинне строк, длинные в начале, чтобы потом заменять
			qsort stri_long2 sortexcel_len --сортировка по длинне строк, длинные в начале, чтобы потом заменять										
		)

		excel_file_ul = GetDir #maxroot + "GeoScripts\\ul5.csv" --для проверки существующих названий улиц
		excel_file_pos = GetDir #maxroot + "GeoScripts\\ul4.csv" --для проверки существующих названий поселений
		stri_arr3 = #()
		stri_arr4 = #()
		stri_arr3 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file_ul ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "файл ul5.csv не найден или не открывается")
		stri_arr4 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file_pos ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "файл ul4.csv не найден или не открывается")

		stri_ul = #()
		stri_ul_full = #()
		stri_pos = #()
		stri_pos_pre = #()

		if stri_arr3.count > 0 do 
		(
			for i in #{1..stri_arr3.count} do append stri_ul_full (filterstring stri_arr3[i] ";")[3] 
			for i in #{1..stri_arr3.count} do append stri_ul (filterstring stri_arr3[i] ";")[4] 
		)
		if stri_arr4.count > 0 do 
		(
			for i in #{1..stri_arr4.count} do append stri_pos_pre (filterstring stri_arr4[i] ";")[2] 
			for i in #{1..stri_arr4.count} do append stri_pos (filterstring stri_arr4[i] ";")[3] 
		)		

/*		
		excel_file = GetDir #maxroot +"\\GeoScripts\\abbr2.csv" --для проверки сокращений в имени 
							
		stri_arr = #()
		stri = #()
		stri_long = #()
		stri_arr = try ((dotNetClass "System.IO.File").ReadAllLines excel_file ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "файл abbr2.csv не найден или не открывается")
		--print #(stri_arr)
	
		if stri_arr.count > 0 do 
		(
			for i in #{1..stri_arr.count} do append stri (filterstring stri_arr[i] ";")[2] 
			for i in #{1..stri_arr.count} do append stri_long (translit (filterstring stri_arr[i] ";")[1])
			qsort stri sortexcel_len --сортировка по длинне строк, длинные в начале, чтобы потом заменять
			qsort stri_long sortexcel_len --сортировка по длинне строк, длинные в начале, чтобы потом заменять										
		)
		--print #(stri)	
		--print (stri_long)									
				
		excel_file_ul = GetDir #maxroot +"\\GeoScripts\\ul3.csv" --для проверки существующих названий улиц
		stri_arr = #()
		stri_arr = try ((dotNetClass "System.IO.File").ReadAllLines excel_file_ul ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "файл ul3.csv не найден или не открывается")
		stri_ul = #()
		--print #(stri_arr)
		if stri_arr.count > 0 do 
		(
			for i in #{1..stri_arr.count} do append stri_ul (filterstring stri_arr[i] ";")[3] 
		)
*/								
		--проверки в имени 
		t = adr
		if t != translit t then err += "\x2716 " + adr + ": адрес содержит недопустимые символы не в транслите\n"
		if findstring t " " != undefined then err += "\x2716 " + adr + ": адрес содержит символы пробела « »\n"
		if findstring t "_" == undefined then err += "\x2716 " + adr + ": адрес не содержит символы разделения «_»\n"
		else
		(
			tt = #()
			tt_ini = #()
			tt = filterstring t "_"
			tt_ini = filterstring t "_"
			if tt.count > 0 then
			(
				--проверка первых букв SM
				--if tt[1] != "SM" then err += "\x2716 " + adr + ": адрес содержит ошибки именования, первый элемент должен «SM»\n"
				--проверка первых букв 

				for t1 in #{1..tt.count} do
				(		
					tt[t1][1] = toupper tt[t1][1]  
					if tt[t1] != tt_ini[t1] then err += "\x2716 " + adr + ": адрес возможно содержит ошибки именования, каждое слово должно начинаться с заглавной буквы: " + tt_ini[t1] + "\n"
				)
				print #(tt)		
				
				--проверка если цифры вперемешку с буквами
				for t1 in #{1..tt.count} do
				(		
					tt[t1] = delete_only_digits tt[t1] 
					if tt[t1] != "" and tt[t1] != tt_ini[t1] then err += "\x2716 " + adr + ": адрес возможно содержит ошибки именования, цифры отделяются от других элементов адреса подчеркиванием: " + tt_ini[t1] + "\n"
				)
				print #(tt)
/*										
				--проверка существующих названий улиц
				for t1 in #{1..tt.count} where tt[t1] != "" do
				(		
					for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul[t2] "" --подставляем полный список улиц
					if tt[t1] == tt_ini[t1] then err += "\x2716 " + adr + ": адрес возможно содержит ошибки именования, название не входит в Официальный «Общемосковский классификатор улиц Москвы»: " + tt_ini[t1] + "\n"
				)
				print #(tt)
										
				--проверка если есть несокращенные названия элементов адреса
				for t1 in #{1..tt.count} where tt[t1] != "" do
				(		
					for t2 in #{1..stri_long.count} do tt[t1] = substitutestring tt[t1] stri_long[t2] "" --подставляем полный список эл-тов адреса
					if tt[t1] != tt_ini[t1] then err += "\x2716 " + adr + ": адрес возможно содержит ошибки именования, не сокращены элементы адреса: " + tt_ini[t1] + "\n"
				)
				print #(tt)

				-- Название улицы не должно разделяться нижним подчеркиванием, а должно быть записано слитно, при этом каждое новое слово пишется с большой буквы.
				for t1 in #{1..tt.count} where tt[t1] != "" do
				(		
					for t2 in #{1..stri.count} do tt[t1] = substitutestring tt[t1] stri[t2] "" --подставляем список сокращений эл-тов адреса
					if tt[t1] != tt_ini[t1] then err += "\x2716 " + adr + ": адрес возможно содержит ошибки именования, не должно быть разделения элементов адреса или, возможно, неправильно именованы элементы адреса, название элемента адреса не должно разделяться нижним подчеркиванием, а должно быть записано слитно, при этом каждое новое слово пишется с большой буквы :" + tt_ini[t1] + "\n"											
				)
				print #(tt)
				
*/
				--проверка если есть несокращенные названия элементов адреса
				for t1 in #{1..tt.count} where tt[t1] != "" do
				(		
					for t2 in #{1..stri_long1.count} do tt[t1] = substitutestring tt[t1] stri_long1[t2] "" --подставляем полный список эл-тов адреса
					if tt[t1] != tt_ini[t1] then err += "\x2716 " + adr + ": адрес возможно содержит ошибки именования, не сокращены элементы адреса: " + tt_ini[t1] + "\n"
				)
				print #(tt)	
										
				--проверка существующих названий улиц и поселков
				for t1 in #{1..tt.count} where tt[t1] != "" and t1 <= 3 do
				(		
					for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul_full[t2] "" --подставляем полный список улиц
					for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] ("Pos" + stri_pos[t2]) "" --подставляем полный список поселков
					for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] (stri_pos_pre[t2] + stri_pos[t2]) "" --подставляем полный список поселков

					for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul[t2] "" --подставляем полный список улиц
					for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] stri_pos[t2] "" --подставляем полный список поселков
			
					if tt[t1] == tt_ini[t1] then err += "\x2716 " + adr + ": адрес возможно содержит ошибки именов??ния, название не входит в Официальный «Общемосковский классификатор улиц Москвы»: " + tt_ini[t1] + "\n"
				)
				print #(tt)

				-- Название улицы не должно разделяться нижним подчеркиванием, а должно быть записано слитно, при этом каждое новое слово пишется с большой буквы.
				for t1 in #{1..tt.count} where tt[t1] != "" do
				(		
					for t2 in #{1..stri1.count} do tt[t1] = substitutestring tt[t1] stri1[t2] "" --подставляем список сокращений эл-тов адреса
					if tt[t1] != tt_ini[t1] then err += "\x2716 " + adr + ": адрес возможно содержит ошибки именования, не должно быть разделения элементов адреса или, возможно, неправильно именованы элементы адреса, название элемента адреса не должно разделяться нижним подчеркиванием, а должно быть записано слитно, при этом каждое новое слово пишется с большой буквы :" + tt_ini[t1] + "\n"
				)
				print #(tt)		

				--последующие теги
				for t1 in #{1..tt.count} where tt[t1] != "" do
				(		
					for t2 in #{1..stri2.count} do tt[t1] = substitutestring tt[t1] stri2[t2] "" --подставляем список сокращений эл-тов адреса
					if tt[t1] == "D" or tolower tt[t1] == "dom" then err += "\x2716 ;1.3.1.; " + adr + ": адрес возможно содержит ошибки именования, сокращение D как «дом» опускается: " + tt_ini[t1] + " \n"											
					if tt[t1] == "Uch" then err += "\x2716 ;1.3.1.; " + adr + ": адрес возможно содержит ошибки именования, «Uch» желательно заменить на «ZU»: " + tt_ini[t1] + " \n"											
					if tt[t1] == tt_ini[t1] then err += "\x2716 ;1.3.1.; " + adr + ": адрес возможно содержит ошибки именования, сокращение элемента адреса не входит в список: " + tt_ini[t1] + " \n"											
				)
				print #(tt)									
			)
		)
		messagebox err		
	)

	on btn_unwrap_windows pressed do with undo "Unwrap Windows" on 
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			s = selection[1]
			max create mode
			faces = #{1..(polyop.getnumfaces s)}
			elems = faces_to_elements s faces 
			print #(elems)
			clusters = #()
			found = false
			first = true
			for el in elems where not keyboard.escPressed do
			(
				if first then 
				(
					append clusters el
					first = false
				)
				found = false
				ind = 1		
				for c in #{1..clusters.count} where dist s el clusters[c] spn_unwrap_windows.value and not keyboard.escPressed do 
				(			
					found = true
					ind = c
					exit
				)
				if found then 
				(
					join clusters[ind] el
					found = false
				)
				else append clusters el
			)
			print #(clusters)
			print clusters.count
			
			--max create mode
			max modify mode
			wins = #()
			gab = #()
			if clusters.count > 0 then
			(
				for c in clusters where not keyboard.escPressed do
				(
					print #(c)
					max modify mode
					--max create mode
					polyop.detachfaces s c asNode:true delete:false name:(s.name + "_window001")
					win = maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))
					if chk_unwrap_windows_rotation.checked then append gab (get_gabarites win) else append gab (amax #(win.max.x - win.min.x, win.max.y - win.min.y, win.max.z - win.min.z ))
					append wins win
				)
				sc = amax gab
				format "" sc

				if wins.count > 0 then
				(
					for win in wins where not keyboard.escPressed do
					(	
						select win
						--polyop.applyUVWMap s #box utile:1.0 vtile:1.0 wtile:1.0 uflip:false vflip:false wflip:false cap:true tm: channel:1
						centerpivot win 
						
						if chk_unwrap_windows_rotation.checked then
						(
							max modify mode --max create mode
							angles = rotate_to_min_Y win (2.0 * spn_unwrap_windows_rotation_acc.value) -90.0 90.0
							angles = rotate_to_min_Y win (0.1 * spn_unwrap_windows_rotation_acc.value) (angles - 5) (angles + 5)
							rotate win (eulerangles 0 0 angles)
							resetxform win
							converttopoly win
						)							
						addmodifier win (uvwmap length:sc width:sc height:sc maptype:4 axis:2)
						
						if chk_unwrap_windows_rotation.checked then rotate win (eulerangles 0 0 -angles)
						--giz = win.modifiers[1].Gizmo
						--giz.rotation.z = angles
						if chk_unwrap_windows_align.checked then alignUVGizmo win win.uvwmap 
						--FitUVWMapToFace win win.uvwmap 
							--polyop.freeVData <Poly poly> <int vdChannel>
							--polyop.resetVData <Poly poly> <int vdChannel>
					)
					
					if wins.count > 1 then
					(
						max modify mode
						if chk_unwrap_windows_rotation.checked then resetxform wins[1]
						converttopoly wins[1] 
						for w in #{2..wins.count} do polyop.attach wins[1] wins[w]  
					)
					addmodifier wins[1] (Unwrap_UVW())
					wins[1].name = s.name
					wins[1].pivot = s.pivot
					select wins[1]
					max modify mode	
					if chk_unwrap_windows_flatten.checked then btn_bricks_flatten.pressed()
					chk = chk_UdimFit.checked 
					wins[1].modifiers[1].selectFaces #{1..wins[1].modifiers[1].numberPolygons()}
					wins[1].modifiers[1].setTVSubObjectMode 3 
					
					chk_UdimFit.checked = false 
					btn_UdimFit.pressed()
					chk_UdimFit.checked = chk
					delete s
				)
			)
		)
	)
	
	on btn_render_mat rightclick do
	(
		if selection.count > 0 then
		(
			local start = GetINI_ImageMagick()
			local nam
			local m, sub_m
			local size
			local udim 
			local difuse, normal, erm, erm_r, erm_g, erm_b, erm_temp, tex_r, tex_g, tex_b
			local mats = #()
			local mats_r = #()
			local mats_g = #()
			local mats_b = #()
			
			for i in selection where i.material != undefined and not keyboard.escPressed do
			(	
				nam = i.name
				nam = substitutestring nam "_Main" ""
				nam = substitutestring nam "SM_" "T_"
				
				m = i.material

				size = case rdo_tex.state of
				(
					1: 256
					2: 512
					3: 1024
					4: 2048
					5: 4096
				)		
				
				case (classof m) of
				(
					
					shell_material: messagebox "Shell_Material do not supported" 
					
					CoronaLegacyMtl:
					(
					)
					
					CoronaPhysicalMtl:
					(
					)
					
					Physical_Material:
					(
					)
	
					Standardmaterial:
					(
					)
								
					Multimaterial: 
					(
						for id in #{1..m.numsubs} where m.materialList[id] != undefined and not keyboard.escPressed do
						(
							sub_m = m.materialList[id]
							
							udim = (id + 1000) as string
							format "ID = %, UDIM = %\n" id udim
							if not doesDirectoryExist edt_multimat_path.text then makeDir edt_multimat_path.text
							difuse = edt_multimat_path.text + nam + "_Diffuse_1." + udim + ".png"
							normal = edt_multimat_path.text + nam + "_Normal_1." + udim + ".png"
							erm = edt_multimat_path.text + nam + "_ERM_1." + udim + ".png"
							erm_r = edt_multimat_path.text + nam + "_ERM_1." + udim + "_r.png"
							erm_g = edt_multimat_path.text + nam + "_ERM_1." + udim + "_g.png"
							erm_b = edt_multimat_path.text + nam + "_ERM_1." + udim + "_b.png"
							erm_temp = edt_multimat_path.text + nam + "_ERM_1." + udim + "_temp.png"
						
							mats = map_type sub_m "diffuse"
							format "diffuse %\n" #(mats)
							render_map_diffuse mats[1] mats[2] mats[3] mats[4] size difuse start
							
							mats = map_type sub_m "opacity"
							format "opacity %\n" #(mats)
							render_map_opacity mats[1] mats[2] mats[3] mats[4] size difuse start
							
							mats = map_type sub_m "normal"
							format "normal %\n" #(mats)
							render_map_bump mats[1] mats[2] mats[3] mats[4] size normal start
							
							--для ERM по одной карте добавляем в канал, если есть - текстуру, если нет то цвет (или черный)
							mats_b = map_type sub_m "reflect"
							mats_g = map_type sub_m "reflect_glossiness"
							mats_r = map_type sub_m "selfillum"
							
							format "reflect %\n" #(mats_b)
							format "reflect_glossiness %\n" #(mats_g)
							format "selfillum %\n" #(mats_r)
							
							tex_b = get_tex_filename mats_b[1]
							tex_g = get_tex_filename mats_g[1]
							tex_r = get_tex_filename mats_r[1]

							--если в пути текстуры был _ERM_, просто копируем текстуру, если нет, то создаем новый _ERM_ поканально, начиная с рефлекта в металлисити (Рафнесс в глоссинесс, металлисити в рефлект)		
							if findstring (getfilenamefile tex_b) "_ERM_" != undefined or findstring (getfilenamefile tex_g) "_ERM_" != undefined or findstring (getfilenamefile tex_r) "_ERM_" != undefined then
							(
								local tex_resize = ""
								if findstring (getfilenamefile tex_b) "_ERM_" != undefined then tex_resize = tex_b
								if findstring (getfilenamefile tex_g) "_ERM_" != undefined then tex_resize = tex_g
								if findstring (getfilenamefile tex_r) "_ERM_" != undefined then tex_resize = tex_r
								--print tex_resize
								
								local resize = tex_equal_size tex_resize 256
								--print resize
								local need_resizeto_256 = false 
								
								local tex_resize_temp = tex_resize + ".png"
								
								--HiddenDOSCommand ("magick " + "\"" + tex_resize + "\"" + " -separate -threshold 50%% -combine -colors 32 -unique-colors " + "\"" + tex_resize_temp + "\"") startpath:start
								HiddenDOSCommand ("magick " + "\"" + tex_resize + "\"" + " -colors 4096 -unique-colors " + "\"" + tex_resize_temp + "\"") startpath:start
								local bt = openBitMap tex_resize_temp gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
								if bt != undefined then
								(
									if bt.width == 1 then need_resizeto_256 = true else need_resizeto_256 = false
									close bt
									free bt
								)
								if doesFileExist tex_resize_temp then deleteFile tex_resize_temp
									
								if not resize and need_resizeto_256 then 
								(
									HiddenDOSCommand ("magick " + "\"" + tex_resize + "\"" + " -resize 256x256^! -alpha remove -alpha off -define png:color-type=6 " + "\"" + erm + "\"") startpath:start
									HiddenDOSCommand ("magick " + "\"" + erm + "\"" + " PNG24:" + "\"" + erm + "\"") startpath:start				
								)
								
								if not resize and not need_resizeto_256 then
								(
									HiddenDOSCommand ("magick " + "\"" + tex_resize + "\"" + " -resize " + size as string + "x" + size as string + "^! -alpha remove -alpha off -define png:color-type=6 " + "\"" + erm + "\"") startpath:start
									HiddenDOSCommand ("magick " + "\"" + erm + "\"" + " PNG24:" + "\"" + erm + "\"") startpath:start				
								)
								
								if resize and need_resizeto_256 then
								(
									HiddenDOSCommand ("magick " + "\"" + tex_resize + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + erm + "\"") startpath:start
									HiddenDOSCommand ("magick " + "\"" + erm + "\"" + " PNG24:" + "\"" + erm + "\"") startpath:start				
								)
							)
							else
							(
								render_map_reflect mats_b[1] mats_b[2] mats_b[3] mats_b[4] size erm_b start
								render_map_glossiness mats_g[1] mats_g[2] mats_g[3] mats_g[4] size erm_g start							
								render_map_selfillum mats_r[1] mats_r[2] mats_r[3] mats_r[4] size erm_r start
								
								--HiddenDOSCommand ("magick " + "\"" + erm_r + "\"" + " ( " + "\"" + erm_g + "\"" + " -negate ) " + "\"" + erm_b + "\"" + " -channel red,green,blue -combine -set colorspace sRGB -define png:color-type=6 " + "\"" + erm + "\"") startpath:start
								--HiddenDOSCommand ("magick " + "\"" + erm_r + "\"" + " " + "\"" + erm_g + "\"" + " " + "\"" + erm_b + "\"" + " -channel red,green,blue -combine -set colorspace sRGB -define png:color-type=6 " + "\"" + erm + "\"") startpath:start
								HiddenDOSCommand ("magick " + "\"" + erm_r + "\"" + " " + "\"" + erm_g + "\"" + " " + "\"" + erm_b + "\"" + " -channel red,green,blue -combine -set colorspace RGB -colorspace RGB -define png:color-type=6 " + "\"" + erm + "\"") startpath:start
								HiddenDOSCommand ("magick " + "\"" + erm + "\"" + " PNG24:" + "\"" + erm + "\"") startpath:start	
								
								--HiddenDOSCommand ("magick " + "\"" + erm + "\"" + " -separate -threshold 50%% -combine -colors 32 -unique-colors " + "\"" + erm_temp + "\"") startpath:start
								HiddenDOSCommand ("magick " + "\"" + erm + "\"" + " -colors 4096 -unique-colors " + "\"" + erm_temp + "\"") startpath:start
								need_resizeto_256 = false
								local bt = openBitMap erm_temp gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
								if bt != undefined then
								(
									if bt.width == 1 then need_resizeto_256 = true else need_resizeto_256 = false
									close bt
									free bt
								)
								else need_resizeto_256 = false
								if doesFileExist erm_temp then deleteFile erm_temp
								if need_resizeto_256 then 
								(
									HiddenDOSCommand ("magick " + "\"" + erm + "\"" + " -resize 256x256^! -alpha remove -alpha off -define png:color-type=6 " + "\"" + erm + "\"") startpath:start
									HiddenDOSCommand ("magick " + "\"" + erm + "\"" + " PNG24:" + "\"" + erm + "\"") startpath:start				
								)
								if doesFileExist erm_r then deleteFile erm_r
								if doesFileExist erm_g then deleteFile erm_g
								if doesFileExist erm_b then deleteFile erm_b	
							)
							
							/*
							case classof sub_m of
							(
								CoronaLegacyMtl:
								(
									--showproperties sub_m
									--format "id=% diff=% mat=%\n" id difuse sub_m.texmapDiffuse.filename
									if sub_m.texmapDiffuse != undefined then
									(
										if isProperty sub_m.texmapDiffuse #filename then copy_mat sub_m.texmapDiffuse.filename difuse start
										else render_map sub_m.texmapDiffuse rez difuse
										--render_map_diffuse sub_m.texmapDiffuse sub_m.texmapOpacity rez difuse start 
									)
									else if not doesfileexist difuse then
									(
										HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX sub_m.colorDiffuse + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:difuse color:sub_m.colorDiffuse gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:start --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start
									)

									if sub_m.texmapBump != undefined then
									(		
										if isProperty sub_m.texmapBump #filename then copy_mat sub_m.texmapBump.filename normal start
										else render_map sub_m.texmapBump rez normal
										--render_map_bump sub_m.texmapBump rez normal start
									)
									else if not doesfileexist normal then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:start --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start
									)
										
									if sub_m.texmapReflect != undefined then
									(
										if isProperty sub_m.texmapReflect #filename then copy_mat sub_m.texmapReflect.filename erm start
										else render_map sub_m.texmapReflect rez erm
									)
									else if not doesfileexist erm then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:start --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start
									)
									--sub_m.texmapSelfIllum
									
									--if sub_m.texmapReflect != undefined then render_map sub_m.texmapReflect rez (edt_multimat_path.text + sub_m.name + "_Reflect" + ".png")
									--if sub_m.texmapReflectGlossiness != undefined then render_map sub_m.texmapReflectGlossiness rez (edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png")
									--if sub_m.texmapRefract != undefined then render_map sub_m.texmapRefract rez (edt_multimat_path.text + sub_m.name + "_Refract" + ".png")
									--if sub_m.texmapRefractGlossiness != undefined then render_map sub_m.texmapRefractGlossiness rez (edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png")
									--if sub_m.texmapOpacity != undefined then render_map sub_m.texmapOpacity rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
									--if sub_m.texmapTranslucency != undefined then render_map sub_m.texmapTranslucency rez (edt_multimat_path.text + sub_m.name + "_Translucency" + ".png")
									--if sub_m.texmapDisplace != undefined then render_map sub_m.texmapDisplace rez (edt_multimat_path.text + sub_m.name + "_Displace" + ".png")
									--if sub_m.texmapSelfIllum != undefined then render_map sub_m.texmapSelfIllum rez (edt_multimat_path.text + sub_m.name + "_SelfIllum" + ".png")
								)
								
								CoronaPhysicalMtl:
								(
									if sub_m.baseTexmap != undefined then
									(
										if isProperty sub_m.baseTexmap #filename then copy_mat sub_m.baseTexmap.filename difuse start
										else render_map sub_m.baseTexmap rez difuse
									)
									else if not doesfileexist difuse then
									(
										b = bitmap 256 256 filename:difuse color:sub_m.baseColor gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:start --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start
									)
									
									if sub_m.baseBumpTexmap != undefined then
									(		
										if isProperty sub_m.baseBumpTexmap #filename then copy_mat sub_m.baseBumpTexmap.filename normal start
										else render_map sub_m.baseBumpTexmap rez normal
									)
									else if not doesfileexist normal then
									(											
										b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:start --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start
									)
									--metalnessTexmap
									if sub_m.baseRoughnessTexmap != undefined then
									(
										if isProperty sub_m.baseRoughnessTexmap #filename then copy_mat sub_m.baseRoughnessTexmap.filename erm start
										else render_map sub_m.baseRoughnessTexmap rez erm
									)
									else if not doesfileexist erm then
									(											
										b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:start --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start
									)																
								)
								
								Physical_Material:
								(
									if sub_m.base_color_map != undefined then
									(
										if isProperty sub_m.base_color_map #filename then copy_mat sub_m.base_color_map.filename difuse start
										else render_map sub_m.base_color_map rez difuse
									)
									else if not doesfileexist difuse then
									(
										b = bitmap 256 256 filename:difuse color:sub_m.base_color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:start --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start
									)
									
									if sub_m.bump_map != undefined then
									(		
										if isProperty sub_m.bump_map #filename then copy_mat sub_m.bump_map.filename normal start
										else render_map sub_m.bump_map rez normal
									)
									else if not doesfileexist normal then
									(											
										b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:start --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start
									)
										
									if sub_m.roughness_map != undefined then
									(
										if isProperty sub_m.roughness_map #filename then copy_mat sub_m.roughness_map.filename erm start
										else render_map sub_m.roughness_map rez erm
									)
									else if not doesfileexist erm then
									(											
										b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:start --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start
									)									
									-- .emission_map : texturemap 
									--emit_color
									--if sub_m.base_color_map != undefined then copy_mat sub_m.base_color_map.filename difuse (GetINI_ImageMagick())
									--if sub_m.roughness_map != undefined then render_map sub_m.roughness_map rez (edt_multimat_path.text + sub_m.name + "_Roughness" + ".png")
									--if sub_m.metalness_map != undefined then render_map sub_m.metalness_map rez (edt_multimat_path.text + sub_m.name + "_Metalness" + ".png")	
									--if sub_m.bump_map != undefined then copy_mat sub_m.bump_map.filename normal (GetINI_ImageMagick())
									--if sub_m.cutout_map != undefined then render_map sub_m.cutout_map rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
								
								Standardmaterial:
								(
									if sub_m.DiffuseMap != undefined then
									(
										if isProperty sub_m.DiffuseMap #filename then copy_mat sub_m.DiffuseMap.filename difuse start
										else render_map sub_m.DiffuseMap.filename rez difuse
									)
									else if not doesfileexist difuse then
									(
										b = bitmap 256 256 filename:difuse color:sub_m.diffuse gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:start --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start
									)

									if sub_m.BumpMap != undefined then
									(		
										if isProperty sub_m.BumpMap #filename then copy_mat sub_m.BumpMap.filename normal start
										else render_map sub_m.BumpMap rez normal
									)
									else if not doesfileexist normal then
									(											
										b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:start --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start
									)
										
									if sub_m.ReflectionMap != undefined then
									(
										if isProperty sub_m.ReflectionMap #filename then copy_mat sub_m.ReflectionMap.filename erm start
										else render_map sub_m.ReflectionMap rez erm
									)
									else if not doesfileexist erm then
									(											
										b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:start --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start
									)									
									
									--if sub_m.DiffuseMap != undefined then copy_mat sub_m.DiffuseMap.filename difuse	(GetINI_ImageMagick())		
									--if sub_m.BumpMap != undefined then copy_mat sub_m.BumpMap.filename normal (GetINI_ImageMagick())
									--if sub_m.ReflectionMap != undefined then render_map sub_m.ReflectionMap rez (edt_multimat_path.text + sub_m.name + "_Reflection" + ".png")
									--if sub_m.GlossinessMap != undefined then render_map sub_m.GlossinessMap rez (edt_multimat_path.text + sub_m.name + "_Glossiness" + ".png")
									--if sub_m.OpacityMap != undefined then render_map sub_m.OpacityMap rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
							)
							*/
						)
					)					
				)
			)
		)			
	)
	
	on btn_render_mat pressed do
	(
		if selection.count > 0 then
		(
			rez = case rdo_tex.state of
			(
				1: 256
				2: 512
				3: 1024
				4: 2048
				5: 4096
			)			

			for i in selection where i.material != undefined and not keyboard.escPressed do
			(	
				if not doesDirectoryExist edt_multimat_path.text then makedir edt_multimat_path.text
				m = i.material
				print edt_multimat_path.text
				print i
				print (classof m)
				case (classof m) of
				(
					CoronaLegacyMtl:
					(
						if m.texmapDiffuse != undefined then render_map m.texmapDiffuse rez (edt_multimat_path.text + m.name + "_Diffuse" + ".png")
						if m.texmapReflect != undefined then render_map m.texmapReflect rez (edt_multimat_path.text + m.name + "_Reflect" + ".png")
						if m.texmapReflectGlossiness != undefined then render_map m.texmapReflectGlossiness rez (edt_multimat_path.text + m.name + "_ReflectGlossiness" + ".png")
						if m.texmapRefract != undefined then render_map m.texmapRefract rez (edt_multimat_path.text + m.name + "_Refract" + ".png")
						if m.texmapRefractGlossiness != undefined then render_map m.texmapRefractGlossiness rez (edt_multimat_path.text + m.name + "_RefractGlossiness" + ".png")
						if m.texmapOpacity != undefined then render_map m.texmapOpacity rez (edt_multimat_path.text + m.name + "_Opacity" + ".png")
						if m.texmapBump != undefined then render_map m.texmapBump rez (edt_multimat_path.text + m.name + "_Bump" + ".png")
						if m.texmapTranslucency != undefined then render_map m.texmapTranslucency rez (edt_multimat_path.text + m.name + "_Translucency" + ".png")
						if m.texmapDisplace != undefined then render_map m.texmapDisplace rez (edt_multimat_path.text + m.name + "_Displace" + ".png")
						if m.texmapSelfIllum != undefined then render_map m.texmapSelfIllum rez (edt_multimat_path.text + m.name + "_SelfIllum" + ".png")
					)
					
					CoronaPhysicalMtl:
					(
					)
					
					Physical_Material:
					(
						if m.base_color_map != undefined then render_map m.base_color_map rez (edt_multimat_path.text + m.name + "_Diffuse" + ".png")
						if m.roughness_map != undefined then render_map m.roughness_map rez (edt_multimat_path.text + m.name + "_Roughness" + ".png")
						if m.metalness_map != undefined then render_map m.metalness_map rez (edt_multimat_path.text + m.name + "_Metalness" + ".png")	
						if m.bump_map != undefined then render_map m.bump_map rez (edt_multimat_path.text + m.name + "_Bump" + ".png")
						if m.cutout_map != undefined then render_map m.cutout_map rez (edt_multimat_path.text + m.name + "_Opacity" + ".png")
					)
	
					Standardmaterial:
					(
						if m.DiffuseMap != undefined then render_map m.DiffuseMap rez (edt_multimat_path.text + m.name + "_Diffuse" + ".png")				
						if m.BumpMap != undefined then render_map m.BumpMap rez (edt_multimat_path.text + m.name + "_Bump" + ".png")
						if m.ReflectionMap != undefined then render_map m.ReflectionMap rez (edt_multimat_path.text + m.name + "_Reflection" + ".png")
						if m.GlossinessMap != undefined then render_map m.GlossinessMap rez (edt_multimat_path.text + m.name + "_Glossiness" + ".png")
						if m.OpacityMap != undefined then render_map m.OpacityMap rez (edt_multimat_path.text + m.name + "_Opacity" + ".png")
					)
								
					Multimaterial: 
					(
						for sub_m in m.materialList where not keyboard.escPressed do
						(
							case classof sub_m of
							(
								CoronaLegacyMtl:
								(
									if sub_m.texmapDiffuse != undefined then render_map sub_m.texmapDiffuse rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")
									if sub_m.texmapReflect != undefined then render_map sub_m.texmapReflect rez (edt_multimat_path.text + sub_m.name + "_Reflect" + ".png")
									if sub_m.texmapReflectGlossiness != undefined then render_map sub_m.texmapReflectGlossiness rez (edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png")
									if sub_m.texmapRefract != undefined then render_map sub_m.texmapRefract rez (edt_multimat_path.text + sub_m.name + "_Refract" + ".png")
									if sub_m.texmapRefractGlossiness != undefined then render_map sub_m.texmapRefractGlossiness rez (edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png")
									if sub_m.texmapOpacity != undefined then render_map sub_m.texmapOpacity rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
									if sub_m.texmapBump != undefined then render_map sub_m.texmapBump rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
									if sub_m.texmapTranslucency != undefined then render_map sub_m.texmapTranslucency rez (edt_multimat_path.text + sub_m.name + "_Translucency" + ".png")
									if sub_m.texmapDisplace != undefined then render_map sub_m.texmapDisplace rez (edt_multimat_path.text + sub_m.name + "_Displace" + ".png")
									if sub_m.texmapSelfIllum != undefined then render_map sub_m.texmapSelfIllum rez (edt_multimat_path.text + sub_m.name + "_SelfIllum" + ".png")
								)
								
								CoronaPhysicalMtl:
								(
									
								)
								
								Physical_Material:
								(
									if sub_m.base_color_map != undefined then render_map sub_m.base_color_map rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")
									if sub_m.roughness_map != undefined then render_map sub_m.roughness_map rez (edt_multimat_path.text + sub_m.name + "_Roughness" + ".png")
									if sub_m.metalness_map != undefined then render_map sub_m.metalness_map rez (edt_multimat_path.text + sub_m.name + "_Metalness" + ".png")	
									if sub_m.bump_map != undefined then render_map sub_m.bump_map rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
									if sub_m.cutout_map != undefined then render_map sub_m.cutout_map rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
								
								Standardmaterial:
								(
									if sub_m.DiffuseMap != undefined then render_map sub_m.DiffuseMap rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")				
									if sub_m.BumpMap != undefined then render_map sub_m.BumpMap rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
									if sub_m.ReflectionMap != undefined then render_map sub_m.ReflectionMap rez (edt_multimat_path.text + sub_m.name + "_Reflection" + ".png")
									if sub_m.GlossinessMap != undefined then render_map sub_m.GlossinessMap rez (edt_multimat_path.text + sub_m.name + "_Glossiness" + ".png")
									if sub_m.OpacityMap != undefined then render_map sub_m.OpacityMap rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
							)
						)
					)
				)
			)
		)
	)
	
	on btn_bricks_flatten pressed do with undo "Flatten UV" on
	(
		if selection.count == 1 then
		(
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(
				faces = unwrapmod.getselectedfaces() 
				verts = #{}
				if faces.isempty then
				(
					faces = #{1..unwrapmod.numberPolygons()}
					verts = #{1..unwrapmod.NumberVertices()}
				)
				else
				(
					unwrapmod.faceToVertSelect() 
					verts = unwrapmod.getSelectedVertices() 
				)
				--print #(verts)
				if verts.numberset > 0 then
				(
					--for i in verts do
					--(
						--print i
						--poi = unwrapmod.getvertexposition currenttime i
						--print poi
						unwrapmod.selectVertices verts -- #{i}
						unwrapmod.moveZ 0.0
						--unwrapmod.moveSelected [0, 0, -poi.z]
					--)
				)
			)	
		)		
	)
	
	on btn_editor pressed do
	(
		global sel = if selection.count > 0 then selection[1].name else "None"

		try(destroyDialog ::BitmapsEDITOR)catch()
		try(closeRolloutFloater BitmapsEDITOR)catch()
		BitmapsEDITOR = newRolloutFloater "Bitmaps" 500 850
		rollout TextureEditor "Texture Editor" autoLayoutOnResize:true width:500 height:850
		(
			group "Opacity texture from Diffuse texture Maker"
			(
				label lbl_d "Diffuse texture" across:2
				label lbl_o "Opacity texture" 
				imgtag img_tag_diffuse bitmap:(bitmap 200 200 color:(color 10 10 10) gamma:1.0 hdr:false alpha:true) width:200 height:200 style:#bmp_stretch across:3 align:#left
				label lbl_a "=>" offset:[0,100]
				imgtag img_tag_opacity bitmap:(bitmap 200 200 color:(color 255 255 255) gamma:1.0 hdr:false alpha:false) width:200 height:200 style:#bmp_stretch align:#right

				edittext edt_diffuse text:"" width:200 align:#left across:2
				edittext edt_opacity text:"" width:200 align:#right
						
				button bnt_get_diffuse_map "Open Diffuse texture" align:#left width:200 across:2 tooltip:""
				button btn_make_opacity_map "Make Opacity Texture" align:#right width:200 tooltip:""
				
			)
			group "ERM texture from Three other textures Maker"
			(
				--бегунки яркости каналов, текстуры меняют яркость от них, выбор цвета или текстуры на канал
				label lbl_e "Emission texture" across:3
				label lbl_r "Roughness texture" 	
				label lbl_m "Metallicity texture"
				imgtag img_tag_emission bitmap:(bitmap 150 150 color:(color 255 255 255) gamma:1.0 hdr:false alpha:true) width:150 height:150 style:#bmp_stretch align:#left across:3
				imgtag img_tag_roughness bitmap:(bitmap 150 150 color:(color 255 255 255) gamma:1.0 hdr:false alpha:false) width:150 height:150 style:#bmp_stretch align:#center
				imgtag img_tag_metallicity bitmap:(bitmap 150 150 color:(color 255 255 255) gamma:1.0 hdr:false alpha:false) width:150 height:150 style:#bmp_stretch align:#right
				edittext edt_emission text:"" width:150 align:#left across:3
				edittext edt_roughness text:"" width:150 align:#center
				edittext edt_metallicity text:"" width:150 align:#right
				radiobuttons rdo_emission labels:#("R", "G", "B") enabled:false offset:[30,0] width:150 height:10 default:1 columns:3 rows:1 across:3 align:#left tooltip:"Take selected Channel as R component for ERM texture"
				radiobuttons rdo_roughness labels:#("R", "G", "B") enabled:false offset:[30,0] width:150 height:10 default:2 columns:3 rows:1 align:#center tooltip:"Take selected Channel as G component for ERM texture"
				radiobuttons rdo_metallicity labels:#("R", "G", "B") enabled:false offset:[30,0] width:150 height:10 default:3 columns:3 rows:1 align:#right tooltip:"Take selected Channel as B component for ERM texture"

				button bnt_get_emission_map "Open Emission texture" align:#left width:150 across:3 tooltip:""
				button bnt_get_roughness_map "Open Roughness texture" align:#center width:150 tooltip:""
				button bnt_get_metallicity_map "Open Metallicity texture" align:#right width:150 tooltip:""
				spinner spn_emission "Emission power" range:[0, 255, 0] scale:1 type:#integer fieldwidth:50 width:150 align:#left across:3 tooltip:"0 - no light, 255 - maximum emission of light (color comes from diffuse color)"
				spinner spn_roughness "Roughness power" range:[0, 255, 255] scale:1 type:#integer fieldwidth:50 width:150 align:#center tooltip:"0 - completely gloss, 255 - completely matte, may use middle values"
				spinner spn_metallicity "Metallicity power" range:[0, 255, 0] scale:1 type:#integer fieldwidth:50 width:150 align:#right tooltip:"0 - means none metallic, 255 - means metallic, usually do not use middle values"
				
				label lbl_erm "ERM texture" align:#center
				imgtag img_tag_ERM bitmap:(bitmap 150 150 color:(color 0 255 0) gamma:1.0 hdr:false alpha:false) width:150 height:150 style:#bmp_stretch align:#center
				label lbl_erm2 "Name will be get from last open texture, Size as maximum of all sizes" align:#center
				edittext edt_ERM text:(UDIMs.edt_multimat_path.text + "ERM.png") width:450 align:#center
				button btn_make_ERM_map "Make ERM Texture" width:450 
			)
			--vec3 rgb_normal = normal * 0.5 + 0.5; // переход от [-1,1] к [0,1]   
			
			on btn_make_ERM_map pressed do
			(
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity
				local bitmap_large_ERM, bitmap_small_ERM
				
				if img_tag_emission.bitmap.filename != "" then
				(
					if doesfileexist img_tag_emission.bitmap.filename then bitmap_large_emission = openBitMap img_tag_emission.bitmap.filename else bitmap_large_emission = bitmap 150 150 color:(color 255 255 255)
				)
				else bitmap_large_emission = bitmap 150 150 color:(color 255 255 255)

				if img_tag_roughness.bitmap.filename != "" then
				(
					if doesfileexist img_tag_roughness.bitmap.filename then bitmap_large_roughness = openBitMap img_tag_roughness.bitmap.filename else bitmap_large_roughness = bitmap 150 150 color:(color 255 255 255)
				)
				else bitmap_large_roughness = bitmap 150 150 color:(color 255 255 255)
				
				if img_tag_metallicity.bitmap.filename != "" then
				(
					if doesfileexist img_tag_metallicity.bitmap.filename then bitmap_large_metallicity = openBitMap img_tag_metallicity.bitmap.filename else bitmap_large_metallicity = bitmap 150 150 color:(color 255 255 255) 
				)
				else bitmap_large_metallicity = bitmap 150 150 color:(color 255 255 255) 
				
				bitmap_small_ERM = img_tag_ERM.bitmap

				width = amax #(bitmap_large_emission.width, bitmap_large_roughness.width, bitmap_large_metallicity.width)
				height = amax #(bitmap_large_emission.height, bitmap_large_roughness.height, bitmap_large_metallicity.height)	

				bitmap_small_emission = bitmap width height color:(color 255 255 255) filename:bitmap_large_emission.filename
				bitmap_small_roughness = bitmap width height color:(color 255 255 255) filename:bitmap_large_roughness.filename
				bitmap_small_metallicity = bitmap width height color:(color 255 255 255) filename:bitmap_large_metallicity.filename
				
				bitmap_large_ERM = bitmap width height color:(color 255 255 255) alpha:false hdr:false gamma:1.0 --filename:(UDIMs.edt_multimat_path.text + "ERM.png") 
				
				copy bitmap_large_emission bitmap_small_emission
				copy bitmap_large_roughness bitmap_small_roughness
				copy bitmap_large_metallicity bitmap_small_metallicity
				
				line_bitmap_emission = #()
				line_bitmap_roughness = #()
				line_bitmap_metallicity = #()
				line_bitmap_ERM = #()

					for line_num in #{1..height} do
					(
						line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
						line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
						line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

						if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
						(		
							line_bitmap_ERM = #()
							for p in #{1..width} do 
							(
								p_emission = line_bitmap_emission[p]
								p_roughness = line_bitmap_roughness[p]
								p_metallicity = line_bitmap_metallicity[p]
								p_ERM = color (p_emission.r * spn_emission.value / 255) (p_roughness.g * spn_roughness.value / 255) (p_metallicity.b * spn_metallicity.value / 255)
								append line_bitmap_ERM p_ERM
							)	
						)				
						setPixels bitmap_large_ERM [0, line_num - 1] line_bitmap_ERM 
					)
	
					img_tag_ERM.bitmap = bitmap_small_ERM
					--edt_ERM.text = bitmap_large_ERM.filename
					if doesfileexist (getfilenamepath edt_ERM.text) then
					(
						bitmap_large_ERM.filename = edt_ERM.text
						save bitmap_large_ERM gamma:1.0 quiet:true --(UDIMs.edt_multimat_path.text + "ERM.png") 
					)
					close bitmap_large_ERM
					free bitmap_large_ERM
					close bitmap_small_emission
					close bitmap_small_roughness
					close bitmap_small_metallicity	
					free bitmap_small_emission
					free bitmap_small_roughness
					free bitmap_small_metallicity							
					close bitmap_large_emission						
					free bitmap_large_emission
					close bitmap_large_roughness
					free bitmap_large_roughness						
					close bitmap_large_metallicity
					free bitmap_large_metallicity
			)
			
			on TextureEditor open do
			(
				gc()
				img_tag_emission.bitmap = bitmap 150 150 color:(color ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer + 1))
				img_tag_roughness.bitmap = bitmap 150 150 color:(color ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer))
				img_tag_metallicity.bitmap = bitmap 150 150 color:(color ((255*spn_metallicity.value/255) as integer + 1) ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer))
				img_tag_ERM.bitmap = bitmap 150 150 color:(color ((255*spn_emission.value/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_metallicity.value/255) as integer))
			)
			
			on TextureEditor close do
			(
				gc()
				close img_tag_diffuse.bitmap
				close img_tag_emission.bitmap
				close img_tag_roughness.bitmap
				close img_tag_metallicity.bitmap
				close img_tag_ERM.bitmap
				free img_tag_diffuse.bitmap				
				free img_tag_emission.bitmap
				free img_tag_roughness.bitmap
				free img_tag_metallicity.bitmap
				free img_tag_ERM.bitmap				
			)
			
			on spn_emission changed valit do 
			(
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity
				
				val = if valit == 0 then 1 else valit 
				if img_tag_emission.bitmap.filename != "" then
				(
					if doesfileexist img_tag_emission.bitmap.filename then 
					(
						bitmap_large_emission = openBitMap img_tag_emission.bitmap.filename
						bitmap_small_emission = bitmap 150 150 filename:bitmap_large_emission.filename
						copy bitmap_large_emission bitmap_small_emission
						close bitmap_large_emission
						free bitmap_large_emission
					)
					else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) --bitmap_small_emission = bitmap 150 150 color:(color ((255*valit/255) as integer) ((255*valit/255) as integer) ((255*valit/255) as integer + 1))

				)
				else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255)

				if img_tag_roughness.bitmap.filename != "" then
				(
					if doesfileexist img_tag_roughness.bitmap.filename then 
					(					
						bitmap_large_roughness = openBitMap img_tag_roughness.bitmap.filename
						bitmap_small_roughness = bitmap 150 150 filename:bitmap_large_roughness.filename
						copy bitmap_large_roughness bitmap_small_roughness
						close bitmap_large_roughness
						free bitmap_large_roughness
					)
					else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) -- bitmap 150 150 color:(color ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer + 1))

				)
				else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer + 1))

				if img_tag_metallicity.bitmap.filename != "" then
				(
					if doesfileexist img_tag_metallicity.bitmap.filename then 
					(					
						bitmap_large_metallicity = openBitMap img_tag_metallicity.bitmap.filename
						bitmap_small_metallicity = bitmap 150 150 filename:bitmap_large_metallicity.filename
						copy bitmap_large_metallicity bitmap_small_metallicity
						close bitmap_large_metallicity
						free bitmap_large_metallicity
					)
					else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer + 1))

				)
				else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer + 1))

				bitmap_small_ERM = img_tag_ERM.bitmap
				
				line_bitmap_emission = #()
				line_bitmap_roughness = #()
				line_bitmap_metallicity = #()
				line_bitmap_ERM = #()

				width = 150 --pixels.width
				height = 150 --pixels.height				
				if bitmap_small_emission != undefined then
				(
					for line_num in #{1..height} do
					(
						line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
						line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
						line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

						if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
						(		
							line_bitmap_ERM = #()
							for p in #{1..width} do 
							(
								p_emission = line_bitmap_emission[p]
								p_roughness = line_bitmap_roughness[p]
								p_metallicity = line_bitmap_metallicity[p]
								p_ERM = color (p_emission.r * val / 255) (p_roughness.g * spn_roughness.value / 255) (p_metallicity.b * spn_metallicity.value / 255)
								append line_bitmap_ERM p_ERM
							)	
						)				
						line_bitmap_emission = for pixel in line_bitmap_emission collect (color (pixel.r * val / 255) (pixel.g * val / 255) (pixel.b * val / 255))
	
						setPixels bitmap_small_emission [0, line_num - 1] line_bitmap_emission 
						setPixels bitmap_small_ERM [0, line_num - 1] line_bitmap_ERM 
					)
					img_tag_emission.bitmap = bitmap_small_emission
					img_tag_ERM.bitmap = bitmap_small_ERM

					close bitmap_small_roughness
					close bitmap_small_metallicity				
					free bitmap_small_roughness
					free bitmap_small_metallicity	
				)
				--if img_tag_emission.bitmap.filename == "" and img_tag_roughness.bitmap.filename == "" and img_tag_metallicity.bitmap.filename == "" then 
				--(
				--	img_tag_emission.bitmap = bitmap 150 150 color:(color ((255*val/255) as integer) ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer + 1))
				--	img_tag_ERM.bitmap = bitmap 150 150 color:(color ((255*val/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_metallicity.value/255) as integer))
				--)
			)

			on spn_roughness changed valit do 
			(
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity
				
				val = if valit == 0 then 1 else valit 
				if img_tag_emission.bitmap.filename != "" then
				(
					if doesfileexist img_tag_emission.bitmap.filename then 
					(
						bitmap_large_emission = openBitMap img_tag_emission.bitmap.filename
						bitmap_small_emission = bitmap 150 150 filename:bitmap_large_emission.filename
						copy bitmap_large_emission bitmap_small_emission
						close bitmap_large_emission
						free bitmap_large_emission
					)
					else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer + 1))


				)
				else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer + 1))


				if img_tag_roughness.bitmap.filename != "" then
				(
					if doesfileexist img_tag_roughness.bitmap.filename then 
					(					
						bitmap_large_roughness = openBitMap img_tag_roughness.bitmap.filename
						bitmap_small_roughness = bitmap 150 150 filename:bitmap_large_roughness.filename
						copy bitmap_large_roughness bitmap_small_roughness
						close bitmap_large_roughness
						free bitmap_large_roughness
					)
					else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*valit/255) as integer) ((255*valit/255) as integer) ((255*valit/255) as integer + 1))

				)
				else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*valit/255) as integer) ((255*valit/255) as integer) ((255*valit/255) as integer + 1))

				if img_tag_metallicity.bitmap.filename != "" then
				(
					if doesfileexist img_tag_metallicity.bitmap.filename then 
					(					
						bitmap_large_metallicity = openBitMap img_tag_metallicity.bitmap.filename
						bitmap_small_metallicity = bitmap 150 150 filename:bitmap_large_metallicity.filename
						copy bitmap_large_metallicity bitmap_small_metallicity
						close bitmap_large_metallicity
						free bitmap_large_metallicity
					)
					else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer + 1))

				)
				else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer + 1))

				bitmap_small_ERM = img_tag_ERM.bitmap
				
				line_bitmap_emission = #()
				line_bitmap_roughness = #()
				line_bitmap_metallicity = #()
				line_bitmap_ERM = #()

				width = 150 --pixels.width
				height = 150 --pixels.height				
				if bitmap_small_roughness != undefined then
				(
					for line_num in #{1..height} do
					(
						line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
						line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
						line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

						if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
						(		
							line_bitmap_ERM = #()
							for p in #{1..width} do 
							(
								p_emission = line_bitmap_emission[p]
								p_roughness = line_bitmap_roughness[p]
								p_metallicity = line_bitmap_metallicity[p]
								p_ERM = color (p_emission.r * spn_emission.value / 255) (p_roughness.g * val / 255) (p_metallicity.b * spn_metallicity.value / 255)
								append line_bitmap_ERM p_ERM
							)	
						)				
						line_bitmap_roughness = for pixel in line_bitmap_roughness collect (color (pixel.r * val / 255) (pixel.g * val / 255) (pixel.b * val / 255))
	
						setPixels bitmap_small_roughness [0, line_num - 1] line_bitmap_roughness 
						setPixels bitmap_small_ERM [0, line_num - 1] line_bitmap_ERM 
					)
					img_tag_roughness.bitmap = bitmap_small_roughness
					img_tag_ERM.bitmap = bitmap_small_ERM

					close bitmap_small_emission
					close bitmap_small_metallicity				
					free bitmap_small_emission
					free bitmap_small_metallicity	
				)
			)

			on spn_metallicity changed valit do 
			(
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity
				
				val = if valit == 0 then 1 else valit 
				if img_tag_emission.bitmap.filename != "" then
				(
					if doesfileexist img_tag_emission.bitmap.filename then 
					(
						bitmap_large_emission = openBitMap img_tag_emission.bitmap.filename
						bitmap_small_emission = bitmap 150 150 filename:bitmap_large_emission.filename
						copy bitmap_large_emission bitmap_small_emission
						close bitmap_large_emission
						free bitmap_large_emission
					)
					else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer + 1))

				)
				else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer + 1))

				if img_tag_roughness.bitmap.filename != "" then
				(
					if doesfileexist img_tag_roughness.bitmap.filename then 
					(					
						bitmap_large_roughness = openBitMap img_tag_roughness.bitmap.filename
						bitmap_small_roughness = bitmap 150 150 filename:bitmap_large_roughness.filename
						copy bitmap_large_roughness bitmap_small_roughness
						close bitmap_large_roughness
						free bitmap_large_roughness
					)
					else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer + 1))

				)
				else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer + 1))

				if img_tag_metallicity.bitmap.filename != "" then
				(
					if doesfileexist img_tag_metallicity.bitmap.filename then 
					(					
						bitmap_large_metallicity = openBitMap img_tag_metallicity.bitmap.filename
						bitmap_small_metallicity = bitmap 150 150 filename:bitmap_large_metallicity.filename
						copy bitmap_large_metallicity bitmap_small_metallicity
						close bitmap_large_metallicity
						free bitmap_large_metallicity
					)
					else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*valit/255) as integer) ((255*valit/255) as integer) ((255*valit.value/255) as integer + 1))

				)
				else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*valit/255) as integer) ((255*valit/255) as integer) ((255*valit/255) as integer + 1))

				bitmap_small_ERM = img_tag_ERM.bitmap
				
				line_bitmap_emission = #()
				line_bitmap_roughness = #()
				line_bitmap_metallicity = #()
				line_bitmap_ERM = #()

				width = 150 --pixels.width
				height = 150 --pixels.height				
				if bitmap_small_metallicity != undefined then
				(
					for line_num in #{1..height} do
					(
						line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
						line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
						line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

						if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
						(		
							line_bitmap_ERM = #()
							for p in #{1..width} do 
							(
								p_emission = line_bitmap_emission[p]
								p_roughness = line_bitmap_roughness[p]
								p_metallicity = line_bitmap_metallicity[p]
								p_ERM = color (p_emission.r * spn_emission.value / 255) (p_roughness.g * spn_roughness.value / 255) (p_metallicity.b * val / 255)
								append line_bitmap_ERM p_ERM
							)	
						)				
						line_bitmap_metallicity = for pixel in line_bitmap_metallicity collect (color (pixel.r * val / 255) (pixel.g * val / 255) (pixel.b * val / 255))
	
						setPixels bitmap_small_metallicity [0, line_num - 1] line_bitmap_metallicity
						setPixels bitmap_small_ERM [0, line_num - 1] line_bitmap_ERM 
					)
					img_tag_metallicity.bitmap = bitmap_small_metallicity
					img_tag_ERM.bitmap = bitmap_small_ERM

					close bitmap_small_roughness
					close bitmap_small_emission				
					free bitmap_small_roughness
					free bitmap_small_emission	
				)
			)
			
			on bnt_get_diffuse_map pressed do
			(
				source = getOpenFileName "Select Diffuse map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then	
					(
						img_tag_diffuse.bitmap = openBitMap source 
						edt_diffuse.text = source --getfilenamefile source + getfilenametype source
						edt_opacity.text = getfilenamepath (img_tag_diffuse.bitmap.filename) + getfilenamefile (img_tag_diffuse.bitmap.filename) + "_Opacity" + getfilenametype (img_tag_diffuse.bitmap.filename)
					)
				)
			)
			
			on btn_make_opacity_map pressed do
			(
				if img_tag_diffuse.bitmap.filename != "" then
				(
					source = if edt_opacity.text != "" then edt_opacity.text else getfilenamepath (img_tag_diffuse.bitmap.filename) + getfilenamefile (img_tag_diffuse.bitmap.filename) + "_Opacity" + getfilenametype (img_tag_diffuse.bitmap.filename)
					if doesfileexist (getfilenamepath source) then HiddenDOSCommand ("magick " + "\"" + img_tag_diffuse.bitmap.filename + "\"" + " -transparent black -alpha extract -define png:color-type=6 " + "\"" + source + "\"") startpath:(GetINI_ImageMagick())
					edt_opacity.text = source --getfilenamefile source + getfilenametype source
					img_tag_opacity.bitmap = openBitMap source				
				)
				else messagebox "Make Opacity texture first"
			)
			
			on img_tag_diffuse mousedown do try(display (openBitMap (img_tag_diffuse.bitmap.filename) ))catch(bnt_get_diffuse_map.pressed())
			on img_tag_opacity mousedown do try(display (openBitMap (img_tag_opacity.bitmap.filename) ))catch(messagebox "Make Opacity texture first")

			on img_tag_emission mousedown do try(display (openBitMap (img_tag_emission.bitmap.filename) ))catch(bnt_get_emission_map.pressed())
			on img_tag_roughness mousedown do try(display (openBitMap (img_tag_roughness.bitmap.filename) ))catch(bnt_get_roughness_map.pressed())
			on img_tag_metallicity mousedown do try(display (openBitMap (img_tag_metallicity.bitmap.filename) ))catch(bnt_get_metallicity_map.pressed())
				
			on bnt_get_emission_map pressed do
			(
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity
				source = getOpenFileName "Select Emission map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then 		
					(
						bitmap_large_emission = openBitMap source
						bitmap_small_emission = bitmap 150 150 filename:bitmap_large_emission.filename
						copy bitmap_large_emission bitmap_small_emission
						img_tag_emission.bitmap = bitmap_small_emission
						edt_emission.text = getfilenamefile source + getfilenametype source
						spn_emission.value = 255

						if img_tag_roughness.bitmap.filename != "" then
						(
							if doesfileexist img_tag_roughness.bitmap.filename then 
							(					
								bitmap_large_roughness = openBitMap img_tag_roughness.bitmap.filename
								bitmap_small_roughness = bitmap 150 150 filename:bitmap_large_roughness.filename
								copy bitmap_large_roughness bitmap_small_roughness
								close bitmap_large_roughness
								free bitmap_large_roughness
							)
							else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) 
						)
						else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255)
						
						if img_tag_metallicity.bitmap.filename != "" then
						(
							if doesfileexist img_tag_metallicity.bitmap.filename then 
							(					
								bitmap_large_metallicity = openBitMap img_tag_metallicity.bitmap.filename
								bitmap_small_metallicity = bitmap 150 150 filename:bitmap_large_metallicity.filename
								copy bitmap_large_metallicity bitmap_small_metallicity
								close bitmap_large_metallicity
								free bitmap_large_metallicity
							)
							else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255)
						)
						else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) 
						
						bitmap_small_ERM = img_tag_ERM.bitmap
						
						line_bitmap_emission = #()
						line_bitmap_roughness = #()
						line_bitmap_metallicity = #()
						line_bitmap_ERM = #()

						width = 150 
						height = 150 				
						if bitmap_small_metallicity != undefined then
						(
							for line_num in #{1..height} do
							(
								line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
								line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
								line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

								if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
								(		
									line_bitmap_ERM = #()
									for p in #{1..width} do 
									(
										p_emission = line_bitmap_emission[p]
										p_roughness = line_bitmap_roughness[p]
										p_metallicity = line_bitmap_metallicity[p]
										p_ERM = color (p_emission.r * spn_emission.value / 255) (p_roughness.g * spn_roughness.value / 255) (p_metallicity.b * spn_metallicity.value / 255)
										append line_bitmap_ERM p_ERM
									)	
								)				
								setPixels bitmap_small_ERM [0, line_num - 1] line_bitmap_ERM 
							)
							img_tag_ERM.bitmap = bitmap_small_ERM
							edt_erm.text = UDIMs.edt_multimat_path.text + getfilenamefile source + "_ERM.png" 
							close bitmap_small_roughness
							close bitmap_small_metallicity				
							free bitmap_small_roughness
							free bitmap_small_metallicity	
						)
					)
				)
			)				
				
			on bnt_get_roughness_map pressed do
			(
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity				
				source = getOpenFileName "Select Roughness map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then 		
					(
						bitmap_large_roughness = openBitMap source
						bitmap_small_roughness = bitmap 150 150 filename:bitmap_large_roughness.filename
						copy bitmap_large_roughness bitmap_small_roughness
						img_tag_roughness.bitmap = bitmap_small_roughness
						edt_roughness.text = getfilenamefile source + getfilenametype source
						spn_roughness.value = 255

						if img_tag_emission.bitmap.filename != "" then
						(
							if doesfileexist img_tag_emission.bitmap.filename then 
							(
								bitmap_large_emission = openBitMap img_tag_emission.bitmap.filename
								bitmap_small_emission = bitmap 150 150 filename:bitmap_large_emission.filename
								copy bitmap_large_emission bitmap_small_emission
								close bitmap_large_emission
								free bitmap_large_emission
							)
							else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) 
						)
						else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255)

						if img_tag_metallicity.bitmap.filename != "" then
						(
							if doesfileexist img_tag_metallicity.bitmap.filename then 
							(					
								bitmap_large_metallicity = openBitMap img_tag_metallicity.bitmap.filename
								bitmap_small_metallicity = bitmap 150 150 filename:bitmap_large_metallicity.filename
								copy bitmap_large_metallicity bitmap_small_metallicity
								close bitmap_large_metallicity
								free bitmap_large_metallicity
							)
							else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255)
						)
						else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) 
						
						bitmap_small_ERM = img_tag_ERM.bitmap
						
						line_bitmap_emission = #()
						line_bitmap_roughness = #()
						line_bitmap_metallicity = #()
						line_bitmap_ERM = #()

						width = 150 
						height = 150 				
						if bitmap_small_roughness != undefined then
						(
							for line_num in #{1..height} do
							(
								line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
								line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
								line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

								if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
								(		
									line_bitmap_ERM = #()
									for p in #{1..width} do 
									(
										p_emission = line_bitmap_emission[p]
										p_roughness = line_bitmap_roughness[p]
										p_metallicity = line_bitmap_metallicity[p]
										p_ERM = color (p_emission.r * spn_emission.value / 255) (p_roughness.g * spn_roughness.value / 255) (p_metallicity.b * spn_metallicity.value / 255)
										append line_bitmap_ERM p_ERM
									)	
								)				
								setPixels bitmap_small_ERM [0, line_num - 1] line_bitmap_ERM 
							)
							img_tag_ERM.bitmap = bitmap_small_ERM
							edt_erm.text = UDIMs.edt_multimat_path.text + getfilenamefile source + "_ERM.png" 
							close bitmap_small_emission
							close bitmap_small_metallicity				
							free bitmap_small_emission
							free bitmap_small_metallicity	
						)
					)
				)				
			)
			
			on bnt_get_metallicity_map pressed do
			(				
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity
				source = getOpenFileName "Select Metallicity map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then 		
					(
						bitmap_large_metallicity = openBitMap source
						bitmap_small_metallicity = bitmap 150 150 filename:bitmap_large_metallicity.filename
						copy bitmap_large_metallicity bitmap_small_metallicity
						img_tag_metallicity.bitmap = bitmap_small_metallicity
						edt_metallicity.text = getfilenamefile source + getfilenametype source
						spn_metallicity.value = 255
						
						if img_tag_emission.bitmap.filename != "" then
						(
							if doesfileexist img_tag_emission.bitmap.filename then 
							(
								bitmap_large_emission = openBitMap img_tag_emission.bitmap.filename
								bitmap_small_emission = bitmap 150 150 filename:bitmap_large_emission.filename
								copy bitmap_large_emission bitmap_small_emission
								close bitmap_large_emission
								free bitmap_large_emission
							)
							else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) 
						)
						else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255)

						if img_tag_roughness.bitmap.filename != "" then
						(
							if doesfileexist img_tag_roughness.bitmap.filename then 
							(					
								bitmap_large_roughness = openBitMap img_tag_roughness.bitmap.filename
								bitmap_small_roughness = bitmap 150 150 filename:bitmap_large_roughness.filename
								copy bitmap_large_roughness bitmap_small_roughness
								close bitmap_large_roughness
								free bitmap_large_roughness
							)
							else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) 
						)
						else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255)
						
						bitmap_small_ERM = img_tag_ERM.bitmap
						
						line_bitmap_emission = #()
						line_bitmap_roughness = #()
						line_bitmap_metallicity = #()
						line_bitmap_ERM = #()

						width = 150 
						height = 150 				
						if bitmap_small_metallicity != undefined then
						(
							for line_num in #{1..height} do
							(
								line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
								line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
								line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

								if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
								(		
									line_bitmap_ERM = #()
									for p in #{1..width} do 
									(
										p_emission = line_bitmap_emission[p]
										p_roughness = line_bitmap_roughness[p]
										p_metallicity = line_bitmap_metallicity[p]
										p_ERM = color (p_emission.r * spn_emission.value / 255) (p_roughness.g * spn_roughness.value / 255) (p_metallicity.b * spn_metallicity.value / 255)
										append line_bitmap_ERM p_ERM
									)	
								)				
								setPixels bitmap_small_ERM [0, line_num - 1] line_bitmap_ERM 
							)
							img_tag_ERM.bitmap = bitmap_small_ERM
							edt_erm.text = UDIMs.edt_multimat_path.text + getfilenamefile source + "_ERM.png" 
							close bitmap_small_roughness
							close bitmap_small_emission				
							free bitmap_small_roughness
							free bitmap_small_emission	
						)
					)
				)				
			)				
		)
		addRollout TextureEditor BitmapsEDITOR
		
	)
	
	on btn_id_roll pressed do with undo "Offset IDs" on
	(
		for i in selection where classof i == editable_poly do
		(
			for j in #{1..(polyOp.getNumFaces i)} do polyop.setFaceMatID i #{j} (spn_id_roll.value + (polyop.getFaceMatID i j))
		)
	)
	
	on btn_Condense pressed do with undo "Condense IDs" on
	(
		/*
		local compilerParams = dotNetObject "System.CodeDom.Compiler.CompilerParameters" #(
			"System.dll", "System.Core.dll", getDir #maxRoot + "Autodesk.Max.dll",
			getDir #maxRoot + "\bin\assemblies\Autodesk.Max.Wrappers.dll")
		compilerParams.GenerateInMemory = on
	 
		local compilerResults = (dotNetObject "Microsoft.CSharp.CSharpCodeProvider").CompileAssemblyFromSource compilerParams #(
			"using System;
			using System.Linq;
			using System.Collections.Generic;
			using Autodesk.Max;
			using Autodesk.Max.Wrappers;
	 
			internal static class TabExtensions {
				public static IEnumerable<T> ToEnumerable<T>(this ITab<T> tab) {
					for (int i = 0; i < tab.Count; i++)
						yield return tab[i];
				}
			}
	 
			class Poly {
				internal static readonly IGlobal Global = GlobalInterface.Instance;
	 
				public static int[] GetSelectedObjMatIDs() {
					var pIgame = Global.IGameInterface;
					pIgame.InitialiseIGame(true);
					pIgame.SetStaticFrame(0);
	 
					using (var currNode = Global.COREInterface.GetSelNode(0))
					using (var gameNode = pIgame.GetIGameNode(currNode))
					using (var gameMesh = Global.IGameMesh.Marshal((gameNode.IGameObject as Autodesk.Max.Wrappers.IGameObject).INativeObject__NativePointer)) {
						return gameMesh.InitializeData ? gameMesh.ActiveMatIDs.ToEnumerable().Select(id => id + 1).ToArray() : new int[0];
					}
				}
			}"
		)
		::poly = compilerResults.CompiledAssembly.CreateInstance "Poly"

		if selection.count == 1 and isKindOf selection[1] GeometryClass do 
		(
			IDs = #()
			IDs = Poly.GetSelectedObjMatIDs()
			print #(IDs)
		)
		*/		
		
		if selection.count == 1 and classof selection[1] == Editable_Poly and selection[1].material != undefined and classof selection[1].material == Multimaterial then
		(
			max modify mode
			local s = selection[1]
			local ss = copy s
			ss.name = s.name + "_new"
			
			local ids_mat = s.material.materialIDList
			local ids_obj = #()
			local faceSel = #{}
			for id in ids_mat where not keyboard.escPressed do 
			(
				s.selectbymaterial id clearCurrentSelection:true
				
				faceSel = polyOp.getFaceSelection s
				if not faceSel.isempty then appendIfUnique ids_obj id
			)
			print #(ids_obj)
			print #(ids_mat)
			
			local ids_new = #{}
			local id_new = 0
			local m = multimaterial numsubs:1 name:(s.material.name + "_new")
			ss.material = m
			for id in ids_obj do
			(
				id_new += 1
				m.numsubs = id_new
				m.materialList[id_new] = copy s.material.materialList[id]
				m.materialList[id_new].name = s.material.materialList[id].name
				m.names[id_new] = s.material.names[id]
				ss.selectbymaterial id clearCurrentSelection:true
				local faceSel = #{}
				faceSel = polyOp.getFaceSelection ss
				if not faceSel.isempty then polyop.setFaceMatID ss faceSel id_new			
			)
			
			/*
			for i in selection where classof i == editable_poly do
			(
				IDs = for j in #{1..(polyOp.getNumFaces i)} collect polyop.getFaceMatID i j
				(
					polyop.setFaceMatID i #{j} (spn_id_roll.value + (polyop.getFaceMatID i j))
				)
			)
			*/
		)
	)
	
	on btn_transfer_edges pressed do
	(
		if selection.count == 1 then transfer_edges()
	)
	
	on btn_edges_selector rightclick do
	(
		Obj_Spln.chk_DetriangulateSel.checked = true --только выделить
		Obj_Spln.chk_DetriangulateUV.checked = true
		Obj_Spln.chk_DetriangulateSM.checked = true
		Obj_Spln.chk_DetriangulateAn.checked	= true
		Obj_Spln.spn_DetriangulateAngle.value = 10.0
		--chk_DetriangulateDisputed.checked = false
		Obj_Spln.btn_Detriangulate.pressed()
		Obj_Spln.chk_DetriangulateSel.checked = false
	)
	
	on btn_edges_selector pressed do
	(
		if selection.count == 1 and selection[1].modifiers.count == 0 and classof selection[1].baseobject == Editable_Poly then
		(
			max create mode
			sel = selection[1]
			t = 0.01
			need = #{}
			for edge in #{1..polyop.getNumEdges sel} do
			(
				verts = polyop.getVertsUsingEdge sel edge
				poses = for v in verts collect polyop.getVert sel v
				if abs (poses[1].x - poses[2].x) <= t or abs (poses[1].y - poses[2].y) <= t then append need edge 
			)
			polyop.setEdgeSelection sel need
			max modify mode
			try(subobjectlevel = 2)catch()
		)
		else messagebox "Select single editable poly object."
	)
	
	on btn_poly_to_edges_selector pressed do
	(
		if keyboard.controlPressed then --выделение криволинейных эджей
		(
			Obj_Spln.chk_DetriangulateSel.checked = true --только выделить
			Obj_Spln.chk_DetriangulateUV.checked = true
			Obj_Spln.chk_DetriangulateSM.checked = true
			Obj_Spln.chk_DetriangulateAn.checked	= true
			Obj_Spln.spn_DetriangulateAngle.value = 10.0
			--Obj_Spln.chk_DetriangulateDisputed.checked = false
			Obj_Spln.btn_Detriangulate.pressed()
			Obj_Spln.chk_DetriangulateSel.checked = false
		)
		else
		if selection.count == 1 and selection[1].modifiers.count == 0 and classof selection[1].baseobject == Editable_Poly then --выделение строго параллельных эджей
		(
			max create mode
			sel = selection[1]
			t = 0.01
			need = #{}
			edges = #{}
			polys = if (polyop.getFaceSelection sel).numberset > 0 then polyop.getFaceSelection sel else #{1..polyop.getNumFaces sel}
			polys_other = #{1..polyop.getNumFaces sel} - polys
			edges = polyop.getEdgesUsingFace sel polys
			edges_other = polyop.getEdgesUsingFace sel polys_other
			
			for edge in edges do
			(
				verts = polyop.getVertsUsingEdge sel edge
				poses = for v in verts collect polyop.getVert sel v
				if abs (poses[1].x - poses[2].x) <= t or abs (poses[1].y - poses[2].y) <= t then append need edge 
			)
			need += edges * edges_other --края добавляем			
			
			polyop.setEdgeSelection sel need
			max modify mode
			try(subobjectlevel = 2)catch()
			--transfer_edges()
		)
		else messagebox "Select single editable poly object."
	)

/*	
	on btn_UdimFit pressed do
	(
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		sc = 1.0
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.numberset > 0 then
			(
				unwrapmod.faceToVertSelect()
				verts = unwrapmod.getSelectedVertices()
				poi_x = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).x)
				poi_y = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).y)
				sc = if abs (amax poi_y - amin poi_y) >= abs (amax poi_x - amin poi_x) then spn_bricks_unwrap_sc.value/(amax poi_y - amin poi_y) else spn_bricks_unwrap_sc.value/(amax poi_x - amin poi_x)
				print sc
				unwrapmod.scaleSelectedCenter sc 0
				pos = unwrapmod.getSelCenter()
				print pos
				format "offset: x = %, y = %\n" (0.5 - pos.x) (0.5 - pos.y)
				unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0]
				
				if chk_UdimFit.checked then
				(

				)					
			)
		)		
	)
*/

	on btn_UdimFit pressed do with undo "Fit texels to UDIM" on
	(
		local ctrl = keyboard.controlPressed
		local alt = keyboard.altPressed
		local shift = keyboard.shiftPressed
		local start = GetINI_ImageMagick()
		
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		local sc = 1.0
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			local faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.numberset > 0 then
			(
				unwrapmod.faceToVertSelect()
				local verts = unwrapmod.getSelectedVertices()
				local poi_x = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).x)
				local poi_y = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).y)
				sc = if abs (amax poi_y - amin poi_y) >= abs (amax poi_x - amin poi_x) then spn_bricks_unwrap_sc.value/(amax poi_y - amin poi_y) else spn_bricks_unwrap_sc.value/(amax poi_x - amin poi_x)
				--print sc
				local pos_ini = unwrapmod.getSelCenter()
				unwrapmod.scaleSelectedCenter sc 0
				local pos = unwrapmod.getSelCenter()
				--print pos
				if ctrl then unwrapmod.moveSelected [pos_ini.x as integer + 0.5 - pos.x, pos_ini.y as integer + 0.5 - pos.y, 0] else unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0]
				local pos2 = unwrapmod.getSelCenter()

				if chk_UdimFit.checked then
				(
					format "scale=% ini_pos:% fin_pos:% offset:x=%, y=% \n" sc pos pos2 (0.5 - pos.x) (0.5 - pos.y)
					if alt then
					(
						local arr = #()
						local rez = case rdo_tex.state of
						(
							1: 256
							2: 512
							3: 1024
							4: 2048
							5: 4096
						)
						local m = selection[1].material
						if m != undefined then
						(
							case (classof m) of
							(
								--для multitile --for i in #{1..$.material.base_color_map.tileCount()} collect ($.material.base_color_map.getTileTexmap i).filename
								Multimaterial: 
								(	
									local ids = #()
									local id = 1
									for f in faces where not keyboard.escPressed do
									(
										unwrapmod.selectfaces #{f}
										id = unwrapmod.getSelectMatID()
										appendIfUnique ids id
										--exit
									)
									unwrapmod.selectfaces faces
									if ids.count > 0 then
									(
										for id in ids where id != undefined and id > 0 do 
										(
											local sub_m = m.materialList[id]

											if shift then
											(
												case classof sub_m of
												(
													CoronaLegacyMtl:
													(
														if sub_m.texmapDiffuse != undefined then (render_map sub_m.texmapDiffuse rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapDiffuse = bitmaptexture filename:(t + ".png"))
														if sub_m.texmapReflect != undefined then (render_map sub_m.texmapReflect rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapReflect = bitmaptexture filename:(t + ".png"))
														if sub_m.texmapReflectGlossiness != undefined then (render_map sub_m.texmapReflectGlossiness rez (t = edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapReflectGlossiness = bitmaptexture filename:(t + ".png"))
														if sub_m.texmapRefract != undefined then (render_map sub_m.texmapRefract rez (t = edt_multimat_path.text + sub_m.name + "_Refract" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapRefract = bitmaptexture filename:(t + ".png"))
														if sub_m.texmapRefractGlossiness != undefined then (render_map sub_m.texmapRefractGlossiness rez (t = edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapRefractGlossiness = bitmaptexture filename:(t + ".png"))
														if sub_m.texmapOpacity != undefined then (render_map sub_m.texmapOpacity rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapOpacity = bitmaptexture filename:(t + ".png"))
														if sub_m.texmapBump != undefined then (render_map sub_m.texmapBump rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapBump = bitmaptexture filename:(t + ".png"))
														if sub_m.texmapTranslucency != undefined then (render_map sub_m.texmapTranslucency rez (t = edt_multimat_path.text + sub_m.name + "_Translucency" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapTranslucency = bitmaptexture filename:(t + ".png"))
														if sub_m.texmapDisplace != undefined then (render_map sub_m.texmapDisplace rez (t = edt_multimat_path.text + sub_m.name + "_Displace" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapDisplace = bitmaptexture filename:(t + ".png"))
													)

													CoronaPhysicalMtl:
													(
														if sub_m.baseTexmap != undefined then (render_map sub_m.baseTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseTexmap = bitmaptexture filename:(t + ".png"))
														if sub_m.baseRoughnessTexmap != undefined then (render_map sub_m.baseRoughnessTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseRoughnessTexmap = bitmaptexture filename:(t + ".png"))
														if sub_m.baseBumpTexmap != undefined then (render_map sub_m.baseBumpTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseBumpTexmap = bitmaptexture filename:(t + ".png"))
														if sub_m.opacityTexmap != undefined then (render_map sub_m.opacityTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseBumpTexmap = bitmaptexture filename:(t + ".png"))
													)
									
													Physical_Material:
													(
														if sub_m.base_color_map != undefined then (render_map sub_m.base_color_map rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.base_color_map = bitmaptexture filename:(t + ".png"))
														if sub_m.roughness_map != undefined then (render_map sub_m.roughness_map rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.roughness_map = bitmaptexture filename:(t + ".png"))
														if sub_m.bump_map != undefined then (render_map sub_m.bump_map rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.bump_map = bitmaptexture filename:(t + ".png"))
														if sub_m.cutout_map != undefined then (render_map sub_m.cutout_map rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.bump_map = bitmaptexture filename:(t + ".png"))
														--emission_map 
														--emit_color
														--metalness_map
													)
									
													Standardmaterial:
													(
														if sub_m.DiffuseMap != undefined then (render_map sub_m.DiffuseMap rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
														if sub_m.ReflectionMap != undefined then (render_map sub_m.ReflectionMap rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.ReflectionMap = bitmaptexture filename:(t + ".png"))
														if sub_m.BumpMap != undefined then (render_map sub_m.BumpMap rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.BumpMap = bitmaptexture filename:(t + ".png"))
														if sub_m.OpacityMap != undefined then (render_map sub_m.OpacityMap rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
														--GlossinessMap 
													)

													Vraymtl:
													(
														if sub_m.texmap_diffuse != undefined then (render_map sub_m.texmap_diffuse rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
														if sub_m.texmap_reflection != undefined then (render_map sub_m.texmap_reflection rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.ReflectionMap = bitmaptexture filename:(t + ".png"))
														if sub_m.texmap_bump != undefined then (render_map sub_m.texmap_bump rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.BumpMap = bitmaptexture filename:(t + ".png"))
														if sub_m.texmap_opacity != undefined then (render_map sub_m.texmap_opacity rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
													)
													
													default: (messageBox "Do not supported this type of sub-material")
												)
											)
											else
											(
												local maps = usedMaps sub_m
												print maps
												if not doesDirectoryExist edt_multimat_path.text then makeDir edt_multimat_path.text
												for t in maps do 
												(
													local t_new = edt_multimat_path.text + getFilenameFile t + getFilenameType t
													local t_old = edt_multimat_path.text + getFilenameFile t + getFilenameType t + ".png"
													format "current=%   new=%   bak=%\n" t t_new t_old
													if doesFileExist t_old then deleteFile t_old
													if doesFileExist t then copyFile t t_old
													fit_map t t_new pos sc rez start	
												)
											)
										)
									)
								)
								
								default: (messageBox "Do not supported this type of material, use only Multimaterial")
							)
							/*
							if arr.count > 0 then
							(								
								for sourcepath in arr do 
								(									
									finalpath = (getfilenamepath sourcepath) + (getfilenamefile sourcepath) + "_fit.png"
									HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:(GetINI_ImageMagick())
									wid = rez
									hei = rez
									x_ = -(pos.x - 0.5)
									y_ = -(pos.y - 0.5)
									x = ((x_ * wid ) as integer) 
									y = ((y_ * hei ) as integer) 
									x = if x >= 0 then "+" + (x as string) else (x as string)
									y = if y >= 0 then "+" + (y as string) else (y as string)
									
									format "scale=% x=% % y=% %\n" sc x_ x y_ y
									
									cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
									--print cmd
									
									HiddenDOSCommand cmd startpath:(GetINI_ImageMagick())
									--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -distort SRT '" + X + "," + Y + " " + sc + " 0 " + NewX + "," + NewY + "'" + "\"" + sourcepath + ".png" + "\"") startpath:(GetINI_ImageMagick())
									HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:(GetINI_ImageMagick())	
								)
							)	
							*/
						)
					)
					else
					(
						sourcepath = getOpenFileName "Select file for fit map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
						print sourcepath
						if sourcepath != undefined then
						(
							--предупреждение
							may_backup_file = false
							finalpath = sourcepath
							if getfilenamepath sourcepath != edt_multimat_path.text then
							(
								messagebox "Output file will be renamed and placed near initial as .png file.\nChange material to see it.\nInitial file will be not changed."
								finalpath = sourcepath + ".png"
								may_backup_file = false
							)
							else 
							(
								messagebox "Initial file will be backuped and placed near output as +(.png) file.\nFinal file will be saved as .png with initial name and may be overwritten."
								may_backup_file = true
								finalpath = (getfilenamepath sourcepath) + (getfilenamefile sourcepath) + ".png"
							)
		
							a = openBitMap sourcepath
							
							if a != undefined then
							(
								if doesfileexist (sourcepath + ".png") then deletefile (sourcepath + ".png")
								if not doesfileexist (sourcepath + ".png") and may_backup_file then copyfile sourcepath (sourcepath + ".png")
								
								hei = a.height
								wid = a.width 
								close a
								free a

								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -distort SRT '" + X + "," + Y + " " + "1" + " 0 " + NewX + "," + NewY + "' " + "\"" + sourcepath + ".png" + "\"")
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile  -distort SRT '0 90' " + "\"" + sourcepath + ".png" + "\"")
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -resize 50% -virtual-pixel tile -extent 2048x2048 -roll +200+200 " + "\"" + sourcepath + ".png" + "\"")
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -resize 50% -virtual-pixel tile -extent 2048x2048 -roll +200+200 " + "\"" + sourcepath + ".png" + "\"")
								
								--print ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"")
								HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
							
								x_ = -(pos.x - 0.5)
								y_ = -(pos.y - 0.5)
								x = ((x_ * wid ) as integer) 
								y = ((y_ * hei ) as integer) 
								x = if x >= 0 then "+" + (x as string) else (x as string)
								y = if y >= 0 then "+" + (y as string) else (y as string)
								
								format "scale=% x=% % y=% %\n" sc x_ x y_ y
								
								cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
								--print cmd
								
								HiddenDOSCommand cmd startpath:start
								--HiddenDOSCommand ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -distort SRT '" + X + "," + Y + " " + sc + " 0 " + NewX + "," + NewY + "'" + "\"" + sourcepath + ".png" + "\"") startpath:(GetINI_ImageMagick())
								HiddenDOSCommand ("magick  " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:start
								--deletefile (sourcepath + ".png")
							)
						)
					)
				)					
			)
		)		
	)
	
	on btn_UdimFit rightclick do with undo "Fit texture to Unwrap" on
	(
		local ctrl = keyboard.controlPressed
		local alt = keyboard.altPressed
		
		max modify mode
		--sel_ini = selection[1]
		--sel = copy sel_ini
		--select sel
		local sel = selection[1]
		local unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		local sc = 1.0
		local pos_ini, pos, pos2
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			local faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.numberset > 0 then
			(
				local mX, mY, mWidth, mHeight, mAreaUVW, mAreaGeom
				unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
				format "mWidth=% mHeight=% mX=% mY=%\n" mWidth mHeight mX mY
				if mHeight <= 1.0 and mWidth <= 1.0 then
				(
					sc = if mHeight >= mWidth then mHeight else mWidth
					--sc = if mHeight >= mWidth then 1/mHeight else 1/mWidth
					--unwrapmod.moveSelected [0.5 - pos_ini.x, 0.5 - pos_ini.y, 0]
					pos = unwrapmod.getSelCenter()
					--unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter sc 0
					--pos2 = unwrapmod.getSelCenter()
					--format "scale=% ini_pos:% offset:x=%, y=% \n" sc pos (0.5 - pos.x) (0.5 - pos.y)

					if alt then
					(
						arr = #()
						rez = case rdo_tex.state of
						(
							1: 256
							2: 512
							3: 1024
							4: 2048
							5: 4096
						)
						m = selection[1].material
						if m != undefined then
						(
							case (classof m) of
							(
								--для multitile --for i in #{1..$.material.base_color_map.tileCount()} collect ($.material.base_color_map.getTileTexmap i).filename
								Multimaterial: 
								(	
									ids = #()
									id = 1
									for f in faces where not keyboard.escPressed do
									( 
										unwrapmod.selectfaces #{f}
										id = unwrapmod.getSelectMatID()
										appendIfUnique ids id
										--exit
									)
									unwrapmod.selectfaces faces
									if ids.count > 0 then
									(
										for id in ids where id != undefined and id > 0 do 
										(
											sub_m = m.materialList[id]
											case classof sub_m of
											(
												CoronaLegacyMtl:
												(
													if sub_m.texmapDiffuse != undefined then (render_map sub_m.texmapDiffuse rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapDiffuse = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapReflect != undefined then (render_map sub_m.texmapReflect rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapReflect = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapReflectGlossiness != undefined then (render_map sub_m.texmapReflectGlossiness rez (t = edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapReflectGlossiness = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapRefract != undefined then (render_map sub_m.texmapRefract rez (t = edt_multimat_path.text + sub_m.name + "_Refract" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapRefract = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapRefractGlossiness != undefined then (render_map sub_m.texmapRefractGlossiness rez (t = edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapRefractGlossiness = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapOpacity != undefined then (render_map sub_m.texmapOpacity rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapOpacity = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapBump != undefined then (render_map sub_m.texmapBump rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapBump = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapTranslucency != undefined then (render_map sub_m.texmapTranslucency rez (t = edt_multimat_path.text + sub_m.name + "_Translucency" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapTranslucency = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapDisplace != undefined then (render_map sub_m.texmapDisplace rez (t = edt_multimat_path.text + sub_m.name + "_Displace" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapDisplace = bitmaptexture filename:(t + ".png"))
												)

												CoronaPhysicalMtl:
												(
													if sub_m.baseTexmap != undefined then (render_map sub_m.baseTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseTexmap = bitmaptexture filename:(t + ".png"))
													if sub_m.baseRoughnessTexmap != undefined then (render_map sub_m.baseRoughnessTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseRoughnessTexmap = bitmaptexture filename:(t + ".png"))
													if sub_m.baseBumpTexmap != undefined then (render_map sub_m.baseBumpTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseBumpTexmap = bitmaptexture filename:(t + ".png"))
													if sub_m.opacityTexmap != undefined then (render_map sub_m.opacityTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseBumpTexmap = bitmaptexture filename:(t + ".png"))
												)
								
												Physical_Material:
												(
													if sub_m.base_color_map != undefined then (render_map sub_m.base_color_map rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.base_color_map = bitmaptexture filename:(t + ".png"))
													if sub_m.roughness_map != undefined then (render_map sub_m.roughness_map rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.roughness_map = bitmaptexture filename:(t + ".png"))
													if sub_m.bump_map != undefined then (render_map sub_m.bump_map rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.bump_map = bitmaptexture filename:(t + ".png"))
													if sub_m.cutout_map != undefined then (render_map sub_m.cutout_map rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.bump_map = bitmaptexture filename:(t + ".png"))
													--emission_map 
													--emit_color
													--metalness_map
												)
								
												Standardmaterial:
												(
													if sub_m.DiffuseMap != undefined then (render_map sub_m.DiffuseMap rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
													if sub_m.ReflectionMap != undefined then (render_map sub_m.ReflectionMap rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.ReflectionMap = bitmaptexture filename:(t + ".png"))
													if sub_m.BumpMap != undefined then (render_map sub_m.BumpMap rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.BumpMap = bitmaptexture filename:(t + ".png"))
													if sub_m.OpacityMap != undefined then (render_map sub_m.OpacityMap rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
													--GlossinessMap 
												)	

												Vraymtl:
												(
													if sub_m.texmap_diffuse != undefined then (render_map sub_m.texmap_diffuse rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
													if sub_m.texmap_reflection != undefined then (render_map sub_m.texmap_reflection rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.ReflectionMap = bitmaptexture filename:(t + ".png"))
													if sub_m.texmap_bump != undefined then (render_map sub_m.texmap_bump rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.BumpMap = bitmaptexture filename:(t + ".png"))
													if sub_m.texmap_opacity != undefined then (render_map sub_m.texmap_opacity rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
												)												
											)
										)
									)
								)
							)
						)
					)
					else
					(
						local sourcepath = getOpenFileName "Select file for fit map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
						print sourcepath
						if sourcepath != undefined then
						(
							--предупреждение
							local may_backup_file = false
							local finalpath = sourcepath + ".png"
							if getfilenamepath sourcepath != edt_multimat_path.text then
							(
								messagebox "Output file will be renamed and placed near initial as .png file.\nChange material to see it.\nInitial file will be not changed."
								finalpath = sourcepath + ".png"
								may_backup_file = false
							)
							else 
							(
								messagebox "Initial file will be backuped and placed near output as +(.png) file.\nFinal file will be saved as .png with initial name and may be overwritten."
								may_backup_file = true
								finalpath = (getfilenamepath sourcepath) + (getfilenamefile sourcepath) + ".png"
							)
/*
							local rez = 4096
								
							a = openBitMap sourcepath
							
							if a != undefined then
							(
								if doesfileexist (sourcepath + ".png") then deletefile (sourcepath + ".png")
								if not doesfileexist (sourcepath + ".png") and may_backup_file then copyfile sourcepath (sourcepath + ".png")
								
								hei = a.height
								wid = a.width 
								close a
								free a
								
								if hei != undefined and wid != undefined then
								(
									if hei == wid then rez = hei
									else rez = 4096 
								)
							)
*/							
					

							fit_map_edge sourcepath finalpath pos sc mX mY mWidth mHeight (GetINI_ImageMagick())	
								
							/*	
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -distort SRT '" + X + "," + Y + " " + "1" + " 0 " + NewX + "," + NewY + "' " + "\"" + sourcepath + ".png" + "\"")
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -distort SRT '0 90' " + "\"" + sourcepath + ".png" + "\"")
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -resize 50% -virtual-pixel tile -extent 2048x2048 -roll +200+200 " + "\"" + sourcepath + ".png" + "\"")
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -resize 50% -virtual-pixel tile -extent 2048x2048 -roll +200+200 " + "\"" + sourcepath + ".png" + "\"")
								
								--print ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"")
								HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:(GetINI_ImageMagick())
							
								x_ = 0.5 - pos.x --mX-pos.x -- - mX --0.5 - pos.x
								y_ = 0.5 - pos.y --mY-pos.y -- - mY --0.5 - pos.y
								x = ((x_ * wid) as integer) 
								y = ((y_ * hei) as integer) 
								x = if x >= 0 then "+" + (x as string) else (x as string)
								y = if y >= 0 then "+" + (y as string) else (y as string)
								
								format "scale=% x=% % y=% %\n" sc x_ x y_ y
								
								cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel edge -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
								print cmd
								
								HiddenDOSCommand cmd startpath:(GetINI_ImageMagick())
								--HiddenDOSCommand ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -distort SRT '" + X + "," + Y + " " + sc + " 0 " + NewX + "," + NewY + "'" + "\"" + sourcepath + ".png" + "\"") startpath:(GetINI_ImageMagick())
								HiddenDOSCommand ("convert " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:(GetINI_ImageMagick())	
								--deletefile (sourcepath + ".png")
							*/
							--)
						)
					)
				)
				else
				(
					messagebox "Selected object have unwrap larger than one UDIM, no need to upscale texture." 
				)
			)
		)		
	)	
	
	on btn_UdimFitMat pressed do with undo "Fit texels to UDIMs with Mats" on
	(
		local ctrl = keyboard.controlPressed
		
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		local sc = 1.0
		local spn = spn_bricks_unwrap_sc.value
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(		
			local rez = case rdo_tex.state of
			(
				1: 256
				2: 512
				3: 1024
				4: 2048
				5: 4096
			)
			local facenum = unwrapmod.numberPolygons()
			local faces = unwrapmod.getselectedfaces() 
			local faces_ini = faces
			if faces.isempty then faces = #{1..facenum}
			local other_sel = #{1..facenum} - faces
			local sel_face = #{}
			
			local start = GetINI_ImageMagick()
			if not faces.isempty then
			(
				local m = selection[1].material
				if m != undefined then
				(
					if classof m == Multimaterial then
					(
						local ids = #{}
						for id in m.materialIDList do ids += #{id} -- for id in #{1..m.numsubs} do ids += #{id}          where m.materialList[id] != undefined do ids += #{id}
						unwrapmod.setPolygonMode true
						unwrapmod.setTVSubObjectMode 3
						unwrapmod.unhide() 
						print #(ids)
						if not ids.isempty then
						(
							for id in ids where id != undefined and id > 0 and not keyboard.escPressed do 
							(
								--unwrapmod.selectfaces faces
								unwrapmod.selectByMatID id
								unwrapmod.polygonSelect()
								sel_face = unwrapmod.getselectedfaces() - other_sel
								if not sel_face.isempty then
								(
									--unwrapmod.faceToVertSelect()
									--verts = unwrapmod.getSelectedVertices()
									--poi_x = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).x)
									--poi_y = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).y)
									--sc = if abs(amax poi_y - amin poi_y) >= abs (amax poi_x - amin poi_x) then spn / (amax poi_y - amin poi_y) else spn / (amax poi_x - amin poi_x)
									
									unwrapmod.getarea sel_face &nX &nY &nWidth &nHeight &nAreaUVW &nAreaGeom
									
									sc = if nWidth > nHeight then spn / nWidth else spn / nHeight
										
									pos_ini = unwrapmod.getSelCenter()
									--unwrapmod.moveSelected [- floor pos_ini.x, - floor pos_ini.y, 0] 
									
									--unwrapmod.scaleSelectedXY sc sc pos_ini   --unwrapmod.scaleSelectedCenter sc 0
									--unwrapmod.moveSelected [-(pos_ini.x as integer), -(pos_ini.y as integer), 0] 
									--unwrapmod.moveSelected [pos_ini.x as integer + 0.5 - pos.x, pos_ini.y as integer + 0.5 - pos.y, 0]
									
									pos = unwrapmod.getSelCenter()
									unwrapmod.scaleSelectedXY sc sc pos --unwrapmod.scaleSelectedCenter sc 0
									
									if ctrl then unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0] else unwrapmod.moveSelected [0.5 - (pos.x - (pos.x as integer)), 0.5 - (pos.y - (pos.y as integer)), 0]
									
									pos2 = unwrapmod.getSelCenter()

									format "scale=% ini_pos:% pos:% fin_pos:% offset:x=%, y=% \n" sc pos_ini pos pos2 (0.5 - pos.x) (0.5 - pos.y)
									
									/*
									local sub_maps = get_sub_maps m.materialList[id]
									--print sub_maps

									local maps_arr = for s in sub_maps where classof s != multitile and (usedMaps s) != ok collect usedMaps s
									--print #(maps_arr)
									local maps = #()
									local done_maps = #()
									for map in maps_arr where map != ok do join maps map 
									makeUniqueArray maps
									*/
									
									local done_maps = #()
									local maps = #()
									--local damat = #()
									--damat = for ref in refs.dependents (m.materialList[id]) collect ref 
									--refs.dependentNodes (m.materialList[id])
									--print #(damat)
									maps = try(getClassInstances BitmapTexture target:m.materialList[id] asTrackViewPick:off)catch() 
									join maps (try(getClassInstances CoronaBitmap target:m.materialList[id] asTrackViewPick:off)catch())
									join maps (try(getClassInstances VRayBitmap target:m.materialList[id] asTrackViewPick:off)catch())
									print #(maps)
									format "path:%\n" edt_multimat_path.text
									if not doesDirectoryExist edt_multimat_path.text then makeDir edt_multimat_path.text
									if maps.count > 0 then
									(
										for b in maps where (for d in done_maps where b.filename == d collect d).count == 0 do --надо дополнительно собирать одинаковые карты по путям, чтобы не делать их дважды, например, когда одинаковые дифуз и опасити
										(
											t = b.filename
											bt = openBitMap t
											if bt != undefined then 
											(
												if bt.width == 256 and bt.height == 256 then  --добавить учет заглушек в переразмер, их надо игнорировать
												(
													close bt
													free bt
													continue
												)
												else
												(
													close bt
													free bt
												)
											)
											else continue
											
											local t_new = edt_multimat_path.text + getFilenameFile t + "_id" + id as string + getFilenameType t
											local t_old = edt_multimat_path.text + getFilenameFile t + "_old" + getFilenameType t
											local t_temp = edt_multimat_path.text + getFilenameFile t + "_temp" + getFilenameType t --getfilenamepath t + "temp.png"
											--format "current=%   new=%   bak=% sc=%\n" t t_new t_old sc
											if doesFileExist t_old then deleteFile t_old
											if doesFileExist t then copyFile t t_old
											--if doesFileExist t_new and t != t_new then deleteFile t_new	
											if doesFileExist t_temp then deleteFile t_temp	
											if doesFileExist t then copyFile t t_temp
												
											HiddenDOSCommand ("magick " + "\"" + t + "\"" + " -resize " + rez as string + "x" + rez as string + "^! " + "\"" + t_temp + "\"") startpath:start
											
												--local x_ = (rez * (- pos.x)) as integer
												--local y_ = (rez * (- pos.y)) as integer

												--local x_ = if pos.x <= 0.5 then (rez * (0.5 - pos.x)) as integer else -(rez * (0.5 - pos.x)) as integer
												--local y_ = if pos.y <= 0.5 then -(rez * (0.5 - pos.y)) as integer else (rez * (0.5 - pos.y)) as integer
												
											--local x_ = (rez * (0.5 - pos_ini.x)) as integer 
											--local y_ = -(rez * (0.5 - pos_ini.y)) as integer
											
												--local x_ = (0) as integer -- + (rez * (0.5 - pos.x))) as integer
												--local y_ = (0) as integer -- + -(rez * (0.5 - pos.y))) as integer
											
												--local x_ = (rez * (0.5 - pos.x) / sc) as integer
												--local y_ = -(rez * (0.5 - pos.y) / sc) as integer

											--local x = if x_ >= 0 then "+" + (x_ as string) else (x_ as string)
											--local y = if y_ >= 0 then "+" + (y_ as string) else (y_ as string)
											
											
											--HiddenDOSCommand ("magick " + "\"" + t_temp + "\"" + " -roll " + x + y + " -resize " + (sc * 100) as string + "%% " + "\"" + t_temp + "\"") startpath:start
											--HiddenDOSCommand ("magick " + "\"" + t_temp + "\"" + " -resize " + (sc * 100) as string + "%% " + "\"" + t_temp + "\"") startpath:start

												--x_ = rou ( (-((sc / 2) - pos.x) ) * rez ) 
												--y_ = rou ( (-((sc / 2) - pos.y) ) * rez )

											--x_ = rou ( (rez / sc) / 2) 
											--y_ = rou ( (rez / sc) / 2) 

											--x_ = -rou (rez/sc/2) --перемещает угол в центр
											--y_ = -rou (rez/sc/2) --перемещает угол в центр

											--x_ = -rou ( rez / sc / 2 ) 
											--y_ = -rou ( rez / sc / 2 ) 
												
											--x_ = rou ( rez / sc / (0.5 - pos.x) )
											--y_ = rou ( rez / sc / (0.5 - pos.y) )

											--x_ = - rou ( rez / sc / 2  - (rez / sc / (0.5 - pos.x)) )
											--y_ = - rou ( rez / sc / 2  - (rez / sc / (0.5 - pos.y)) )
											
											--x = if x_ >= 0 then "+" + (x_ as string) else (x_ as string)
											--y = if y_ >= 0 then "+" + (y_ as string) else (y_ as string)
											
											--HiddenDOSCommand ("magick " + "\"" + t_temp + "\"" + " -define distort:viewport=" + 125x125-25-25 + " -virtual-pixel tile -distort SRT 0  +repage " + "\"" + t_temp + "\"") startpath:start
											--cmd = "magick " + "\"" + t_temp + "\"" + " -set option:distort:viewport " + (rou (rez/sc)) as string + "x" + (rou (rez/sc)) as string + x + y + " -set option:distort:scale " + sc as string + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + t_temp + "\""

											--cmd = "magick " + "\"" + t_temp + "\"" + " -set option:distort:viewport " + (rou (rez)) as string + "x" + (rou (rez)) as string + x + y + " -set option:distort:scale " + 1.0 as string + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + t_temp + "\""
											--cmd = "magick " + "\"" + t_temp + "\"" + " -set option:distort:viewport " + (rez/sc) as string + "x" + (rez/sc) as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + t_temp + "\""
											--cmd = "magick " + "\"" + t_temp + "\"" + " -set option:distort:viewport " + (rou rez/sc) as string + "x" + (rou rez/sc) as string " +0+0 -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + t_temp + "\""
											--cmd = "magick " + "\"" + t_temp + "\"" + " -set option:distort:viewport " + (rou rez/sc) as string + "x" + (rou rez/sc) as string + " +0+0 -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + t_temp + "\""
											
											--print sc
											
											--print (rou (rez/sc))
											
											--s = (rou (rez/sc)) as string												
											--s2 = (rou (rez/2)) as string
											
											--s = substitutestring s "." ","
											--s2 = substitutestring s2 "." ","
											
											--print s
											--print s2
												
											--cmd = if sc >= 1.0 then ("magick " + "\"" + t_temp + "\"" + " -gravity center -crop " + (rou (rez*sc)) as string + "x" + (rou (rez*sc)) as string + " +repage " + "\"" + t_temp + "\"")
											--else ("magick " + "\"" + t_temp + "\"" + " -gravity center -crop " + (rou (rez*sc)) as string + "x" + (rou (rez*sc)) as string + " +repage " + "\"" + t_temp + "\"")
											
											if sc >= 1.0 then 
											(
												local s = (rou (rez/sc)) as string												
												local s2 = (rou (rez/2)) as string
												
												local x_ = (rez * (0.5 - pos_ini.x)) as integer 
												local y_ = -(rez * (0.5 - pos_ini.y)) as integer

												local x = if x_ >= 0 then "+" + (x_ as string) else (x_ as string)
												local y = if y_ >= 0 then "+" + (y_ as string) else (y_ as string)
												
												--print s
												--print s2
													
												cmd = ("magick " + "\"" + t_temp + "\"" + " -roll " + x + y + " " + "\"" + t_temp + "\"")
												--print cmd	
												HiddenDOSCommand (cmd) startpath:start
													
												cmd = ("magick " + "\"" + t_temp + "\"" + " +repage -gravity center -crop " + s + "x" + s + "+0+0 +repage " + "\"" + t_temp + "\"")
												--("magick " + "\"" + t_temp + "\"" + " +repage -gravity center -crop " + s + "x" + s + x + y + " +repage " + "\"" + t_temp + "\"")
												--("magick " + "\"" + t_temp + "\"" + " +repage -gravity center -crop " + (rou (rez/sc)) as string + "x" + (rou (rez/sc)) as string + x + y + " +repage " + "\"" + t_temp + "\"")
												--print cmd
												HiddenDOSCommand (cmd) startpath:start												
											)
											else 
											(
												
												local x_ = (rez * (0.5 - pos_ini.x)) as integer 
												local y_ = -(rez * (0.5 - pos_ini.y)) as integer

												local x = if x_ >= 0 then "+" + (x_ as string) else (x_ as string)
												local y = if y_ >= 0 then "+" + (y_ as string) else (y_ as string)

												ss = (rez * ((ceil (1/sc)) as integer)) as string
												--print ss
													
												local s = (rou (rez/sc)) as string												
												local s2 = (rou (((ceil (1/sc)) as integer)*rez/4)) as string
												local s3 = "+" + (rou (rez/2)) as string	
													
												--print s
												--print s2
													
												--print ("magick " + "\"" + t_temp + "\"" + " -tile " + ss + "x" + ss + " " + "\"" + t_temp + "\"")
												--HiddenDOSCommand ("magick " + "\"" + t_temp + "\"" + " -tile " + ss + "x" + ss + "\"" + t_temp + "\"") startpath:start	
												--print ("magick -size " + ss + "x" + ss  + " tile:" + "\"" + t_temp + "\"" + " " + "\"" + t_temp + "\"")
												HiddenDOSCommand ("magick " + "\"" + t_temp + "\"" + " -roll " + x + y + " " + "\"" + t_temp + "\"") startpath:start	
												HiddenDOSCommand ("magick -size " + ss + "x" + ss  + " tile:" + "\"" + t_temp + "\"" + " " + "\"" + t_temp + "\"") startpath:start

												--cmd = ("magick " + "\"" + t_temp + "\"" + " +repage -gravity center -crop " + s + "x" + s + "+" + s2 + "+" + s2 + " +repage " + "\"" + t_temp + "\"")	
												cmd = if mod ((ceil (1/sc)) as integer) 2 == 1 then  	
													("magick " + "\"" + t_temp + "\"" + " +repage -gravity center -crop " + s + "x" + s + "+0+0 +repage " + "\"" + t_temp + "\"")
												else 
													--("magick " + "\"" + t_temp + "\"" + " +repage -gravity center -crop " + s + "x" + s + "-" + s2 + "-" + s2 + " +repage " + "\"" + t_temp + "\"")
													("magick " + "\"" + t_temp + "\"" + " -roll " + s3 + s3 + " +repage -gravity center -crop " + s + "x" + s + "+0+0 +repage " + "\"" + t_temp + "\"")
												-- -fx 'v.p{  (i+.5)*v.w/w-.5, (j+.5)*v.h/h-.5  }' 
												--("magick " + "\"" + t_temp + "\"" + " +repage -define distort:viewport=" + (rou (rez/sc)) as string + "x" + (rou (rez/sc)) as string + " -virtual-pixel edge -distort SRT 0 +repage " + "\"" + t_temp + "\"")
												--("magick " + "\"" + t_temp + "\"" + " +repage -virtual-pixel tile -set option:distort:viewport " + (rou (rez/sc)) as string + "x" + (rou (rez/sc)) as string + "-%[fx:max((h-w)/2,0)]-%[fx:max((w-h)/2,0)] +repage " + "\"" + t_temp + "\"")
												--("magick " + "\"" + t_temp + "\"" + " +repage -set option:distort:viewport " + s + "x" + s + "-" + s2 + "-" + s2 + " -virtual-pixel tile -distort srt 0 " + "\"" + t_temp + "\"")
												--cmd = ("magick " + "\"" + t_temp + "\"" + " +repage -set option:distort:viewport " + s + "x" + s + x + y + " -virtual-pixel tile -distort srt 0 " + "\"" + t_temp + "\"")
												--("magick " + "\"" + t_temp + "\"" + " +repage -set option:distort:viewport " + s + "x" + s + "+0+0 -virtual-pixel tile -distort srt 0 " + "\"" + t_temp + "\"")
												--print cmd
												HiddenDOSCommand (cmd) startpath:start		
											)	
											
											--print cmd
											--HiddenDOSCommand (cmd) startpath:start
											
											HiddenDOSCommand ("magick " + "\"" + t_temp + "\"" + " -resize " + rez as string + "x" + rez as string + "^! " + "\"" + t_temp + "\"") startpath:start

											--HiddenDOSCommand ("magick " + "\"" + t_temp + "\"" + " -set option:distort:viewport " + (rez) as string + "x" + (rez) as string + "+0+0 -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + t_temp + "\"") startpath:start
											--HiddenDOSCommand ("magick " + "\"" + t_temp + "\"" + " -set option:distort:viewport " + (rez/sc) as string + "x" + (rez/sc) as string + "+0+0 -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + t_temp + "\"") startpath:start
											--fit_map t t_temp pos2 sc rez start		
											--fit_map_mat t t_temp pos2 sc rez start
											
											if doesFileExist t_new then deleteFile t_new
											if doesFileExist t_temp then renamefile t_temp t_new
											appendIfUnique done_maps t_new

											--defMtl = copy b
											--defMtl.filename = t_new 
											--for d in refs.dependents (m.materialList[id]) do 
											--(
											--	refIdx = 0
											--	for i = 1 to refs.getNumRefs d do 
											--	(
											--		print #(refs.getreference d i)
													--if (refs.getreference d i) == m.materialList[id] do refIdx = i
											--	)
											--	refs.replaceReference (m.materialList[id]) refIdx defMtl
											--)	
											--b = copy b
											b.filename = t_new 
										)
									)
									--unwrapmod.moveSelected [pos_ini.x as integer + 0.5 - pos.x, pos_ini.y as integer + 0.5 - pos.y, 0]
									--unwrapmod.moveSelected [pos_ini.x as integer, pos_ini.y as integer, 0]
									--unwrapmod.moveSelected [floor pos_ini.x, floor pos_ini.y, 0]
								)
							)
						)
					)
					else
					(
						messageBox "Object should have Multimaterial for this operation"
					)
					unwrapmod.selectfaces faces_ini
					
				)
				else 
				(
					messageBox "Object should have Multimaterial for this operation"
				)
			)
		)
	)					
	
	on btn_UdimLeft pressed do
	(
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.count > 0 then
			(
				unwrapmod.moveSelected [-1.0, 0.0, 0.0]
			)
		)
	)
	
	on btn_UdimRight pressed do
	(
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.count > 0 then
			(
				unwrapmod.moveSelected [1.0, 0.0, 0.0]
			)
		)
	)
	
	on btn_UdimUp pressed do
	(
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.count > 0 then
			(
				unwrapmod.moveSelected [0.0, 1.0, 0.0]
			)
		)
	)
	
	on btn_UdimDown pressed do
	(
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.count > 0 then
			(
				unwrapmod.moveSelected [0.0, -1.0, 0.0]
			)
		)
	)

	on btn_unwrap_lowpoly_from_material pressed do with undo "Unwrap Atlas" on 
	(
		if selection.count > 0 then
		(
			if selection.count >= 2 then
			(
				sel = selection as Array
				converttopoly sel[1]
				for s in #{2..sel.count} do 
				(
					converttopoly sel[s]
					polyop.attach sel[1] sel[s]
				)
				select sel[1]
			)
			if selection.count == 1 then converttopoly selection[1]
		)
		
		if selection.count == 1 then
		(
			if selection[1].material != undefined then
			(
				--local atlas_size = 2048 
				local atlas_size = case (ddl_size_atlas.selection as integer) of
				(
					1: 256
					2: 512
					3: 1024
					4: 2048
					5: 4096
				)
				
				local rez = 1024				
				local size_thumb = 256
				
				local i = selection[1]
				local m = selection[1].material 
				local num = if classof (selection[1].material) == Multimaterial then selection[1].material.numsubs else 0
				local nam = substituteString (selection[1].name) "SM_" "T_"

				local ids_colors = #()
				
				local alt = not keyboard.altPressed
				local ctrl = keyboard.controlPressed
				local shift = keyboard.shiftPressed
				
				local start = GetINI_ImageMagick()
				
/*				
				for i in #{1..num} do 
				(
					print ((classof m.materialList[i]) as string) 
					case ((classof m.materialList[i]) as string) of 
					(
						
						"UndefinedClass": continue 
						
						"Standard":
						(
							if m.materialList[i].DiffuseMap == undefined then 
							(
								append colors (m.materialList[i].Diffuse)
								append ids_colors i
							)
						)
						
						"Physical_Material":
						(
							if m.materialList[i].base_color_map == undefined then 
							(
								append colors (m.materialList[i].base_color)
								append ids_colors i
							)
							
						)
						
						"CoronaLegacyMtl":
						(
							if m.materialList[i].texmapDiffuse == undefined then 
							(
								append colors (m.materialList[i].colorDiffuse) 
								append ids_colors i
							)
						)
					)
					
				)
*/

				if not doesDirectoryExist edt_multimat_path.text then makedir edt_multimat_path.text
				print edt_multimat_path.text
				print i
				print (classof m)
				makedir (edt_multimat_path.text + "rendered_textures\\")
				
				difuse = edt_multimat_path.text + "rendered_textures\\" + nam + "_Diffuse_" + ".png"
				normal = edt_multimat_path.text + "rendered_textures\\" + nam + "_Normal_" + ".png"
				erm = edt_multimat_path.text + "rendered_textures\\" + nam + "_ERM_" + ".png"
				opacity = edt_multimat_path.text + "rendered_textures\\" + nam + "_Opacity_" + ".png"
		
				case (classof m) of
				(
					default: (messagebox "No support this single type of material yet")	
					
					CoronaPhysicalMtl: (messagebox "No support for single CoronaPhysicalMtl yet")
					Physical_Material: (messagebox "No support for single Physical_Material yet")
					Standardmaterial: (messagebox "No support for single Standardmaterial yet")
					CoronaLayeredMtl: (messagebox "No support for single CoronaLayeredMtl yet")
					
					CoronaLegacyMtl: 
					(
						if m.texmapDiffuse != undefined then
						(
							--if isProperty sub_m.texmapDiffuse #filename then copy_mat sub_m.texmapDiffuse.filename difuse (GetINI_ImageMagick())
							--else render_map sub_m.texmapDiffuse rez difuse
							render_map_rect m.texmapDiffuse rez size_thumb difuse ctrl start "Diffuse"
						)
						else if not doesfileexist difuse then
						(
							HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX m.colorDiffuse + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
							--b = bitmap 256 256 filename:difuse color:m.colorDiffuse gamma:1.0 hdr:false
							--save b gamma:1.0 quiet:true
							--close b
							--free b
							--HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
							HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start
						)

						if m.texmapBump != undefined then
						(		
							--if isProperty sub_m.texmapBump #filename then copy_mat sub_m.texmapBump.filename normal (GetINI_ImageMagick())
							--else render_map sub_m.texmapBump rez normal
							render_map_rect m.texmapBump rez size_thumb normal ctrl start "Bump"
						)
						else if not doesfileexist normal then
						(			
							HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
							--b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
							--save b gamma:1.0 quiet:true
							--close b
							--free b
							--HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
							HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start --(GetINI_ImageMagick())
						)
										
						if m.texmapReflect != undefined then
						(
							--if isProperty sub_m.texmapReflect #filename then copy_mat sub_m.texmapReflect.filename erm (GetINI_ImageMagick())
							--else render_map sub_m.texmapReflect rez erm
							render_map_rect m.texmapReflect rez size_thumb erm	ctrl start "Reflect"
						)
						else if not doesfileexist erm then
						(		
							HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
							--b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
							--save b gamma:1.0 quiet:true
							--close b
							--free b
							--HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
							HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start --(GetINI_ImageMagick())
						)

						if m.texmapOpacity != undefined then
						(
							--if isProperty sub_m.texmapOpacity #filename then copy_mat sub_m.texmapOpacity.filename opacity (GetINI_ImageMagick())
							--else render_map sub_m.texmapOpacity rez opacity
							render_map_rect m.texmapOpacity rez size_thumb opacity	ctrl start "Opacity"
						)
						else if not doesfileexist opacity then
						(	
							HiddenDOSCommand ("magick -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " +  "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
							--b = bitmap 256 256 filename:opacity color:white gamma:1.0 hdr:false
							--save b gamma:1.0 quiet:true
							--close b
							--free b
							--HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " -alpha remove -alpha off " + "\"" + opacity + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
							HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " PNG24:" + "\""+ opacity + "\"") startpath:start --(GetINI_ImageMagick())
						)

						--if sub_m.texmapReflect != undefined then render_map sub_m.texmapReflect rez (edt_multimat_path.text + sub_m.name + "_Reflect" + ".png")
						--if sub_m.texmapReflectGlossiness != undefined then render_map sub_m.texmapReflectGlossiness rez (edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png")
						--if sub_m.texmapRefract != undefined then render_map sub_m.texmapRefract rez (edt_multimat_path.text + sub_m.name + "_Refract" + ".png")
						--if sub_m.texmapRefractGlossiness != undefined then render_map sub_m.texmapRefractGlossiness rez (edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png")
						--if sub_m.texmapTranslucency != undefined then render_map sub_m.texmapTranslucency rez (edt_multimat_path.text + sub_m.name + "_Translucency" + ".png")
						--if sub_m.texmapDisplace != undefined then render_map sub_m.texmapDisplace rez (edt_multimat_path.text + sub_m.name + "_Displace" + ".png")
						--if sub_m.texmapSelfIllum != undefined then render_map sub_m.texmapSelfIllum rez (edt_multimat_path.text + sub_m.name + "_SelfIllum" + ".png")
						
						id = 1
						
						--append ids_colors #(id, amax #((d = openBitMap difuse).width, d.height, (n = openBitMap normal).width, n.height, (e = openBitMap erm).width, e.height, (o = openBitMap opacity).width, o.height ), difuse, normal, erm, opacity)
							
						local d = if doesfileexist difuse then openBitMap difuse else undefined
						local n = if doesfileexist normal then openBitMap normal else undefined
						local e = if doesfileexist erm then openBitMap erm else undefined
						local o = if doesfileexist opacity then openBitMap opacity else undefined
							
						if d != undefined and n != undefined and e != undefined and o != undefined then 
						(
							append ids_colors #(id, amax #(d.width, d.height, n.width, n.height, e.width, e.height, o.width, o.height), difuse, normal, erm, opacity)
							close d; close n; close e; close o;
							free d; free n; free e;	free o;	
						)
						else 
						(
							messagebox (id as string + " ID: Error, one or few maps do not generated or found") 
							continue
						)								

					)
					
					Multimaterial: 
					(
						for id in #{1..m.numsubs} where m.materialList[id] != undefined and not keyboard.escPressed do
						(
							sub_m = m.materialList[id]
							difuse = edt_multimat_path.text + "rendered_textures\\" + nam + "_Diffuse_" + id as string + ".png"
							normal = edt_multimat_path.text + "rendered_textures\\" + nam + "_Normal_" + id as string + ".png"
							erm = edt_multimat_path.text + "rendered_textures\\" + nam + "_ERM_" + id as string + ".png"
							opacity = edt_multimat_path.text + "rendered_textures\\" + nam + "_Opacity_" + id as string + ".png"
							
							case classof sub_m of
							(
								CoronaLegacyMtl:
								(
									--showproperties sub_m
									--format "id=% diff=% mat=%\n" id difuse sub_m.texmapDiffuse.filename
									if sub_m.texmapDiffuse != undefined then
									(
										--if isProperty sub_m.texmapDiffuse #filename then copy_mat sub_m.texmapDiffuse.filename difuse (GetINI_ImageMagick())
										--else render_map sub_m.texmapDiffuse rez difuse
										render_map_rect sub_m.texmapDiffuse rez size_thumb difuse ctrl start "Diffuse"
									)
									else if not doesfileexist difuse then
									(
										HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX sub_m.colorDiffuse + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:difuse color:sub_m.colorDiffuse gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start --(GetINI_ImageMagick())
									)

									if sub_m.texmapBump != undefined then
									(		
										--if isProperty sub_m.texmapBump #filename then copy_mat sub_m.texmapBump.filename normal (GetINI_ImageMagick())
										--else render_map sub_m.texmapBump rez normal
										render_map_rect sub_m.texmapBump rez size_thumb normal ctrl start "Bump"
									)
									else if not doesfileexist normal then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
											--b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start --(GetINI_ImageMagick())
									)
										
									if sub_m.texmapReflect != undefined then
									(
										--if isProperty sub_m.texmapReflect #filename then copy_mat sub_m.texmapReflect.filename erm (GetINI_ImageMagick())
										--else render_map sub_m.texmapReflect rez erm
										render_map_rect sub_m.texmapReflect rez size_thumb erm ctrl start "Reflect"
									)
									else if not doesfileexist erm then
									(			
										HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start --(GetINI_ImageMagick())
									)

									if sub_m.texmapOpacity != undefined then
									(
										--if isProperty sub_m.texmapOpacity #filename then copy_mat sub_m.texmapOpacity.filename opacity (GetINI_ImageMagick())
										--else render_map sub_m.texmapOpacity rez opacity
										render_map_rect sub_m.texmapOpacity rez size_thumb opacity ctrl start "Opacity"
									)
									else if not doesfileexist opacity then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " +  "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:opacity color:white gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " -alpha remove -alpha off " + "\"" + opacity + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " PNG24:" + "\""+ opacity + "\"") startpath:start --(GetINI_ImageMagick())
									)

									--if sub_m.texmapReflect != undefined then render_map sub_m.texmapReflect rez (edt_multimat_path.text + sub_m.name + "_Reflect" + ".png")
									--if sub_m.texmapReflectGlossiness != undefined then render_map sub_m.texmapReflectGlossiness rez (edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png")
									--if sub_m.texmapRefract != undefined then render_map sub_m.texmapRefract rez (edt_multimat_path.text + sub_m.name + "_Refract" + ".png")
									--if sub_m.texmapRefractGlossiness != undefined then render_map sub_m.texmapRefractGlossiness rez (edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png")
									--if sub_m.texmapTranslucency != undefined then render_map sub_m.texmapTranslucency rez (edt_multimat_path.text + sub_m.name + "_Translucency" + ".png")
									--if sub_m.texmapDisplace != undefined then render_map sub_m.texmapDisplace rez (edt_multimat_path.text + sub_m.name + "_Displace" + ".png")
									--if sub_m.texmapSelfIllum != undefined then render_map sub_m.texmapSelfIllum rez (edt_multimat_path.text + sub_m.name + "_SelfIllum" + ".png")
								)
								
								CoronaPhysicalMtl:
								(
									if sub_m.baseTexmap != undefined then
									(
										--if isProperty sub_m.baseTexmap #filename then copy_mat sub_m.baseTexmap.filename difuse (GetINI_ImageMagick())
										--else render_map sub_m.baseTexmap rez difuse
										render_map_rect sub_m.baseTexmap rez size_thumb difuse ctrl start "Diffuse"
									)
									else if not doesfileexist difuse then
									(
										--print ("convert -size 256x256 canvas:" + RGBtoHEX sub_m.baseColor + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX sub_m.baseColor + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:difuse color:sub_m.baseColor gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start --(GetINI_ImageMagick())
									)
									
									if sub_m.baseBumpTexmap != undefined then
									(		
										--if isProperty sub_m.baseBumpTexmap #filename then copy_mat sub_m.baseBumpTexmap.filename normal (GetINI_ImageMagick())
										--else render_map sub_m.baseBumpTexmap rez normal
										render_map_rect sub_m.baseBumpTexmap rez size_thumb normal	ctrl start "Bump"
									)
									else if not doesfileexist normal then
									(		
										--print ("convert -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start --(GetINI_ImageMagick())
									)
									--metalnessTexmap
									if sub_m.baseRoughnessTexmap != undefined then
									(
										--if isProperty sub_m.baseRoughnessTexmap #filename then copy_mat sub_m.baseRoughnessTexmap.filename erm (GetINI_ImageMagick())
										--else render_map sub_m.baseRoughnessTexmap rez erm
										render_map_rect sub_m.baseRoughnessTexmap rez size_thumb erm ctrl start "Reflect"
									)
									else if not doesfileexist erm then
									(		
										--print ("convert -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start --(GetINI_ImageMagick())
									)
									--opacityTexmap 
									if sub_m.opacityTexmap != undefined then
									(
										--if isProperty sub_m.texmapOpacity #filename then copy_mat sub_m.texmapOpacity.filename opacity (GetINI_ImageMagick())
										--else render_map sub_m.texmapOpacity rez opacity
										render_map_rect sub_m.opacityTexmap rez size_thumb opacity	ctrl start "Opacity"
									)
									else if not doesfileexist opacity then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " +  "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:opacity color:white gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " -alpha remove -alpha off " + "\"" + opacity + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " PNG24:" + "\""+ opacity + "\"") startpath:start --(GetINI_ImageMagick())
									)
								)
								
								Physical_Material:
								(
									if sub_m.base_color_map != undefined then
									(
										--if isProperty sub_m.base_color_map #filename then copy_mat sub_m.base_color_map.filename difuse (GetINI_ImageMagick())
										--else render_map sub_m.base_color_map rez difuse
										render_map_rect sub_m.base_color_map rez size_thumb difuse ctrl start "Diffuse"
									)
									else if not doesfileexist difuse then
									(
										--print ("convert -size 256x256 canvas:" + RGBtoHEX sub_m.base_color + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX sub_m.base_color + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:difuse color:sub_m.base_color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") 
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start --(GetINI_ImageMagick())
									)
									
									if sub_m.bump_map != undefined then
									(		
										--if isProperty sub_m.bump_map #filename then copy_mat sub_m.bump_map.filename normal (GetINI_ImageMagick())
										--else render_map sub_m.bump_map rez normal
										render_map_rect sub_m.bump_map rez size_thumb normal ctrl start "Bump"
									)
									else if not doesfileexist normal then
									(		
										--print ("convert -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start --(GetINI_ImageMagick())
									)
										
									if sub_m.roughness_map != undefined then
									(
										--if isProperty sub_m.roughness_map #filename then copy_mat sub_m.roughness_map.filename erm (GetINI_ImageMagick())
										--else render_map sub_m.roughness_map rez erm
										render_map_rect sub_m.roughness_map rez size_thumb erm ctrl start "Reflect"
									)
									else if not doesfileexist erm then
									(		
										--print ("convert -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + erm + "\""+ " PNG24:" + "\"" + erm + "\"")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
									)	

									if sub_m.cutout_map != undefined then
									(
										--if isProperty sub_m.cutout_map #filename then copy_mat sub_m.cutout_map.filename opacity (GetINI_ImageMagick())
										--else render_map sub_m.cutout_map rez opacity
										render_map_rect sub_m.cutout_map rez size_thumb opacity ctrl start "Opacity"
									)
									else if not doesfileexist opacity then
									(	
										--print ("convert -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " +  "\"" + opacity + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " +  "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:opacity color:white gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + opacity + "\""+ " -alpha remove -alpha off " + "\"" + opacity + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + opacity + "\""+ " PNG24:" + "\""+ opacity + "\"")
										HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " PNG24:" + "\""+ opacity + "\"") startpath:start --(GetINI_ImageMagick())
									)
									
									-- .emission_map : texturemap 
									--emit_color
									--if sub_m.base_color_map != undefined then copy_mat sub_m.base_color_map.filename difuse (GetINI_ImageMagick())
									--if sub_m.roughness_map != undefined then render_map sub_m.roughness_map rez (edt_multimat_path.text + sub_m.name + "_Roughness" + ".png")
									--if sub_m.metalness_map != undefined then render_map sub_m.metalness_map rez (edt_multimat_path.text + sub_m.name + "_Metalness" + ".png")	
									--if sub_m.bump_map != undefined then copy_mat sub_m.bump_map.filename normal (GetINI_ImageMagick())
									--if sub_m.cutout_map != undefined then render_map sub_m.cutout_map rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
								
								Standardmaterial:
								(
									if sub_m.DiffuseMap != undefined then
									(
										--if isProperty sub_m.DiffuseMap #filename then copy_mat sub_m.DiffuseMap.filename difuse (GetINI_ImageMagick())
										--else render_map sub_m.DiffuseMap.filename rez difuse
										render_map_rect sub_m.DiffuseMap rez size_thumb difuse ctrl start "Diffuse"
									)
									else if not doesfileexist difuse then
									(
										--print ("convert -size 256x256 canvas:" + RGBtoHEX sub_m.diffuse + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX sub_m.diffuse + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:difuse color:sub_m.diffuse gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start --(GetINI_ImageMagick())
									)

									if sub_m.BumpMap != undefined then
									(		
										--if isProperty sub_m.BumpMap #filename then copy_mat sub_m.BumpMap.filename normal (GetINI_ImageMagick())
										--else render_map sub_m.BumpMap rez normal
										render_map_rect sub_m.BumpMap rez size_thumb normal ctrl start "Bump"
									)
									else if not doesfileexist normal then
									(		
										--print ("convert -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start --(GetINI_ImageMagick())
									)
										
									if sub_m.ReflectionMap != undefined then
									(
										--if isProperty sub_m.ReflectionMap #filename then copy_mat sub_m.ReflectionMap.filename erm (GetINI_ImageMagick())
										--else render_map sub_m.ReflectionMap rez erm
										render_map_rect sub_m.ReflectionMap rez size_thumb erm ctrl start "Reflect"
									)
									else if not doesfileexist erm then
									(		
										--print ("convert -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start --(GetINI_ImageMagick())
									)									
									
									if sub_m.OpacityMap != undefined then
									(
										--if isProperty sub_m.OpacityMap #filename then copy_mat sub_m.OpacityMap.filename opacity (GetINI_ImageMagick())
										--else render_map sub_m.OpacityMap rez opacity
										render_map_rect sub_m.OpacityMap rez size_thumb opacity ctrl start "Opacity"
									)
									else if not doesfileexist opacity then
									(	
										--print ("convert -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " + "\"" + opacity + "\"") 
										HiddenDOSCommand ("magick -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " + "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:opacity color:white gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close bs
										--free b
										--HiddenDOSCommand ("convert " + "\"" + opacity + "\""+ " -alpha remove -alpha off " + "\"" + opacity + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + opacity + "\""+ " PNG24:" + "\""+ opacity + "\"")
										HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " PNG24:" + "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
									)
									
									--if sub_m.DiffuseMap != undefined then copy_mat sub_m.DiffuseMap.filename difuse	(GetINI_ImageMagick())		
									--if sub_m.BumpMap != undefined then copy_mat sub_m.BumpMap.filename normal (GetINI_ImageMagick())
									--if sub_m.ReflectionMap != undefined then render_map sub_m.ReflectionMap rez (edt_multimat_path.text + sub_m.name + "_Reflection" + ".png")
									--if sub_m.GlossinessMap != undefined then render_map sub_m.GlossinessMap rez (edt_multimat_path.text + sub_m.name + "_Glossiness" + ".png")
									--if sub_m.OpacityMap != undefined then render_map sub_m.OpacityMap rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
								
								Vraymtl:
								(
									--texmap_diffuse
									--texmap_reflection
									--texmap_bump
									--texmap_opacity
									
									if sub_m.texmap_diffuse != undefined then
									(
										render_map_rect sub_m.texmap_diffuse rez size_thumb difuse ctrl start "Diffuse"
									)
									else if not doesfileexist difuse then
									(
										HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX sub_m.diffuse + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start --(GetINI_ImageMagick())
									)

									if sub_m.texmap_bump != undefined then
									(		
										render_map_rect sub_m.texmap_bump rez size_thumb normal ctrl start "Bump"
									)
									else if not doesfileexist normal then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start --(GetINI_ImageMagick())
									)
										
									if sub_m.texmap_reflection != undefined then
									(
										render_map_rect sub_m.texmap_reflection rez size_thumb erm ctrl start "Reflect"
									)
									else if not doesfileexist erm then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start --(GetINI_ImageMagick())
									)									
									
									if sub_m.texmap_opacity != undefined then
									(
										render_map_rect sub_m.texmap_opacity rez size_thumb opacity ctrl start "Opacity"
									)
									else if not doesfileexist opacity then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " + "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
										HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " PNG24:" + "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
									)
								)
								
								CoronaLayeredMtl:
								(
									messagebox "No support for CoronaLayeredMtl in Multisub yet" 
									continue
								)
								
								default:
								(
									messagebox "No support of this material type yet" 
									continue									
								)
							)
							
							local d = if doesfileexist difuse then openBitMap difuse else undefined
							local n = if doesfileexist normal then openBitMap normal else undefined
							local e = if doesfileexist erm then openBitMap erm else undefined
							local o = if doesfileexist opacity then openBitMap opacity else undefined
							
							if d != undefined and n != undefined and e != undefined and o != undefined then 
							(
								append ids_colors #(id, amax #(d.width, d.height, n.width, n.height, e.width, e.height, o.width, o.height), difuse, normal, erm, opacity)
								close d; close n; close e; close o;
								free d; free n; free e; free o;	
							)
							else 
							(
								messagebox (id as string + " ID: Error, one or few maps do not generated or found") 
								continue
							)								
						)
					)					
				)

				print #(ids_colors)
				
				local ids_z = #()
				local ids_l = #()
				
				local scales = #()
				local errored_texelDensities = ""

		
				--предварительно сгладить развертку в 0 по W
				--предварительно переразмерить развертку и текстуры в первый юдим
				if ids_colors.count > 0 then 
				(
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(	
						verts = #{}
						verts = #{1..unwrapmod.NumberVertices()} 
				
						if verts.numberset > 0 then
						(
							unwrapmod.selectVertices verts 
							unwrapmod.moveZ 0.0
						)	
						
						for i in #{1..ids_colors.count} where not keyboard.escPressed do
						(
							unwrapmod.setPolygonMode true
							unwrapmod.setTVSubObjectMode 3
							unwrapmod.unhide() 
							unwrapmod.selectByMatID ids_colors[i][1]
							--print ids_colors[i][1]
							unwrapmod.polygonSelect()
							local sel_face_pre = #{}
							local sc_pre = 1.0	
							local pos_pre = [0,0,0]
							sel_face_pre = unwrapmod.getselectedfaces()
							
							if not sel_face_pre.isempty then
							(
								unwrapmod.getarea sel_face_pre &nX &nY &nWidth &nHeight &nAreaUVW &nAreaGeom
								--if nWidth > 1.0 or nHeight > 1.0 then 

								sc_pre = if nWidth > nHeight then 0.95/nWidth else 0.95/nHeight
								pos_pre = unwrapmod.getSelCenter()
								unwrapmod.scaleSelectedXY sc_pre sc_pre [pos_pre.x, pos_pre.y, 0]
								unwrapmod.moveSelected [0.5 - pos_pre.x, 0.5 - pos_pre.y, 0]

								if ctrl then 
								(
									fit_map_new (ids_colors[i][3]) (ids_colors[i][3]) ([-0.5 + pos_pre.x, -0.5 + pos_pre.y, 0]) sc_pre (rez as integer) start
									fit_map_new (ids_colors[i][4]) (ids_colors[i][4]) ([-0.5 + pos_pre.x, -0.5 + pos_pre.y, 0]) sc_pre (rez as integer) start
									fit_map_new (ids_colors[i][5]) (ids_colors[i][5]) ([-0.5 + pos_pre.x, -0.5 + pos_pre.y, 0]) sc_pre (rez as integer) start
									fit_map_new (ids_colors[i][6]) (ids_colors[i][6]) ([-0.5 + pos_pre.x, -0.5 + pos_pre.y, 0]) sc_pre (rez as integer) start
									ids_colors[i][2] = rez as integer									
								) 
								else
								(
									if ids_colors[i][2] != size_thumb then
									(
										fit_map_new (ids_colors[i][3]) (ids_colors[i][3]) ([-0.5 + pos_pre.x, -0.5 + pos_pre.y, 0]) sc_pre (rez as integer) start
										fit_map_new (ids_colors[i][4]) (ids_colors[i][4]) ([-0.5 + pos_pre.x, -0.5 + pos_pre.y, 0]) sc_pre (rez as integer) start
										fit_map_new (ids_colors[i][5]) (ids_colors[i][5]) ([-0.5 + pos_pre.x, -0.5 + pos_pre.y, 0]) sc_pre (rez as integer) start
										fit_map_new (ids_colors[i][6]) (ids_colors[i][6]) ([-0.5 + pos_pre.x, -0.5 + pos_pre.y, 0]) sc_pre (rez as integer) start
										ids_colors[i][2] = rez as integer
									)
									else
									(
										fit_map_new (ids_colors[i][3]) (ids_colors[i][3]) ([-0.5 + pos_pre.x, -0.5 + pos_pre.y, 0]) sc_pre (size_thumb as integer) start
										fit_map_new (ids_colors[i][4]) (ids_colors[i][4]) ([-0.5 + pos_pre.x, -0.5 + pos_pre.y, 0]) sc_pre (size_thumb as integer) start
										fit_map_new (ids_colors[i][5]) (ids_colors[i][5]) ([-0.5 + pos_pre.x, -0.5 + pos_pre.y, 0]) sc_pre (size_thumb as integer) start
										fit_map_new (ids_colors[i][6]) (ids_colors[i][6]) ([-0.5 + pos_pre.x, -0.5 + pos_pre.y, 0]) sc_pre (size_thumb as integer) start
										ids_colors[i][2] = size_thumb as integer
									)
								)
							)
						)
					)
					addmodifier selection[1] (Unwrap_UVW()) --converttopoly selection[1]
				)

				if ids_colors.count > 0 then 
				(
					if ctrl then 
					(
						ids_z = #()
						ids_l = for i in #{1..ids_colors.count} collect ids_colors[i]
					)
					else
					(
						ids_z = for i in #{1..ids_colors.count} where ids_colors[i][2] == size_thumb collect ids_colors[i]
						ids_l = for i in #{1..ids_colors.count} where ids_colors[i][2] != size_thumb collect ids_colors[i]
					)
						
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						local sel_face = #{}
						local quant = ids_l.count + (if ids_z.count == 0 then 0 else 1)
						local uv_h, uv_hs = #()
						local uv_w, uv_ws = #()
						local poi_x, poi_xs = #()
						local poi_y, poi_ys = #()
						local pos
						local texelDensities = #()
						
						print quant
						
						local size_h_row = 1.0
						local size_g_col = 1.0	
						local quota_g = 1.0 / size_g_col
						local quota_h = 1.0 / size_h_row	
						local padding_w = 1.052631 -- ==1/0.95
						local padding_h = 1.052631 -- ==1/0.95
						
						/*
						case of
						(
							(quant == 1): (size_h_row = 1; size_g_col = 1)	--Num Images Tile Setting 1 1x1
							(quant == 2): (size_h_row = 1; size_g_col = 2)  --2 2x1
							(quant == 3): (size_h_row = 1; size_g_col = 3)  --3 3x1
							(quant == 4): (size_h_row = 2; size_g_col = 2)	--4	2x2
							(quant == 5 or quant == 6): (size_h_row = 2; size_g_col = 3) --5-6	3x2
							(quant == 7 or quant == 8): (size_h_row = 2; size_g_col = 4)  --7-8	4x2
							(quant == 9): (size_h_row = 3; size_g_col = 3)  --9	3x3
							(quant == 10 or quant == 11 or quant == 12): (size_h_row = 3; size_g_col = 4) --10- 12 4x3
							(quant == 13 or quant == 14 or quant == 15): (size_h_row = 3; size_g_col = 5) --13-15 5x3
							(quant == 16 or quant == 17 or quant == 18 or quant == 19 or quant == 20): (size_h_row = 4; size_g_col = 5) --16-20 5x4
							(quant == 21 or quant == 22 or quant == 23 or quant == 24): (size_h_row = 4; size_g_col = 6) --21-24 6x4
							(quant == 25): (size_h_row = 5; size_g_col = 5) --25 5x5
							(quant == 26 or quant == 27 or quant == 28 or quant == 29 or quant == 30): (size_h_row = 5; size_g_col = 6) --26-30	6x5
							(quant == 31 or quant == 32 or quant == 33 or quant == 34 or quant == 35): (size_h_row = 5; size_g_col = 7) --31-35	7x5						
							(quant == 36): (size_h_row = 6; size_g_col = 6) --36 6x6
							(quant == 37 or quant == 38 or quant == 39 or quant == 40 or quant == 41 or quant == 42): (size_h_row = 6; size_g_col = 7) --37-42 7x6								
							(quant == 43 or quant == 44 or quant == 45 or quant == 46 or quant == 47 or quant == 48): (size_h_row = 6; size_g_col = 8) --43-48 8x6							
						)
						*/
						
						size_h_row = (ceil (sqrt (quant))) as integer
						size_g_col = size_h_row
						
						quota_g = 1.0 / size_g_col
						quota_h = 1.0 / amax #(size_g_col, size_h_row)	
						
						local size_g = 0.0
						local size_h = 0.0

						local page = 0.0
						local sc_h = 1.0
						local sc_g = 1.0
						local sc = 1.0	
					
						for i in #{1..ids_colors.count} where ids_colors[i][2] != size_thumb and not keyboard.escPressed do
						(
							local mWidths = #()
							local mHeights = #()
							unwrapmod.setPolygonMode true
							unwrapmod.setTVSubObjectMode 3
							unwrapmod.unhide() 
							unwrapmod.selectByMatID ids_colors[i][1]
							--print ids_colors[i][1]
							unwrapmod.polygonSelect()
							sel_face = unwrapmod.getselectedfaces()
							
							if not sel_face.isempty then 
							(
								unwrapmod.getarea sel_face &mXX &mYY &mWidth &mHeight &mAreaUVW &mAreaGeom
								sc_h = 1.0
								sc_g = 1.0
								
								padding_w = if mWidth <= 1.0 then 1.0/mWidth else 1.052631
								padding_h = if mHeight <= 1.0 then 1.0/mHeight else 1.052631
								
								case of
								(
									(mHeight > quota_h and mWidth > quota_g): (sc_h = quota_h / mHeight; sc_g = quota_g / mWidth)
									(mHeight > quota_h and mWidth <= quota_g): sc_h = quota_h / mHeight
									(mHeight <= quota_h and mWidth > quota_g): sc_g = quota_g / mWidth
									(mHeight <= quota_h and mWidth <= quota_g):	(sc_h = quota_h / mHeight; sc_g = quota_g / mWidth)  
								)

								sc = if sc_h < sc_g then sc_h else sc_g
									
								--amax #(sc/padding_w, sc/padding_h)
								
								pos = unwrapmod.getSelCenter()
								--print pos
								unwrapmod.scaleSelectedXY (amax #(sc/padding_w, sc/padding_h)) (amax #(sc/padding_w, sc/padding_h)) [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter (sc) 0
								pos = unwrapmod.getSelCenter()
								posX = (size_g * quota_g) + (0.5 / size_g_col) - pos.x
								posY = 1 - ( (size_h * quota_h) + (0.5 / amax #(size_g_col, size_h_row) ) ) - pos.y
								unwrapmod.moveSelected [posX, posY, 0]
									
								pos = unwrapmod.getSelCenter()	
								local textureArea = atlas_size ^ 2	
								texelDensities = #()		

								unwrapmod.getarea sel_face &mX__ &mY__ &mWidth__ &mHeight__ &mAreaUVW__ &mAreaGeom__	
								for t in sel_face do
								(
									unwrapmod.getarea #{t} &mXXX &mYYY &mWidth_ &mHeight_ &mAreaUVW_ &mAreaGeom_
									local texelDensity = sqrt ((mAreaUVW_ * textureArea) / mAreaGeom_)	
									append texelDensities texelDensity
								)	
								local t_min = amin(texelDensities)
								local t_max = amax(texelDensities)								
								
								local sc_min = 10.01 / t_min
								local sc_max = 39.90 / t_max 
								--print (sc_max * t_min)
								
								if (sc_max * t_min) <= 10 then append errored_texelDensities (i as string + ": not fited to lower border of densities [10..40]\n")

								if (mWidth__ * sc_max ) > (quota_g * 0.95) or (mHeight__ * sc_max) > (quota_h * 0.95) then 
								(
									if (mWidth__ * sc_max) > (mHeight__ * sc_max) then sc_max = 0.95 * quota_g / mWidth__ else sc_max = 0.95 * quota_h / mHeight__  
									errored_texelDensities += i as string + ": not fited to quadrant borders, downscaled to fit\n"
								)
								
								/*
								if sc_max < 0.5 then --need to re unwrap
								(
									unwrapmod.flattenMap 45.0 #([1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]) 0.001 true 0 true true 
									unwrapmod.selectByMatID ids_colors[i][1]
									unwrapmod.breakSelected()
									unwrapmod.selectByMatID ids_colors[i][1]
									unwrapmod.faceToEdgeSelect() 
									--local edges_ = #{}
									--edges_ = unwrapmod.getSelectedEdges()
									--unwrapmod.selectElement()
									unwrapmod.breakSelected()
									--edges_ = unwrapmod.getSelectedEdges()
									--unwrapmod.edgeToFaceSelect() 
									unwrapmod.selectByMatID ids_colors[i][1]
									sel_face = unwrapmod.getselectedfaces()
									for f in sel_face where not keyboard.escPressed do 
									(
										local pp = unwrapmod.getSelCenter()
										unwrapmod.selectFaces #{f} 
										unwrapmod.moveSelected [pos.x - pp.x, pos.x - pp.y, 0]
									)
									unwrapmod.getarea sel_face &mX__ &mY__ &mWidth__ &mHeight__ &mAreaUVW__ &mAreaGeom__
									local sc_max = 39.90 / sqrt ((mAreaUVW__ * textureArea) / mAreaGeom__) 
								)	
								*/
								
								if not alt then unwrapmod.scaleSelectedXY (sc_max) (sc_max) [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter (sc) 0
								
								unwrapmod.getarea sel_face &mX___ &mY___ &mWidth___ &mHeight___ &mAreaUVW___ &mAreaGeom___

								format "id=% t_min=% t_max=% mHeight=% mWidth=%  sc=%  sc_g=%  sc_h=% padding_h=% padding_w=% size=% mHeight_new=% mWidth_new=% sc_max=% quota_h=% quota_g=% *=% *=%\n" ids_colors[i][1] t_min t_max mHeight mWidth sc sc_g sc_h padding_h padding_w ids_colors[i][2] mWidth__ mHeight__ sc_max quota_h quota_g (mWidth__ * sc_max) (mHeight__ * sc_max)
								append scales #(i, amax #(sc/padding_w, sc/padding_h), (sc_max), mX__, mY__, mWidth__, mHeight__, mX___, mY___, mWidth___, mHeight___)
							)
							
							if size_g + 1.0 >= size_g_col then 
							(
								if size_h + 1.0 >= amax #(size_g_col, size_h_row) then 
								(
									page += 1.0
									size_h = 0.0
									size_g = 0.0
								)
								else
								(
									size_h += 1.0
									size_g = 0.0
								)
							)
							else
							(
								size_g += 1.0
							)							
						)
						
						--print scales
						
						--сузить пространство до части юдима и повторить развертки по прежнему алгоритму квадрантов
						quant = ids_z.count
						padding_w = 1.052631 -- ==1/0.95
						padding_h = 1.052631 -- ==1/0.95
							/*
							case of
							(
								(quant == 1): (size_h_row = 1; size_g_col = 1)	--Num Images Tile Setting 1 1x1
								(quant == 2): (size_h_row = 1; size_g_col = 2)  --2 2x1
								(quant == 3): (size_h_row = 1; size_g_col = 3)  --3 3x1
								(quant == 4): (size_h_row = 2; size_g_col = 2)	--4	2x2
								(quant == 5 or quant == 6): (size_h_row = 2; size_g_col = 3) --5-6	3x2
								(quant == 7 or quant == 8): (size_h_row = 2; size_g_col = 4)  --7-8	4x2
								(quant == 9): (size_h_row = 3; size_g_col = 3)  --9	3x3
								(quant == 10 or quant == 11 or quant == 12): (size_h_row = 3; size_g_col = 4) --10- 12 4x3
								(quant == 13 or quant == 14 or quant == 15): (size_h_row = 3; size_g_col = 5) --13-15 5x3
								(quant == 16 or quant == 17 or quant == 18 or quant == 19 or quant == 20): (size_h_row = 4; size_g_col = 5) --16-20 5x4
								(quant == 21 or quant == 22 or quant == 23 or quant == 24): (size_h_row = 4; size_g_col = 6) --21-24 6x4
								(quant == 25): (size_h_row = 5; size_g_col = 5) --25 5x5
								(quant == 26 or quant == 27 or quant == 28 or quant == 29 or quant == 30): (size_h_row = 5; size_g_col = 6) --26-30	6x5
								(quant == 31 or quant == 32 or quant == 33 or quant == 34 or quant == 35): (size_h_row = 5; size_g_col = 7) --31-35	7x5						
								(quant == 36): (size_h_row = 6; size_g_col = 6) --36 6x6
								(quant == 37 or quant == 38 or quant == 39 or quant == 40 or quant == 41 or quant == 42): (size_h_row = 6; size_g_col = 7) --37-42 7x6								
								(quant == 43 or quant == 44 or quant == 45 or quant == 46 or quant == 47 or quant == 48): (size_h_row = 6; size_g_col = 8) --43-48 8x6							
							)
							*/
						size_h_row = (ceil (sqrt (quant))) as integer
						size_g_col = size_h_row

						local size_g_old = size_g * quota_g --смещение из положения старого квадранта
						local size_h_old = size_h * quota_h --смещение из положения старого квадранта

						quota_g = amax #(quota_g, quota_h) / size_g_col
						quota_h = amax #(quota_g, quota_h) / amax #(size_g_col, size_h_row)	

						size_g = 0.0
						size_h = 0.0
							
						page = 0.0
						sc_h = 1.0
						sc_g = 1.0
						sc = 1.0	

						for i in #{1..ids_colors.count} where ids_colors[i][2] == size_thumb and not keyboard.escPressed do
						(
							local mWidths = #()
							local mHeights = #()
							unwrapmod.setPolygonMode true
							unwrapmod.setTVSubObjectMode 3
							unwrapmod.unhide() 
							unwrapmod.selectByMatID ids_colors[i][1]
							--print ids_colors[i][1]
							unwrapmod.polygonSelect()
							sel_face = unwrapmod.getselectedfaces()
							
							if not sel_face.isempty then 
							(
								unwrapmod.getarea sel_face &mXX &mYY &mWidth &mHeight &mAreaUVW &mAreaGeom
								sc_h = 1.0
								sc_g = 1.0
								
								padding_w = if mWidth <= 1.0 then 1.0/mWidth else 1.052631
								padding_h = if mHeight <= 1.0 then 1.0/mHeight else 1.052631
								
								case of
								(
									(mHeight > quota_h and mWidth > quota_g): (sc_h = quota_h / mHeight; sc_g = quota_g / mWidth)
									(mHeight > quota_h and mWidth <= quota_g): sc_h = quota_h / mHeight
									(mHeight <= quota_h and mWidth > quota_g): sc_g = quota_g / mWidth
									(mHeight <= quota_h and mWidth <= quota_g):	(sc_h = quota_h / mHeight; sc_g = quota_g / mWidth)  
								)

								sc = if sc_h < sc_g then sc_h else sc_g
								format "id=% mHeight=% mWidth=% sc=% sc_g=% sc_h=% padding_h=% padding_w=% size=%\n" ids_colors[i][1] mHeight mWidth sc sc_g sc_h padding_h padding_w ids_colors[i][2]
								pos = unwrapmod.getSelCenter()
								--print pos
								unwrapmod.scaleSelectedXY (amax #(sc/padding_w, sc/padding_h)) (amax #(sc/padding_w, sc/padding_h)) [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter (sc) 0
								pos = unwrapmod.getSelCenter()
								posX = size_g_old + ((size_g - 1) * quota_g) + (0.5 / size_g_col) - pos.x
								posY = 1 - (size_h_old + ((size_h - 1) * quota_h) + (0.5 / amax #(size_g_col, size_h_row) )) - pos.y
								unwrapmod.moveSelected [posX, posY, 0]
								if ids_l.count == 0 then unwrapmod.moveSelected [quota_g, -quota_h, 0]
							)
							
							if size_g + 1.0 >= size_g_col then 
							(
								if size_h + 1.0 >= amax #(size_g_col, size_h_row) then 
								(
									page += 1.0
									size_h = 0.0
									size_g = 0.0
								)
								else
								(
									size_h += 1.0
									size_g = 0.0
								)
							)
							else
							(
								size_g += 1.0
							)	
							
						)
						
						--дополнительное аварийное сдвигание
						sel_face_zagl = #{}
						for i in #{1..ids_colors.count} where ids_colors[i][2] == size_thumb and not keyboard.escPressed do
						(
							unwrapmod.selectByMatID ids_colors[i][1]
							unwrapmod.polygonSelect()
							sel_face_zagl += unwrapmod.getselectedfaces()
						)
						unwrapmod.selectfaces sel_face_zagl
						pos = unwrapmod.getSelCenter()
						posX = size_g_old + ((size_g - 1) * quota_g) + (0.5 / size_g_col) - pos.x
						posY = 1 - (size_h_old + ((size_h - 1) * quota_h) + (0.5 / amax #(size_g_col, size_h_row) )) - pos.y
						unwrapmod.moveSelected [posX, posY, 0]
						if ids_l.count == 0 then unwrapmod.moveSelected [quota_g, -quota_h, 0]

								
						/*						
						q = selection[1].modifiers[1]
						--for id in ids_colors do
							--for p in #{1..q.numberPolygons()} where not keyboard.escpressed  do --or getSelectMatID id do
							--(
								--print (p as string + " " + q.numberPolygons() as string)
								--q.unwrap2.setTVSubObjectMode 3
								--q.selectFacesByNode #{p} selection[1]
								--q.unwrap2.faceToVertSelect()
								--sel = q.unwrap.getselectedvertices()
								--poi = (for i in sel collect (q.unwrap.getvertexposition currenttime i))[1]
								--poi = [(amax (for i in sel collect (q.unwrap.getvertexposition currenttime i).x) - amin (for i in sel collect (q.unwrap.getvertexposition currenttime i).x))/2, (amax (for i in sel collect (q.unwrap.getvertexposition currenttime i).y) - amin (for i in sel collect (q.unwrap.getvertexposition currenttime i).y))/2,0]

								uvMax = [-99999,-99999,0]
								uvMin = [99999,99999,0]
								for i in #{1..sel.count} do 
								(
									uvPos = q.unwrap.getvertexposition currenttime i
									if uvPos.x > uvMax.x then 
									(
										uvMax.x = uvPos.x
									)
									else 
									(
										if uvPos.x < uvMin.x do
										(
											uvMin.x = uvPos.x
										)
									)
									if uvPos.y > uvMax.y then 
									(
										uvMax.y = uvPos.y
									)
									else 
									(
										if uvPos.y < uvMin.y do 
										(
											uvMin.y = uvPos.y
										)
									)
								)
								q.unwrap2.setTVSubObjectMode 3
								poi = (uvMax+uvMin)/2 

								--poi = q.unwrap.getvertexposition currenttime sel[1]
								
							
								--print poi
								--id = (poi.x as integer) + 1 + 10 * (poi.y as integer)
								--q.unwrap2.setTVSubObjectMode 3
								--q.selectFacesByNode #{p} selection[1]
								--print id
								--q.setSelectMatID id

						--)
						*/					
					)

					local picpath = edt_multimat_path.text + "rendered_textures\\" + nam + "_d_1.png"
					local picpath_z = edt_multimat_path.text + "rendered_textures\\" + nam + "_d_1z.png"	
					
					local o_picpath = edt_multimat_path.text + "rendered_textures\\" + nam + "_o_1.png" --opacity
					local o_picpath_z = edt_multimat_path.text + "rendered_textures\\" + nam + "_o_1z.png"	
					
					local n_picpath = edt_multimat_path.text + "rendered_textures\\" + nam + "_n_1.png" --normals
					local n_picpath_z = edt_multimat_path.text + "rendered_textures\\" + nam + "_n_1z.png"						
					
					local m_picpath = edt_multimat_path.text + "rendered_textures\\" + nam + "_m_1.png" --metallicity
					local m_picpath_z = edt_multimat_path.text + "rendered_textures\\" + nam + "_m_1z.png"	

					local r_picpath = edt_multimat_path.text + "rendered_textures\\" + nam + "_r_1.png" --roughness
					local r_picpath_z = edt_multimat_path.text + "rendered_textures\\" + nam + "_r_1z.png"	
					
					print picpath
					
					/*
					if alt then
					(
						size = 2048
						size_thumb = 256
						size_pic = 1024
						--if ids_colors.count == m.materialList.count then size_thumb = (size / floor (sqrt ids_colors.count)) as integer
						print size
						print size_thumb	
						picpath = maxFilePath + "Images\\" + m.name + "_d_0000.png"
						picpath_thumb = maxFilePath + "Images\\" + m.name + "_d_0000+.png"
						makeDir (maxFilePath + "Images\\")
						
						texture = bitmap size size gamma:1.0 color:(color 0 0 0 255) filename:picpath hdr:false 
						row = 0
						stolb = 0
						
						size_thumb = 1024
						for i in #{1..ids_colors.count} where ids_colors[i][2] == 1024 do 
						(
							thumb = openBitMap ids_colors[i][3]
							
							pasteBitmap thumb texture [0,0] [size_thumb*stolb, size_thumb*row] type:#paste alphaMultiplier:1.0

							--thumb = bitmap size_thumb size_thumb gamma:1.0 color:colors[i] filename:picpath_thumb hdr:false 
							--save thumb gamma:1.0 quiet:true
							--pasteBitmap thumb texture [0,0] [size_thumb*stolb, size_thumb*row] type:#paste alphaMultiplier:1.0
							stolb += 1
							if stolb >= size / size_thumb or stolb * size_thumb >= size then 
							(
								stolb = 0
								row += 1
							)
							close thumb
							free thumb						
						)
						
						size_thumb = 256
						for i in #{1..ids_colors.count} where ids_colors[i][2] == 256 do 
						(
							thumb = openBitMap ids_colors[i][3]
							
							pasteBitmap thumb texture [0,0] [size_thumb*stolb, size_thumb*row] type:#paste alphaMultiplier:1.0

							--thumb = bitmap size_thumb size_thumb gamma:1.0 color:colors[i] filename:picpath_thumb hdr:false 
							--save thumb gamma:1.0 quiet:true
							--pasteBitmap thumb texture [0,0] [size_thumb*stolb, size_thumb*row] type:#paste alphaMultiplier:1.0
							stolb += 1
							if stolb >= size / size_thumb or stolb * size_thumb >= size then 
							(
								stolb = 0
								row += 1
							)
							close thumb
							free thumb						
						)					
						
						save texture gamma:1.0 quiet:true
						close texture
						free texture
					
					)
					else
					(
					*/
					
					--local cmd = ""
					--local pics = ""
					
					--local o_cmd = ""
					--local o_pics = ""
					--local n_cmd = ""
					--local n_pics = ""
					--local m_cmd = ""
					--local m_pics = ""
					--local r_cmd = ""
					--local r_pics = ""
					
					--for i in #{1..ids_colors.count} do pics += "\"" + ids_colors[i][3] + "\"" + " "

					if ids_z.count > 0 then 
					(
						local tile_z = ((ceil (sqrt (ids_z.count))) as integer) as string 
						/*	
						pics = ""
						o_pics = ""
						n_pics = ""
						m_pics = ""
						r_pics = ""
						
						for i in #{1..ids_colors.count} where ids_colors[i][2] == size_thumb do
						(
							--difuse - 3, normal - 4, erm - 5, opacity - 6
							pics += "\"" + ids_colors[i][3] + "\"" + " " --difuse
							o_pics += "\"" + ids_colors[i][6] + "\"" + " " --opacity
							n_pics += "\"" + ids_colors[i][4] + "\"" + " " --normal
							m_pics += "\"" + ids_colors[i][5] + "\"" + " " --erm
							r_pics += "\"" + ids_colors[i][5] + "\"" + " " --erm
						)
						*/	

						--composite {overlay} {background} [{mask}] [-compose {method}]   {result}
						--magick {background} {overlay} [{mask}] [-compose {method}] -composite   {result}
						-- -compose src-over modulate -define compose:args=100 -composite 
						local poi_x = 0
						local poi_y = 0
						local t = 0
						HiddenDOSCommand ("magick -size " + (256 * (tile_z as integer)) as string + "x" + (256 * (tile_z as integer)) as string + " canvas:black -define png:color-type=6 " +  "\"" + picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick -size " + (256 * (tile_z as integer)) as string + "x" + (256 * (tile_z as integer)) as string + " canvas:white -define png:color-type=6 " +  "\"" + o_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick -size " + (256 * (tile_z as integer)) as string + "x" + (256 * (tile_z as integer)) as string + " canvas:#8080FF -define png:color-type=6 " +  "\"" + n_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick -size " + (256 * (tile_z as integer)) as string + "x" + (256 * (tile_z as integer)) as string + " canvas:black -define png:color-type=6 " +  "\"" + m_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick -size " + (256 * (tile_z as integer)) as string + "x" + (256 * (tile_z as integer)) as string + " canvas:white -define png:color-type=6 " +  "\"" + r_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())

						for i in #{1..ids_colors.count} where ids_colors[i][2] == size_thumb do
						(	
							poi_x = 256 * ((mod t (tile_z as integer)) as integer)
							poi_y = (256 * ((tile_z as integer) - 1)) - (256 * (floor (t / (tile_z as integer))))
							--print poi_x
							--print poi_y
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + ids_colors[i][3] + "\"" + " " + "\"" + picpath_z + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + ids_colors[i][6] + "\"" + " " + "\"" + o_picpath_z + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + o_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + ids_colors[i][4] + "\"" + " " + "\"" + n_picpath_z + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + n_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + ids_colors[i][5] + "\"" + " " + "\"" + m_picpath_z + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + m_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + ids_colors[i][5] + "\"" + " " + "\"" + r_picpath_z + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + r_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
							t += 1
						)						
						
							/*
							case of  
							(
								default: cmd = ""
								--надо помещать 256х256 в квадрат 1024х1024, это по 4х4шт
								(ids_z.count > 0 and ids_z.count <= 4 and ids_l.count > 0 and ids_l.count <= 3): cmd = "magick montage " + pics + " -geometry 512x512+0+0 -tile 2x2 -border 0 -background black " + "\"" + picpath_z + "\""
								(ids_z.count > 0 and ids_z.count <= 4 and ids_l.count > 3): cmd = "magick montage " + pics + " -geometry 256x256+0+0 -tile 1x4 -border 0 -background black " + "\"" + picpath_z + "\""
								(ids_z.count > 4 and ids_z.count <= 9 and ids_l.count > 0 and ids_l.count <= 3): cmd = "magick montage " + pics + " -geometry 256x256+0+0 -tile 3x3 -border 0 -background black " + "\"" + picpath_z + "\""
								(ids_z.count > 4 and ids_z.count <= 8): cmd = "magick montage " + pics + " -geometry 256x256+0+0 -tile 2x4 -border 0 -background black " + "\"" + picpath_z + "\""
								(ids_z.count > 8 and ids_z.count <= 16): cmd = "magick montage " + pics + " -geometry 256x256+0+0 -tile 4x4 -border 0 -background black " + "\"" + picpath_z + "\""
							)
							*/
						
						--cmd = "magick montage " + pics + " -filter point -tile " + tile_z + "x" + tile_z + " -geometry 256x256+0+0 -border 0 -background black " + "\"" + picpath_z + "\""
						--o_cmd = "magick montage " + o_pics + " -filter point -tile " + tile_z + "x" + tile_z + " -geometry 256x256+0+0 -border 0 -background white " + "\"" + o_picpath_z + "\""
						--n_cmd = "magick montage " + n_pics + " -filter point -tile " + tile_z + "x" + tile_z + " -geometry 256x256+0+0 -border 0 -background black " + "\"" + n_picpath_z + "\""
						--m_cmd = "magick montage " + m_pics + " -filter point -tile " + tile_z + "x" + tile_z + " -geometry 256x256+0+0 -border 0 -background black " + "\"" + m_picpath_z + "\""	
						--r_cmd = "magick montage " + r_pics + " -filter point -tile " + tile_z + "x" + tile_z + " -geometry 256x256+0+0 -border 0 -background black " + "\"" + r_picpath_z + "\""							
						
						--cmd = "magick montage " + pics + " -filter point -geometry 256x256+0+0 -border 0 -background black " + "\"" + picpath_z + "\""
						--o_cmd = "magick montage " + o_pics + " -filter point -geometry 256x256+0+0 -border 0 -background white " + "\"" + o_picpath_z + "\""
						--n_cmd = "magick montage " + n_pics + " -filter point -geometry 256x256+0+0 -border 0 -background black " + "\"" + n_picpath_z + "\""
						--m_cmd = "magick montage " + m_pics + " -filter point -geometry 256x256+0+0 -border 0 -background black " + "\"" + m_picpath_z + "\""	
						--r_cmd = "magick montage " + r_pics + " -filter point -geometry 256x256+0+0 -border 0 -background black " + "\"" + r_picpath_z + "\""							
						
						--print cmd
						--HiddenDOSCommand (cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + picpath_z + "\"" + " -interpolate Integer -filter point -resize 1024x1024 +repage -gravity NorthEast -background black -extent 1024x1024 -define png:color-type=6 " + "\"" + picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
	
						--HiddenDOSCommand (o_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + o_picpath_z + "\"" + " -interpolate Integer -filter point -resize 1024x1024 +repage -gravity NorthEast -background white -extent 1024x1024 -define png:color-type=6 " + "\"" + o_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (n_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + n_picpath_z + "\"" + " -interpolate Integer -filter point -resize 1024x1024 +repage -gravity NorthEast -background black -extent 1024x1024 -define png:color-type=6 " + "\"" + n_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						
						--HiddenDOSCommand (m_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + m_picpath_z + "\"" + " -interpolate Integer -filter point -resize 1024x1024 +repage -gravity NorthEast -background black -extent 1024x1024 -define png:color-type=6 " + "\"" + m_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + m_picpath_z + "\"" + " -channel B -separate " + "\"" + m_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
							
						--HiddenDOSCommand (r_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + r_picpath_z + "\"" + " -interpolate Integer -filter point -resize 1024x1024 +repage -gravity NorthEast -background black -extent 1024x1024 -define png:color-type=6 " + "\"" + r_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + r_picpath_z + "\"" + " -channel G -separate " + "\"" + r_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						/*	
						pics = ""	
						o_pics = ""
						n_pics = ""
						m_pics = ""
						r_pics = ""
							
						for i in #{1..ids_colors.count} where ids_colors[i][2] != size_thumb do 
						(
							pics += "\"" + ids_colors[i][3] + "\"" + " " --difuse
							o_pics += "\"" + ids_colors[i][6] + "\"" + " " --opacity
							n_pics += "\"" + ids_colors[i][4] + "\"" + " " --normal
							m_pics += "\"" + ids_colors[i][5] + "\"" + " " --erm
							r_pics += "\"" + ids_colors[i][5] + "\"" + " " --erm

						)
						
						pics += "\"" + picpath_z + "\"" 
						o_pics += "\"" + o_picpath_z + "\"" 
						n_pics += "\"" + n_picpath_z + "\"" 
						m_pics += "\"" + m_picpath_z + "\"" 
						r_pics += "\"" + r_picpath_z + "\"" 
						*/
					)	

					local tile = if ctrl then ((ceil (sqrt (ids_l.count + ids_z.count))) as integer) as string else ((ceil (sqrt (ids_l.count + (if ids_z.count == 0 then 0 else 1) ))) as integer) as string 

					--convert *.png -append sprites.png (append vertically)
					--convert *.png +append sprites.png (append horizontally)
						
					local poi_x = 0
					local poi_y = 0
					local t = 0
					
					HiddenDOSCommand ("magick -size " + (1024 * (tile as integer)) as string + "x" + (1024 * (tile as integer)) as string + " canvas:black -define png:color-type=6 " +  "\"" + picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("magick -size " + (1024 * (tile as integer)) as string + "x" + (1024 * (tile as integer)) as string + " canvas:white -define png:color-type=6 " +  "\"" + o_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("magick -size " + (1024 * (tile as integer)) as string + "x" + (1024 * (tile as integer)) as string + " canvas:#8080FF -define png:color-type=6 " +  "\"" + n_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("magick -size " + (1024 * (tile as integer)) as string + "x" + (1024 * (tile as integer)) as string + " canvas:black -define png:color-type=6 " +  "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("magick -size " + (1024 * (tile as integer)) as string + "x" + (1024 * (tile as integer)) as string + " canvas:white -define png:color-type=6 " +  "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())

					for i in #{1..ids_colors.count} where ids_colors[i][2] != size_thumb and not keyboard.escPressed do
					(		
						--переразмер карт под квадрант
						
						local scale_proc = "100"
						local scale_edge = 0
						--local hei = "1024"
						--local wid = "1024"
						--local ofs_x = "0"
						--local ofs_y = "0"
						--local need = false
						
						if scales.count > 0 then 
							for j in #{1..scales.count} where scales[j][1] == i and scales[j][3] != "OK" do 
							(
								scale_proc = ((scales[j][3] as float) * 100.0) as string
								scale_edge = (round (512 * (1 - (scales[j][3] as float)))) as integer 
							)
								
						scale_proc = substitutestring scale_proc "," "."

						format "i=% scale_proc=% scale_edge=%\n" i scale_proc scale_edge
							
						poi_x = 1024 * ((mod t (tile as integer)) as integer)
						poi_y = (1024 * ((tile as integer) - 1)) - (1024 * (floor (t / (tile as integer))))
							
							/*						
							--if scales[i][3] != undefined then
							try
							(
								--format "scales=%  sc=%     1024/scales[j][3]=% \n" scales[j][3] scales[j][2] (1024/scales[j][3])
								need = if scales[j][3] == 1.0 then false else true
								hei = if (round (1024 / scales[j][3])) <= 10240 then (round (1024 / scales[j][3])) as string else "10240"
								wid = hei
								if hei == "10240" then errored_texelDensities += i as string + ": wrong scale leaded to oversized texture\n"
								scale_proc = (scales[j][3] * 100) as string
								ofs_x = round ( ((1024 / scales[j][3]) / -2) + 512 )
								ofs_y = round ( ((1024 / scales[j][3]) / -2) + 512 )
								if ofs_x > 10240 then ofs_x = 0 
								if ofs_x < -10240 then ofs_x = 0	
								if ofs_y > 10240 then ofs_y = 0 
								if ofs_y < -10240 then ofs_y = 0	
									
								ofs_x = if ofs_x >= 0 then "+" + (ofs_x) as string else (ofs_x) as string
								ofs_y = if ofs_y >= 0 then "+" + (ofs_y) as string else (ofs_y) as string
								format "i=% sc=% scales=% x=% y=% \n" i scales[j][3] scales[j] ofs_x ofs_y --#(i, amax #(sc/padding_w, sc/padding_h), sc_max, mX__, mY__, mWidth__, mHeight__, mX___, mY___, mWidth___, mHeight___ )
							)
							catch(need = false)
									
						poi_x = 1024 * ((mod t (tile as integer)) as integer)
						poi_y = (1024 * ((tile as integer) - 1)) - (1024 * (floor (t / (tile as integer))))
						--print poi_x
						--print poi_y
						*/	
						
						if not alt then -- and need then
						(
							--просчет через вьюпорт заменен на простой перемасштаб, потому что переразмер в юдим сделан в предварительной подготовке каждой текстуры
						
							HiddenDOSCommand ("magick " + "\"" + ids_colors[i][3] + "\"" + " -interpolate Integer -filter point -resize " + scale_proc + "%% -define png:color-type=6 " + "\"" + ids_colors[i][3] + "\"") startpath:start
							HiddenDOSCommand ("magick " + "\"" + ids_colors[i][4] + "\"" + " -interpolate Integer -filter point -resize " + scale_proc + "%% -define png:color-type=6 " + "\"" + ids_colors[i][4] + "\"") startpath:start
							HiddenDOSCommand ("magick " + "\"" + ids_colors[i][5] + "\"" + " -interpolate Integer -filter point -resize " + scale_proc + "%% -define png:color-type=6 " + "\"" + ids_colors[i][5] + "\"") startpath:start
							HiddenDOSCommand ("magick " + "\"" + ids_colors[i][6] + "\"" + " -interpolate Integer -filter point -resize " + scale_proc + "%% -define png:color-type=6 " + "\"" + ids_colors[i][6] + "\"") startpath:start
						
							--прошлый рабочий вариант
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][3] + "\"" + " -interpolate Integer -filter point -resize " + scale_proc + "%% +repage -gravity Center -background black -extent 1024x1024 -define png:color-type=6 " + "\"" + ids_colors[i][3] + "\"") startpath:start
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][4] + "\"" + " -interpolate Integer -filter point -resize " + scale_proc + "%% +repage -gravity Center -background #8080FF -extent 1024x1024 -define png:color-type=6 " + "\"" + ids_colors[i][4] + "\"") startpath:start
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][5] + "\"" + " -interpolate Integer -filter point -resize " + scale_proc + "%% +repage -gravity Center -background white -extent 1024x1024 -define png:color-type=6 " + "\"" + ids_colors[i][5] + "\"") startpath:start
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][6] + "\"" + " -interpolate Integer -filter point -resize " + scale_proc + "%% +repage -gravity Center -background white -extent 1024x1024 -define png:color-type=6 " + "\"" + ids_colors[i][6] + "\"") startpath:start
							--	--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][3] + "\"" + " -resize " + scale_proc + "^% " + "\"" + ids_colors[i][3] + "\"") startpath:start
								
							HiddenDOSCommand ("magick " + "\"" + ids_colors[i][3] + "\"" + " -set option:distort:viewport 1024x1024-" + scale_edge as string + "-" + scale_edge as string + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][3] + "\"") startpath:start --(GetINI_ImageMagick())	
							HiddenDOSCommand ("magick " + "\"" + ids_colors[i][6] + "\"" + " -set option:distort:viewport 1024x1024-" + scale_edge as string + "-" + scale_edge as string + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][6] + "\"") startpath:start --(GetINI_ImageMagick())	
							HiddenDOSCommand ("magick " + "\"" + ids_colors[i][4] + "\"" + " -set option:distort:viewport 1024x1024-" + scale_edge as string + "-" + scale_edge as string + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][4] + "\"") startpath:start --(GetINI_ImageMagick())	
							HiddenDOSCommand ("magick " + "\"" + ids_colors[i][5] + "\"" + " -set option:distort:viewport 1024x1024-" + scale_edge as string + "-" + scale_edge as string + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][5] + "\"") startpath:start --(GetINI_ImageMagick())	
						
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][3] + "\"" + " -set option:distort:viewport " + wid + "x" + hei + ofs_x + ofs_y + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][3] + "\"") startpath:start --(GetINI_ImageMagick())	
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][6] + "\"" + " -set option:distort:viewport " + wid + "x" + hei + ofs_x + ofs_y + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][6] + "\"") startpath:start --(GetINI_ImageMagick())	
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][4] + "\"" + " -set option:distort:viewport " + wid + "x" + hei + ofs_x + ofs_y + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][4] + "\"") startpath:start --(GetINI_ImageMagick())	
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][5] + "\"" + " -set option:distort:viewport " + wid + "x" + hei + ofs_x + ofs_y + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][5] + "\"") startpath:start --(GetINI_ImageMagick())	
						
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][5] + "\"" + " -set option:distort:viewport " + wid + "x" + hei + ofs_x + ofs_y + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][5] + "\"") startpath:(GetINI_ImageMagick())	
						)
					
						if not shift then 	
						(
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024^! " + "\"" + ids_colors[i][3] + "\"" + " ) " + "\"" + picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024^! " + "\"" + ids_colors[i][6] + "\"" + " ) " + "\"" + o_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + o_picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024^! " + "\"" + ids_colors[i][4] + "\"" + " ) " + "\"" + n_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + n_picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024^! " + "\"" + ids_colors[i][5] + "\"" + " ) " + "\"" + m_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024^! " + "\"" + ids_colors[i][5] + "\"" + " ) " + "\"" + r_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())
						)
						else
						(
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -filter Lanczos2Sharp -resize 1024x1024^! " + "\"" + ids_colors[i][3] + "\"" + " ) " + "\"" + picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -filter Lanczos2Sharp -resize 1024x1024^! " + "\"" + ids_colors[i][6] + "\"" + " ) " + "\"" + o_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + o_picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -filter Lanczos2Sharp -resize 1024x1024^! " + "\"" + ids_colors[i][4] + "\"" + " ) " + "\"" + n_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + n_picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -filter Lanczos2Sharp -resize 1024x1024^! " + "\"" + ids_colors[i][5] + "\"" + " ) " + "\"" + m_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -filter Lanczos2Sharp -resize 1024x1024^! " + "\"" + ids_colors[i][5] + "\"" + " ) " + "\"" + r_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())
						)
						t += 1
					)	
					
					--вклеить набор заглушек
					poi_x = 1024 * ((mod t (tile as integer)) as integer)
					poi_y = (1024 * ((tile as integer) - 1)) - (1024 * (floor (t / (tile as integer))))
					HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024 " + "\"" + picpath_z + "\"" + " ) " + "\"" + picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024 " + "\"" + o_picpath_z + "\"" + " ) " + "\"" + o_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + o_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024 " + "\"" + n_picpath_z + "\"" + " ) " + "\"" + n_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + n_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024 " + "\"" + m_picpath_z + "\"" + " ) " + "\"" + m_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024 " + "\"" + r_picpath_z + "\"" + " ) " + "\"" + r_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--		HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:(GetINI_ImageMagick())
						--		cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
						--		HiddenDOSCommand cmd startpath:(GetINI_ImageMagick())
						--		HiddenDOSCommand ("convert " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:(GetINI_ImageMagick())	

						--cmd = "magick montage " + pics + " -filter point -tile " + tile + "x" + tile + " -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + picpath + "\""	--point Lanczos2Sharp				

						--cmd = "magick montage " + pics + " -filter point -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + picpath + "\""	--point Lanczos2Sharp				
						
						--cmd = "magick montage " + pics + " -geometry 1024x1024+0+0^> -border 0 -background black " + "\"" + picpath + "\""
						--cmd = "magick montage " + pics + " -geometry 1024x1024+0+0 -border 0 -background black -resize 2048x2048^> " + "\"" + picpath + "\""
						--print cmd
						
						--o_cmd = "magick montage " + o_pics + " -filter point -geometry 1024x1024+0+0 -border 0 -background white " + "\"" + o_picpath + "\""
						--n_cmd = "magick montage " + n_pics + " -filter point -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + n_picpath + "\""
						--m_cmd = "magick montage " + m_pics + " -filter point -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + m_picpath + "\""
						--r_cmd = "magick montage " + r_pics + " -filter point -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + r_picpath + "\""	

						--o_cmd = "magick montage " + o_pics + " -filter point -tile " + tile + "x" + tile + " -geometry 1024x1024+0+0 -border 0 -background white " + "\"" + o_picpath + "\""
						--n_cmd = "magick montage " + n_pics + " -filter point -tile " + tile + "x" + tile + " -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + n_picpath + "\""
						--m_cmd = "magick montage " + m_pics + " -filter point -tile " + tile + "x" + tile + " -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + m_picpath + "\""
						--r_cmd = "magick montage " + r_pics + " -filter point -tile " + tile + "x" + tile + " -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + r_picpath + "\""						
						--print cmd
						
					if not shift then
					(
						--HiddenDOSCommand (cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + picpath + "\"" + " -interpolate Nearest -filter point -resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (o_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + o_picpath + "\"" + " -interpolate Nearest -filter point -resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background white -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + o_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (n_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + n_picpath + "\"" + " -interpolate Nearest -filter point -resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + n_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (m_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + m_picpath + "\"" + " -interpolate Nearest -filter point -resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + m_picpath + "\"" + " -channel B -separate " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (r_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + r_picpath + "\"" + " -interpolate Nearest -filter point -resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + r_picpath + "\"" + " -channel G -separate " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					)
					else
					(
						--HiddenDOSCommand (cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + picpath + "\"" + " -filter Lanczos2Sharp -adaptive-resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (o_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + o_picpath + "\"" + " -filter Lanczos2Sharp -adaptive-resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background white -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + o_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (n_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + n_picpath + "\"" + " -filter Lanczos2Sharp -adaptive-resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + n_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (m_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + m_picpath + "\"" + " -filter Lanczos2Sharp -adaptive-resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + m_picpath + "\"" + " -channel B -separate " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (r_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + r_picpath + "\"" + " -filter Lanczos2Sharp -adaptive-resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + r_picpath + "\"" + " -channel G -separate " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					)
					
					HiddenDOSCommand ("magick " + "\"" + picpath + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + picpath + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + picpath + "\"" + " PNG24:" + "\"" + picpath + "\"") startpath:start
					
					HiddenDOSCommand ("magick " + "\"" + o_picpath + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + o_picpath + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + o_picpath + "\"" + " PNG24:" + "\"" + o_picpath + "\"") startpath:start
					
					HiddenDOSCommand ("magick " + "\"" + n_picpath + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + n_picpath + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + n_picpath + "\"" + " PNG24:" + "\"" + n_picpath + "\"") startpath:start

					HiddenDOSCommand ("magick " + "\"" + m_picpath + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + m_picpath + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + m_picpath + "\"" + " PNG24:" + "\"" + m_picpath + "\"") startpath:start

					HiddenDOSCommand ("magick " + "\"" + r_picpath + "\"" + " -alpha remove -alpha off -define png:color-type=6 " + "\"" + r_picpath + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + r_picpath + "\"" + " PNG24:" + "\"" + r_picpath + "\"") startpath:start

					
					if doesFileExist picpath_z then deleteFile picpath_z
					if doesFileExist o_picpath_z then deleteFile o_picpath_z
					if doesFileExist n_picpath_z then deleteFile n_picpath_z
					if doesFileExist m_picpath_z then deleteFile m_picpath_z	
					if doesFileExist r_picpath_z then deleteFile r_picpath_z	

					i.material = shell_material name:m.name viewportMtlIndex:1 renderMtlIndex:1 originalMaterial:m bakedMaterial:(standardmaterial name:m.name DiffuseMap:(bitmaptexture filename:picpath) BumpMap:(bitmaptexture filename:n_picpath) ReflectionMap:(bitmaptexture filename:m_picpath) GlossinessMap:(bitmaptexture filename:r_picpath) OpacityMap:(bitmaptexture filename:o_picpath))
					gc light:true
					if not alt then if errored_texelDensities.count > 0 then messageBox ("There are IDs with problems:\n" + (errored_texelDensities) as string)
				)
			)
		)
	)

	on btn_UdimScale pressed do with undo "Scale Selection of Texel" on
	(
		if selection.count > 0 then 
		(	
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(
				faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
				if faces.count > 0 then
				(
					if ctrl and alt then
					(
						areas = #()
						arr = faces
						while not arr.isempty do
						(
							if keyboard.escPressed then exit
							for i in arr do (unwrapmod.selectFaces #{i}; exit)
							unwrapmod.selectElement()
							elem = unwrapmod.getselectedfaces()
							pos = unwrapmod.getSelCenter()
							--unwrapmod.breakSelected()
							unwrapmod.getArea elem &x &y &width &height &areaUVW &areaGeom
							if width > height then append areas width else append areas height 
							arr -= elem
						)
						scal = amax areas		
						arr = faces
						while not arr.isempty do
						(
							if keyboard.escPressed then exit
							for i in arr do (unwrapmod.selectFaces #{i}; exit)
							unwrapmod.selectElement()
							elem = unwrapmod.getselectedfaces()
							pos = unwrapmod.getSelCenter()
							unwrapmod.getArea elem &x &y &width &height &areaUVW &areaGeom
							sc = if width > height then width else height 
							unwrapmod.scaleSelectedXY (scal/sc) (scal/sc) [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter sc 0
							arr -= elem
						)
						unwrapmod.selectFaces faces						
					)
					
					if ctrl and not alt then
					(
						areas = #()
						arr = faces
						pos = unwrapmod.getSelCenter()
						while not arr.isempty do
						(
							if keyboard.escPressed then exit
							for i in arr do (unwrapmod.selectFaces #{i}; exit)
							unwrapmod.selectElement()
							elem = unwrapmod.getselectedfaces()
							--unwrapmod.breakSelected()
							unwrapmod.getArea elem &x &y &width &height &areaUVW &areaGeom
							if width > height then append areas width else append areas height --собираем все ширины лоскутов и потом берем максимальную, а надо отделять еще по вертикали
							arr -= elem
						)
						sc = spn_bricks_unwrap_sc.value/(amax areas) --equal to udim borders = 1/(amax areas) 
						unwrapmod.selectFaces faces	
						unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter sc 0							
					)
					
					if alt and not ctrl then
					(
						arr = faces
						while not arr.isempty do
						(
							areas = #()
							if keyboard.escPressed then exit
							for i in arr do (unwrapmod.selectFaces #{i}; exit)
							unwrapmod.selectElement()
							elem = unwrapmod.getselectedfaces()
							pos = unwrapmod.getSelCenter()
							--unwrapmod.breakSelected()
							unwrapmod.getArea elem &x &y &width &height &areaUVW &areaGeom
							if width > height then append areas width else append areas height --собираем все ширины лоскутов и потом берем максимальную, а надо отделять еще по вертикали
							arr -= elem
							sc = spn_bricks_unwrap_sc.value/(amax areas) --equal to udim borders = 1/(amax areas) 		
							unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter sc 0								
						)
						unwrapmod.selectFaces faces	
					)
					
					if not ctrl and not alt then
					(
						areas = #()
						pos = unwrapmod.getSelCenter()
						for i in faces where not keyboard.escPressed do
						(
							unwrapmod.getArea #{i} &x &y &width &height &areaUVW &areaGeom
							if width > height then append areas width else append areas height --собираем все ширины лоскутов и потом берем максимальную, а надо отделять еще по вертикали
						)
						sc = spn_bricks_unwrap_sc.value/(amax areas) --equal to udim borders = 1/(amax areas) 
						unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter sc 0
					)
				)
			)
		)
	)
	
	on btn_Editor rightclick do with undo "Edit Texture" on
	(
		global id = 1
		global m = undefined
		global tex = undefined
		global textures = #()
		global unwrapmod 
		global faces
		global pos
		global img_tag_initial_large
		global img_tag_scaled_large
		
		if selection.count > 0 then 
		(
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(
				faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
				if faces.count > 0 then
				(
					pos = unwrapmod.getSelCenter()
					--unwrapmod.getArea faces &mX &mY &width &height &areaUVW &areaGeom
					id = (pos.x as integer) + 1 + 10 * (pos.y as integer)
					--UDIM = id + 1000
				)
			)
			
			if selection[1].material != undefined then
			(
				m = selection[1].material
				case classof m of
				(
					CoronaLegacyMtl:
					(
						if m.texmapDiffuse != undefined then tex = m.texmapDiffuse
						--if m.texmapReflect != undefined then render_map m.texmapReflect rez (edt_multimat_path.text + m.name + "_Reflect" + ".png")
						--if m.texmapReflectGlossiness != undefined then render_map m.texmapReflectGlossiness rez (edt_multimat_path.text + _m.name + "_ReflectGlossiness" + ".png")
						--if m.texmapRefract != undefined then render_map m.texmapRefract rez (edt_multimat_path.text + m.name + "_Refract" + ".png")
						--if m.texmapRefractGlossiness != undefined then render_map m.texmapRefractGlossiness rez (edt_multimat_path.text + m.name + "_RefractGlossiness" + ".png")
						--if m.texmapOpacity != undefined then render_map m.texmapOpacity rez (edt_multimat_path.text + m.name + "_Opacity" + ".png")
						--if m.texmapBump != undefined then render_map m.texmapBump rez (edt_multimat_path.text + m.name + "_Bump" + ".png")
						--if m.texmapTranslucency != undefined then render_map m.texmapTranslucency rez (edt_multimat_path.text + m.name + "_Translucency" + ".png")
						--if m.texmapDisplace != undefined then render_map m.texmapDisplace rez (edt_multimat_path.text + m.name + "_Displace" + ".png")
						--if m.texmapSelfIllum != undefined then render_map m.texmapSelfIllum rez (edt_multimat_path.text + m.name + "_SelfIllum" + ".png")
					)
					
					CoronaPhysicalMtl:
					(
					)
					
					Physical_Material:
					(
						if m.base_color_map != undefined then tex = m.base_color_map --render_map m.base_color_map rez (edt_multimat_path.text + _m.name + "_Diffuse" + ".png")
						--if m.roughness_map != undefined then render_map m.roughness_map rez (edt_multimat_path.text + _m.name + "_Roughness" + ".png")
						--if m.metalness_map != undefined then render_map m.metalness_map rez (edt_multimat_path.text + _m.name + "_Metalness" + ".png")	
						--if m.bump_map != undefined then render_map m.bump_map rez (edt_multimat_path.text + m.name + "_Bump" + ".png")
						--if m.cutout_map != undefined then render_map m.cutout_map rez (edt_multimat_path.text + m.name + "_Opacity" + ".png")
					)
	
					Standardmaterial:
					(
						if m.DiffuseMap != undefined then tex = m.DiffuseMap --render_map m.DiffuseMap rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")				
						--if m.BumpMap != undefined then render_map m.BumpMap rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
						--if m.ReflectionMap != undefined then render_map m.ReflectionMap rez (edt_multimat_path.text + sub_m.name + "_Reflection" + ".png")
						--if m.GlossinessMap != undefined then render_map m.GlossinessMap rez (edt_multimat_path.text + sub_m.name + "_Glossiness" + ".png")
						--if m.OpacityMap != undefined then render_map m.OpacityMap rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
					)
								
					Multimaterial: 
					(
						sub_m = m.materialList[id]
						if sub_m != undefined then
						(
							case classof sub_m of
							(
								CoronaLegacyMtl:
								(
									if sub_m.texmapDiffuse != undefined then tex = sub_m.texmapDiffuse --render_map sub_m.texmapDiffuse rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")
									--if sub_m.texmapReflect != undefined then render_map sub_m.texmapReflect rez (edt_multimat_path.text + sub_m.name + "_Reflect" + ".png")
									--if sub_m.texmapReflectGlossiness != undefined then render_map sub_m.texmapReflectGlossiness rez (edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png")
									--if sub_m.texmapRefract != undefined then render_map sub_m.texmapRefract rez (edt_multimat_path.text + sub_m.name + "_Refract" + ".png")
									--if sub_m.texmapRefractGlossiness != undefined then render_map sub_m.texmapRefractGlossiness rez (edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png")
									--if sub_m.texmapOpacity != undefined then render_map sub_m.texmapOpacity rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
									--if sub_m.texmapBump != undefined then render_map sub_m.texmapBump rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
									--if sub_m.texmapTranslucency != undefined then render_map sub_m.texmapTranslucency rez (edt_multimat_path.text + sub_m.name + "_Translucency" + ".png")
									--if sub_m.texmapDisplace != undefined then render_map sub_m.texmapDisplace rez (edt_multimat_path.text + sub_m.name + "_Displace" + ".png")
									--if sub_m.texmapSelfIllum != undefined then render_map sub_m.texmapSelfIllum rez (edt_multimat_path.text + sub_m.name + "_SelfIllum" + ".png")
								)
								
								CoronaPhysicalMtl:
								(
									
								)
								
								Physical_Material:
								(
									if sub_m.base_color_map != undefined then tex = sub_m.base_color_map --render_map sub_m.base_color_map rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")
									--if sub_m.roughness_map != undefined then render_map sub_m.roughness_map rez (edt_multimat_path.text + sub_m.name + "_Roughness" + ".png")
									--if sub_m.metalness_map != undefined then render_map sub_m.metalness_map rez (edt_multimat_path.text + sub_m.name + "_Metalness" + ".png")	
									--if sub_m.bump_map != undefined then render_map sub_m.bump_map rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
									--if sub_m.cutout_map != undefined then render_map sub_m.cutout_map rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
								
								Standardmaterial:
								(
									if sub_m.DiffuseMap != undefined then tex = sub_m.DiffuseMap --render_map sub_m.DiffuseMap rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")				
									--if sub_m.BumpMap != undefined then render_map sub_m.BumpMap rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
									--if sub_m.ReflectionMap != undefined then render_map sub_m.ReflectionMap rez (edt_multimat_path.text + sub_m.name + "_Reflection" + ".png")
									--if sub_m.GlossinessMap != undefined then render_map sub_m.GlossinessMap rez (edt_multimat_path.text + sub_m.name + "_Glossiness" + ".png")
									--if sub_m.OpacityMap != undefined then render_map sub_m.OpacityMap rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
							)
						)
					)
				)
				if tex != undefined then
				(
					if hasproperty tex "filename" then tex = tex --.filename
					else tex = undefined -- or render texture to file
				)
			)
		)
		
		try(destroyDialog ::ScaleEDITOR)catch()
		try(closeRolloutFloater ScaleEDITOR)catch()
		ScaleEDITOR = newRolloutFloater "Edit Bitmaps and UVW" 500 720
		rollout TextureEDITOR "Texture Editor" autoLayoutOnResize:true width:500 height:360
		(
			radiobuttons rdo_texture_source labels: #("Get texture from Material", "Get from source") offsets:#([0,0], [0,0]) default:1 columns:2 rows:1 offset:[0,0] across:2 align:#left enabled:false tooltip:""
			radiobuttons rdo_scale_corner labels: #("ul","ur","center","dl","dr") offsets:#([0,0], [0,0], [0,0], [0,0], [0,0]) default:3 columns:3 rows:2 offset:[0,0] tooltip:""
 			label lbl_d "Initial texture" across:2 align:#left
			label lbl_o "Edited texture" align:#right
			imgtag img_tag_initial bitmap:(bitmap 200 200 color:(color 100 100 100) gamma:1.0 hdr:false alpha:true) width:200 height:200 style:#bmp_stretch across:3 align:#left
			label lbl_a "=>" offset:[0,100]
			imgtag img_tag_Scaled bitmap:(bitmap 200 200 color:(color 100 100 100) gamma:1.0 hdr:false alpha:true) width:200 height:200 style:#bmp_stretch align:#right

			edittext edt_Initial text:"" width:200 align:#left across:2
			edittext edt_Scaled text:"" width:200 align:#right
			
			spinner spn_materialID "Material ID" range:[1, 1000, id] type:#integer width:50 fieldWidth:20 across:5 align:#left tooltip:""	
			spinner spn_rotation "Rotation" range:[-360.0, 360.0, 0.0] type:#float scale:0.1 offset:[70,0] width:50 fieldWidth:50 tooltip:""			
			spinner spn_scale "Scale" range:[0.001, 10000.0, 1.0] type:#float scale:0.001 width:50 fieldWidth:40 offset:[20,0] tooltip:""
			spinner spn_roll_x "Roll X" range:[-10000.0, 10000.0, 0.0] type:#float scale:0.001 width:50 fieldWidth:40 align:#right tooltip:""
			spinner spn_roll_y "Roll Y" range:[-10000.0, 10000.0, 0.0] type:#float scale:0.001 width:50 fieldWidth:40 align:#right tooltip:""
			button bnt_get_Initial_map "Open Initial texture" width:150 align:#left across:4 tooltip:""
			button btn_make_Scaled_map "Edit Texture" width:100 offset:[30,0] tooltip:""
			checkbox chk_do_all_texs "Do all maps" checked:false offset:[50,0] 
			checkbox chk_scale_uv "Also Edit UVW" checked:false align:#right
			
			on bnt_get_Initial_map pressed do
			(
				source = getOpenFileName "Select Initial map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then	
					(
						img_tag_initial.bitmap = openBitMap source 
						edt_Initial.text = source --getfilenamefile source + getfilenametype source
						edt_Scaled.text = getfilenamepath (img_tag_initial.bitmap.filename) + getfilenamefile (img_tag_initial.bitmap.filename) + "_Edited" + getfilenametype (img_tag_initial.bitmap.filename)
					)
				)
			)
			
			on img_tag_initial mousedown do try(display (openBitMap (img_tag_initial.bitmap.filename) ))catch(bnt_get_Initial_map.pressed())
			on img_tag_Scaled mousedown do try(display (openBitMap (img_tag_Scaled.bitmap.filename) ))catch(messagebox "Make Edited texture first")
	
			on btn_make_Scaled_map pressed do
			(	
				if img_tag_initial.bitmap.filename != "" then
				(
					sourcepath = if edt_Initial.text != "" then edt_Initial.text  
					finalpath = if edt_Scaled.text != "" then edt_Scaled.text else getfilenamepath (img_tag_initial.bitmap.filename) + getfilenamefile (img_tag_initial.bitmap.filename) + "_Edited" + getfilenametype (img_tag_initial.bitmap.filename)

					a = openBitMap sourcepath
					if a != undefined then
					(
						if doesfileexist finalpath then deletefile finalpath
														
						hei = a.height
						wid = a.width 
						alfa = false
						if a.hasalpha != undefined then alfa = a.hasAlpha
						close a
						free a
						
						sc = spn_scale.value
						
						HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:(GetINI_ImageMagick())
							
						--x_ = -(spn_roll_x.value - 0.5)
						--y_ = -(spn_roll_y.value - 0.5)
						x_ = spn_roll_x.value
						y_ = spn_roll_y.value							
						x = ((x_ * wid ) as integer) 
						y = ((y_ * hei ) as integer) 
						x = if x >= 0 then "+" + (x as string) else (x as string)
						y = if y >= 0 then "+" + (y as string) else (y as string)
								
						format "scale=% x=% % y=% %\n" sc x_ x y_ y
								
						--cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
						--cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT " + spn_rotation.value as string + " +repage " + "\"" + finalpath + "\""

						if alfa then
						(
							--cmd = "magick " + "\"" + finalpath + "\"" + " -alpha set -set option:distort:scale " + (substitutestring (sc as string) "," ".") + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT " + spn_rotation.value as string + " +repage " + "\"" + finalpath + "\""
							cmd = "magick " + "\"" + finalpath + "\"" + " -alpha set -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT " + spn_rotation.value as string + " +repage " + "\"" + finalpath + "\""

						)	
						else
						(
							--cmd = "magick " + "\"" + finalpath + "\"" + " -alpha off -set option:distort:scale " + (substitutestring (sc as string) "," ".") + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT " + spn_rotation.value as string + " +repage " + "\"" + finalpath + "\""
							cmd = "magick " + "\"" + finalpath + "\"" + " -alpha off -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT " + spn_rotation.value as string + " +repage " + "\"" + finalpath + "\""
						)
						
						--magick checks.png -alpha set -virtual-pixel tile -distort ScaleRotateTranslate  '20,20  .5  30' checks_srt_tile.png
						HiddenDOSCommand cmd startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:(GetINI_ImageMagick())	
					)			
					img_tag_Scaled.bitmap = openBitMap finalpath				
				)
				else messagebox "Load Initial texture first"	
				
				if chk_scale_uv.checked then
				if selection.count > 0 then 
				(
					--ctrl = keyboard.controlPressed
					--alt = keyboard.altPressed
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
						if faces.count > 0 then
						(
							pos = unwrapmod.getSelCenter()
							unwrapmod.getArea faces &x &y &width &height &areaUVW &areaGeom
							sc = spn_bricks_unwrap_sc.value
							unwrapmod.selectFaces faces	
							
							case rdo_scale_corner.state of
							(
								3: unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter sc 0		
							)
							unwrapmod.moveSelected [spn_roll_x.value, spn_roll_y.value, 0.0]
							unwrapmod.rotateSelectedCenter spn_rotation.value
							--unwrapmod.rotateSelected <float>angle <point3>axis 
						)
					)
				)
			)
			
			on TextureEditor open do
			(
				gc()
				if tex != undefined then --if hasproperty filename checked upper
				(
					img_tag_initial_large = openBitMap tex.filename
					img_tag_initial.bitmap = copy img_tag_initial_large 
					img_tag_initial.bitmap.filename = tex.filename
					img_tag_Scaled.bitmap = copy img_tag_initial_large
					img_tag_scaled_large = copy img_tag_initial_large
					
					edt_Initial.text = tex.filename
					edt_Scaled.text = getfilenamepath (img_tag_initial.bitmap.filename) + getfilenamefile (img_tag_initial.bitmap.filename) + "_Edited" + getfilenametype (img_tag_initial.bitmap.filename)
				)					
			)
			
			on TextureEditor close do
			(
				if img_tag_initial != undefined then close img_tag_initial.bitmap
				if img_tag_Scaled != undefined then close img_tag_Scaled.bitmap
				if img_tag_initial_large != undefined then close img_tag_initial_large
				if img_tag_initial_large != undefined then free img_tag_initial_large
				if img_tag_initial != undefined then free img_tag_initial.bitmap				
				if img_tag_Scaled != undefined then free img_tag_Scaled.bitmap
				gc()
			)
			
			--on spn_rotation changed val do 
			--(
			--)
		)
		addRollout TextureEDITOR ScaleEDITOR
		
		rollout BlendEDITOR "Blend Editor" autoLayoutOnResize:true width:500 height:360
		(
 			imgtag img_tag_initial1 bitmap:(bitmap 200 200 color:(color 100 100 100) gamma:1.0 hdr:false alpha:true) width:200 height:200 style:#bmp_stretch across:4 align:#left
			imgtag img_tag_initial2 bitmap:(bitmap 200 200 color:(color 100 100 100) gamma:1.0 hdr:false alpha:true) width:200 height:200 offset:[-115, 205] style:#bmp_stretch align:#left
			label lbl_a "=>" offset:[-60, 190]
			imgtag img_tag_blend bitmap:(bitmap 200 200 color:(color 100 100 100) gamma:1.0 hdr:false alpha:true) width:200 height:200 style:#bmp_stretch align:#right
		
			radiobuttons rdo_scale_corner labels: #("ul","ur","center","dl","dr") offsets:#([0,0], [0,0], [0,0], [0,0], [0,0]) default:3 columns:5 rows:1 offset:[0,0] align:#left tooltip:""
 
			spinner spn_rotation "Rotation" range:[-360.0, 360.0, 0.0] type:#float scale:0.1 offset:[0,0] width:50 across:5 fieldWidth:50 align:#left tooltip:""			
			spinner spn_scale "Scale" range:[0.001, 10000.0, 1.0] type:#float scale:0.001 width:50 fieldWidth:40 offset:[20,0] tooltip:""
			spinner spn_roll_x "Roll X" range:[-10000.0, 10000.0, 0.0] type:#float scale:0.001 width:50 fieldWidth:40 tooltip:""
			spinner spn_roll_y "Roll Y" range:[-10000.0, 10000.0, 0.0] type:#float scale:0.001 width:50 fieldWidth:40 tooltip:""
			spinner spn_gamma "gamma" range:[0.01, 100.0, 1.0] type:#float scale:0.001 width:50 fieldWidth:40 align:#right tooltip:""
	
			edittext edt_Initial1 text:"" width:150 align:#left across:3
			edittext edt_Initial2 text:"" width:150
			edittext edt_Blend text:"" width:150 align:#right	

			button bnt_get_Initial_map1 "Open Initial texture 1" width:150 align:#left across:3 tooltip:""
			button bnt_get_Initial_map2 "Open Initial texture 2" width:150 tooltip:""
			button btn_make_blend_map "Edit Texture" width:150 align:#right offset:[0,0] tooltip:""

			on BlendEDITOR open do
			(
				gc()
			)
			
			on BlendEDITOR close do
			(
				gc()
			)
			
			on bnt_get_Initial_map1 pressed do
			(
				source = getOpenFileName "Select Initial map 1" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then	
					(
						img_tag_initial1.bitmap = openBitMap source 
						edt_Initial1.text = source --getfilenamefile source + getfilenametype source
						edt_Blend.text = getfilenamepath (img_tag_initial1.bitmap.filename) + getfilenamefile (img_tag_initial1.bitmap.filename) + "_Edited" + getfilenametype (img_tag_initial1.bitmap.filename)
					)
				)
			)
			
			on bnt_get_Initial_map2 pressed do
			(
				source = getOpenFileName "Select Initial map 2" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then	
					(
						img_tag_initial2.bitmap = openBitMap source 
						edt_Initial2.text = source --getfilenamefile source + getfilenametype source
						--edt_Blended.text = getfilenamepath (img_tag_initial1.bitmap.filename) + getfilenamefile (img_tag_initial1.bitmap.filename) + "_Edited" + getfilenametype (img_tag_initial1.bitmap.filename)
					)
				)
			)
			
			on img_tag_initial1 mousedown do try(display (openBitMap (img_tag_initial1.bitmap.filename) ))catch(bnt_get_Initial_map1.pressed())
			on img_tag_initial2 mousedown do try(display (openBitMap (img_tag_initial2.bitmap.filename) ))catch(bnt_get_Initial_map2.pressed())
				
			on img_tag_blend mousedown do try(display (openBitMap (img_tag_blend.bitmap.filename) ))catch(messagebox "Make Edited texture first")
	
			on btn_make_blend_map pressed do
			(	
				if img_tag_initial1.bitmap.filename != "" and img_tag_initial2.bitmap.filename != "" then
				(
					sourcepath1 = if edt_Initial1.text != "" then edt_Initial1.text  
					sourcepath2 = if edt_Initial2.text != "" then edt_Initial2.text  
					finalpath = if edt_Blend.text != "" then edt_Blend.text else getfilenamepath (img_tag_initial1.bitmap.filename) + getfilenamefile (img_tag_initial1.bitmap.filename) + "_Edited" + getfilenametype (img_tag_initial1.bitmap.filename)
					finalpath2 = getfilenamepath (img_tag_initial2.bitmap.filename) + getfilenamefile (img_tag_initial2.bitmap.filename) + "_Edited" + ".png"

					a = openBitMap sourcepath1
					b = openBitMap sourcepath2
					if a != undefined and b != undefined then
					(
						if doesfileexist finalpath then deletefile finalpath
						if doesfileexist finalpath2 then deletefile finalpath2
														
						--hei = a.height
						--wid = a.width 
						alfa = false
						if a.hasalpha != undefined then alfa = a.hasAlpha
						close a
						free a
						
						--hei2 = b.height
						--wid2 = b.width 
						alfa2 = false
						if b.hasalpha != undefined then alfa2 = b.hasAlpha
						close b
						free b						
						
						sc = spn_scale.value
						x_ = spn_roll_x.value
						y_ = spn_roll_y.value							
						--x = ((x_ * wid2 ) as integer) 
						--y = ((y_ * hei2 ) as integer) 
						x = if x_ >= 0 then "+" + (x_ as string) else (x_ as string)
						y = if y_ >= 0 then "+" + (y_ as string) else (y_ as string)
								
						format "scale=% x=% % y=% %\n" sc x_ x y_ y			
						
						HiddenDOSCommand ("magick " + "\"" + sourcepath2 + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath2 + "\"") startpath:(GetINI_ImageMagick())
								
						--cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
						--cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT " + spn_rotation.value as string + " +repage " + "\"" + finalpath + "\""

						local cmd_alpha = if alfa then "set" else "off"
		
						local corner = case rdo_scale_corner.state of 
						(
							--#("ul","ur","center","dl","dr")
							1: "northwest"
							2: "northeast"
							3: "center"
							4: "southwest"
							5: "southeast"
						)
						
						--cmd = "magick " + "\"" + finalpath2 + "\"" + " -alpha " + cmd_alpha + " -set option:distort:viewport " + wid2 as string + "x" + hei2 as string + x + y + " -virtual-pixel tile -filter point -distort SRT " + spn_rotation.value as string + " +repage " + "\"" + finalpath + "\""
						--HiddenDOSCommand ("convert " + "\"" + sourcepath1 + "\"" + " "+ "\"" + finalpath2 + "\"" + " -gravity center -geometry +0+0 -compose src-over modulate -define compose:args=100 -composite -define png:color-type=6 " + "\""+ finalpath + "\"") startpath:(getINISetting (GetDir #maxroot +"\\GeoScripts\\GeoScripts.ini") "Directories" "ImageMagick")

						cmd = "magick " + "\"" + sourcepath1 + "\"" + " -gamma " + (substitutestring (spn_gamma.value as string) "," ".") + " " + "\"" + finalpath2 + "\"" + " -gravity " + corner + " " + cmd_alpha + " -geometry " + x + y + " -compose src-over modulate -define compose:args=100 -composite -define png:color-type=6 " + "\""+ finalpath + "\""

						print cmd
						HiddenDOSCommand cmd startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:(GetINI_ImageMagick())	
					)			
					img_tag_blend.bitmap = openBitMap finalpath				
				)
				else messagebox "Load Initial texture first"	
				
			)
		)
		addRollout BlendEDITOR ScaleEDITOR
	)
	
	on btn_UdimRotate pressed do with undo "Rotate Selection to Axis" on
	(
		fn getAngleDiff dx dy=
		(
			local _a_abs_ = ""
			local _a_abs = mod ((atan2 dx dy) + 4*360) 360	--the angle in closed 360 degrees			
			local _a_off = (mod _a_abs 90)	--angle offset
			--print _a_abs
			--print _a_off
			if (_a_abs > 45 and _a_abs < 135) or (_a_abs > 225 and _a_abs < 335) then
			(
				_a_abs_ = "v"
			)
			else
			(
				_a_abs_ = "h"
			)
			if (_a_off > 45)then
			(
				_a_off = -(90 - _a_off)
			)
			#(_a_off,_a_abs_)
			--_a_off 
			--_a_off
		)
		
		if selection.count > 0 then
		(
			alt = keyboard.altPressed
			ctrl = keyboard.controlPressed
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(	
				local elems = #()
				local faces = unwrapmod.getselectedfaces()
				if faces.count > 0 then
				(
					local arr = faces
					while not arr.isempty do
					(
						if keyboard.escPressed then exit
						for i in arr do (unwrapmod.selectFaces #{i}; exit)
						unwrapmod.selectElement()
						elem = unwrapmod.getselectedfaces()
						append elems elem
						arr -= elem
					)

					for elem in elems do
					(
						unwrapmod.selectFaces elem
						local pos = unwrapmod.getSelCenter()
						unwrapmod.FaceToEdgeSelect() 
						local edges = unwrapmod.getSelectedEdges() 		
						if edges.count > 0 then
						(
							local angles = #()
							local dists = #()
							local verts = #{}
							local pp = #()
							for e in edges do
							(
								unwrapmod.selectEdges #{e}
								unwrapmod.edgeToVertSelect()
								local verts = unwrapmod.getSelectedVertices()
								local p = for v in verts collect unwrapmod.getvertexposition currenttime v
								append dists #(e, distance p[1] p[2], p[1], p[2])
							)
							local longest = amax (for e in dists collect e[2])
							local longest2 = amax (for e in dists where e[2] < longest collect e[2])
							local need = for e in dists where e[2] == longest2 do exit with e
							if ctrl then need = for e in dists where e[2] == longest do exit with e
							local pp = #(need[3], need[4]) 
							
							if pp[1].y <= pp[2].y then angle = acos (dot y_axis (normalize (pp[2] - pp[1]))) else angle = acos (dot y_axis (normalize (pp[1] - pp[2])))
							--if pp[1].x > pp[2].x then append angles #(angle, angle, distance pp[1] pp[2]) else append angles #(-angle, angle, distance pp[1] pp[2])
							angles = if pp[1].x <= pp[2].x then angle else -angle
							--print angles
							unwrapmod.RotateSelected (degToRad -angles /** 0.0174533*/) pos
							if alt then unwrapmod.RotateSelected (degToRad 90) pos
							
								--local ptA = pp[1]
								--local ptB = pp[2]
								--local dx = ptB.x - ptB.y
								--local dy = ptA.x - ptA.y
								--append angles (getAngleDiff dx dy)
								--unwrapmod.RotateSelected (degToRad -(getAngleDiff 1 dy)[1] ) pos
									
								--if vh == "v" do unwrapmod.RotateSelected (degToRad 90) pos
								--if vh == "h" do unwrapmod.RotateSelected (degToRad 90) pos
								--append angles a_off
								
							
							--local dist = amin (for a in angles collect a[3])
							--local angle = for a in angles where a[3] == dist do exit with a[1]
							--unwrapmod.RotateSelected (-angles[1][1] * 0.0174533) pos
							--local angle = amin (for a in angles collect a[1])
							--local vh = for a in angles where a[1] == b do exit with a[2]
							--unwrapmod.RotateSelected  (-angle * 0.0174533) pos --[(ptA.x + dx/2),(ptA.y + dy/2),0]
							--if vh == "v" do unwrapmod.RotateSelected (degToRad 90) pos
							--if vh == "h" do unwrapmod.RotateSelected (degToRad 90) pos
						)
					)
					unwrapmod.selectFaces faces
				)
			)				
		)
	)
	
	on btn_UdimMove rightclick do with undo "Move Selection to First UDIM" on --перенос лоскутов в центр юдима
	(
		if selection.count > 0 then
		(
			alt = keyboard.altPressed
			ctrl = keyboard.controlPressed
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(	
				local elems = #()
				local faces = unwrapmod.getselectedfaces()
				if faces.count > 0 then
				(
					unwrapmod.getArea faces &x &y &width &height &areaUVW &areaGeom
					pos_ini = unwrapmod.getSelCenter() 
					if width <= 1 and height <= 1 then
					(
						local arr = faces
						while not arr.isempty do
						(
							if keyboard.escPressed then exit
							for i in arr do (unwrapmod.selectFaces #{i}; exit)
							unwrapmod.selectElement()
							elem = unwrapmod.getselectedfaces()
							unwrapmod.getArea elem &x &y &width &height &areaUVW &areaGeom
							append elems #(elem, areaUVW, x, y, width, height) 
							arr -= elem
						)

						qsort elems qsort_area

						side = sqrt elems.count
						width_max = amax (for elem in elems collect elem[5])
						height_max = amax (for elem in elems collect elem[6])
						
						pos_x = 0 + (1 - spn_bricks_unwrap_sc.value)
						pos_y = 0 + (1 - spn_bricks_unwrap_sc.value)
					
						div_x = 1 / (side + width_max + 2 * (1 - spn_bricks_unwrap_sc.value))
						div_y = 1 / (side + height_max + 2 * (1 - spn_bricks_unwrap_sc.value))
				
						for elem in elems do
						(
							unwrapmod.selectFaces elem[1]
							unwrapmod.moveSelected [pos_x - (elem[3] - (elem[3] as integer)), pos_y - (elem[4] - (elem[4] as integer)), 0.0]
							if (pos_x + div_x) > 1 then 
							(
								pos_y += div_y
								pos_x = 0 + (1 - spn_bricks_unwrap_sc.value)
							)								
							else pos_x += div_x 
						)
						free elems
					)
				)
			)
			gc light:true
		)
	)
	
	on btn_UdimMove pressed do with undo "Move Selection to First UDIM" on --перенос лоскутов в центр юдима
	(
		if selection.count > 0 then
		(
			alt = keyboard.altPressed
			ctrl = keyboard.controlPressed
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(	
				faces = unwrapmod.getselectedfaces()
				if faces.count > 0 then
				(
					if ctrl then
					(
						for i in faces where not keyboard.escPressed do
						(
							unwrapmod.selectFaces #{i}
							unwrapmod.breakSelected()
							pos = unwrapmod.getSelCenter()
							unwrapmod.moveSelected [(0.5 - pos.x), (0.5 - pos.y), 0]
						)
						unwrapmod.selectFaces faces
					)
					
					if alt then
					(
						arr = faces
						while not arr.isempty do --for i in faces do
						(
							if keyboard.escPressed then exit
							for i in arr do (unwrapmod.selectFaces #{i}; exit)
							unwrapmod.selectElement()
							elem = unwrapmod.getselectedfaces()
							--unwrapmod.breakSelected()
							pos = unwrapmod.getSelCenter()
							unwrapmod.moveSelected [(0.5 - pos.x), (0.5 - pos.y), 0]
							arr -= elem
						)
						unwrapmod.selectFaces faces						
					)
					
					if not ctrl and not alt then
					(
						--unwrapmod.selectFaces faces
						unwrapmod.breakSelected()
						pos = unwrapmod.getSelCenter()
						--unwrapmod.moveSelected [(0.5 - (dr pos.x)), (0.5 - (dr pos.y)), 0]
						unwrapmod.moveSelected [(0.5 - pos.x), (0.5 - pos.y), 0]
						--btn_UdimScale.pressed()
					)
				)
			)
		)
	)
	
	on btn_bricks_unwrap_get_num pressed do --получение номера одного выбранного текселя, не работает на множестве выделения
	(
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces()
			if (faces as array).count == 1 then
			(
				spn_bricks_unwrap_num.value = (faces as array)[1]
			)
			else messagebox "Select single face."
		)
	)
	
	on btn_bricks_unwrap pressed do
	(
		if chk_bricks_unwrap_undo.checked then 
		(
			clearUndoBuffer()
			gc()
			with undo off 
			(
				if chk_bricks_unwrap_rescale.checked then btn_Udim_Rescale.pressed()
				if chk_bricks_unwrap_cut.checked then 
				(
					TAG (selection as array) false
					--slicers.btn_uv_cut.pressed() 
					addmodifier selection[1] (Unwrap_UVW())
				)
				if chk_bricks_unwrap_cut2.checked then 
				(
					slicers.btn_uv_cut_pressed.pressed()
					addmodifier selection[1] (Unwrap_UVW())
				)				
				btn_bricks_unwrap_pressed.pressed()
			)
			gc()
		)
		else 
		(
			with undo "Tiles Unwrap" on 
			(
				if chk_bricks_unwrap_rescale.checked then btn_Udim_Rescale.pressed()
				if chk_bricks_unwrap_cut.checked then 
				(
					TAG (selection as array) false
					--slicers.btn_uv_cut.pressed()
					addmodifier selection[1] (Unwrap_UVW())
				)
				if chk_bricks_unwrap_cut2.checked then 
				(
					slicers.btn_uv_cut_pressed.pressed()
					addmodifier selection[1] (Unwrap_UVW())
				)	
				btn_bricks_unwrap_pressed.pressed() 
			)
		)
	)
	
	on btn_bricks_unwrap rightclick do
	(
		if chk_bricks_unwrap_undo.checked then 
		(
			clearUndoBuffer()
			gc()
			with undo off 
			(
				if chk_bricks_unwrap_cut.checked then 
				(
					TAG (selection as array) false
					--slicers.btn_uv_cut.pressed() 
					addmodifier selection[1] (Unwrap_UVW())
				)
				if chk_bricks_unwrap_cut2.checked then 
				(
					slicers.btn_uv_cut_pressed.pressed()
					addmodifier selection[1] (Unwrap_UVW())
				)	
				btn_bricks_unwrap_rightclick.pressed()
			)
			gc()
		)
		else 
		(
			with undo "Tiles Unwrap" on 
			(
				if chk_bricks_unwrap_cut.checked then 
				(
					TAG (selection as array) false
					--slicers.btn_uv_cut.pressed()
					addmodifier selection[1] (Unwrap_UVW())
				)	
				if chk_bricks_unwrap_cut2.checked then 
				(
					slicers.btn_uv_cut_pressed.pressed()
					addmodifier selection[1] (Unwrap_UVW())
				)					
				btn_bricks_unwrap_rightclick.pressed() 
			)
		)
	)
	
	on btn_bricks_unwrap_pressed pressed do --with undo "Tiles Unwrap" on
	(
		gc light:true
		sc = 1.0
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			unwrapmod.setTVSubObjectMode 3 --unwrapmod.setPolygonMode true
			faces = #{}
			faces = unwrapmod.getselectedfaces()
			if faces.isempty then faces = #{1..unwrapmod.numberPolygons()}
			t = spn_bricks_unwrap_treshold.value --0.05
			if not faces.isempty then
			(
				if chk_bricks_unwrap_unfold.checked then
					try
					(
						unwrapmod.unfoldMapNoParams() --unwrapmod.unfoldMap 1
						--unwrapmod.selectFaces faces
						--unwrapmod.breakSelected()
					)catch() 
				unwrapmod.faceToEdgeSelect()
				unwrapmod.setTVSubObjectMode 2
				--edges = unwrapmod.getSelectedEdges()
				unwrapmod.breakSelected()
				unwrapmod.setTVSubObjectMode 3
				
				unwrapmod.selectFaces faces --дополнительно
				for f in faces where not keyboard.escPressed do
				(
					unwrapmod.selectFaces #{f}
					unwrapmod.breakSelected()
				)
				
				unwrapmod.selectFaces faces
				face = if not chk_unwrap_texel_or_poly.checked then spn_bricks_unwrap_num.value else 10000000
				have = false
				if not chk_unwrap_texel_or_poly.checked then 
					for i in faces where spn_bricks_unwrap_num.value == i and not keyboard.escPressed do 
					(
						have = true
						exit
					) --if not chk_bricks_unwrap_unfold.checked then

				--areas = #()
				dims_h = #()
				dims_w = #()
				if not have then 
				(
					for i in faces where not keyboard.escPressed do
					(
						unwrapmod.getArea #{i} &x &y &width &height &areaUVW &areaGeom
						--if chk_bricks_unwrap_height.checked then append areas height else append areas width
						append dims_h height 
						append dims_w width
					)
				)
				else 
				(
					unwrapmod.getArea #{face} &x &y &width &height &areaUVW &areaGeom
					--if chk_bricks_unwrap_height.checked then append areas height else append areas width
					append dims_h height 
					append dims_w width				
				)
				
				hei = amax dims_h
				wid = amax dims_w		
				
				if chk_bricks_unwrap_scale.checked then
				(
					--if not chk_bricks_unwrap_unfold.checked then 
					if chk_bricks_unwrap_height.checked and chk_bricks_unwrap_width.checked then sc = 1.0 / amax #(hei, wid)
					if chk_bricks_unwrap_height.checked and not chk_bricks_unwrap_width.checked then sc = 1.0 / hei
					if not chk_bricks_unwrap_height.checked and chk_bricks_unwrap_width.checked then sc = 1.0 / wid		
					if not chk_bricks_unwrap_height.checked and not chk_bricks_unwrap_width.checked then sc = 1.0 
					--sc = 1.0/(amax areas) 
					--spn_bricks_unwrap_sc.value as float/(amax areas) else 1.0
				)
				else sc = 1.0
				format "scale=%\n" sc
				--нельзя масштабировать по центру, это нарушит смещения в текстуре, надо масштабировать к точке от рассчетного текселя
				--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0

				case rdo_unwrap_method.state of
				(
					1: --"Centers"
					(
						if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0
						for i in faces where not keyboard.escPressed do
						(
							unwrapmod.selectFaces #{i}
							pos = unwrapmod.getSelCenter()
							unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0] 
						)
					)
					
					2: --"??"
						(
							unwrapmod.setPolygonMode true
							
							--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0

							if chk_unwrap_texel_or_poly.checked then --надо искать тексель
							(
								unwrapmod.selectFaces faces
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()		
								
								--определить x и y всех текселей и сместить по углу всё целиком
								minX = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								maxY = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
							
								--надо отсеивать неполные острова, лучше смещать по углу максимальный остров со всей разверткой, 
								--если найдется такой остров, то ставим новые значен??я, если нет, то оставлять прежние

								for f in faces where not keyboard.escPressed do
								(
									unwrapmod.selectFaces #{f}
									unwrapmod.getArea #{f} &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										maxY = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minX = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
									)								
								)												
								unwrapmod.selectFaces faces 
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, maxY, 0]
									
								--смещаем все фейсы на целую часть, не теряя офсет по текстуре
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (maxY - t)), 0] 
								else unwrapmod.moveSelected [-(minX as integer), -(maxY as integer), 0] 										
							)
							else
							(
								unwrapmod.selectFaces #{face}
								unwrapmod.getArea #{face} &x &y &width &height &areaUVW &areaGeom	
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								maxY = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								minX = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
								unwrapmod.selectFaces faces 	
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, maxY, 0]
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (maxY - t)), 0] 
								else unwrapmod.moveSelected [-(minX as integer), -(maxY as integer), 0]															
							)

							arr = #()
							for f in faces where not keyboard.escPressed do 	
							(
								unwrapmod.selectFaces #{f}
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								poi_min_x = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								poi_max_x = 0 --amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								poi_min_y = 0 --amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								poi_max_y = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								append arr #(#{f}, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
							)		
							for a in arr where not keyboard.escPressed do
							(
								unwrapmod.selectFaces a[1]
								--для равных размеров островов и кусочков смещаем на целую часть в первый юдим
								
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[2] + t)), -(floor (a[5] - t)), 0] 
								else unwrapmod.moveSelected [ -(a[2] as integer), -(a[5] as integer), 0] 	
							)
						)
						
					3: --"??"
						(
							unwrapmod.setPolygonMode true
							
							--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0
								
							if chk_unwrap_texel_or_poly.checked then --надо искать тексель
							(
								unwrapmod.selectFaces faces
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()		
								
								--определить x и y всех текселей и сместить по углу всё целиком
								maxX = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								maxY = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
							
								--надо отсеивать неполные острова, лучше смещать по углу максимальный остров со всей разверткой, 
								--если найдется такой остров, то ставим новые значения, если нет, то оставлять прежние

								for f in faces where not keyboard.escPressed do
								(
									unwrapmod.selectFaces #{f}
									unwrapmod.getArea #{f} &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										maxY = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										maxX = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
									)								
								)												
								unwrapmod.selectFaces faces 
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, maxY, 0]
								--смещаем все фейсы на целую часть, не теряя офсет по текстуре
								--unwrapmod.moveSelected [-(maxX as integer), -(maxY as integer), 0] 	
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (maxY - t)), 0] 
								else unwrapmod.moveSelected [-(maxX as integer), -(maxY as integer), 0]									
							)
							else
							(
								unwrapmod.selectFaces #{face}
								unwrapmod.getArea #{face} &x &y &width &height &areaUVW &areaGeom	
								unwrapmod.faceToVertSelect()
								v = unwrapmod.getselectedvertices()
								maxY = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								maxX = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
								unwrapmod.selectFaces faces 	
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, maxY, 0]
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (maxY - t)), 0] 
								else unwrapmod.moveSelected [-(maxX as integer), -(maxY as integer), 0]																
							)

							arr = #()
							for f in faces where not keyboard.escPressed do 	
							(
								unwrapmod.selectFaces #{f}
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								poi_min_x = 0 --amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
								poi_max_x = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
								poi_min_y = 0 --amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
								poi_max_y = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
								append arr #(#{f}, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
							)		
							for a in arr where not keyboard.escPressed do
							(
								unwrapmod.selectFaces a[1]
								--для равных размеров островов и кусочков смещаем на целую часть в первый юдим
								
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[3] - t)), -(floor (a[5] - t)), 0] 
								else unwrapmod.moveSelected [ -(a[3] as integer), -(a[5] as integer), 0]
							)							
						)
						
					4: --"Integers"
					(
						unwrapmod.selectFaces faces
						if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0
						for i in faces where not keyboard.escPressed do
						(
							unwrapmod.selectFaces #{i}
							pos = unwrapmod.getSelCenter()
							if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (pos.x)), -(floor (pos.y)), 0]
							else unwrapmod.moveSelected [ -(pos.x as integer), -(pos.y as integer), 0]
							
						)	
					)	
					
					5: --"??"
						(
							unwrapmod.setPolygonMode true

							if chk_unwrap_texel_or_poly.checked then --надо искать тексель
							(
								unwrapmod.selectFaces faces --#{1..unwrapmod.numberPolygons()}
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()		
								
								--определить минимум x,y всех текселей и сместить по левому нижнему углу всё целиком
								minX = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								minY = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								--print minX
								--print minY
							
								--надо отсеивать неполные острова (снизу и слева модели), лучше смещать по углу максимальный остров со всей разверткой, 
								--если найдется такой остров, то ставим новые значения, если нет, то оставлять прежние
								
								--sc = if not chk_bricks_unwrap_scale.checked then 1.0 / amax #(hei, wid) else 1.0
								for f in faces where not keyboard.escPressed do
								(
									unwrapmod.selectFaces #{f}
									unwrapmod.getArea #{f} &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minY = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minX = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
									)								
								)							
								--print minX
								--print minY					
								unwrapmod.selectFaces faces --#{1..unwrapmod.numberPolygons()}
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, minY, 0] --unwrapmod.scaleSelected sc 0 [minX, minY, 0]
								
								if chk_bricks_unwrap_pack.checked then
								(
									--ставим все острова левым нижним углом в первый юдим - ошибка, потеряем офсет от соседних
									unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0] 
									--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelected sc 0 [0, 0, 0]
								)
								else
								(
									--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelected sc 0 [minX, minY, 0]
									--unwrapmod.moveSelected [-(minX as integer), -(minY as integer), 0] 
									--смещаем все фейсы на целую часть, не теряя офсет по текстуре
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] 
									else unwrapmod.moveSelected [-(minX as integer), -(minY as integer), 0]
								)
							)
							else
							(
								unwrapmod.selectFaces #{face}
								--unwrapmod.getArea #{face} &x &y &width &height &areaUVW &areaGeom	
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								minY = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								minX = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
								
								unwrapmod.selectFaces faces --#{1..unwrapmod.numberPolygons()}		
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelected sc 0 [minX, minY, 0] --сбивает оффсет, работает с ошибкой
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, minY, 0]	
								
								if chk_bricks_unwrap_pack.checked then
								(
									--ставим все острова левым нижним углом (целевого текселя) в первый юдим									
									unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0] 
									--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelected sc 0 [0, 0, 0]
								)
								else
								(
									--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelected sc 0 [minX, minY, 0]
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] 
									else unwrapmod.moveSelected [-(minX as integer), -(minY as integer), 0]						
								)
							)

							--можно смещать по разнице между островами (а еще можно смещать как вручную по вертикальным и горизонтальным островам по линиям из островов)
							arr = #()
							for f in faces where not keyboard.escPressed do 	
							(
								unwrapmod.selectFaces #{f}
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								poi_min_x = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								poi_max_x = 0 --amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								poi_min_y = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								poi_max_y = 0 --amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								append arr #(#{f}, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
							)		
							--print arr
							
							for a in arr where not keyboard.escPressed do
							(
								unwrapmod.selectFaces a[1]
								--для равных размеров островов и кусочков смещаем на целую часть в первый юдим (получается к левому нижему углу)
								--(для неравных островов, возможно надо будет смещать, просчитывая разницу от первого острова)
								
								--порог определения отступа, добавляем к минимальной точке, чтобы не залезать в соседний юдим (для максимальных точек надо будет вычитать его)
								--порог не нужен для integer вместо floor

								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[2] + t)), -(floor (a[4] + t)), 0] 
								else unwrapmod.moveSelected [ -(a[2] as integer), -(a[4] as integer), 0]
							)
						)
						
					6: --"??"
						(
							unwrapmod.setPolygonMode true
							
							--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0
								
							if chk_unwrap_texel_or_poly.checked then --надо искать тексель
							(
								unwrapmod.selectFaces faces
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()		

								--определить x,y всех текселей и сместить по углу всё целиком
								maxX = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								minY = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
							
								--надо отсеивать неполные острова, лучше смещать по углу максимальный остров со всей разверткой, 
								--если найдется такой остров, то ставим новые значения, если нет, то оставлять прежние

								for f in faces where not keyboard.escPressed do
								(
									unwrapmod.selectFaces #{f}
									unwrapmod.getArea #{f} &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minY = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										maxX = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
									)								
								)							
							
								unwrapmod.selectFaces faces
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, minY, 0]
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (minY + t)), 0] 
								else unwrapmod.moveSelected [-(maxX as integer), -(minY as integer), 0]	
								--смещаем все фейсы на целую часть, не теряя офсет по текстуре
							)
							else
							(
								unwrapmod.selectFaces #{face}
								unwrapmod.getArea #{face} &x &y &width &height &areaUVW &areaGeom	
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								minY = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								maxX = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
								unwrapmod.selectFaces faces	
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, minY, 0]
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (minY + t)), 0] 
								else unwrapmod.moveSelected [-(maxX as integer), -(minY as integer), 0]							
							)

							--можно смещать по разнице между островами (а ??ще можно смещать как вручную по вертикальным и горизонтальным островам по линиям из островов)
							arr = #()
							for f in faces where not keyboard.escPressed do 	
							(
								unwrapmod.selectFaces #{f}
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								poi_min_x = 0 -- amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								poi_max_x = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								poi_min_y = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								poi_max_y = 0 --amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								append arr #(#{f}, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
							)		
							for a in arr where not keyboard.escPressed do
							(
								unwrapmod.selectFaces a[1]
								--для равных размеров островов и кусочков смещаем на целую часть в первый юдим
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[3] - t)), -(floor (a[4] + t)), 0] 
								else unwrapmod.moveSelected [ -(a[3] as integer), -(a[4] as integer), 0]
							)							
						)
				)
				unwrapmod.selectFaces faces --#{1..unwrapmod.numberPolygons()}	
				if chk_bricks_unwrap_redo.checked then 
				(
					unwrapmod.setPolygonMode true
					for f in faces where not keyboard.escPressed do 	
					(
						unwrapmod.selectFaces #{f}
						local pos = unwrapmod.getSelCenter()
						if pos.x > 1.0 then unwrapmod.moveSelected [-1, 0, 0]
						if pos.x < 0.0 then unwrapmod.moveSelected [1, 0, 0]
						if pos.y > 1.0 then	unwrapmod.moveSelected [0, -1, 0]
						if pos.y < 0.0 then unwrapmod.moveSelected [0, 1, 0]	
					)	
					unwrapmod.selectFaces faces
				)
			)
			gc light:true
		)
	)

	on btn_bricks_unwrap_rightclick pressed do --with undo "Tiles Unwrap" on 
	(
		gc light:true
		local ctrl = keyboard.controlPressed
		local sc = 1.0
		local t = spn_bricks_unwrap_treshold.value --0.05
		max modify mode
		local unwrapmod = modpanel.getcurrentobject()
		local faces = #{}
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			unwrapmod.setTVSubObjectMode 3 --unwrapmod.setPolygonMode true
			faces = #{}
			faces = unwrapmod.getselectedfaces()
			--if faces.isempty then faces = #{1..unwrapmod.numberPolygons()}
		)
		if not faces.isempty then	
		(
			for f in faces where not keyboard.escPressed do 	
			(
				unwrapmod.selectFaces #{f}
				unwrapmod.breakSelected()
				if ctrl then 
				(
					unwrapmod.faceToEdgeSelect()
					unwrapmod.breakSelected()
					unwrapmod.selectFaces #{f}
				)
				unwrapmod.faceToVertSelect() 
				local vv = unwrapmod.getselectedvertices()
				local pp = for i in vv collect (unwrapmod.getvertexposition currenttime i)
				local poi_min_x = amin (for i in pp collect i.x)
				local poi_min_y = amin (for i in pp collect i.y)

				if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (poi_min_x - t)), -(floor (poi_min_y + t)), 0] 
				else unwrapmod.moveSelected [-(poi_min_x as integer), -(poi_min_y as integer), 0]

				if chk_bricks_unwrap_redo.checked then 
				(
					local pos = unwrapmod.getSelCenter()
					if pos.x > 1.0 then unwrapmod.moveSelected [-1, 0, 0]
					if pos.x < 0.0 then unwrapmod.moveSelected [1, 0, 0]
					if pos.y > 1.0 then	unwrapmod.moveSelected [0, -1, 0]
					if pos.y < 0.0 then unwrapmod.moveSelected [0, 1, 0]	
				)
			)	
			unwrapmod.selectFaces faces	
			gc light:true			
		)	
	)
	
/*	
	on btn_bricks_unwrap rightclick do with undo "Tiles Unwrap" on 
	(
		sc = 1.0
		areas = 1.0
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			unwrapmod.setTVSubObjectMode 3 --unwrapmod.setPolygonMode true
			faces = unwrapmod.getselectedfaces() 
			if faces.count > 0 then
			(
				face = spn_bricks_unwrap_num.value --не хватает проверки что этот фейс существует в выделении или в модели
				unwrapmod.selectFaces #{face}
				if (unwrapmod.getselectedfaces()).count > 0 then
				(
					unwrapmod.getArea #{face} &x &y &width &height &areaUVW &areaGeom
					if chk_bricks_unwrap_height.checked then areas = height else areas = width 
					sc = 1.0/areas --(spn_bricks_unwrap_sc.value as float)/areas 
					unwrapmod.selectFaces faces
					
					--unwrapmod.unfoldMapNoParams() --unwrapmod.unfoldMap 1
					unwrapmod.faceToEdgeSelect()
					unwrapmod.setTVSubObjectMode 2
					edges = unwrapmod.getSelectedEdges()
					unwrapmod.breakSelected()
					unwrapmod.setTVSubObjectMode 3
					unwrapmod.selectFaces faces
					unwrapmod.scaleSelectedCenter sc 0
					for i in faces do
					(
						unwrapmod.selectFaces #{i}
						pos = unwrapmod.getSelCenter()
						unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0]
					)
				)
			)
		)
	)
*/
	
	on btn_bricks_unwrap_new pressed do with undo "Tiles Landscape" on 
	(
		--берем полиобъект с выделенными эджами после слайса, или колапсим после слайсов
		--делаем копию, выделяем и режем эджи, выделяем самый большой элемент, удаляем остальные элементы и накладываем на оставшийся планарную уввмапу
		--тем самым получаем мэпинг по всему ландшафту для первого объекта
		--копируем мод уввмапы на первый поли, колапсим, копию удаляем
		--трансфер эджей в анврап
		--брэкаем эджи в анврапе (согласно элементам)
		--ищем самый большой по габаритам элемент в анврапе
		--определяем масштаб от него для помещения в юдим
		--масштабируем все элементы или фейсы
		
		--способ 1
			--смещаем все острова на целочисленную часть от левого нижнего угла в угол первого UDIM (переносим все элементы в юдим без целой части, вычисляя и сохраняя отступ)
		
		--способ 2
			--переносим в центр перого юдима все элементы		
		
		--реализован:
		--ставим все острова вместе с найденным большим в первый юдим левым нижним углом, масштабируем к этой точке, смещаем на целочисленную часть каждый левый нижний угол всех островов
		
		if selection.count == 1 and classof selection[1].baseobject == Editable_Poly and selection[1].modifiers.count == 0 then
		(
			gc()
			max modify mode 
			
			FacesSelection = polyop.getFaceSelection selection[1]
			EdgesSelection = polyop.getEdgeSelection selection[1]
			FacesTotal = #{1..polyop.getNumFaces selection[1]}
			EdgesTotal = #{1..polyop.getNumEdges selection[1]}			
			FacesTotalNum = polyop.getNumFaces selection[1]
			EdgesTotalNum = polyop.getNumEdges selection[1]
			
			
			if EdgesSelection.numberSet == 0 and FacesSelection.numberSet == 0 then
			(
				print "Selected object is undefined type, no selection of faces and edges..."
				FacesSelection = FacesTotal 
				btn_edges_selector.pressed() --btn_poly_to_edges_selector.pressed()
				EdgesSelection = polyop.getEdgeSelection selection[1]
			)
			
			if EdgesSelection.numberSet == 0 and FacesTotalNum == FacesSelection.numberSet then 
			(
				print "Selected object is a whole Ground without another elements, but no selected edges..."
				btn_poly_to_edges_selector.pressed()
				EdgesSelection = polyop.getEdgeSelection selection[1]
				FacesSelection = FacesTotal 
			)
			
			--случай, когда в модели Ground выделена только земля, есть другие объекты, которые не нужно трогать в развертке  			
			if EdgesSelection.numberSet == 0 and FacesSelection.numberSet != FacesTotalNum and FacesSelection.numberSet > 0 then 
			(
				print "Selected object is a Ground with another elements, selected faces is ground surface, but no edges selected, try to select parallel edges..."
				--выделить только те параллельные эджи, которые принадлежат выделенным полигонам				
				btn_poly_to_edges_selector.pressed()
				EdgesSelection = polyop.getEdgeSelection selection[1]
				FacesSelection = polyop.getFaceSelection selection[1]
			)

			--случай, когда в модели Ground выделена только земля, есть другие объекты, которые не нужно трогать в развертке, также выделены эджи для развертки  	
			if EdgesSelection.numberSet > 0 and FacesSelection.numberSet != FacesTotalNum and FacesSelection.numberSet > 0 then 
			(
				print "Selected object is a Ground with another elements, selected faces is ground surface, parallel edges selected..."
				EdgesSelection = polyop.getEdgeSelection selection[1]
				FacesSelection = polyop.getFaceSelection selection[1]			
			)			
			
			if EdgesSelection.numberSet > 0 and FacesTotalNum == FacesSelection.numberSet then
			(
				print "Selected object is a whole Ground without another elements, with edges selected"
				EdgesSelection = polyop.getEdgeSelection selection[1]
				FacesSelection = polyop.getFaceSelection selection[1]	
			)
			
			if EdgesSelection.numberSet > 0 and FacesSelection.numberSet == 0 then
			(
				print "Selected object is undefined type, no face selection, but there are edges selection..."
				EdgesSelection = polyop.getEdgeSelection selection[1]
				FacesSelection = FacesTotal	
			)
				
			sel = selection[1]
			FacesOther = FacesTotal - FacesSelection
			EdgesOther = polyop.getEdgesUsingFace sel FacesOther		
			
			if chk_bricks_unwrap_unfold.checked then
			(
				sel_copy = copy selection[1]

				--делаем копию объекта, режем его на элементы вдоль выделенных ребер и удаляем все полигоны кроме самого большого элемента и делаем ему планарный мэпинг, копируем его на исходный объект
				elems_poly = #()

				--print #(FacesOther)
				if EdgesSelection.count > 0 then --(polyop.getEdgeSelection sel_copy).count > 0 then 
				(
					polyop.splitEdges sel_copy EdgesSelection --(EdgesSelection + EdgesOther)         (polyop.getEdgeSelection sel_copy)
					for i in FacesSelection do --#{1..(polyop.getNumFaces sel_copy)} do
					(
						elem = polyOp.getElementsUsingFace sel_copy #{i}
						appendifunique elems_poly elem
					)
				)
				--print #(elems_poly)
				
				areas = #()
				areas_ = #()
				for elem in elems_poly do 
				(
					area_ = 0.0
					for el in elem do area_ += polyop.getFaceArea sel_copy el
					append areas area_ 
					append areas_ #(area_, elem)
				)
				--elem_largest = #{}
				elem_largest = for a in areas_ where amax areas == a[1] do exit with a[2]
				--print #(elem_largest)
				
				select sel_copy
				--polyop.deleteFaces sel_copy (FacesOther + FacesSelection - elem_largest) delIsoVerts:true --polyop.setFaceSelection sel_copy elem_largest
				polyop.deleteFaces sel_copy (#{1..(polyop.getNumFaces sel_copy)} - elem_largest) delIsoVerts:true --polyop.setFaceSelection sel_copy elem_largest
				
				if (polyop.getNumFaces sel_copy) > 0 then
				(
					addmodifier sel_copy (uvwmap maptype:0 axis:2)
					
					lModifier = copy $.modifiers[1]
					select sel
					addModifier sel lModifier
					delete sel_copy
					convertToPoly sel
					sel = selection[1] --.baseobject					
				)
				else messagebox "No unwrap made, error."
			)

				if selection.count == 1 and classof selection[1].baseobject == Editable_Poly then	
				(
					--if (polyop.getEdgeSelection sel).count > 0 then transfer_edges() --трансформируем выделенные эджи на объекте поли в выбранные эджи в анврапе
					if not EdgesSelection.isempty then transfer_edges() --трансформируем выделенные эджи на объекте поли в выбранные эджи в анврапе
					--после трансфера есть новый анврап
					--трансфер создает свою развертку unwrap
					unwrapmod = modpanel.getcurrentobject()
					
					--if FacesSelection.numberset != FacesTotalNum then 
					--(
						--unwrapmod.selectFaces FacesSelection
						--unwrapmod.setTVSubObjectMode 3 
						--unwrapmod.selectFaces FacesSelection
						--unwrapmod.breakSelected() --разбиваем по границе выделенных полигонов
					--)
					unwrapmod.setTVSubObjectMode 2
					unwrapmod.breakSelected() --разбиваем на острова вдоль выделенных эджей всю развертку модели
					unwrapmod.selectFaces FacesSelection --#{1..unwrapmod.numberPolygons()}
					faces = #{}
					faces = unwrapmod.getSelectedFaces()
					unwrapmod.setTVSubObjectMode 3 
					unwrapmod.breakSelected() --разбиваем по границе выделенных полигонов
					unwrapmod.setPolygonMode true
					
					--unwrapmod.unfoldMapNoParams() 
					--unwrapmod.unfoldMap 1
					--unwrapmod.normalMapNoParams()
		
					sc = 1.0 
					hei = 0.0
					wid = 0.0
					t = spn_bricks_unwrap_treshold.value  --0.05
					if faces.count > 0 then
					(
						elems = #()
						for f in faces do --находим из всего набора фейсов - острова, записываем их
						(
							unwrapmod.selectFaces #{f}
							unwrapmod.selectElement()	
							elem = unwrapmod.getSelectedFaces()
							appendifunique elems elem
						)
						
						--выясняем самый большой остров, теоретически он близок к 1.0х1.0 по габаритам, т.к. такая развертка UVW_MAP
						dims_h = #()
						dims_w = #()
						
						--дописать сюда масштаб из выбранного острова
						
						for f in elems do --выясняем самые большие г??бариты островов, по высоте и ширине (самого широкого и самого высокого такого может и не быть)
						(
							unwrapmod.selectFaces f
							unwrapmod.getArea f &x &y &width &height &areaUVW &areaGeom
							append dims_h height 
							append dims_w width
						)
						hei = amax dims_h
						wid = amax dims_w
						--print sc
				
						if chk_bricks_unwrap_scale.checked then
						(
							if chk_bricks_unwrap_height.checked and chk_bricks_unwrap_width.checked then sc = 1.0 / amax #(hei, wid)
							if chk_bricks_unwrap_height.checked and not chk_bricks_unwrap_width.checked then sc = 1.0 / hei
							if not chk_bricks_unwrap_height.checked and chk_bricks_unwrap_width.checked then sc = 1.0 / wid		
							if not chk_bricks_unwrap_height.checked and not chk_bricks_unwrap_width.checked then sc = 1.0 
						)
						else sc = 1.0							

						unwrapmod.selectFaces FacesSelection --#{1..unwrapmod.numberPolygons()}
						--масштабировать всю развертку с масштабом, посчитанным из самого большого острова к размеру юдима, 
						--нельзя по центру, т.к. это приведет к смещению по текстуре 
						--unwrapmod.scaleSelectedCenter sc 0 
						
						--print #(elems)
						case rdo_unwrap_method.state of
						(
							1: --"Centers"
							(
								unwrapmod.setTVSubObjectMode 3
								unwrapmod.setPolygonMode true
								for f in elems do
								(
									unwrapmod.selectFaces f
									pos = unwrapmod.getSelCenter()
									unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0] --смещаем все острова в центр первого юдима, считая смещение от центра острова
									if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0
								)									
							)
							
							4: --"Integers"
							(
								unwrapmod.setTVSubObjectMode 3
								unwrapmod.setPolygonMode true
								for f in elems do
								(
									unwrapmod.selectFaces f
									pos = unwrapmod.getSelCenter()
									--unwrapmod.moveSelected [ -(floor pos.x), -(floor pos.y), 0] 
									--смещаем все острова на целое число юдимов в первый юдим, считая смещение от центра острова
									
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [ -(floor pos.x), -(floor pos.y), 0]
									else unwrapmod.moveSelected [ -(pos.x as integer), -(pos.y as integer), 0]

									if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0
								)									
							)
							
							5: --"Corner Landscape ??"
							(
								unwrapmod.setPolygonMode true
								unwrapmod.faceToVertSelect() 
								VertsSelectionMod = unwrapmod.getselectedvertices()
								--определить минимум x,y всех островов и сместить к левому нижнему углу всё целиком, потом от тойже точки всё отмасштабировать
								minX = amin (for i in VertsSelectionMod collect (unwrapmod.getvertexposition currenttime i).x)
								minY = amin (for i in VertsSelectionMod collect (unwrapmod.getvertexposition currenttime i).y)
								
								--minX = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								--minY = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								--print minX
								--print minY
								
								--надо отсеивать неполные острова (снизу и слева модели), лучше смещать в угол максимальный остров со всей разверткой, 
								--если найдется такой остров, то ставим новые значения, если нет, то оставлять прежние
								for f in elems do
								(
									unwrapmod.selectFaces f
									unwrapmod.getArea f &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minY = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minX = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)									
									)								
								)							
								--print minX
								--print minY

								unwrapmod.selectFaces FacesSelection --#{1..unwrapmod.numberPolygons()}
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, minY, 0]  --unwrapmod.scaleSelected sc 0 [minX, minY, 0]
								
								if chk_bricks_unwrap_pack.checked then
								(
									--ставим все острова левым нижним углом в первый юдим, так собьётся исходный отступ от текстуры	
									unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0]
								)
								else
								(
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] 
									else unwrapmod.moveSelected [ -(minX as integer), -(minY as integer), 0]
								)
								
								--можно смещать по разнице между островами (а еще можно смещать как вручную по вертикальным и горизонтальным островам по линиям из островов)
								arr = #()
								for f in elems do 	
								(
									unwrapmod.selectFaces f
									unwrapmod.faceToVertSelect() 
									v = unwrapmod.getselectedvertices()
									poi_min_x = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_max_x = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_min_y = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									poi_max_y = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									append arr #(f, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
								)		
								--print arr
																
								for a in arr do
								(
									unwrapmod.selectFaces a[1]
									--для равных размеров островов и кусочков смещаем на целую часть в первый юдим (получается к левому нижему углу)
									--(для неравных островов, надо будет смещать, просчитывая разницу от первого острова)
									
									--порог определения допуска, добавляем к минимальной точке, чтобы не залезать в соседний юдим (для максимальных точек надо будет вычитать его)

									--разобраться с добавочным порогом, он мешает ставить точно		
									--unwrapmod.moveSelected [-(floor (a[2] + t)), -(floor (a[4] + t)), 0] 
									--unwrapmod.moveSelected [-(a[2] as integer), -(a[4] as integer), 0]

									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[2] + t)), -(floor (a[4] + t)), 0] 
									else unwrapmod.moveSelected [-(a[2] as integer), -(a[4] as integer), 0]
								)
							)
							
							2: --"Corner Landscape ??"
							(
								unwrapmod.setPolygonMode true
								
								--определить минимум x,y всех островов и сместить к левому нижнему углу всё целиком, потом от тойже точки всё отмасштабировать
								minX = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								--minY = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								--maxX = amax (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								maxY = amax (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								
								--надо отсеивать неполные острова (снизу и слева модели), лучше смещать в угол максимальный остров со всей разверткой, 
								--если найдется такой остров, то ставим новые значения, если нет, то оставлять прежние
								for f in elems do
								(
									unwrapmod.selectFaces f
									unwrapmod.getArea f &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										--minY = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
										maxY = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minX = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
										--maxX = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									)								
								)							

								unwrapmod.selectFaces #{1..unwrapmod.numberPolygons()}
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, minY, 0]
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, minY, 0]
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, maxY, 0]
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, maxY, 0]									
								
								if chk_bricks_unwrap_pack.checked then
								(
									--ставим все острова левым нижним углом в первый юдим, так собьётся исходный отступ от текстуры	
									--unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0]
									--unwrapmod.moveSelected [0.0 - maxX, 0 - minY, 0]
									unwrapmod.moveSelected [0.0 - minX, 0 - maxY, 0]
									--unwrapmod.moveSelected [0.0 - maxX, 0 - maxY, 0]									
								)
								else
								(
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] else unwrapmod.moveSelected [ -(minX as integer), -(minY as integer), 0]
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (maxY + t)), 0] else unwrapmod.moveSelected [ -(minX as integer), -(maxY as integer), 0]
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (minY + t)), 0] else unwrapmod.moveSelected [ -(maxX as integer), -(minY as integer), 0]
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (maxY - t)), 0] else unwrapmod.moveSelected [ -(maxX as integer), -(maxY as integer), 0]
								)
								
								--можно смещать по разнице между островами (а еще можно смещать как вручную по вертикальным и горизонтальным островам по линиям из островов)
								arr = #()
								for f in elems do 	
								(
									unwrapmod.selectFaces f
									unwrapmod.faceToVertSelect() 
									v = unwrapmod.getselectedvertices()
									poi_min_x = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_max_x = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_min_y = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									poi_max_y = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									append arr #(f, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
								)		
								--print arr
																
								for a in arr do
								(
									unwrapmod.selectFaces a[1]
									--для равных размеров островов и кусочков смещаем на целую часть в первый юдим (получается к левому нижему углу)
									--(для неравных островов, надо будет смещать, просчитывая разницу от первого острова)
									--порог определения допуска, добавляем к минимальной точке, чтобы не залезать в соседний юдим (для максимальных точек надо будет вычитать его)

									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[2] + t)), -(floor (a[5] + t)), 0] else unwrapmod.moveSelected [-(a[2] as integer), -(a[5] as integer), 0]
								)
							)
														
							3: --"Corner Landscape ??"
							(
								unwrapmod.setPolygonMode true
								
								--определить минимум x,y всех островов и сместить к левому нижнему углу всё целиком, потом от тойже точки всё отмасштабировать
								--minX = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								--minY = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								maxX = amax (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								maxY = amax (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								
								--надо отсеивать неп??лные острова (снизу и слева модели), лучше смещать в угол максимальный остров со всей разверткой, 
								--если найдется такой остров, то ставим новые значения, если нет, то оставлять прежние
								for f in elems do
								(
									unwrapmod.selectFaces f
									unwrapmod.getArea f &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										--minY = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
										maxY = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										--minX = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
										maxX = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									)								
								)							

								unwrapmod.selectFaces #{1..unwrapmod.numberPolygons()}
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, minY, 0]
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, minY, 0]
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, maxY, 0]
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, maxY, 0]									
								
								if chk_bricks_unwrap_pack.checked then
								(
									--ставим все острова левым нижним углом в первый юдим, так собьётся исходный отступ от текстуры	
									--unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0]
									--unwrapmod.moveSelected [0.0 - maxX, 0 - minY, 0]
									--unwrapmod.moveSelected [0.0 - minX, 0 - maxY, 0]
									unwrapmod.moveSelected [0.0 - maxX, 0 - maxY, 0]									
								)
								else
								(
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] else unwrapmod.moveSelected [ -(minX as integer), -(minY as integer), 0]
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (maxY - t)), 0] else unwrapmod.moveSelected [ -(minX as integer), -(maxY as integer), 0]
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (minY + t)), 0] else unwrapmod.moveSelected [ -(maxX as integer), -(minY as integer), 0]
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (maxY - t)), 0] else unwrapmod.moveSelected [ -(maxX as integer), -(maxY as integer), 0]
								)
								
								--можно смещать по разнице между островами (а еще можно смещать как вручную по вертикальным и горизонтальным островам по линиям из островов)
								arr = #()
								for f in elems do 	
								(
									unwrapmod.selectFaces f
									unwrapmod.faceToVertSelect() 
									v = unwrapmod.getselectedvertices()
									poi_min_x = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_max_x = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_min_y = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									poi_max_y = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									append arr #(f, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
								)		
								--print arr
																
								for a in arr do
								(
									unwrapmod.selectFaces a[1]
									--для равных размеров островов и кусочков смещаем на целую часть в первый юдим (получается к левому нижему углу)
									--(для неравных островов, надо будет смещать, просчитывая разницу от первого острова)
									--порог определения допуска, добавляем к минимальной точке, чтобы не залезать в соседний юдим (для максимальных точек надо будет вычитать его)

									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[3] + t)), -(floor (a[5] + t)), 0] else unwrapmod.moveSelected [-(a[3] as integer), -(a[5] as integer), 0]
								)
							)
							
							6: --"Corner Landscape ??"
							(
								unwrapmod.setPolygonMode true
								
								--определить минимум x,y всех островов и сместить к левому нижнему углу всё целиком, потом от тойже точки всё отмасштабировать
								--minX = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								minY = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								maxX = amax (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								--maxY = amax (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								
								--надо отсеивать неполные острова (снизу и слева модели), лучше смещать в угол максимальный остров со всей разверткой, 
								--если найдется такой остров, то ставим новые значения, если нет, то оставлять прежние
								for f in elems do
								(
									unwrapmod.selectFaces f
									unwrapmod.getArea f &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minY = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
										--maxY = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										--minX = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
										maxX = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									)								
								)							

								unwrapmod.selectFaces #{1..unwrapmod.numberPolygons()}
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, minY, 0]
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, minY, 0]
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, maxY, 0]
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, maxY, 0]									
								
								if chk_bricks_unwrap_pack.checked then
								(
									--ставим все острова левым нижним углом в первый юдим, так собьётся исходный отступ от текстуры	
									--unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0]
									unwrapmod.moveSelected [0.0 - maxX, 0 - minY, 0]
									--unwrapmod.moveSelected [0.0 - minX, 0 - maxY, 0]
									--unwrapmod.moveSelected [0.0 - maxX, 0 - maxY, 0]									
								)
								else
								(
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] else unwrapmod.moveSelected [ -(minX as integer), -(minY as integer), 0]
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (maxY - t)), 0] else unwrapmod.moveSelected [ -(minX as integer), -(maxY as integer), 0]
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX + t)), -(floor (minY + t)), 0] else unwrapmod.moveSelected [ -(maxX as integer), -(minY as integer), 0]
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (maxY - t)), 0] else unwrapmod.moveSelected [ -(maxX as integer), -(maxY as integer), 0]
								)
								
								--можно смещать по разнице между островами (а еще можно смещать как вручную по вертикальным и горизонтальным островам по линиям из островов)
								arr = #()
								for f in elems do 	
								(
									unwrapmod.selectFaces f
									unwrapmod.faceToVertSelect() 
									v = unwrapmod.getselectedvertices()
									poi_min_x = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_max_x = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_min_y = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									poi_max_y = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									append arr #(f, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
								)		
								--print arr
																
								for a in arr do
								(
									unwrapmod.selectFaces a[1]
									--для равных размеров островов и кусочков смещаем на целую часть в первый юдим (получается к левому нижему углу)
									--(для неравных островов, надо будет смещать, просчитывая разницу от первого острова)
									--порог определения допуска, добавляем к минимальной точке, чтобы не залезать в соседний юдим (для максимальных точек надо будет вычитать его)
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[3] + t)), -(floor (a[4] + t)), 0] else unwrapmod.moveSelected [-(a[3] as integer), -(a[4] as integer), 0]
								)
							)							
						)
						unwrapmod.selectFaces #{1..unwrapmod.numberPolygons()}
					)
				)
				--else messagebox "Select parallel edges after square slices!"
		)
		else messagebox "Select single EDITABLE POLY object with NO MODIFICATORS!"
	)

	
	on btn_bricks_unwrap_new rightclick do
	(
		if selection.count == 1 and classof selection[1].baseobject == Editable_Poly and selection[1].modifiers.count == 0 then
		(
			gc()
			max modify mode 
			sel = selection[1]

			FacesTotal = #{1..polyop.getNumFaces sel}
			EdgesTotal = #{1..polyop.getNumEdges sel}			
			
			FacesTotalNum = polyop.getNumFaces sel
			EdgesTotalNum = polyop.getNumEdges sel
			
			FacesSelection = polyop.getFaceSelection sel
			EdgesSelection = polyop.getEdgeSelection sel
			
			if FacesSelection.isempty then FacesSelection = FacesTotal
			if EdgesSelection.isempty then EdgesSelection = EdgesTotal

				if selection.count == 1 and classof selection[1].baseobject == Editable_Poly then	
				(
					if not EdgesSelection.isempty then transfer_edges() --трансформируем выделенные эджи на объекте поли в выбранные эджи в анврапе
					--после трансфера есть новый анврап
					--трансфер создает свою развертку unwrap
					unwrapmod = modpanel.getcurrentobject()
					
					unwrapmod.setTVSubObjectMode 2
					unwrapmod.breakSelected() --разбиваем на острова вдоль выделенных эджей всю развертку модели
					unwrapmod.selectFaces FacesSelection --#{1..unwrapmod.numberPolygons()}
					faces = #{}
					faces = unwrapmod.getSelectedFaces()
					unwrapmod.setTVSubObjectMode 3 
					unwrapmod.breakSelected() --разбиваем по границе выделенных полигонов
					unwrapmod.setPolygonMode true
		
					sc = 1.0 
					hei = 1.0
					wid = 1.0
					t = spn_bricks_unwrap_treshold.value  --0.05
					if faces.count > 0 then
					(
						elems = #()
						for f in faces do --находим из всего набора фейсов - острова, записываем их
						(
							unwrapmod.selectFaces #{f}
							unwrapmod.selectElement()	
							elem = unwrapmod.getSelectedFaces()
							appendifunique elems elem
						)
						unwrapmod.selectFaces FacesSelection

							--"Corner Landscape ??"
								unwrapmod.setPolygonMode true
								unwrapmod.faceToVertSelect() 
								VertsSelectionMod = unwrapmod.getselectedvertices()
								--определить минимум x,y всех островов и сместить к левому нижнему углу всё целиком, потом от тойже точки всё отмасштабировать
								minX = amin (for i in VertsSelectionMod collect (unwrapmod.getvertexposition currenttime i).x)
								minY = amin (for i in VertsSelectionMod collect (unwrapmod.getvertexposition currenttime i).y)

								unwrapmod.selectFaces FacesSelection
								
								if chk_bricks_unwrap_pack.checked then
								(
									unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0]
								)
								else
								(
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] 
									else unwrapmod.moveSelected [ -(minX as integer), -(minY as integer), 0]
								)
								
								arr = #()
								for f in elems do 	
								(
									unwrapmod.selectFaces f
									unwrapmod.faceToVertSelect() 
									v = unwrapmod.getselectedvertices()
									poi_min_x = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_max_x = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_min_y = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									poi_max_y = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									append arr #(f, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
								)		

								for a in arr do
								(
									unwrapmod.selectFaces a[1]
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[2] + t)), -(floor (a[4] + t)), 0] 
									else unwrapmod.moveSelected [-(a[2] as integer), -(a[4] as integer), 0]
								)
						unwrapmod.selectFaces #{1..unwrapmod.numberPolygons()}
					)
				)
				--else messagebox "Select parallel edges after square slices!"
		)
		else messagebox "Select single EDITABLE POLY object with NO MODIFICATORS!"
	)

	on btn_udims_as_ids pressed do with undo "Place to UDIMs by IDs" on with redraw off --разделение по ID
	(
		if selection.count == 1 then
		(
			local ctrl = keyboard.controlPressed
			if (classof selection[1] == editable_poly and selection[1].modifiers.count == 0) or (classof selection[1].modifiers[1] == Unwrap_UVW and classof selection[1].baseobject == editable_poly and selection[1].modifiers.count > 0) then 
			(
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
				(
					addmodifier selection[1] (Unwrap_UVW())
					unwrapmod = modpanel.getcurrentobject()
				)
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					max modify mode	
					unwrapmod.setTVSubObjectMode 3
					local sc = 1.0
					local faces
					local spn = spn_bricks_unwrap_sc2.value
					for id in #{1..100} do --unwrapmod.numberMatIDs()} могут быть больше в цифрах чем их число, поэтому пока до 100
					(
						faces = #{}
						unwrapmod.selectByMatID (id as integer)
						faces = unwrapmod.getselectedfaces()

						if not faces.isempty then
						(					
							unwrapmod.breakSelected()
							if not ctrl then 
							(
								unwrapmod.faceToVertSelect()
								verts = unwrapmod.getSelectedVertices()
								poi_x = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).x)
								poi_y = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).y)
								sc = if abs (amax poi_y - amin poi_y) >= abs (amax poi_x - amin poi_x) then spn/(amax poi_y - amin poi_y) else spn_bricks_unwrap_sc.value/(amax poi_x - amin poi_x)
								--print sc
								unwrapmod.scaleSelectedCenter sc 0
								pos = unwrapmod.getSelCenter()								
								--print pos
								--format "offset: x = %, y = %\n" (0.5 - pos.x) (0.5 - pos.y)
								unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0]
							)
							else
							(
								pos = unwrapmod.getSelCenter()	
								unwrapmod.moveSelected [- floor pos.x, - floor pos.y, 0]
							)

							case of
							(
								(id > 0  and id <= 10): unwrapmod.moveSelected [id - 1, 0, 0]	
								(id > 10 and id <= 20): unwrapmod.moveSelected [id - 11, 1, 0]
								(id > 20 and id <= 30): unwrapmod.moveSelected [id - 21, 2, 0]					
								(id > 30 and id <= 40): unwrapmod.moveSelected [id - 31, 3, 0]	
								(id > 40 and id <= 50): unwrapmod.moveSelected [id - 41, 4, 0]
								(id > 50 and id <= 60): unwrapmod.moveSelected [id - 51, 5, 0]
								(id > 60 and id <= 70): unwrapmod.moveSelected [id - 61, 6, 0]	
								(id > 70 and id <= 80): unwrapmod.moveSelected [id - 71, 7, 0]	
								(id > 80 and id <= 90): unwrapmod.moveSelected [id - 81, 8, 0]	
								(id > 90 and id <= 100): unwrapmod.moveSelected [id - 91, 9, 0]		
								default:()
							)
						)
					)
				)
			) 
			else messagebox "Selected object is not an EDITABLE POLY!"
			
			gc light:true
		)
		else messagebox "Select single EDITABLE POLY object with Unwrap UVW modifier!"
	)
	
	on btn_count_area pressed do
	(
		if selection.count == 1 then
		(
			gc()
			if classof selection[1] != editable_poly then 
			(
				messagebox "Selected object is not an EDITABLE POLY!"
				with undo "Convert to EDITABLE POLY" on
				(
					convertToPoly selection[1]
				)
			)
			max modify mode
			xViewChecker.on = false
			global dirs_select = #()
			global selmod = modpanel.getcurrentobject()
			global faces = #()
			
			if selmod != undefined and classof selmod == editable_poly then
			(
				faces = selmod.GetSelection #Face 
				if faces.count > 0 then
				(
					--print faces
					--for f in faces do
					--(
					--	append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
					--)
				)
			)
			
			try(destroyDialog ::ro_count_area)catch()
			rollout ro_count_area "Counts Area of Polygons" 
			(
				fn defColor r g b = ((dotNetClass "System.Drawing.Color").FromArgb r g b)
				
				local maxBC = defColor 60 60 60
				local maxFC = defColor 200 200 200
				
				fn autoResizeColumn lv columns: = 
				(
					vScrollWidth = 21 -- vertical scrollbar width
					for c = 0 to columns-1 do
					(
						lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
						vScrollWidth += lv.Columns.Item[c].Width
					) 
					vScrollWidth
				)
	
				fn compileListItemSorter =
				(
					source =  "using System;\n"
					source += "using System.Windows.Forms;\n"
					source += "using System.Collections;\n"
					source += "class ListViewItemComparer : IComparer\n"
					source += "{\n"
					source += "    private int c;\n"
					source += "    private bool num = false;\n"
					source += "    private int dir = 1;\n"
					source += "    public ListViewItemComparer() { c = 0; }\n"
					source += "    public ListViewItemComparer(int column, bool numeric, bool reverse)\n"
					source += "    { c = column; num = numeric; dir = reverse ? -1 : 1; }\n"
					source += "    public int Compare(object x, object y)\n"
					source += "    {\n"
					source += "        if (num) return Convert.ToInt32(((ListViewItem)x).SubItems[c].Text).CompareTo(\n"
					source += "            Convert.ToInt32(((ListViewItem)y).SubItems[c].Text)) * dir;\n"
					source += "        else return String.Compare(((ListViewItem)x).SubItems[c].Text,\n"
					source += "            ((ListViewItem)y).SubItems[c].Text) * dir;\n"
					source += "    }\n"
					source += "}"
				 
					local csharpProvider = dotNetObject "Microsoft.CSharp.CSharpCodeProvider"
					local compilerParams = dotNetObject "System.CodeDom.Compiler.CompilerParameters"
					compilerParams.GenerateInMemory = true
					compilerParams.ReferencedAssemblies.Add("System.Windows.Forms.dll")
					compilerResults = csharpProvider.CompileAssemblyFromSource compilerParams #(source)
					compilerResults.CompiledAssembly
				)
				
				fn qsort_csv arr1 arr2 = 
				(
					case of 
					(
						(arr1[1] as float < arr2[1] as float): -1
						(arr1[1] as float > arr2[1] as float): 1
						default:0
					)
				)

				fn qsort_csv3 arr1 arr2 = 
				(
					case of 
					(
						(arr1[3] as float < arr2[3] as float): -1
						(arr1[3] as float > arr2[3] as float): 1
						default:0
					)
				)
				
				fn PopulateList lv dirs_select faces =
				(
					qsort dirs_select qsort_csv
					
					lv.Items.Clear()
					lv.view = (dotNetClass "system.windows.forms.view").details
					lv.HideSelection = true 
					lv.HeaderStyle = (dotNetClass "System.Windows.Forms.ColumnHeaderStyle").clickable
					--lv.height = 390
					lv.FullRowSelect = true    
					lv.MultiSelect = false --true    
					lv.AllowColumnReorder = true
					lv.GridLines = true
					lv.checkBoxes = false --true 
					lv.Scrollable = true
					lv.ShowItemToolTips = true
					columnsAr = #("Poly Area", "ID", ("Number Of " + dirs_select.count as string))
					lv.columns.Clear()
					for i = 1 to 3 do lv.columns.add columnsAr[i] 0	
					--lv.width = autoResizeColumn lv columns:3
					--lv.width = 490
					--lv.Update()
					
					rows = #()
					for t = 1 to dirs_select.count do
					(
						li = dotNetObject "System.Windows.Forms.ListViewItem" (dirs_select[t][1])
						li.UseItemStyleForSubItems = true
						if dirs_select[t][1] as float <= 0.00001 then li.forecolor = li.forecolor.fromARGB 200 0 0
						li.subitems.add dirs_select[t][2]
						li.subitems.add dirs_select[t][3]
						append rows li
					)
					lv.items.addRange rows
					--lv.Update()
					lv.width = autoResizeColumn lv columns:3
					lv.width = 490
					lv.Update()
				)
				
				dotNetControl lv "ListView" pos:[5,5] width:490 height:300
				--label lbmin "" pos:[470,20]
				--label lbmax "" pos:[470,290]
				group "filter"
				(
					button btnFilterZero "Filter with Zero Area" across:4 align:#left tooltip:"Вывести из всех выделенных полигонов список граней с околонулевой площадью | List faces with zero area only"
					edittext edt_tresh "Treshold" text: "0.00001" width:100 fieldWidth:80 				
					button btnFilterAll "Show All Selected" offset: [0,0] tooltip:"Вывести список всех граней с их площадью | List all selected faces with their areas"
					button btnRightClk "View Selected" align:#right tooltip:"Просмотр выбранной грани в окне проекции | View selected face in viewport" --offset: [20,0]	
				)
				group "edit"
				(
					button btnRepairAll "Repair All" across:5 align:#left tooltip:""
					button btnDeleteZero "Collapse Face" offset:[0,0] tooltip:"LMB: Удалить выбранную грань\nLMB+CTRL: Свернуть выбранную грань | LMB: Delete selected face\nLMB+CTRL: Collapse selected face" --offset: [-30,0]
					button btnMoveZero "Slight Move" offset:[0,0] tooltip:"Немного отодвинуть проблемную вершину грани, чтобы увеличить площадь полигона | Move the problematic vertex slightly to increase the polygon area"
					button btnEdgesWeld "Edges Weld" offset:[-10,0] tooltip:"Сварить все наложенные ребра в выделенных полигонах, работает также только на выделении ребер | Weld all overlayed edges in selected objects, also work only on selected edges"
					button btnDeleteEdge "Remove Overlayed" align:#right tooltip:"LMB: Удалить дублирующее сдвоенное ребро у выбранной грани\nLMB+CTRL: Только выбрать ребра\вершины | LMB: Delete (dublicated) overlayed edge in selected face\nLMB+CTRL: select edges\verts only"
				)
				group "selection"	
				(
					label lbl "Selected:" across:5 width:150 align:#left style_sunkenedge:true
					button btnSelectionAll "Select All Faces" offset:[55,0] tooltip:"Выделить все грани объекта | Select all faces of object"
					button btnSelectID "Select Faces by ID" offset:[60,0] tooltip:"Выбрать грани с текущим ID объекта | Select faces with current ID of object"
					spinner spn_ID "ID" range:[1, 10000, 1] type:#integer offset:[40,0] tooltip:"ID объекта | ID of object"
					button btnClose "Close" align:#right tooltip:"Закрыть диалоговое окно | Close dialog"
				)	
				
				on lv columnClick columnHeader do
				(
					lv.ListViewItemSorter = dotnetobject "MXS_dotNet.ListViewItemComparer" columnHeader.column
					lv.ListViewItemSorter = undefined
				)
				
				on btnSelectionAll pressed do
				(
					max modify mode
					selmod = modpanel.getcurrentobject()
					if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then 
					(
						polyop.setFaceSelection selmod #all
						faces = selmod.GetSelection #Face 
						if faces.count > 0 then
						(
							dirs_select = #()
							--print faces
							for f in faces do
							(
								append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
							)
						)
						--PopulateList lv dirs_select faces	
						lbl.text = "Selected: " + (faces.numberset as string)
					)
				)
				
				on btnSelectID pressed do with undo "View Checked" on
				(
					max modify mode
					selmod = modpanel.getcurrentobject()
					if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then 
					(
						selID = #{}
						for i in #{1..(polyop.getNumFaces selmod)} where (polyop.getFaceMatID selmod i) == (spn_ID.value as integer) do append selID i 
						polyop.setFaceSelection selmod selID
						faces = selmod.GetSelection #Face 
						if faces.count > 0 then
						(
							dirs_select = #()
							--print faces
							for f in faces do
							(
								append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
							)
						)
						--PopulateList lv dirs_select faces		
						lbl.text = "Selected: " + (faces.numberset as string)						
					)
					
				)
				
				on btnMoveZero pressed do with undo "Move Middle Vert" on
				(
					ctrl = keyboard.controlPressed
					max modify mode
					sel_faces = #{}
					for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected /*and (dirs_select[val+1][1] as float) <= 0.00001*/ do append sel_faces (dirs_select[val+1][3] as integer)
					print sel_faces
					selmod = modpanel.getcurrentobject()
					if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
					(
						if not sel_faces.isempty then
						(
							for s in sel_faces where not keyboard.escPressed do 
							(
								polyop.setFaceSelection selmod #{s}
								--subObjectLevel = 4
								vv = polyop.getVertsUsingFace selmod sel_faces
								if vv.numberset == 3 then
								(
									--pp = polyop.getVerts selmod vv
									for v in vv do
									(
										pp = polyop.getVerts selmod (vv - #{v})
										p = polyop.getVert selmod v
										vec1 = normalize (p - pp[1])
										vec2 = normalize (p - pp[2])
										--dott = dot vec1 vec2
										cros = normalize (cross -vec1 -vec2)
										--print dott
										print cros
										if (distance pp[1] pp[2]) >= ((distance pp[1] p) + (distance pp[2] p)) then
										(
											if ctrl then (polyop.setVertSelection selmod #{v}; subObjectLevel = 1) else polyop.moveVert selmod #{v} (0.01 * cros)
											exit
										)
									)
								)
							)
						)
					)
				)
					
				on btnDeleteZero pressed do with undo "Delete Selected Poly" on
				(
					--delete polygon (may be with zero area)
					ctrl = keyboard.controlPressed
					max modify mode
					sel_faces = #{}
					for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected /*and (dirs_select[val+1][1] as float) <= 0.00001*/ do append sel_faces (dirs_select[val+1][3] as integer)
					print sel_faces
					selmod = modpanel.getcurrentobject()
					if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
					(
						polyop.setFaceSelection selmod sel_faces
						--subObjectLevel = 4
						if ctrl then polyop.collapseFaces selmod sel_faces else polyop.deleteFaces selmod sel_faces
						polyop.setFaceSelection selmod #all
						faces = selmod.GetSelection #Face 
						if faces.count > 0 then
						(
							dirs_select = #()
							--print faces
							for f in faces do
							(
								append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
							)
						)
						PopulateList lv dirs_select faces
						lbl.text = "Selected: " + (faces.numberset as string)
					)
				)

				on btnRepairAll pressed do with undo "Repair Poly" on --мод meshcleaner()
				(
					if selection.count == 1 then
					(
						max modify mode
						selmod = modpanel.getcurrentobject()
						if (selection.count == 1 and classof selection[1] != Editable_Poly) or (selection.count == 1 and classof selection[1] != Editable_Poly and selection[1].modifiers.count != 0) then converttopoly selection[1]
						addmodifier selection[1] (meshcleaner())
						selmod = modpanel.getcurrentobject()
						selmod.ValidateMesh()
	
						--print (curMaxVersion = ((maxversion())[1] / 1000) - 2 + 2000)
						local curMaxVersion = ((maxversion())[1] / 1000) - 2 + 2000	
						if curMaxVersion == 2024 then
						(
							selmod.repairHoles = true
							selmod.repairNonManifold = true
							selmod.repairSelfIntersections = true
						)
						if curMaxVersion >= 2025 then
						(
							selmod.repairHoles = true
							selmod.repairNonManifold = true
							selmod.repairSelfIntersections = true
							selmod.repairZeroAreaUVs = true	
							selmod.repairNonPlanarFaces = true
							selmod.repairIsolatedVertices = true
						)
						selmod.RepairMesh()
						converttopoly selection[1]
							
						/*
							showinterfaces selmod
							showproperties selmod
							
						max 2025	
						.numDegenerateEdges : integer
						.numDegenerateFaces : integer
						.repairHoles : boolean
						.numHoles : integer
						.repairNonManifold : boolean
						.numNonManifold : integer
						.repairSelfIntersections : boolean
						.numSelfIntersections : integer
						.numZeroAreaUVs : integer
						.repairZeroAreaUVs : boolean
						.numNonPlanarFaces : integer
						.repairNonPlanarFaces : boolean
						.numIsolatedVertices : integer
						.repairIsolatedVertices : boolean
						.validationRan : boolean	
							
						max 2024	
						.numDegenerateEdges : integer
						.numDegenerateFaces : integer
						.repairHoles : boolean
						.numHoles : integer
						.repairNonManifold : boolean
						.numNonManifold : integer
						.repairSelfIntersections : boolean
						.numSelfIntersections : integer
						.validationRan : boolean
						*/

					)
				)
				
				on btnEdgesWeld pressed do
				(
					if selection.count == 1 then
					(
						if classof selection[1] == Editable_Poly and selection[1].modifiers.count == 0 then
						(
							selmod = modpanel.getcurrentobject()
							sel_faces = #{}
							sel_edges = #{}
						
							for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected /* and (dirs_select[val+1][1] as float) <= 0.00001 */ do append sel_faces (dirs_select[val+1][3] as integer)
							--print sel_faces
							
							for sel_face in sel_faces do
							(
								polyop.setFaceSelection selmod #{sel_face}
								sel_edges = polyop.getEdgesUsingFace selmod #{sel_face}
								polyOp.setEdgeSelection selmod sel_edges
								
								--нажать из раллаута object operations
								Obj_Spln.btn_EdgeWeld.pressed()
								
								polyop.setFaceSelection selmod #{sel_face}
								vv = polyop.getVertsUsingFace selmod #{sel_face}
								--pp = polyop.getVerts selmod vv
								for v1 in vv where vv.numberset == 4 do
								(
									for v2 in vv where v1 < v2 and distance (p1 = polyop.getVert selmod v1) (p2 = polyop.getVert selmod v2) <= 0.002 do
									(
										polyOp.setVertSelection selmod #{v1,v2}
										--polyop.cutFace selmod sel_face p1 p2 (polyop.getFaceNormal selmod sel_face)
										selmod.slice p1 p2 flaggedFacesOnly:true
									)
								)
							)
						)
					)
				)					
				
				on btnDeleteEdge pressed do with undo "Delete Wrong Edges & Verts" on --delete edges/verts on polygon with zero area
				(
					max modify mode
					ctrl = keyboard.controlPressed
					if selection.count == 1 and classof selection[1] == Editable_Poly and selection[1].modifiers.count == 0 then
					(
						selmod = modpanel.getcurrentobject()
						sel_faces = #{}
						equal = false
						edges_eq = #{}
						verts_eq = #{}
						for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected /* and (dirs_select[val+1][1] as float) <= 0.00001 */ do append sel_faces (dirs_select[val+1][3] as integer)
						print sel_faces
						if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
						(
							polyop.setFaceSelection selmod sel_faces
							--subObjectLevel = 4
							arr = #{}
							verts_ini = polyop.getVertsUsingFace selmod sel_faces
							verts_close = #()
							for v in verts_ini do 
								for w in verts_ini where w > v do
									if distance (polyop.getvert selmod v) (polyop.getvert selmod w) <= 0.002 then append verts_close #{v,w}
							--ищем полигоны, у которых точки близко друг к другу, если такие есть, значит это не ошибочная триангуляция, 
							--а задвоенные точки, порождающие полигон нулевой площади
							
							if verts_close.count == 0 then --для ошибочной триангуляции
							(
								for i in (polyop.getVertsUsingFace selmod sel_faces) do	
								(			
									if keyboard.escPressed then exit
									edges = polyop.getEdgesUsingVert selmod #{i}
									verts = #{}
									for j in edges do join verts (polyop.getVertsUsingEdge selmod #{j})
									p1 = polyop.getvert selmod i
									verts = verts - #{i}
									for k in verts do 
									(
										p2 = polyop.getvert selmod k
										for l in verts where l > k do 
										(
											if keyboard.escPressed then exit
											p3 = polyop.getvert selmod l
											v1 = p2 - p1
											v2 = p3 - p1
											if (acos(dot (normalize v1) (normalize v2))) <= 0.001 then --== 0.0
											(
												edge_k = 0
												edge_l = 0
												for m in edges do
												(
													pp = polyop.getVertsUsingEdge selmod #{m}
													if finditem pp i > 0 and finditem pp k > 0 then edge_k = m
													if finditem pp i > 0 and finditem pp l > 0 then edge_l = m
												)
												if (distance p2 p1) >= (distance p3 p1) then append arr edge_k else append arr edge_l
												
												if abs((distance p2 p1) - (distance p3 p1)) <= 0.001 then 
												(
													edges_eq += #{edge_k, edge_l}
													verts_eq += #{p2,p3}
													equal = true
													print "equal"
												)
												
											)
										)
									)		
								)
								polyOp.setEdgeSelection selmod arr
							
								print arr
								
								if ctrl then 
								(
									max modify mode
									subObjectLevel = 2
								)
								else
								(
									if equal then 
									(	
										
										--selmod.weldEdges edges_eq[1] edges_eq[2]
										pos = polyop.getvert selmod verts_eq[1]
										undo "Remove Overlay Verts" on selmod.weldVerts verts_eq[1] verts_eq[2] pos
									)
									else
										undo "Remove Overlay Edges" on selmod.remove selLevel:#edge
								)
							)
							else --для задвоенных вертексов
							(
								print #(verts_close)
								case verts_close.count of
								(
									1:
									(
										if ctrl then 
										(
											selmod.SetSelection #Vertex verts_close[1]
											subobjectlevel = 1
										)
										else
										(
											pos = polyop.getvert selmod verts_close[1][1]
											undo "Remove Overlay Verts" on selmod.weldVerts verts_close[1][1] verts_close[1][1] pos
										)
									)
									default: 
									(
										all = #{}
										for vw in verts_close do join all vw 
										if ctrl then 
										(
											selmod.SetSelection #Vertex all	
											subobjectlevel = 1
										)
										else
										(
											selmod.weldThreshold = 0.002
											undo "Remove Overlay Verts" on polyop.weldVertsByThreshold selmod all
										)
									)
								)
							)
							
							polyop.setFaceSelection selmod #all
							
							faces = selmod.GetSelection #Face 
							if faces.count > 0 then
							(
								dirs_select = #()
								--print faces
								for f in faces where (polyop.getFaceArea selmod f) <= (edt_tresh.text as float) do
								(
									append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
								)
							)
							PopulateList lv dirs_select faces
							lbl.text = "Selected: " + (faces.numberset as string)
						)
					)
				)

				on ro_count_area open do
				(  
					PopulateList lv dirs_select faces
					lbl.text = "Selected: " + (faces.numberset as string)
					--lbmin.text = ""
					--lbmax.text = ""
					
					for i in ro_count_area.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_rocount_area.ini") i.name "rocount_area" (syssetup.rdo_lang.state))
				)
				
				on lv MouseDown arg do
				(
					if arg.button == arg.button.middle then
					(                
						if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
						(
						)                
					)
					if arg.button == arg.button.right then
					(                
						if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
						(
							val = hitNode.index + 1
							max modify mode
							selmod = modpanel.getcurrentobject()
							if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
							(
								faces_curr = selmod.GetSelection #Face 
								sel_face = dirs_select[val][3] as integer
								polyop.setFaceSelection selmod #{sel_face}
								subObjectLevel = 4
								max zoomext sel all
								max zoomext sel all
							)
						)           
					)
				)

				on btnRightClk pressed do
				(
					sel_face = #{}
					for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected do append sel_face (dirs_select[val+1][3] as integer)
					if sel_face.count > 0 then
					(
						max modify mode
						selmod = modpanel.getcurrentobject()
						if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
						(
							faces_curr = selmod.GetSelection #Face 
							polyop.setFaceSelection selmod sel_face
							subObjectLevel = 4
							max zoomext sel all
							max zoomext sel all
						)
						lbl.text = "Selected: " + (faces.numberset as string)
					)
				)
				
				on btnFilterZero pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					selmod = modpanel.getcurrentobject()
					if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
					(
						faces = selmod.GetSelection #Face 
						if faces.count > 0 then
						(
							--print faces
							for f in faces where (polyop.getFaceArea selmod f) <= (edt_tresh.text as float) do
							(
								append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
							)
						)
						PopulateList lv dirs_select faces
						lbl.text = "Selected: " + (faces.numberset as string)
					)
				)

				on btnFilterAll pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					selmod = modpanel.getcurrentobject()
					if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
					(
						faces = selmod.GetSelection #Face 
						if faces.count > 0 then
						(
							--print faces
							for f in faces do
							(
								append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
							)
						)
					)
					PopulateList lv dirs_select faces
					lbl.text = "Selected: " + faces.numberset as string
				)

				on btnClose pressed do
				(
					try(destroyDialog ::ro_count_area)catch()
				)	
				
			)
			createDialog ro_count_area width:500 height:470 style:#(#style_titlebar, #style_border, #style_sysmenu, #style_resizing)		
		)
		else
		(
			messagebox "Select one EDITABLE POLY object."
		)
	)
	
	on btn_count_area rightclick do
	(
		global dirs_select = #()
		global selmod = modpanel.getcurrentobject()
		global faces
		if selmod != undefined and classof selmod == editable_poly then
		(
			faces = selmod.GetSelection #Face 
			if faces.count > 0 then
			(
				--print faces
				for f in faces do
				(
					append dirs_select ((polyop.getFaceArea selmod f) as string + "  " + f as string)
				)
			)
		)
		
		try(destroyDialog ::ro_count_area)catch()
		rollout ro_count_area "Counts Area of Polygons" width:200 --height:1000
		(
			--progressBar pb13 "ProgressBar" width:950 height:10
			edittext edt "count: " style_sunkenedge:true
			MultiListBox mlbList "polyarea num" items:(dirs_select as array) width:170 height:40 selection:#()
			button btnFilterZero "Zero" across:4
			button btnFilterAll "All"
			button btnDeleteZero "Del"
			button btnClose "Close"
			
			on mlbList rightClick val do 
			(
				selmod = modpanel.getcurrentobject()
				if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
				(
					faces_curr = selmod.GetSelection #Face 
					sel_face = (filterstring dirs_select[val] " ")[(filterstring dirs_select[val] " ").count] as float
					polyop.setFaceSelection selmod #{sel_face}
					subObjectLevel = 4
					max zoomext sel all
					max zoomext sel all
				)
			)
			
			on btnDeleteZero pressed do
			(		
				--delete polygon with zero area
			)
			
			on btnFilterAll pressed do
			(
				dirs_select = #()
				selmod = modpanel.getcurrentobject()
				if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
				(
					faces = selmod.GetSelection #Face 
					if faces.count > 0 then
					(
						--print faces
						for f in faces do
						(
							append dirs_select ((polyop.getFaceArea selmod f) as string + "  " + f as string)
						)
					)
				)
				mlbList.items = dirs_select as array
				edt.text = (dirs_select as array).count as string
			)
			
			on btnFilterZero pressed do
			(
				dirs_select = #()
				selmod = modpanel.getcurrentobject()
				if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
				(
					faces = selmod.GetSelection #Face 
					if faces.count > 0 then
					(
						--print faces
						for f in faces where (polyop.getFaceArea selmod f) < 0.000001 do
						(
							append dirs_select ((polyop.getFaceArea selmod f) as string + "  " + f as string)
						)
					)
				)
				mlbList.items = dirs_select as array	
				edt.text = (dirs_select as array).count as string				
			)
			
			on btnClose pressed do
			(
				try(destroyDialog ::ro_count_area)catch()
			)
		) --rollout
		createDialog ro_count_area style:#(#style_sunkenedge,#style_titlebar,#style_sysmenu,#style_minimizebox,#style_maximizebox)		
	)	
	
	on btn_count_texel pressed do
	(
		gc()
		if selection.count == 1 then
		(
			if (classof selection[1] == editable_poly and selection[1].modifiers.count == 0) or (classof selection[1].modifiers[1] == Unwrap_UVW and classof selection[1].baseobject == editable_poly and selection[1].modifiers.count > 0) then () else messagebox "Selected object is not an EDITABLE POLY!"
			max modify mode
			xViewChecker.on = false
			global dirs_select = #()
			global theMapSize = 2048 
			global textureArea = theMapSize^2 -- Calculate the total texture area
			global unwrapmod = modpanel.getcurrentobject()
			global faces = #{} --#()
			global last_pressed = "All"
			global selected_from = 0
			global mouse_down = 0
			global scroll_down = 0
			
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(
				faces = unwrapmod.getselectedfaces()
				/*
				if faces.count > 0 then
				(
					unwrapmod.setPolygonMode true
					unwrapmod.setTVSubObjectMode 3				
					--print faces
					for f in faces where not keyboard.escPressed do
					(
						--unwrapmod.selectFaces #{f}
						--unwrapmod.polygonSelect() 
						unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
						usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
						texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
						--print texelDensity
						append dirs_select #(texelDensity as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
					)
					--unwrapmod.selectFaces faces
					--unwrapmod.polygonSelect() 
				)
				*/
			)

			try(destroyDialog ::rocount_texel)catch()
			rollout rocount_texel "Counts texels density in UDIMS" 
			(
				fn defColor r g b = ((dotNetClass "System.Drawing.Color").FromArgb r g b)
				
				local maxBC = defColor 50 50 50
				local maxFC = defColor 200 200 200
				
				fn autoResizeColumn lv columns: = 
				(
					vScrollWidth = 21 -- vertical scrollbar width
					for c = 0 to columns-1 do
					(
						lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
						vScrollWidth += lv.Columns.Item[c].Width
					) 
					vScrollWidth
				)
				
				fn compileListItemSorter =
				(
					source =  "using System;\n"
					source += "using System.Windows.Forms;\n"
					source += "using System.Collections;\n"
					source += "class ListViewItemComparer : IComparer\n"
					source += "{\n"
					source += "    private int c;\n"
					source += "    private bool num = false;\n"
					source += "    private int dir = 1;\n"
					source += "    public ListViewItemComparer() { c = 0; }\n"
					source += "    public ListViewItemComparer(int column, bool numeric, bool reverse)\n"
					source += "    { c = column; num = numeric; dir = reverse ? -1 : 1; }\n"
					source += "    public int Compare(object x, object y)\n"
					source += "    {\n"
					source += "        if (num) return Convert.ToInt32(((ListViewItem)x).SubItems[c].Text).CompareTo(\n"
					source += "            Convert.ToInt32(((ListViewItem)y).SubItems[c].Text)) * dir;\n"
					source += "        else return String.Compare(((ListViewItem)x).SubItems[c].Text,\n"
					source += "            ((ListViewItem)y).SubItems[c].Text) * dir;\n"
					source += "    }\n"
					source += "}"
				 
					local csharpProvider = dotNetObject "Microsoft.CSharp.CSharpCodeProvider"
					local compilerParams = dotNetObject "System.CodeDom.Compiler.CompilerParameters"
					compilerParams.GenerateInMemory = true
					compilerParams.ReferencedAssemblies.Add("System.Windows.Forms.dll")
					compilerResults = csharpProvider.CompileAssemblyFromSource compilerParams #(source)
					compilerResults.CompiledAssembly
				)
				
				fn qsort_csv arr1 arr2 = 
				(
					case of 
					(
						(arr1[1] as float < arr2[1] as float): -1
						(arr1[1] as float > arr2[1] as float): 1
						default:0
					)
				)

				fn qsort_csv3 arr1 arr2 = 
				(
					case of 
					(
						(arr1[3] as float < arr2[3] as float): -1
						(arr1[3] as float > arr2[3] as float): 1
						default:0
					)
				)
				
				fn PopulateList lv dirs_select =
				(
					/*
					Me.lvBlah.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
					Me.lvBlah.CheckBoxes = True
					Me.lvBlah.Columns.AddRange(New System.Windows.Forms.ColumnHeader() {Me.colNum, Me.colStatic, Me.colKinetic})
					Me.lvBlah.Font = New System.Drawing.Font("Courier New", 8.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
					Me.lvBlah.FullRowSelect = True
					Me.lvBlah.GridLines = True
					Me.lvBlah.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable
					Me.lvBlah.HideSelection = False
					Me.lvBlah.Location = New System.Drawing.Point(21, 285)
					Me.lvBlah.Name = "lvBlah"
					Me.lvBlah.ShowGroups = False
					Me.lvBlah.Size = New System.Drawing.Size(346, 205)
					Me.lvBlah.TabIndex = 13
					Me.lvBlah.UseCompatibleStateImageBehavior = False
					Me.lvBlah.View = System.Windows.Forms.View.Details
					*/
					
					try (qsort dirs_select qsort_csv)catch()
					
					lv.Items.Clear()
					lv.view = (dotNetClass "system.windows.forms.view").details --lv.view = (dotNetClass "View").details
					lv.HideSelection = true 
					lv.HeaderStyle = (dotNetClass "System.Windows.Forms.ColumnHeaderStyle").clickable
					--lv.Font = dotNetObject "System.Drawing.Font" "Tahoma" 18 (dotNetClass "System.Drawing.FontStyle").Regular (dotNetClass "System.Drawing.GraphicsUnit").Pixel
					--lv.backcolor = maxBC 
					--lv.forecolor = maxFC
					--lv.height = 390
					lv.FullRowSelect = true    
					lv.MultiSelect = false --true    
					lv.AllowColumnReorder = true
					lv.GridLines = true
					lv.checkBoxes = true 
					lv.Scrollable = true
					lv.ShowItemToolTips = true
					--for i = 0 to lv.Items.count-1 do lv.Items.Item[i].checked = true
					columnsAr = #("Density           ", "UDIM  ", "ID    ", "Area Geometry  ", "Area UV          ", ("Number Of " + dirs_select.count as string))
					lv.columns.Clear()
					for i = 1 to 6 do lv.columns.add columnsAr[i] 0	
					lv.width = autoResizeColumn lv columns:6
					lv.width = 440
					--lv.Update()
					rows = #()
					for t = 1 to dirs_select.count do
					(
						li = dotNetObject "System.Windows.Forms.ListViewItem" (dirs_select[t][1])
						li.UseItemStyleForSubItems = true
						--полосатость списка
						--colAdd = 240 + (if (mod t 2) == 0 then 10 else -10)
						--li.BackColor = li.backcolor.fromARGB colAdd colAdd colAdd
						try 
						(
							if dirs_select[t][5] as float <= 0.000001 then li.forecolor = li.forecolor.fromARGB 0 0 200								
							if dirs_select[t][4] as float <= 0.00001 then li.forecolor = li.forecolor.fromARGB 0 200 0							
							if dirs_select[t][1] as float <= 0.1 then li.forecolor = li.forecolor.fromARGB 200 0 0
						)catch()
						li.subitems.add dirs_select[t][2]
						li.subitems.add dirs_select[t][3]
						li.subitems.add dirs_select[t][4]
						li.subitems.add dirs_select[t][5]
						li.subitems.add dirs_select[t][6]
						append rows li
					)
					lv.items.addRange rows
					--lv.Update()
					--lv.width = autoResizeColumn lv columns:6
					--lv.width = 440
					lv.Update()
				)
				
				dotNetControl lv "ListView" pos:[5,5] width:440 height:300
				label lbmin "" pos:[470,20]
				label lbmax "" pos:[470,290]
				
				group "View items" --grp1 "" width:480 height:35 
				(
					label itm "Texture Dims" across:6 offset:[0, 0]
					dropdownlist dl_tex_dim "" items:#("256", "512", "1024", "2048", "4096") selection:4 width:60 fieldWidth:60 offset:[0, 0]
					button btnSelect "View Checked" offset:[0, 0] tooltip:"Просмотр отмеченных галками элементов в окне проекций | View checked items in viewport"
					button btnRightClk "View RMB" offset:[0, 0] tooltip:"Просмотр отдельного элемента в окне проекций (аналогично нажатию ПКМ) | View rightclicked single item in viewport"
					button btnSelectAll "Check All" offset:[0, 0] tooltip:"Отметить галками все элементы в списке | Check all items in list"
					button btnDeselectAll "Uncheck All" offset:[0, 0] tooltip:"Снять галки у всех элементов в списке | Uncheck all items in list"
				)
				group "Filter items"
				(
					button btnFilterZero "Bad Zero" across:5 align:#left offset:[0,0] tooltip:"Показать из выделенных текселей только те, что с площадью = 0 или близкой к 0 | Show selected texels with area = 0 or near 0" 
					button btnFilterBadLP "Bad LowPoly" offset:[-20,0] tooltip:"Показать из выделенных текселей только те, которые не входят в интервал [10 >= плотность >= 40], актуально только для НПМ Ground модели! | Show selected texels that do not enter interval\n[10 >= density >= 40],\nactual only for Lowpoly Ground model!"
					button btnFilterBadHP "Bad HighPoly" offset:[-20,0] tooltip:"Показать из выделенных текселей только те, которые не входят в интервал [512 >= плотность >= 1706], актуально для ВПМ моделей с текстурами | Show selected texels that do not enter interval\n[512 >= density >= 1706],\nactual for Highpoly models with textures"
					button btnFilterBadHPMat "Bad HighPoly by Mat" offset:[0,0] tooltip:"Экспериментальное! Показать из выделенных текселей только те, которые не входят в интервал\n[512 >= плотность >= 1706], и только для размера текстуры, превышающего 256х256 пикселей в заданном материале, актуально для ВПМ моделей с текстурами | Experimental! Show selected texels that do not enter interval\n[512 >= density >= 1706],\nand only for texture size bigger than 256 in assigned material, actual for Highpoly models with textures"
					button btnFilterAll "All \ Refresh" offset:[0,0] align:#right tooltip:"Показать плотности текселей для ВСЕХ выбранных текселей | Show texels density for ALL selected texels"
				)
				group "Set texels density"
				(
					spinner spn_target_density "Target Density" range:[0.001, 10000.0, 1380.0] across:4 width:60 fieldWidth:60 align:#left offset:[0,0] tooltip:"Рекомендуемые диапазоны плотности текселя для ВПМ [512 >= плотность >= 1706], для НПМ Ground [10 >= плотность >= 40] | Recomended texel density ranges\nfor Highpoly [512 >= density >= 1706]\nfor Lowpoly Ground [10 >= density >= 40]"
					checkbox chk_clean_memory "Conserve memory" checked:false offset:[30,0] tooltip:"Экономить память, работает медленнее, но использует меньше памяти и, как правило, без отмены действий | Conserve memory, slower but uses less memory, and usually with no undo"
					button btnReFlatten "ReFlatten checked" offset:[30,0] tooltip:"Переразвернуть развертку у отмеченных галкой элементов | Re Unwrap as flatten checked items"
					button btnRepairAll	"Repair All" align:#right offset:[0,0] tooltip:""	
					button btnSetAll "Set Density checked" across:2 align:#left offset:[0,0] tooltip:"Установить плотность текселей в указанное значение | Set texels density to specified value"
					radiobuttons rdo labels:#("scale by island by enumeration", "scale individual", "scale whole", "scale by island by average", "scale individual with break") default:1 columns:3 rows:2 offset:[-120,0] offsets:#([0,0], [0,0], [-60,0], [0,0], [0,0]) align:#left tooltip:"Scale by island by enumeration - Масштабирование по островам путем перечисления: попробовать выбрать элемент каждого отмеченного текселя, масштаб рассчитывается по очереди для каждого выбранного текселя (не для среднего значения по группе текселей на острове), плотность других текселей на островах может быть разной\nScale by island by average - масштабирование по островам по среднему значению : попробовать выбрать элемент каждого отмеченного текселя, масштабировать на среднее значение для группы текселей на острове, плотность всех текселей на островах может быть неодинаковой\nScale individual - Масштабировать индивидуально: может влиять на положение соседних текселей, они могут быть не разбиты и сместиться при перемасштабировании\nScale individual with break - Масштабировать индивидуально с разрывом: разбивает выбранный тексель перед изменением масштаба, не влияет на соседние тексели\nScale whole - масштабирование текселей целиком: приведение всех выбранных текселей к средней плотности | Scale by island by enumeration: try to select element of each checked texel, scale computes from selected texel (not for average of group of texels in island), other texels density in islands may be not equal\n\nScale by island by average: try to select element of each checked texel, scale computes for average of group of texels in island, all texels density in islands may be not equal\n\nScale individual: can influence on positions of neighbour texels, they are may be not breaked\n\nScale individual with break: breaks selected texel before rescale to density, do not influence on neighbour texels\n\nScale whole: Manage all selected texels to average density"
				)	
				group "Selection in UVW Editor"
				(
					button btnSelectionAll "Select All" across:6 tooltip:"Выделить все тексели объекта | Select all texels of object"
					button btnSelectID "Select by ID" tooltip:"Выбрать тексели с ID объекта | Select texels with current ID of object"
					spinner spn_ID "ID" range:[0, 10000, 1] type:#integer offset:[-20,0] tooltip:"ID объекта | ID of object"
					button btnSelectUDIM "Select by UDIM" tooltip:"РАБОТАЕТ МНОГО ВРЕМЕНИ, ИСПОЛЬЗУЙТЕ КЛАВИШУ ESC!\nВыбрать тексели (по островам) только для текущего UDIM | WORKING A LOT OF TIME, USE ESC!\nSelect texels (by islands) only in current UDIM"
					spinner spn_UDIM "UDIM" range:[1001, 1100, 1001] type:#integer width:60 fieldWidth:40 offset:[30,0] tooltip:"UDIM объекта | UDIM of object"	
					button btnOpenEditor "Editor" align: #right tooltip:"Открыть UVW редактор развертки | Open UVW Editor"
				)
				--dotnetcontrol Slider "System.Windows.Forms.TrackBar" width:400 height:100 pos:[5,550] 
				label lbl "Selected:" width:150 align:#left across:5 style_sunkenedge:true
				button btn_Unhide_all "Unhide all" offset:[50,0] tooltip:"Отобразить все скрытые части объекта | Unhide all parts of object"
				button btn_ShowDensity "Show Density" offset:[50,0] tooltip:"Отобразить плотности в цветах на видовых проекциях с использованием VertexColor | Show densities in viewports with colors using VertexColor"
				button btn_UnShow "UnShow" offset:[50,0] tooltip:"Отключить отображение плотностей | Toggle off showing densities"
				button btnClose "Close" align: #right tooltip:"Закрыть это диалоговое окно | Close this dialog"
				
				/*
				on Slider MouseDown do
				(
				)
 
				on Slider MouseUp do
				(
				)
 
				on Slider ValueChanged val do
				( 
					--print val
					--this.trackBar1.Location = new System.Drawing.Point(40, 104);
					--this.trackBar1.Maximum = 100;
					--this.trackBar1.Name = "trackBar1";
					--this.trackBar1.Size = new System.Drawing.Size(224, 42);
					--this.trackBar1.TabIndex = 0;
					--this.trackBar1.TickFrequency = 5;
					--this.trackBar1.Scroll +=
					--new System.EventHandler(this.trackBar1_Scroll);
				)
				*/
				
				on rocount_texel open do
				(  
					gc()
					PopulateList lv dirs_select 
					--for i = 0 to lv.Items.count-1 do lv.Items.Item[i].selected = true
					--lv.SelectedIndices --: <System.Windows.Forms.ListView+SelectedIndexCollection>, read-only
					--lv.SelectedItems --: <System.Windows.Forms.ListView+SelectedListViewItemCollection>, read-only
					--lv.Alignment : <System.Windows.Forms.ListViewAlignment>	
					--showproperties lv --.Columns[0].Width = -1	
					lbmin.text = ""
					lbmax.text = ""
					lbl.text = "Selected: " + (faces.numberset as string)
					
					for i in rocount_texel.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_rocount_texel.ini") i.name "rocount_texel" (syssetup.rdo_lang.state))

				)
				
				on lv columnClick columnHeader do
				(
					lv.ListViewItemSorter = dotnetobject "MXS_dotNet.ListViewItemComparer" columnHeader.column
					lv.ListViewItemSorter = undefined
					
					--if dirs_select.count > 0 then lbmin.text = lv.Items.Item[0] 
					--if dirs_select.count > 0 then lbmax.text = lv.Items.Item[lv.Items.count-1] 
					--print columnHeader.column
				)
				
				on lv MouseUp arg do
				(
					scroll_down = false
					if arg.button == arg.button.left then
					(                
						if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
						(
							val = hitNode.index --+ 1
							if mouse_down != val then
							(
								st = if mouse_down < val then 1 else -1
								for vv = mouse_down to val by st where vv != mouse_down do 
								(
									lv.Items.Item[vv].checked = not lv.Items.Item[vv].checked
									lv.Items.Item[vv].Focused = true
									lv.Items.Item[vv].selected = true
								)
							)	
							--print selected_from
						)   
					)	
				)
		/*		
				on lv MouseHover arg do 
				(
					--print "MouseHover"
					--ScrollToBottom 
					--listView.setSelection (int position) --Если вы хотите перейти прямо к нужной позиции в списке, просто используйте
					--listView.smoothScrollToPosition (int position) --и если вы хотите плавно перейти к нужной позиции в listView, просто используйте
				)
				
				on lv MouseLeave arg do 
				(
					scroll_down = false
					--print "MouseLeave"
				)
		*/		
				on lv MouseDown arg do
				(
					shift = false
					mouse_down = 0
					scroll_down = true
					if keyboard.shiftPressed then shift = not shift
					if arg.button == arg.button.left then
					(                
						if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
						(
							val = hitNode.index --+ 1
							lv.Items.Item[val].checked = true
							--showproperties lv.Items.Item[val]
							lv.Items.Item[val].Focused = true
							lv.Items.Item[val].selected = true
							--lv.Items.Item[val].BackColor = lv.Items.Item[val].BackColor.fromARGB 200 200 200
							mouse_down = val
							if not shift then selected_from = val
							if shift then 
							(
								st = if selected_from < val then 1 else -1
								for vv = selected_from to val by st do
								(
									lv.Items.Item[vv].checked = true --not lv.Items.Item[vv].checked
									/*	
									--local selColor = (dotNetClass "System.Drawing.Color").fromARGB 238 204 85 -- custom selection color (orangey-yellow)
									--local lvBackColor = selColor.fromARGB 225 225 225
									--arg.Item.BackColor = if arg.isSelected then selColor else lvBackColor
										
									--lv.Items.Item[vv].BackColor = lv.Items.Item[vv].BackColor.fromARGB 100 100 100
									
										dnListView.OwnerDraw = true

										local selColor = (dotNetClass “System.Drawing.Color”).fromARGB 238 204 85 – custom selection color (orangey-yellow)
										local lvBackColor = selColor.fromARGB 225 225 225

										on dnListView ItemSelectionChanged arg do
										(
											arg.Item.BackColor = if arg.isSelected then selColor else lvBackColor
										)

										on dnListView drawitem arg do
										(
											arg.DrawBackground()
											arg.DrawText()
										)
									*/
								)
							)	
							--print selected_from
						)                
					)
					if arg.button == arg.button.middle then
					(                
						if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
						(
							val = hitNode.index --+ 1
							lv.Items.Item[val].checked = true
							if not shift then selected_from = val
							if shift then 
							(
								st = if selected_from < val then 1 else -1
								for vv = selected_from to val by st do lv.Items.Item[vv].checked = false --not lv.Items.Item[vv].checked
							)	
							--print selected_from							
						)                
					)
					if arg.button == arg.button.right then
					(                
						if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
						(
							val = hitNode.index + 1
							max modify mode
							unwrapmod = modpanel.getcurrentobject()
							if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
							(
								sel_face = dirs_select[val][6] as integer
								unwrapmod.selectFaces #{sel_face}
								unwrapmod.setPolygonMode true
								unwrapmod.polygonSelect() 
								max zoomext sel all
								max zoomext sel all
							)
						)                
					)
				)
				
				on btnRepairAll pressed do with undo "Repair Poly" on --мод meshcleaner()
				(
					if selection.count == 1 then
					(
						max modify mode
						selmod = modpanel.getcurrentobject()
						if (selection.count == 1 and classof selection[1] != Editable_Poly) or (selection.count == 1 and classof selection[1] != Editable_Poly and selection[1].modifiers.count != 0) then converttopoly selection[1]
						addmodifier selection[1] (meshcleaner())
						selmod = modpanel.getcurrentobject()
						selmod.ValidateMesh()
	
						--print (curMaxVersion = ((maxversion())[1] / 1000) - 2 + 2000)
						local curMaxVersion = ((maxversion())[1] / 1000) - 2 + 2000	
						if curMaxVersion == 2024 then
						(
							selmod.repairHoles = true
							selmod.repairNonManifold = true
							selmod.repairSelfIntersections = true
						)
						if curMaxVersion >= 2025 then
						(
							selmod.repairHoles = true
							selmod.repairNonManifold = true
							selmod.repairSelfIntersections = true
							selmod.repairZeroAreaUVs = true	
							selmod.repairNonPlanarFaces = true
							selmod.repairIsolatedVertices = true
						)
						selmod.RepairMesh()
						converttopoly selection[1]
						addmodifier selection[1] (Unwrap_UVW())
							
						/*
							showinterfaces selmod
							showproperties selmod
							
						max 2025	
						.numDegenerateEdges : integer
						.numDegenerateFaces : integer
						.repairHoles : boolean
						.numHoles : integer
						.repairNonManifold : boolean
						.numNonManifold : integer
						.repairSelfIntersections : boolean
						.numSelfIntersections : integer
						.numZeroAreaUVs : integer
						.repairZeroAreaUVs : boolean
						.numNonPlanarFaces : integer
						.repairNonPlanarFaces : boolean
						.numIsolatedVertices : integer
						.repairIsolatedVertices : boolean
						.validationRan : boolean	
							
						max 2024	
						.numDegenerateEdges : integer
						.numDegenerateFaces : integer
						.repairHoles : boolean
						.numHoles : integer
						.repairNonManifold : boolean
						.numNonManifold : integer
						.repairSelfIntersections : boolean
						.numSelfIntersections : integer
						.validationRan : boolean
						*/

					)
				)
				
				on btn_ShowDensity pressed do
				(
					max modify mode
					color_face = #()
					
					unwrapmod = modpanel.getcurrentobject()
					sel = selection[1]
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						if lv.Items.count > 0 then 
						(
							convertToPoly sel

							p_zero = #{}
							p_low = #{}
							p_norm = #{}
							p_high = #{}
							
							for val = 0 to lv.Items.count-1 do 
							(
								p = (dirs_select[val+1][1] as float)
								case of
								(
									(p <= 1): p_zero += #{(dirs_select[val+1][6] as integer)}
									(p > 1 and p < 512): p_low += #{(dirs_select[val+1][6] as integer)}
									(p >= 512 and p < 1706): p_norm += #{(dirs_select[val+1][6] as integer)}
									(p >= 1706): p_high += #{(dirs_select[val+1][6] as integer)}
								)
							)
							
							/*
							fn color_density_HP p = 
							(
								local col = color 128 128 128
								col = case of
								(
									(p <= 1): (color 255 0 0)
									(p > 1 and p < 512): (color 255 64 64) --(color ((255 * ( p / (512 * 2) )) as integer + 128) 128 128)
									(p >= 512 and p < 1706): (color 0 255 0) --(color 128 ((255 * p / (1194 * 2)) as integer) 128)
									(p >= 1706): color 0 0 255 --(color 128 128 ((255 / (p - 1705) as integer)))
								)
								--print p
								--print col
								col
							)
							*/
							
							polyop.SetFaceColor sel 0 p_zero (color 255 0 0) 
							polyop.SetFaceColor sel 0 p_low (color 255 64 64)
							polyop.SetFaceColor sel 0 p_norm (color 0 255 0) 
							polyop.SetFaceColor sel 0 p_high (color 0 0 255) 
							
							addmodifier selection[1] (vertexpaint lightingModel:1 useMaps:true colorBy:0 mapChannel:0)

							menu = for i in (UIAccessor.GetChildWindows (DialogMonitorOPS.GetWindowHandle())) where (UIAccessor.GetWindowText i == "VertexPaint") do exit with i
							buttons = windows.getChildrenHWND menu
							UIAccessor.pressButton ((buttons[3])[1]) --вкл	
							--UIAccessor.pressButton ((buttons[2])[1]) --выкл

							convertToPoly selection[1]
							addmodifier selection[1] (Unwrap_UVW ())	
								
							--$.SetFaceColor (color 255 255 255) #VertexColor --Channel enums: {#VertexColor|#Illumination|#Alpha}	
							--select selection[1]
							--max modify mode
							--modPanel.addModToSelection (Unwrap_UVW ()) ui:on --
							--unwrapmod = modpanel.getcurrentobject()
							--unwrapmod.unwrap4.setThickOpenEdges off 
							--unwrapmod.unwrap5.setShowMapSeams off
							--unwrapmod = modpanel.getcurrentobject()
							--unwrapmod.setPeltAlwaysShowSeams = false
							--unwrapmod.setThickOpenEdges	= false
						)		
					)	
				)

				
				on btn_UnShow pressed do
				(
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						converttopoly selection[1] 
						polyop.SetFaceColor selection[1] 0 #all white
						addmodifier selection[1] (vertexpaint lightingModel:3 useMaps:true colorBy:0 mapChannel:0)
						
						menu = for i in (UIAccessor.GetChildWindows (DialogMonitorOPS.GetWindowHandle())) where (UIAccessor.GetWindowText i == "VertexPaint") do exit with i
						buttons = windows.getChildrenHWND menu
						--UIAccessor.pressButton ((buttons[3])[1]) --вкл	
						UIAccessor.pressButton ((buttons[2])[1]) --выкл
							
						converttopoly selection[1] 
						addmodifier selection[1] (Unwrap_UVW())
						--unwrapmod = modpanel.getcurrentobject()
						--selection[1].modifiers[1].setPeltAlwaysShowSeams = false
						--selection[1].modifiers[1].setThickOpenEdges	= false						
					)	
				)
				
				on btn_Unhide_all pressed do
				(
					sel = selection as array
					for i in sel do 
					(
						select i
						max modify mode
						collapseStack i						
						--subObjectLevel = 1
						i.unhideAll #Vertex
						i.unhideAll #Face						
						--subObjectLevel = 0
						unwrapmod = modpanel.getcurrentobject()
						if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
						(
							if validModifier i (Unwrap_UVW()) then addmodifier i (Unwrap_UVW())
							unwrapmod = modpanel.getcurrentobject()
						)
						if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
						(						
							unwrapmod.unhide() 
						)
					)
					select sel	
				)
				
				on btnReFlatten pressed do
				(
					max modify mode
					sel_face = #{}
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						ini_sel_face = #{}
						ini_sel_face = unwrapmod.getselectedfaces()
						sel_face = #{} 
						for val = 0 to lv.Items.count-1 where lv.Items.Item[val].checked do append sel_face (dirs_select[val+1][6] as integer)
						if sel_face.count > 0 then
						(
							unwrapmod.setTVSubObjectMode 3
							unwrapmod.setPolygonMode true
							for f in sel_face where not keyboard.escPressed do
							(
								unwrapmod.selectFaces #{f}
								unwrapmod.setPolygonMode true
								unwrapmod.polygonSelect() 	

								if rdo.state == 1 then unwrapmod.selectElement()
								if rdo.state == 3 then unwrapmod.breakSelected()
								faces = unwrapmod.getselectedfaces()
	
								if faces.count > 0 then
								(							
									pos = unwrapmod.getSelCenter()
									unwrapmod.unfoldMapNoParams() --unwrapmod.unfoldMap 1
									pos2 = unwrapmod.getSelCenter()
									unwrapmod.moveSelected (pos - pos2)
								)
							)
							unwrapmod.setPolygonMode true
							unwrapmod.selectFaces ini_sel_face
							unwrapmod.setPolygonMode true
							unwrapmod.polygonSelect() 		
							
							dirs_select = #()					
							faces = unwrapmod.getselectedfaces()
							if faces.count > 0 then
							(
								for f in faces where not keyboard.escPressed do
								(
									unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
									usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
									texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
									--print texelDensity
									id = (mX as integer) + 1 + 10 * (mY as integer)
									UDIM = id + 1000
									append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
								)
							)		
							PopulateList lv dirs_select
							lbl.text = "Selected: " + (sel_face.numberset as string)
							for val = 0 to lv.Items.count-1 where (for s in sel_face where s == (dirs_select[val+1][6] as integer) collect s).count > 0 do lv.Items.Item[val].checked = true
							if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
							if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""
						)
					)					
				)
				
				on btnSelectUDIM pressed do with undo off
				(
					local ctrl = keyboard.controlPressed
					if ctrl then
					(
						max modify mode
						local sel_face = #{}
						local udim = spn_UDIM.value
						unwrapmod = modpanel.getcurrentobject()
						if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
						(
							addmodifier selection[1] (Unwrap_UVW())
							unwrapmod = modpanel.getcurrentobject()
						)
						if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
						(
							local selected_face = unwrapmod.getselectedfaces()
							unwrapmod.setPolygonMode true
							unwrapmod.setTVSubObjectMode 3
							unwrapmod.unhide() 
							local arr = if selected_face.isempty then #{1..unwrapmod.numberPolygons()} else selected_face
							while not arr.isempty do 
							(
								if keyboard.escpressed then exit with sel_face
								local mX, mY, mWidth, mHeight, mAreaUVW, mAreaGeom
								for i in arr do (unwrapmod.selectFaces #{i}; exit)
								unwrapmod.selectElement()
								ff = unwrapmod.getselectedfaces()
								--local pos = unwrapmod.getSelCenter()
								unwrapmod.getarea ff &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
								local y = ((udim - 1001)/10) as integer
								local x = (mod ((udim - 1001) as integer) 10) as integer
								if mX >= x and mX <= (x+1) and mY >= y and mY <= (y+1) then join sel_face ff
								arr -= ff
							)
							unwrapmod.selectFaces sel_face
							unwrapmod.polygonSelect()
							sel_face = unwrapmod.getselectedfaces()
							lbl.text = "Selected: " + (sel_face.numberset as string)
						)
					)
					else
					(
						max modify mode
						local udim = spn_UDIM.value
						local sel_face = #{}
						unwrapmod = modpanel.getcurrentobject()
						if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
						(
							addmodifier selection[1] (Unwrap_UVW())
							unwrapmod = modpanel.getcurrentobject()
						)
						if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
						(
							unwrapmod.setPolygonMode true
							unwrapmod.setTVSubObjectMode 3
							unwrapmod.unhide() 
							local arr = #{1..unwrapmod.numberPolygons()}
							local qq = #{}
							while not arr.isempty do 
							(
								if keyboard.escpressed then exit with sel_face
								for i in arr do (unwrapmod.selectFaces #{i}; exit)
								unwrapmod.selectElement()
								qq = unwrapmod.getselectedfaces()
								arr -= qq
								local pos = unwrapmod.getSelCenter()
								local y = ((udim - 1001)/10) as integer
								local x = (mod ((udim - 1001) as integer) 10) as integer
								if pos.x >= x and pos.x <= (x+1) and pos.y >= y and pos.y <= (y+1) then --if pos.x as integer == x and (pos.y/10) as integer == y then join sel_face qq	
								(
									join sel_face qq	 
									--format "x=% y=% pos=%\n" x y pos
									--print arr.numberset
								)								
							)
							unwrapmod.selectFaces sel_face
							unwrapmod.polygonSelect()
							--btnFilterAll.pressed()
							sel_face = unwrapmod.getselectedfaces()
							lbl.text = "Selected: " + (sel_face.numberset as string)
						)
					)
				)					
				
				on btnSelectID pressed do with undo off
				(
					max modify mode
					sel_face = #{}
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						unwrapmod.setPolygonMode true
						unwrapmod.setTVSubObjectMode 3
						unwrapmod.unhide() 
						unwrapmod.selectByMatID spn_ID.value
						unwrapmod.polygonSelect()
						--btnFilterAll.pressed()
						sel_face = unwrapmod.getselectedfaces()
						lbl.text = "Selected: " + (sel_face.numberset as string)
					)			
				)
				
				on btnSelectionAll pressed do
				(
					max modify mode
					sel_face = #{}
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						unwrapmod.setPolygonMode true
						unwrapmod.setTVSubObjectMode 3
						unwrapmod.unhide() 
						unwrapmod.selectFaces #{1..unwrapmod.numberPolygons()}
						unwrapmod.polygonSelect()
						--btnFilterAll.pressed()
						sel_face = unwrapmod.getselectedfaces()
						lbl.text = "Selected: " + (sel_face.numberset as string)
					)			
				)
				
				on btnSetAll pressed do with undo "Set Density" on
				(
					if chk_clean_memory.checked then gc()
					theMapSize = case (dl_tex_dim.selection as integer) of
					(
						1: 256
						2: 512
						3: 1024
						4: 2048
						5: 4096
					)
					textureArea = theMapSize^2
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						ini_sel_face = #{}
						ini_sel_face = unwrapmod.getselectedfaces()
						sel_face = #{} 
						for val = 0 to lv.Items.count-1 where lv.Items.Item[val].checked do append sel_face (dirs_select[val+1][6] as integer)
						if sel_face.count > 0 then
						(
							unwrapmod.setTVSubObjectMode 3
							unwrapmod.setPolygonMode true
												
							--1 "scale by island by enumeration", 
							--2 "scale individual"
							--3 "scale whole"
							--4 "scale by island by average"
							--5 "scale individual with break"
							case rdo.state of
							(
								1: --"scale by island by enumeration"
								(
									for f in sel_face where not keyboard.escPressed do
									(
										unwrapmod.selectFaces #{f}
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea 
										if mAreaGeom == 0.0 then continue
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) 
										unwrapmod.selectElement()
										faces = unwrapmod.getselectedfaces()
										if faces.count > 0 and texelDensity > 0.0 then unwrapmod.scaleSelectedCenter (spn_target_density.value * (GetMetersFromGU()) / texelDensity) 0
										if chk_clean_memory.checked then gc()
									)
								)
								
								3: --"scale whole"
								(
									unwrapmod.selectFaces sel_face
									--unwrapmod.setPolygonMode true
									--unwrapmod.polygonSelect() 	
									unwrapmod.getarea sel_face &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
									usedAreaPixels = mAreaUVW * textureArea 
									if mAreaGeom != 0.0 then
									(									
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) 
										faces = unwrapmod.getselectedfaces()
										if faces.count > 0 and texelDensity > 0.0 then unwrapmod.scaleSelectedCenter (spn_target_density.value * (GetMetersFromGU()) / texelDensity) 0
									)
									if chk_clean_memory.checked then gc()
								)
								
								4: --"scale by island by average"
								(
									current_faces = sel_face
									while current_faces.numberset != 0 do
									(
										if keyboard.escpressed then exit 
										for p in current_faces do (unwrapmod.selectFaces #{p}; exit)
										unwrapmod.selectElement()
										faces = unwrapmod.getselectedfaces()
										unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea 
										if mAreaGeom != 0.0 then 
										(
											texelDensity = sqrt (usedAreaPixels/mAreaGeom) 
											faces = unwrapmod.getselectedfaces()
											if faces.count > 0 and texelDensity > 0.0 then unwrapmod.scaleSelectedCenter (spn_target_density.value * (GetMetersFromGU()) / texelDensity) 0
										)
										current_faces -= faces
										if chk_clean_memory.checked then gc()
									)									
								)
								
								5: --"scale individual with break"
								(
									for f in sel_face where not keyboard.escPressed do
									(
										unwrapmod.selectFaces #{f}
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea
										if mAreaGeom == 0.0 then continue
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) 	
										unwrapmod.polygonSelect()
										unwrapmod.breakSelected()
										faces = unwrapmod.getselectedfaces()
										if faces.count > 0 and texelDensity > 0.0 then unwrapmod.scaleSelectedCenter (spn_target_density.value * (GetMetersFromGU()) / texelDensity) 0
										if chk_clean_memory.checked then gc()
									)									
								)
								
								2: --"scale individual"
								(
									for f in sel_face where not keyboard.escPressed do
									(
										unwrapmod.selectFaces #{f}
										--unwrapmod.setPolygonMode true
										--unwrapmod.polygonSelect() 	
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea
										if mAreaGeom == 0.0 then continue
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) 
										--unwrapmod.selectFacesByNode #{p} selection[1]
										--if rdo.state == 1 then unwrapmod.selectElement()
										--if rdo.state == 3 then unwrapmod.breakSelected()
										faces = unwrapmod.getselectedfaces()
										if faces.count > 0 and texelDensity > 0.0 then unwrapmod.scaleSelectedCenter ((spn_target_density.value as float) * (GetMetersFromGU()) / texelDensity) 0
										if chk_clean_memory.checked then gc()
									)
								)
							)
							
							unwrapmod.setPolygonMode true
							unwrapmod.selectFaces ini_sel_face
							unwrapmod.setPolygonMode true
							unwrapmod.polygonSelect() 		
							
							dirs_select = #()					
							faces = unwrapmod.getselectedfaces()
							if faces.count > 0 then
							(
								for f in faces where not keyboard.escPressed do
								(
									unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
									usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
									if mAreaGeom == 0.0 then texelDensity = 0.0
									else texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
									--print texelDensity
									id = (mX as integer) + 1 + 10 * (mY as integer)
									UDIM = id + 1000
									append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
								)
							)		
							PopulateList lv dirs_select
							lbl.text = "Selected: " + (faces.numberset as string)
							for val = 0 to lv.Items.count-1 where (for s in sel_face where s == (dirs_select[val+1][6] as integer) collect s).count > 0 do lv.Items.Item[val].checked = true
							if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
							if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""
						)
					)
					if chk_clean_memory.checked then gc()
					--actionMan.executeAction 2077580866 "40207" --it will rescale the cluster to equalize the texel density
				)
				
				on btnSelectAll pressed do
				(
					max modify mode
					sel_face = #{}
					for val = 0 to lv.Items.count-1 do 
					(
						lv.Items.Item[val].checked = true
						append sel_face (dirs_select[val+1][6] as integer)
					)
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						unwrapmod.setPolygonMode true
						unwrapmod.selectFaces sel_face
						--unwrapmod.setPolygonMode true
						unwrapmod.polygonSelect() 
						max zoomext sel all
						max zoomext sel all
					)				
				)
				
				on btnDeselectAll pressed do
				(
					max modify mode
					sel_face = #{}
					for val = 0 to lv.Items.count-1 do lv.Items.Item[val].checked = false
					unwrapmod.setPolygonMode true
					unwrapmod.selectFaces sel_face
					unwrapmod.polygonSelect() 
				)			
				
				on btnRightClk pressed do
				(
					max modify mode
					sel_face = #{}
					for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected do append sel_face (dirs_select[val+1][6] as integer)
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						unwrapmod.selectFaces sel_face
						unwrapmod.setPolygonMode true
						unwrapmod.polygonSelect() 
						max zoomext sel all
						max zoomext sel all
					)
				)
				
				on dl_tex_dim selected i do 
				(
					theMapSize = case (dl_tex_dim.selection as integer) of
					(
						1: 256
						2: 512
						3: 1024
						4: 2048
						5: 4096
					)
					textureArea = theMapSize^2
					dirs_select = #()
					unwrapmod = modpanel.getcurrentobject()
							
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						faces = unwrapmod.getselectedfaces()
						if faces.count > 0 then
						(
							--print faces
							case last_pressed of
							(
								"All":
								if dirs_select.count != 0 then 
									for f in faces where not keyboard.escPressed do
									(
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
										--print texelDensity
										id = (mX as integer) + 1 + 10 * (mY as integer)
										UDIM = id + 1000
										append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)
								
								"BadHP":
								--if dirs_select.count != 0 then 
									for f in faces where not keyboard.escPressed do
									(
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
										--print texelDensity
										id = (mX as integer) + 1 + 10 * (mY as integer)
										UDIM = id + 1000
										if texelDensity <= 512 or texelDensity >= 1706 then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)
								
								"BadLP":
								--if dirs_select.count != 0 then 
									for f in faces where not keyboard.escPressed do
									(
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
										--print texelDensity
										id = (mX as integer) + 1 + 10 * (mY as integer)
										UDIM = id + 1000
										if texelDensity <= 10 or texelDensity >= 40 then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)
								
								"Zero":
								--if dirs_select.count != 0 then 
									for f in faces where not keyboard.escPressed do
									(
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
										--print texelDensity
										id = (mX as integer) + 1 + 10 * (mY as integer)
										UDIM = id + 1000
										if texelDensity <= 0.01 then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)
								
								default:
								if dirs_select.count != 0 then 
									for f in faces where not keyboard.escPressed do
									(
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
										--print texelDensity
										id = (mX as integer) + 1 + 10 * (mY as integer)
										UDIM = id + 1000
										append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)								
							)
						)
					)
					PopulateList lv dirs_select
					lbl.text = "Selected: " + (faces.numberset as string)
					if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
					if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""	
					if chk_clean_memory.checked then gc()					
				)

				on btnFilterBadHPMat pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						mat = #()
						if selection[1].material != undefined then
							if classof selection[1].material == multiSubMaterial then
							(
								m = selection[1].material
								num = m.materialList.count
								for i in #{1..num} do 
								(
									case classof m.materialList[i] of
									(
										Standard:
										(
											if classof m.materialList[i].DiffuseMap == BitmapTexture then
											(
												--print m.materialList[i].DiffuseMap.fileName
												bm = openbitmap m.materialList[i].DiffuseMap.fileName
												if bm != undefined then
												(
													mat[i] = bm.width --append mat #{i, bm.width}
													close bm
													free bm
												)
												else mat[i] = 0
											)
											else mat[i] = 0 -- append mat = #{i, 0}
										)
										Physical_Material:
										(			
											if classof m.materialList[i].base_color_map == BitmapTexture then --print m.materialList[i].base_color_map.fileName
											(
												--print m.materialList[i].DiffuseMap.fileName
												bm = openbitmap m.materialList[i].base_color_map.fileName
												if bm != undefined then
												(
													mat[i] = bm.width --append mat #{i, bm.width}
													close bm
													free bm
												)
												else mat[i] = 0
											)
											else mat[i] = 0 -- append mat = #{i, 0}												
										)
									)
								)
							)
							
						--print #(mat)
						faces = unwrapmod.getselectedfaces()
						--edt.text = faces.count as string	
						if faces.count > 0 then
						(
							--print faces
							for f in faces where not keyboard.escPressed do
							(
								unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
								usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
								texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
								--print texelDensity
								id = (mX as integer) + 1 + 10 * (mY as integer)
								if id <= 0 then id = 0
								UDIM = if id > 0 then id + 1000 else "wrong"
								--print id
								if id != 0 then 
									if mat[id] != undefined then
									(
										if ((texelDensity <= 512 or texelDensity >= 1706) and mat[id] > 256) or mat[id] == 0 then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)
									else
									(
										if (texelDensity <= 512 or texelDensity >= 1706) then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)
								else if (texelDensity <= 512 or texelDensity >= 1706) then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)

							)
						)
						last_pressed = "BadHP"
						PopulateList lv dirs_select 
						lbl.text = "Selected: " + (faces.numberset as string)
						if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
						if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""				
					)				
				)				
				
				on btnFilterBadHP pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						faces = unwrapmod.getselectedfaces()
						--edt.text = faces.count as string	
						if faces.count > 0 then
						(
							--print faces
							for f in faces where not keyboard.escPressed do
							(
								unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
								usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
								texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
								--print texelDensity
								id = (mX as integer) + 1 + 10 * (mY as integer)
								UDIM = if id > 0 then id + 1000 else "wrong"
								if texelDensity <= 512 or texelDensity >= 1706 then append dirs_select #(texelDensity as string,  UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
							)
						)
						last_pressed = "BadHP"
						PopulateList lv dirs_select 
						lbl.text = "Selected: " + (faces.numberset as string)
						if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
						if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""
					)				
				)

				on btnFilterZero pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						faces = unwrapmod.getselectedfaces()
						--edt.text = faces.count as string	
						if faces.count > 0 then
						(
							--print faces
							for f in faces where not keyboard.escPressed do
							(
								unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
								usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
								texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
								--print texelDensity
								id = (mX as integer) + 1 + 10 * (mY as integer)
								UDIM = if id > 0 then id + 1000 else "wrong"
								if texelDensity <= 0.01 then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
							)
						)
						last_pressed = "Zero"
						PopulateList lv dirs_select 
						lbl.text = "Selected: " + (faces.numberset as string)
						if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
						if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""						
					)				
				)

				on btnFilterBadLP pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						faces = unwrapmod.getselectedfaces()
						--edt.text = faces.count as string	
						if faces.count > 0 then
						(
							--print faces
							for f in faces where not keyboard.escPressed do
							(
								unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
								usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
								texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
								--print texelDensity
								id = (mX as integer) + 1 + 10 * (mY as integer)
								UDIM = if id > 0 then id + 1000 else "wrong"
								if texelDensity <= 10 or texelDensity >= 40 then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
							)
						)
						last_pressed = "BadLP"
						PopulateList lv dirs_select 
						lbl.text = "Selected: " + (faces.numberset as string)
						if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
						if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""						
					)				
				)
				
				on btnSelect pressed do
				(
					max modify mode
					if modpanel.getcurrentobject() != undefined and classof (unwrapmod = modpanel.getcurrentobject()) == unwrap_uvw then
					(
						if (faces = unwrapmod.getselectedfaces()).count > 0 then
						(
							unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom -- Get some information about the selection
							textureArea = theMapSize^2 -- Calculate the total texture area
							usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
							texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
							print texelDensity
						)
					)
					else messagebox "Please select an object with Unwrap UVW modifier applied to it."
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						sel_faces = #{}
						for val = 0 to lv.Items.count-1 where lv.Items.Item[val].checked do append sel_faces (dirs_select[val+1][6] as integer)
						unwrapmod.selectFaces sel_faces
						unwrapmod.setPolygonMode true
						unwrapmod.polygonSelect() 
						max zoomext sel all
						max zoomext sel all
					)
				)

				on btnFilterAll pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
							
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						faces = unwrapmod.getselectedfaces()
						unwrapmod.setPolygonMode true
						unwrapmod.setTVSubObjectMode 3	
						if faces.count > 0 then
						(
							--print faces
							for f in faces where not keyboard.escPressed do
							(
								--unwrapmod.selectFaces #{f}
								--unwrapmod.polygonSelect() 
								unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
								usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
								texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
								--print texelDensity
								id = (mX as integer) + 1 + 10 * (mY as integer)
								UDIM = if id > 0 then id + 1000 else "wrong"
								append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
							)
							--unwrapmod.selectFaces faces
							--unwrapmod.polygonSelect() 
						)
					)
					last_pressed = "All"
					PopulateList lv dirs_select
					if faces.count > 0 then lbl.text = "Selected: " + (faces.numberset as string)
					if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
					if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""				
					--lv.width = 450
					--lv.Update()
				)

				on btnClose pressed do
				(
					try(destroyDialog ::rocount_texel)catch()
					gc()
				)	
				
				on btnOpenEditor pressed do
				(
					max modify mode
					
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						--UIAccessor.PressButton (for i in (windows.getChildrenHWND (windows.getDesktopHWND())) where findstring i[5] "Open UV Editor" != undefined do (print i; exit with i[1]))
						unwrapmod.edit()
						unwrapmod.fit() 
					)
				)
			)
			createDialog rocount_texel width:500 height:580 style:#(#style_titlebar, #style_border, #style_sysmenu, #style_resizing)	
		)
		else
		(
			messagebox "Select one EDITABLE POLY object."
		)
	)

	on btn_count_texel rightclick do
	(
		global dirs_select = #()
		global theMapSize = 2048 
		global textureArea = theMapSize^2 -- Calculate the total texture area
		global unwrapmod = modpanel.getcurrentobject()
		global faces = #()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces()
			if faces.count > 0 then
			(
				--print faces
				for f in faces do
				(
					unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
					usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
					texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
					--print texelDensity
					append dirs_select (texelDensity as string + "  " + unwrapmod.getSelectMatID() as string + "  " + mAreaGeom as string + "  " + mAreaUVW as string + "  " + f as string)
				)
			)
		)
		
		try(destroyDialog ::rocount_texel)catch()
		rollout rocount_texel "Counts texel density in UDIMS" width:350 --height:1000
		(
			--progressBar pb13 "ProgressBar" width:950 height:10
			dropdownlist dl_tex_dim "Texture Dims" items:#("256", "512", "1024", "2048", "4096") selection:4 width:80 across:2
			edittext edt "count: " style_sunkenedge:true text:(faces.count as string)	
			MultiListBox mlbList "density ID areaG areaUV num" items:(dirs_select as array) width:270 height:40 selection:#()
			button btnExport "Select" across:7
			button btnFilterBad "Bad HP"			
			button btnFilterZero "Zero"
			button btnFilterTen "<10 LP" 
			button btnFilterForty ">40 LP" 
			button btnFilterAll "All"
			button btnClose "Close"
			
			on dl_tex_dim selected i do 
			(
				theMapSize = case (dl_tex_dim.selection as integer) of
				(
					1: 256
					2: 512
					3: 1024
					4: 2048
					5: 4096
				)
				textureArea = theMapSize^2				
			)
			
			on mlbList rightClick val do 
			(
				--try (mlbList.width = ((dirs_select[val]).count)*10)catch()
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					faces_curr = unwrapmod.getselectedfaces()
					sel_face = (filterstring dirs_select[val] " ")[(filterstring dirs_select[val] " ").count] as integer
					unwrapmod.selectFaces #{sel_face}
					unwrapmod.setPolygonMode true
					unwrapmod.polygonSelect() 
					max zoomext sel all
					max zoomext sel all
				)
			)
			
			on btnFilterAll pressed do
			(
				dirs_select = #()
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					faces = unwrapmod.getselectedfaces()
					edt.text = faces.count as string
					if faces.count > 0 then
					(
						--print faces
						for f in faces do
						(
							unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
							texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
							--print texelDensity
							append dirs_select (texelDensity as string + "  " + unwrapmod.getSelectMatID() as string + "  " + mAreaGeom as string + "  " + mAreaUVW as string + "  " + f as string)
						)
					)
					mlbList.items = dirs_select as array
				)				
			)
			
			on btnFilterBad pressed do
			(
				dirs_select = #()
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					faces = unwrapmod.getselectedfaces()
					edt.text = faces.count as string	
					if faces.count > 0 then
					(
						--print faces
						for f in faces do
						(
							unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
							texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
							--print texelDensity
							if texelDensity <= 512 or texelDensity >= 1706 then append dirs_select (texelDensity as string + "  " + unwrapmod.getSelectMatID() as string + "  " + mAreaGeom as string + "  " + mAreaUVW as string + "  " + f as string)
						)
					)
					mlbList.items = dirs_select as array
				)				
			)
			
			on btnFilterZero pressed do
			(
				dirs_select = #()
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					faces = unwrapmod.getselectedfaces()
					edt.text = faces.count as string	
					if faces.count > 0 then
					(
						--print faces
						for f in faces do
						(
							unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
							texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
							--print texelDensity
							if texelDensity <= 0.01 then append dirs_select (texelDensity as string + "  " + unwrapmod.getSelectMatID() as string + "  " + mAreaGeom as string + "  " + mAreaUVW as string + "  " + f as string)
						)
					)
					mlbList.items = dirs_select as array
				)				
			)
			
			on btnFilterTen pressed do
			(
				dirs_select = #()
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					faces = unwrapmod.getselectedfaces()
					edt.text = faces.count as string	
					if faces.count > 0 then
					(
						--print faces
						for f in faces do
						(
							unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
							texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
							--print texelDensity
							if texelDensity < 10 then append dirs_select (texelDensity as string + "  " + unwrapmod.getSelectMatID() as string + "  " + mAreaGeom as string + "  " + mAreaUVW as string + "  " + f as string)
						)
					)
					mlbList.items = dirs_select as array
				)				
			)
			
			on btnFilterForty pressed do
			(
				dirs_select = #()
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					faces = unwrapmod.getselectedfaces()
					edt.text = faces.count as string	
					if faces.count > 0 then
					(
						--print faces
						for f in faces do
						(
							unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
							texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
							--print texelDensity
							if texelDensity >= 40 then append dirs_select (texelDensity as string + "  " + unwrapmod.getSelectMatID() as string + "  " + mAreaGeom as string + "  " + mAreaUVW as string + "  " + f as string)
						)
					)
					mlbList.items = dirs_select as array
				)				
			)			
			
			on btnExport pressed do
			(
				theMapSize = 2048
				if modpanel.getcurrentobject() != undefined and classof (modpanel.getcurrentobject()) == Unwrap_UVW then
				(
					print (((GetTexelDensity theMapSize)/(GetMetersFromGU())) as string)		
				)
				else messagebox "Please select an object with Unwrap UVW modifier applied to it."
				
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					sel_faces = #{}
					for val in mlbList.selection do append sel_faces (((filterstring dirs_select[val] " ")[(filterstring dirs_select[val] " ").count]) as integer)
					unwrapmod.selectFaces sel_faces
					unwrapmod.setPolygonMode true
					unwrapmod.polygonSelect() 
					max zoomext sel all
					max zoomext sel all
				)
			)

			on btnClose pressed do
			(
				try(destroyDialog ::rocount_texel)catch()
			)
		) --rollout
		createDialog rocount_texel style:#(#style_sunkenedge,#style_titlebar,#style_sysmenu,#style_minimizebox,#style_maximizebox)		
	)
	
	on btn_count_colors pressed do 
	(
		global dirs_select = #()
		global item_select = #()
		global dirs = #()
		global Selected_dir_Path = edt_multimat_path.text

		try(destroyDialog ::rocount_colors)catch()
		rollout rocount_colors "Counts colors of textures" width:1000 --height:1000
		(
			
			fn autoResizeColumn lv columns: = 
			(
				vScrollWidth = 21 -- vertical scrollbar width
				for c = 0 to columns-1 do
				(
					lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
					vScrollWidth += lv.Columns.Item[c].Width
				) 
				vScrollWidth
			)

			fn PopulateList lv dirs_select =
			(
				lv.Items.Clear()
				lv.view = (dotNetClass "system.windows.forms.view").details --lv.view = (dotNetClass "View").details
				lv.HideSelection = true 
				--lv.height = 390
				lv.FullRowSelect = true    
				lv.MultiSelect = true    
				lv.AllowColumnReorder = true
				lv.GridLines = true
				lv.checkBoxes = false 
				lv.Scrollable = true
				lv.ShowItemToolTips = true
				columnsAr = #("Colors Count", "Size", "Main Colors", "Filename")
				lv.columns.Clear()
				for i = 1 to 4 do lv.columns.add columnsAr[i] 0	
				lv.width = autoResizeColumn lv columns:4
				lv.width = 950
				
				rows = #()
				for t = 1 to dirs_select.count do
				(
					li = dotNetObject "System.Windows.Forms.ListViewItem" (dirs_select[t][1])
					li.UseItemStyleForSubItems = true
					li.subitems.add dirs_select[t][2]
					li.subitems.add dirs_select[t][3]
					li.subitems.add dirs_select[t][4]
					append rows li
				)
				lv.items.addRange rows
				lv.width = autoResizeColumn lv columns:4
				lv.width = 950
				lv.Update()
			)
			
			fn init =
			(
				dirs_select = #()
				dirs = #()
				local start = GetINI_ImageMagick()
				if Selected_dir_Path != undefined then dirs = getfiles (Selected_dir_Path + "*.png")
				if dirs.count != 0 then 
				for i in dirs do 
				(
					local str = ""
					local str_size = ""
					local str_colors = ""	
					local colors_counter = 0.0
					--local colors_arr = #()
				
					/*
					local ii = i + ".jpg"
					
					--HiddenDOSCommand ("magick " + "\"" + i + "\"" + " -unique-colors " + "\"" + ii + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + i + "\"" + " -colors 32 -unique-colors " + "\"" + ii + "\"") startpath:start
					--HiddenDOSCommand ("magick " + "\"" + i + "\"" + " -separate -threshold 50%% -combine -colors 32 -unique-colors " + "\"" + ii + "\"") startpath:start

					local bt = openbitmap ii
					if bt != undefined then
					(
						colors_counter = bt.width
						str = bt.width as string
						colors_arr = getPixels bt [0,0] bt.width linear:true
						--colors_arr_str = for col in colors_arr collect (substitutestring (col as string) "color " "")
						close bt
						free bt
					)
					else
					(
						str = "0"
						colors_counter = 0
					)
					--if doesFileExist ii then deleteFile ii
					local bt = openbitmap i
					if bt != undefined then
					(
						str_size = bt.width as string + "x" + bt.height as string
						if bt.height == 256 and bt.width == 256 then
						(
							
							for col in colors_arr do str_colors += (substitutestring (col as string) "color " "") + " = " + ((ceil ((100.0 * colors_counter) / (bt.height * bt.width)) ) as integer) as string + "%; "
						)
						else
						(
							
						)
						close bt
						free bt
						append dirs_select #(str, str_size, str_colors, (substitutestring i Selected_dir_Path ""))
					)
					else append dirs_select #("open error", " ", " ", (substitutestring i Selected_dir_Path ""))
					*/
					
					
					--/*					
					local bt = openbitmap i

					if bt != undefined then
					(
						bt.gamma = 1.0
						local colors_quantity = #()
						local colors = #()
						if bt.height <= 256 or bt.width <= 256 then 
						(
							for line_num in #{1..bt.height} do
							(
								local line_bitmap = getPixels bt [0,line_num] bt.width linear:true
								for pixel in line_bitmap do appendifunique colors pixel --for pixel in #{1..line_bitmap.count} do appendifunique colors line_bitmap[pixel]
							)
							
							for color_selected in colors where colors.count <= 5 and bt.height <= 256 and bt.width <= 256 do --and colors.count > 1
							(
								colors_counter = 0.0
								for line_num in #{1..bt.height} do
								(
									local line_bitmap = getPixels bt [0, line_num] bt.width linear:true
									for pixel in line_bitmap where color_selected == pixel do colors_counter += 1.0
								)
								local col = substitutestring (color_selected as string) "color " ""
								col = trimright (trimleft col "()") "()"
								col = ((filterstring col " ")[1] as integer) as string + " " + ((filterstring col " ")[2] as integer) as string + " " + ((filterstring col " ")[3] as integer) as string
								append colors_quantity (col + " = " + ((ceil ((100.0 * colors_counter) / (bt.height * bt.width)) ) as integer) as string + "%")
							)
						)
						else
						(
							for line_num in #{1..bt.height} where colors.count <= 19 do
							(
								local line_bitmap = getPixels bt [0,line_num] bt.width linear:true
								for pixel in line_bitmap where colors.count <= 19 do appendifunique colors pixel 
							)
						)
						if colors.count != undefined then 
						(
							case of
							(
								(colors.count == 0): str += "0" as string 
								(colors.count > 0 and colors.count < 20): str += colors.count as string
								(colors.count >= 20): str += "20+" as string 
							)
						)
						else 
						(
							str += "0" as string
						)
						str_size = bt.width as string + "x" + bt.height as string
						
						if colors_quantity.count != undefined then 
						(
							if colors_quantity.count > 0 then 
							(
								if colors_quantity.count == 1 then str_colors += colors_quantity[1] as string
								if colors_quantity.count > 1 then for j in colors_quantity do str_colors += j + "; "
							)
							else
							(
								str_colors += " "
							)
						)
						else
						(
							str_colors += " "
						)
						
						append dirs_select #(str, str_size, str_colors, (substitutestring i Selected_dir_Path ""))
						close bt
						free bt
					)
					else
					(
						append dirs_select #("open error", " ", " ", (substitutestring i Selected_dir_Path ""))
					)
					--*/
				)
			)

			dotNetControl lv "ListView" pos:[5,5] width:950 height:600
			progressBar pb13 "ProgressBar" width:950 height:10
			button btnExport "Write one most popular colors to selected textures..." across:3 tooltip:"Записать самые частовстречающиеся цвета в выбранные текстуры | Write one most popular colors to selected textures"
			button btnOpenPath "Open Folder" tooltip:"Открыть папку | Open Folder"
			button btnClose "Close List" tooltip:"Закрыть список | Close List"

			on rocount_colors open do
			(  
				init()
				PopulateList lv dirs_select 
			)
			
			on lv MouseDown arg do
			(
				if arg.button == arg.button.middle then
				(                
					if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
					(
					)                
				)
				if arg.button == arg.button.right then
				(                
					if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
					(
						val = hitNode.index + 1
						--bm = openbitmap (Selected_dir_Path + dirs_select[val][4])
						--bm.gamma = 1.0
						--display bm
						try (display (openbitmap (Selected_dir_Path + dirs_select[val][4])))catch()
					)                
				)
			)
			
			on btnOpenPath pressed do
			(	
				HiddenDOSCommand ("explorer.exe /e,/select, " + "\"" + Selected_dir_Path + "\"")
			)
			
			on btnExport pressed do
			(
				myfiles = #()
				item_select = for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected collect dirs_select[val+1]
				print item_select
				--print dirs_select
				btnExport.visible = false
				if item_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in item_select do
					(
						--print item
						--item[1] colors quantity
						--item[2] size
						--item[3] colors
						--item[4] filename
						
						filename = Selected_dir_Path + item[4] 
					
						if item[3] != undefined and item[3] != " " and (item[1] as integer) > 0 and item[1] != undefined and item[1] != " " then
						(
							colors_string = ""
							if item[1] as integer > 1 then
							(
								colors_string = (filterstring ((filterstring item[3] ";")[1]) "=")[1]
							)
							else -- == 1
							(
								colors_string = (filterstring item[3] "=")[1]
							)							
							print colors_string	
							color_to_write = color ((filterstring colors_string " ")[1] as integer) ((filterstring colors_string " ")[2] as integer) ((filterstring colors_string " ")[3] as integer)
							print color_to_write
							bm = openbitmap filename
							bm_new = bitmap bm.width bm.height color:color_to_write filename:filename gamma:1.0 hdr:false --неизвестно, создает ли 24бит цвет или нет, лучше надо палитровый и не чб цвет
							close bm 
							free bm
							save bm_new gamma:1.0 quiet:true
							close bm_new
							HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
							free bm_new
						)
						else messagebox ("File do not changed:\n" + item[4])
						pb13.value = 100 * ind / dirs_select.count
						ind += 1
					)
					pb13.value = 100
					
					init()
					PopulateList lv dirs_select 		
				)
				btnExport.visible = true
			) --btnExport
			
			on btnClose pressed do
			(
				try(destroyDialog ::rocount_colors)catch()
			)
		) --rollout
		createDialog rocount_colors style:#(#style_sunkenedge,#style_titlebar,#style_sysmenu,#style_minimizebox,#style_maximizebox)
	)
	
	on btn_count_colors rightclick do --плохо работает на конвертации
	(
		global dirs_select = #()
		global item_select = #()
		global dirs = #()
		
		global Selected_dir_Path = edt_multimat_path.text
		if Selected_dir_Path != undefined then dirs = getfiles (Selected_dir_Path + "*.png")
		if dirs.count != 0 then 
		--kk=1
		for i in dirs do --where kk <= 20 do 
		(
			--kk+=1
			str = ""
			bt = openbitmap i
			if bt != undefined then
			(
				bt.gamma = 1.0
				colors_quantity = #()
				colors = #()
				if bt.height <= 256 or bt.width <= 256 then 
				(
					for line_num in #{1..bt.height} do
					(
						line_bitmap = getPixels bt [0,line_num] bt.width linear:true
						for pixel in line_bitmap do appendifunique colors pixel --for pixel in #{1..line_bitmap.count} do appendifunique colors line_bitmap[pixel]
					)
					
					for color_selected in colors where colors.count <= 5 and bt.height <= 256 and bt.width <= 256 do --and colors.count > 1
					(
						colors_counter = 0.0
						for line_num in #{1..bt.height} do
						(
							line_bitmap = getPixels bt [0,line_num] bt.width linear:true
							for pixel in line_bitmap where color_selected == pixel do colors_counter += 1.0
						)
						col = substitutestring (color_selected as string) "color " ""
						col = trimright (trimleft col "()") "()"
						col = ((filterstring col " ")[1] as integer) as string + " " + ((filterstring col " ")[2] as integer) as string + " " + ((filterstring col " ")[3] as integer) as string
						append colors_quantity (col + "=" + ((ceil ((100.0 * colors_counter) / (bt.height * bt.width)) ) as integer) as string)
					)
				)
				else
				(
					for line_num in #{1..bt.height} where colors.count <= 19 do
					(
						line_bitmap = getPixels bt [0,line_num] bt.width linear:true
						for pixel in line_bitmap where colors.count <= 19 do appendifunique colors pixel 
					)
					print colors.count
				)
				if colors.count != undefined then 
				(
					case of
					(
						(colors.count == 0): str += "0" as string + "   "
						(colors.count > 0 and colors.count < 20): str += colors.count as string + "   "
						(colors.count >= 20):str += "20+" as string + "   "
					)
					--if colors.count > 0 and colors.count <= 20 then str += colors.count as string + "   " else str += "20+" as string + "   "
				)
				else 
				(
					str += "0" as string + "   "
				)
				str += bt.width as string + "x" + bt.height as string + "   "
				if bt.width < 1000 then str += "  "
				if bt.height < 1000 then str += "  "
				str += "|" + substitutestring i Selected_dir_Path "" + "|"
				
				if colors_quantity.count != undefined then 
				(
					if colors_quantity.count > 0 then 
						for j in colors_quantity do str += j + "; "
					else str += "0" + "; "
				)
				else
				(
					str += "0" + "; "
				)
				print str
				append dirs_select str
				close bt
				free bt
			)
		)
		try(destroyDialog ::rocount_colors)catch()
		rollout rocount_colors "Counts colors of textures" width:1000 --height:1000
		(
			progressBar pb13 "ProgressBar" width:950 height:10
			MultiListBox mlbList "List of textures:" items:(dirs_select as array) width:950 height:40 selection:#()
			button btnExport "Write one most popular colors to selected textures..." across:3
			button btnOpenPath "Open one selected path"
			button btnClose "Close List"
			
			on mlbList rightClick val do 
			(
				--try (mlbList.width = ((dirs_select[val]).count)*10)catch()
				bm = openbitmap (Selected_dir_Path + (filterstring dirs_select[val] "|")[2])
				bm.gamma = 1.0
				display bm
			)
			
			on btnOpenPath pressed do
			(	
				--открыть путь выделенной тектсуры
			)
			
			on btnExport pressed do
			(
				myfiles = #()
				item_select = for i = 1 to (mlbList.selection as array).count collect ( (dirs_select[(mlbList.selection as array)[i]]) as string)
				print item_select
				--print dirs_select
				btnExport.visible = false
				if item_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in item_select do --and ind < 5 do 
					(
						print item
						filename = (Selected_dir_Path + (filterstring item "|")[3]) 

						if (filterstring item "|")[4] != undefined and ((filterstring item "|")[4] as integer) > 0 (filterstring item "|")[1] != undefined and ((filterstring item "|")[1] as integer) > 0 then
						(
							--print (filterstring item "|")[1]
							if (filterstring ((filterstring item "|")[1]) " ")[1] as integer > 1 then
							(
								colors_string = (filterstring ((filterstring ((filterstring item "|")[4]) ";")[1]) "=")[1]
								print colors_string	
							)
							color_to_wtite = color ((filterstring colors_string " ")[1] as integer) ((filterstring colors_string " ")[2] as integer) ((filterstring colors_string " ")[3] as integer)
							print color_to_wtite
							bm = openbitmap filename
							bm_new = bitmap bm.width bm.height color:color_to_wtite filename:filename gamma:1.0 hdr:false --неизвестно, создает ли 24бит цвет или нет, лучше надо палитровый и не чб цвет
							close bm 
							free bm
							save bm_new gamma:1.0 quiet:true
							close bm_new
							free bm_new
						)
						else print "file not edited"
						pb13.value = 100*ind/dirs_select.count
						ind += 1
					)
					pb13.value = 100
					
					
					for item = 1 to item_select.count do
					(
						print ((mlbList.items)[(mlbList.selection as array)[item]])
						filename = (Selected_dir_Path + (filterstring item_select[item] "|")[2]) 
						str = ""
						bt = openbitmap filename
						bt.gamma = 1.0
						colors = #()
						colors_quantity = #()
						if bt != undefined then
						(
							if bt.height <= 256 or bt.width <= 256 then 
							(
								for line_num in #{1..bt.height} do
								(
									line_bitmap = getPixels bt [0,line_num] bt.width linear:true
									for pixel in line_bitmap do appendifunique colors pixel 
								)
								for color_selected in colors where colors.count <= 5 and bt.height <= 256 and bt.width <= 256 do --and colors.count > 1
								(
									colors_counter = 0.0
									for line_num in #{1..bt.height} do
									(
										line_bitmap = getPixels bt [0,line_num] bt.width linear:true
										for pixel in line_bitmap where color_selected == pixel do colors_counter += 1.0
									)
									col = substitutestring (color_selected as string) "color " ""
									col = trimright (trimleft col "()") "()"
									col = ((filterstring col " ")[1] as integer) as string + " " + ((filterstring col " ")[2] as integer) as string + " " + ((filterstring col " ")[3] as integer) as string
									append colors_quantity (col + "=" + ((ceil ((100.0 * colors_counter) / (bt.height * bt.width)) ) as integer) as string)
								)
							)
						)
						if colors.count != undefined then 
						(
							case of
							(
								(colors.count == 0): str += "0" as string + "   "
								(colors.count > 0 and colors.count < 20): str += colors.count as string + "   "
								(colors.count >= 20):str += "20+" as string + "   "
							)
							--if colors.count > 0 then str += colors.count as string + "   " else str += "0" as string + "   "
						)
						else 
						(
							str += "0" as string + "   "
						)
						str += bt.width as string + "x" + bt.height as string + "   "
						if bt.width < 1000 then str += "  "
						if bt.height < 1000 then str += "  "
						str += "|" + substitutestring item_select[item] Selected_dir_Path "" + "|"
						if colors_quantity.count != undefined then 
						(
							if colors_quantity.count > 0 then 
								for j in colors_quantity do str += j + "; "
							else str += "0" + "; "
						)
						else
						(
							str += "0" + "; "
						)						
						append dirs_select str
						close bt
						free bt		
					)
				)
				btnExport.visible = true
			) --btnExport
			
			on btnClose pressed do
			(
				try(destroyDialog ::rocount_colors)catch()
			)
		) --rollout
		createDialog rocount_colors style:#(#style_sunkenedge,#style_titlebar,#style_sysmenu,#style_minimizebox,#style_maximizebox)
	)
	
	on btn_alpha_remove pressed do 
	(
		global dirs_select = #()
		global items_select = #()
		global dirs = #()
		global Selected_dir_Path = edt_multimat_path.text
		
		try(destroyDialog ::roalpha_remove)catch()
		rollout roalpha_remove "Remove alpha from textures" width:1000 --height:1000
		(
			fn autoResizeColumn lv columns: = 
			(
				vScrollWidth = 21 -- vertical scrollbar width
				for c = 0 to columns-1 do
				(
					lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
					vScrollWidth += lv.Columns.Item[c].Width
				) 
				vScrollWidth
			)
			
			fn PopulateList lv dirs_select =
			(
				lv.Items.Clear()
				lv.view = (dotNetClass "system.windows.forms.view").details --lv.view = (dotNetClass "View").details
				lv.HideSelection = true 
				--lv.height = 390
				lv.FullRowSelect = true    
				lv.MultiSelect = true    
				lv.AllowColumnReorder = true
				lv.GridLines = true
				lv.checkBoxes = false --true 
				lv.Scrollable = true
				lv.ShowItemToolTips = true
				--for i = 0 to lv.Items.count-1 do lv.Items.Item[i].checked = true
				columnsAr = #("Alpha channel", "Texture size", "Color Depth", "Filename")
				lv.columns.Clear()
				for i = 1 to 4 do lv.columns.add columnsAr[i] 0	
				lv.width = autoResizeColumn lv columns:4
				lv.width = 950
				
				rows = #()
				for t = 1 to dirs_select.count do
				(
					li = dotNetObject "System.Windows.Forms.ListViewItem" (dirs_select[t][1])
					li.UseItemStyleForSubItems = true
					li.subitems.add dirs_select[t][2]
					li.subitems.add dirs_select[t][3]
					li.subitems.add dirs_select[t][4]
					append rows li
				)
				lv.items.addRange rows
				lv.width = autoResizeColumn lv columns:4
				lv.width = 950
				lv.Update()
			)
			
			fn init =
			(	
				dirs_select = #()
				dirs = #()
				if Selected_dir_Path != undefined then dirs = getfiles (Selected_dir_Path + "*.png")
				if dirs.count != 0 then 
				for i in dirs do 
				(
					str = ""
					str_color = ""
					bt = openbitmap i
					if bt != undefined then
					(
						if bt.hasAlpha != undefined then 
						(
							str = if bt.hasAlpha then "alpha" else " "
						)
						else str = "error"
						
						if bt.width != undefined or bt.height != undefined then
						(
							HiddenDOSCommand ("identify " + "\"" + i + "\"" + " > !!.txt") startpath:(GetINI_ImageMagick()) --HiddenDOSCommand ("magick identify -verbose " + "\"" + i + "\"" + " > !.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
							stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!!.txt") ((dotNetClass "System.Text.Encoding").UTF8) --stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!.txt" ((dotNetClass "System.Text.Encoding").UTF8
							if stri != undefined then 
							(
								--print stri
								--for s in stri where (findstring s "-bit" != undefined) do str += (filterstring (substitutestring s i "") " ")[4] 
								--for s in stri where (findstring s "Depth:" != undefined) do str += s
								for s in stri do 
								(
									s = substitutestring s i ""
									sss1 = 4
									sss2 = (filterstring s " ").count - 3
									for ss = sss1 to sss2 do str_color += (filterstring s " ")[ss] + " " --(substitutestring ((filterstring s " ")[ss]) i "") + " "
								)
							)
							append dirs_select #(str,(bt.width as string + "x" + bt.height as string), str_color, (substitutestring i Selected_dir_Path ""))
						)
						close bt
					)
					else 
					(
						append dirs_select #("open error"," ", " ", (substitutestring i Selected_dir_Path ""))
					)
					free bt
				)
				--dirs_select
			)
				
			dotNetControl lv "ListView" pos:[5,5] width:950 height:600
			progressBar pb13 "ProgressBar" width:950 height:10
			button btnRemove "Remove alpha channel" across:6 tooltip:"Удалить альфа-канал | Remove alpha channel"
			button btnBit "Make 8bit Depth and sRGB color" tooltip:"Сконвертировать в 8-бит и в sRGB цвет | Make 8bit Depth and sRGB color" 
			button btn_resize_2048 "Resize to" tooltip:"Переразмерить | Resize to"
			dropdownlist ddl_resize "" items: #("256","512","1024","2048","4096") selection:4 width:100 fieldWidth:100
			button btnOpenFolder "Open Folder" tooltip:"Открыть папку | Open Folder"
			button btnClose "Close List" tooltip:"Закрыть список | Close List"
			
			on roalpha_remove open do
			(
				init()
				PopulateList lv dirs_select 
			)
			
			on lv MouseDown arg do
			(
				if arg.button == arg.button.middle then
				(                
					if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
					(
					)                
				)
				if arg.button == arg.button.right then
				(               
					if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
					(
						val = hitNode.index + 1
						try (display (openbitmap (Selected_dir_Path + dirs_select[val][4])))catch()
						--HWND = for i in (UIAccessor.GetChildWindows (DialogMonitorOPS.GetWindowHandle())) where findstring (UIAccessor.GetWindowText i) (Selected_dir_Path + dirs_select[val][4]) != undefined do exit with i
						--print HWND
						--UIAccessor.CloseDialog HWND
						--windows.SendMessage HWND 0x0201 1 0
						--UIAccessor.SendMessage HWND[1] 0x0201 1 0
						--UIAccessor.SendMessage HWND[1] 0x0202 0 0
						--UIAccessor.SendMessage HWND 0xF5 1 0
					)                
				)
			)

			on btn_resize_2048 pressed do
			(
				btn_resize_2048.visible = false
				myfiles = #()
				items_select = for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected collect Selected_dir_Path + dirs_select[val+1][4]
				print #(items_select)
				if items_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in items_select do
					(
						print item
						if doesfileexist item then 
							case ddl_resize.selection of 
							(
								1: HiddenDOSCommand ("magick " + "\"" + item + "\"" + " -resize 256x256^ -define png:color-type=6 " + "\""+ item + "\"") startpath:(GetINI_ImageMagick())
								2: HiddenDOSCommand ("magick " + "\"" + item + "\"" + " -resize 512x512^ -define png:color-type=6 " + "\""+ item + "\"") startpath:(GetINI_ImageMagick())
								3: HiddenDOSCommand ("magick " + "\"" + item + "\"" + " -resize 1024x1024^ -define png:color-type=6 " + "\""+ item + "\"") startpath:(GetINI_ImageMagick())
								4: HiddenDOSCommand ("magick " + "\"" + item + "\"" + " -resize 2048x2048^ -define png:color-type=6 " + "\""+ item + "\"") startpath:(GetINI_ImageMagick())
								5: HiddenDOSCommand ("magick " + "\"" + item + "\"" + " -resize 4096x4096^ -define png:color-type=6 " + "\""+ item + "\"") startpath:(GetINI_ImageMagick())
							)
						--HiddenDOSCommand ("convert " + "\"" + filename + "\""+ " -alpha remove -alpha off " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						HiddenDOSCommand ("magick " + "\"" + item + "\""+ " PNG24:" + "\""+ item + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100 * ind / dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				--переформировать список
				init()
				PopulateList lv dirs_select 
				btn_resize_2048.visible = true
			)
			
			on btnOpenFolder pressed do 
			(
				HiddenDOSCommand ("explorer.exe /e,/select, " + "\"" + Selected_dir_Path + "\"")
			)			
			
			on btnRemove pressed do --удалить альфаканал из выбранных текстур
			(
				myfiles = #()
				items_select = for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected collect Selected_dir_Path + dirs_select[val+1][4]
				print items_select
				btnRemove.visible = false
				if items_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in items_select do
					(
						print item
						--convert -alpha remove -alpha off 
						HiddenDOSCommand ("magick " + "\"" + item + "\""+ " -alpha remove -alpha off " + "\"" + item + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						HiddenDOSCommand ("magick " + "\"" + item + "\""+ " PNG24:" + "\""+ item + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100 * ind / dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				--переформировать список
				init()
				PopulateList lv dirs_select 
				btnRemove.visible = true
			) --btnRemove

			on btnBit pressed do
			(
				myfiles = #()
				items_select = for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected collect Selected_dir_Path + dirs_select[val+1][4]
				print items_select
				btnBit.visible = false
				if items_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in items_select do
					(
						print item
							--HiddenDOSCommand ("convert " + "\"" + filename + "\""+ " -colorspace rgb -type truecolor -depth 8 -define png:include-chunk=none -define png:exclude-chunk=bkgd -define colorspace:auto-grayscale=off -verbose PNG24:" + "\""+ filename + "\"") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						HiddenDOSCommand ("magick " + "\"" + item + "\""+ " PNG24:" + "\""+ item + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100 * ind / dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				--переформировать список
				init()	
				PopulateList lv dirs_select 
				btnBit.visible = true
			) --btnBit

			on btnClose pressed do
			(
				try(destroyDialog ::roalpha_remove)catch()
			)
		)
		createDialog roalpha_remove width:1000 height:650 style:#(#style_titlebar, #style_border, #style_sysmenu, #style_resizing)	
	)
	
	on btn_alpha_remove rightclick do 
	(
		global dirs_select = #()
		global item_select = #()
		global dirs = #()
		
		global Selected_dir_Path = edt_multimat_path.text
		if Selected_dir_Path != undefined then dirs = getfiles (Selected_dir_Path + "*.png")
		if dirs.count != 0 then 
		for i in dirs do 
		(
			str = ""
			bt = openbitmap i
			if bt != undefined then
			(
				if bt.hasAlpha != undefined then str += bt.hasAlpha as string + "   " else str += "error" + "   "
				if bt.hasAlpha != undefined then if bt.hasAlpha then str += " "
				if bt.width != undefined or bt.height != undefined then
				(
					str += bt.width as string + "x" + bt.height as string + "   "
					if bt.width < 1000 then str += "  "
					if bt.height < 1000 then str += "  "
					HiddenDOSCommand ("identify " + "\"" + i + "\"" + " > !!.txt") startpath:(GetINI_ImageMagick()) --HiddenDOSCommand ("magick identify -verbose " + "\"" + i + "\"" + " > !.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
					stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!!.txt") ((dotNetClass "System.Text.Encoding").UTF8) --stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!.txt" ((dotNetClass "System.Text.Encoding").UTF8
					str += "|" 
					if stri != undefined then 
					(
						--for s in stri where (findstring s "-bit" != undefined) do str += (filterstring (substitutestring s i "") " ")[4] 
						--for s in stri where (findstring s "Depth:" != undefined) do str += s
						for s in stri do for ss = 1 to (filterstring s " ").count where ss > 4 and ss < ((filterstring s " ").count) - 2 do str += (substitutestring ((filterstring s " ")[ss]) i "") + " "
					)
					str += "|" + substitutestring i Selected_dir_Path ""
					append dirs_select str
				)
				close bt
			)
			else 
			(
				str += "open error" + "| |" + substitutestring i Selected_dir_Path ""
				append dirs_select str
			)
			free bt
		)
		try(destroyDialog ::roalpha_remove)catch()
		rollout roalpha_remove "Remove alpha from textures" width:1000 --height:1000
		(
			progressBar pb13 "ProgressBar" width:950 height:10
			MultiListBox mlbList "List of textures:" items:(dirs_select as array) width:950 height:40 selection:#()
			button btnRemove "Remove alpha channel" across:6
			button btnBit "Make 8bit Depth and RGB color" 
			--button btnBitOne "Make 1bit Depth from selected textures..." 
			button btn_resize_2048 "Resize to"
			dropdownlist ddl_resize "" items: #("256","512","1024","2048","4096")
			button btnOpenFolder "Open Folder"
			button btnClose "Close List"
			
			on mlbList rightClick val do 
			(
				try (mlbList.width = ((dirs_select[val]).count)*10)catch()
				try (display (openbitmap (Selected_dir_Path + (filterstring dirs_select[val] "|")[3]) ) )catch()
			)
			
			on btn_resize_2048 pressed do
			(
				
				myfiles = #()
				item_select = for i = 1 to (mlbList.selection as array).count collect (Selected_dir_Path + (dirs_select[(mlbList.selection as array)[i]]) as string)
				print item_select
				if item_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in item_select do --and ind < 5 do 
					(
						print item
						filename = (Selected_dir_Path + (filterstring item "|")[3]) 
						print filename
						if doesfileexist filename then 
						case ddl_resize.selection of 
						(
							1: HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -resize 256x256^ -define png:color-type=6 " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
							2: HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -resize 512x512^ -define png:color-type=6 " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
							3: HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -resize 1024x1024^ -define png:color-type=6 " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
							4: HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -resize 2048x2048^ -define png:color-type=6 " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
							5: HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -resize 4096x4096^ -define png:color-type=6 " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
						)
						--HiddenDOSCommand ("convert " + "\"" + filename + "\""+ " -alpha remove -alpha off " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100*ind/dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				dirs_select = #()
				for i in dirs do 
				(
					str = ""
					bt = openbitmap i
					str += bt.hasAlpha as string + "   "
					if bt.hasAlpha then str += " "
					str += bt.width as string + "x" + bt.height as string + "   "
					if bt.width < 1000 then str += "  "
					if bt.height < 1000 then str += "  "
					HiddenDOSCommand ("identify " + "\"" + i + "\"" + " > !!.txt") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\") --HiddenDOSCommand ("magick identify -verbose " + "\"" + i + "\"" + " > !.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
					--stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!!.txt" ((dotNetClass "System.Text.Encoding").UTF8) 
					--stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!.txt" ((dotNetClass "System.Text.Encoding").UTF8)
					stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!!.txt") ((dotNetClass "System.Text.Encoding").UTF8)
					str += "|" 
					--for s in stri where (findstring s "-bit" != undefined) do str += (filterstring (substitutestring s i "") " ")[4] 
					--for s in stri where (findstring s "Depth:" != undefined) do str += s
					for s in stri do for ss = 1 to (filterstring s " ").count where ss > 4 and ss < ((filterstring s " ").count) - 2 do str += (substitutestring ((filterstring s " ")[ss]) i "") + " "
					str += "|" + substitutestring i Selected_dir_Path ""
					append dirs_select str
					close bt
					free bt
				)
				mlbList.items = (dirs_select as array) 
			)
			
			on btnOpenFolder pressed do 
			(
				HiddenDOSCommand ("explorer.exe /e,/select, " + "\"" + Selected_dir_Path + "\"")
			)			
			
			on btnRemove pressed do
			(
				myfiles = #()
				item_select = for i = 1 to (mlbList.selection as array).count collect (Selected_dir_Path + (dirs_select[(mlbList.selection as array)[i]]) as string)
				print item_select
				--print dirs_select
				btnRemove.visible = false
				if item_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in item_select do --and ind < 5 do 
					(
						print item
						filename = (Selected_dir_Path + (filterstring item "|")[3]) 
						--convert -alpha remove -alpha off 
						HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " -alpha remove -alpha off " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100*ind/dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				dirs_select = #()
				for i in dirs do 
				(
					str = ""
					bt = openbitmap i
					str += bt.hasAlpha as string + "   "
					if bt.hasAlpha then str += " "
					str += bt.width as string + "x" + bt.height as string + "   "
					if bt.width < 1000 then str += "  "
					if bt.height < 1000 then str += "  "
					HiddenDOSCommand ("identify " + "\"" + i + "\"" + " > !!.txt") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\") --HiddenDOSCommand ("magick identify -verbose " + "\"" + i + "\"" + " > !.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
					stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!!.txt") ((dotNetClass "System.Text.Encoding").UTF8) 
					--stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!!.txt" ((dotNetClass "System.Text.Encoding").UTF8) 
					--stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!.txt" ((dotNetClass "System.Text.Encoding").UTF8)
					str += "|" 
					--for s in stri where (findstring s "-bit" != undefined) do str += (filterstring (substitutestring s i "") " ")[4] 
					--for s in stri where (findstring s "Depth:" != undefined) do str += s
					for s in stri do for ss = 1 to (filterstring s " ").count where ss > 4 and ss < ((filterstring s " ").count) - 2 do str += (substitutestring ((filterstring s " ")[ss]) i "") + " "
					str += "|" + substitutestring i Selected_dir_Path ""
					append dirs_select str
					close bt
					free bt
				)
				mlbList.items = (dirs_select as array) 
				btnRemove.visible = true
			) --btnRemove

			on btnBit pressed do
			(
				myfiles = #()
				item_select = for i = 1 to (mlbList.selection as array).count collect (Selected_dir_Path + (dirs_select[(mlbList.selection as array)[i]]) as string)
				print item_select
				--print dirs_select
				btnBit.visible = false
				if item_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in item_select do --and ind < 5 do 
					(
						print item
						filename = (Selected_dir_Path + (filterstring item "|")[3]) 
						--HiddenDOSCommand ("convert " + "\"" + filename + "\""+ " -colorspace rgb -type truecolor -depth 8 -define png:include-chunk=none -define png:exclude-chunk=bkgd -define colorspace:auto-grayscale=off -verbose PNG24:" + "\""+ filename + "\"") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100*ind/dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				dirs_select = #()
				for i in dirs do 
				(
					str = ""
					bt = openbitmap i
					str += bt.hasAlpha as string + "   "
					if bt.hasAlpha then str += " "
					str += bt.width as string + "x" + bt.height as string + "   "
					if bt.width < 1000 then str += "  "
					if bt.height < 1000 then str += "  "
					HiddenDOSCommand ("identify " + "\"" + i + "\"" + " > !!.txt") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\") --HiddenDOSCommand ("magick identify -verbose " + "\"" + i + "\"" + " > !.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
					stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!!.txt") ((dotNetClass "System.Text.Encoding").UTF8)					
					--stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!!.txt" ((dotNetClass "System.Text.Encoding").UTF8) 
					--stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!.txt" ((dotNetClass "System.Text.Encoding").UTF8)
					str += "|" 
					--for s in stri where (findstring s "-bit" != undefined) do str += (filterstring (substitutestring s i "") " ")[4] 
					--for s in stri where (findstring s "Depth:" != undefined) do str += s
					for s in stri do for ss = 1 to (filterstring s " ").count where ss > 4 and ss < ((filterstring s " ").count) - 2 do str += (substitutestring ((filterstring s " ")[ss]) i "") + " "
					str += "|" + substitutestring i Selected_dir_Path ""
					append dirs_select str
					close bt
					free bt
				)
				mlbList.items = (dirs_select as array) 
				btnBit.visible = true
			) --btnBit
/*
			on btnBitOne pressed do
			(
				myfiles = #()
				item_select = for i = 1 to (mlbList.selection as array).count collect (Selected_dir_Path + (dirs_select[(mlbList.selection as array)[i]]) as string)
				print item_select
				--print dirs_select
				btnBitOne.visible = false
				if item_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in item_select do --and ind < 5 do 
					(
						print item
						filename = (Selected_dir_Path + (filterstring item "|")[3]) 
						--HiddenDOSCommand ("convert " + "\"" + filename + "\""+ " -flatten -type palette -depth 1 -colors 1 -define png:include-chunk=none -define png:exclude-chunk=bkgd -verbose " + "\""+ filename + "\"") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						HiddenDOSCommand ("convert " + "\"" + filename + "\""+ " -type palette -define png:include-chunk=none -define png:exclude-chunk=bkgd -verbose " + "\""+ filename + "\"") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100*ind/dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				dirs_select = #()
				for i in dirs do 
				(
					str = ""
					bt = openbitmap i
					str += bt.hasAlpha as string + "   "
					if bt.hasAlpha then str += " "
					str += bt.width as string + "x" + bt.height as string + "   "
					if bt.width < 1000 then str += "  "
					if bt.height < 1000 then str += "  "
					HiddenDOSCommand ("magick identify " + "\"" + i + "\"" + " > !!.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\") --HiddenDOSCommand ("magick identify -verbose " + "\"" + i + "\"" + " > !.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
					stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!!.txt" ((dotNetClass "System.Text.Encoding").UTF8) --stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!.txt" ((dotNetClass "System.Text.Encoding").UTF8)
					str += "|" 
					for s in stri where (findstring s "-bit" != undefined) do str += (filterstring (substitutestring s i "") " ")[4] --for s in stri where (findstring s "Depth:" != undefined) do str += s
					str += "|" + substitutestring i Selected_dir_Path ""
					append dirs_select str
					close bt
					free bt
				)
				mlbList.items = (dirs_select as array) 
				btnBitOne.visible = true
			) --btnBitOne
*/			
			on btnClose pressed do
			(
				try(destroyDialog ::roalpha_remove)catch()
			)
		) --rollout
		createDialog roalpha_remove style:#(#style_sunkenedge,#style_titlebar,#style_sysmenu,#style_minimizebox,#style_maximizebox)
	)	

	on btn_get_multimat_path pressed do
	(
		case rdo_path.state of
		(
			1: edt_multimat_path.text = maxFilePath + "Maps\\"
			2: edt_multimat_path.text = maxFilePath + "Images\\"
			3: edt_multimat_path.text = maxFilePath + edt_path_end.text
		)
	)
	
	on btn_get_multimat_folder pressed do
	(
		try
		(
			edt_multimat_path.text = getSavePath caption:"Select Folder ..." initialDir: maxFilePath
			edt_multimat_path.text += "\\"
		)catch()
		lbl_multimat_path.text = "Search mask: ..." + "\\" + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png"
	)	
	
	on btn_open_multimat_path pressed do
	(
		HiddenDOSCommand ("explorer.exe /e,/select,\"" + edt_multimat_path.text)
	)
	
	on btn_ids_as_udims pressed do with undo "Set IDs as UDIMs" on with redraw off
	(
		if selection.count == 1 and classof selection[1].baseobject == editable_poly and classof selection[1].modifiers[1] == Unwrap_UVW then 
		(
			ctrl = keyboard.controlPressed
			max modify mode
			q = if selection[1].modifiers.count == 0 then selection[1] else selection[1].modifiers[1]
			q = modpanel.getcurrentobject()
			if q != undefined and classof q == Unwrap_UVW then
			(
				arr = #{1..q.numberPolygons()}
				q.unhide() 
				q.setTVSubObjectMode 3
				qq = #{}
				if ctrl then
				(
					poi = [0,0,0]
					while arr.numberset != 0 do 
					(	
						--print arr.numberset
						if keyboard.escpressed then exit 
						for p in arr do (q.selectFaces #{p}; exit)
						q.faceToVertSelect()
						sel = q.getselectedvertices()
						if sel.count > 0 then
						(
							--poi = (for i in sel collect (q.unwrap.getvertexposition currenttime i))[1]
							for i in sel do (poi = q.unwrap.getvertexposition currenttime i;exit)
							/*					
							poi = [(amax (for i in sel collect (q.unwrap.getvertexposition currenttime i).x) - amin (for i in sel collect (q.unwrap.getvertexposition currenttime i).x))/2, (amax (for i in sel collect (q.unwrap.getvertexposition currenttime i).y) - amin (for i in sel collect (q.unwrap.getvertexposition currenttime i).y))/2,0]
							uvMax = [-99999,-99999,0]
							uvMin = [99999,99999,0]
							for i in #{1..sel.count} do 
							(
								uvPos = q.unwrap.getvertexposition currenttime i
								if uvPos.x > uvMax.x then 
								(
									uvMax.x = uvPos.x
								)
								else 
								(
									if uvPos.x < uvMin.x do
									(
										uvMin.x = uvPos.x
									)
								)
								if uvPos.y > uvMax.y then 
								(
									uvMax.y = uvPos.y
								)
								else 
								(
									if uvPos.y < uvMin.y do 
									(
										uvMin.y = uvPos.y
									)
								)
							)
							q.unwrap2.setTVSubObjectMode 3
							poi = (uvMax+uvMin)/2 

							--poi = q.unwrap.getvertexposition currenttime sel[1]
							*/
							if poi != undefined then 
							(
								id = (poi.x as integer) + 1 + 10 * (poi.y as integer)
								q.selectElement()
								q.setSelectMatID id
								qq = q.getSelectedFaces()
								arr -= qq
							)
						)
					)
				)			
				else 
				while arr.numberset != 0  do 
				(
					--print arr.numberset
					if keyboard.escpressed then exit 
					for p in arr do (q.selectFaces #{p}; exit)
					poi = q.getselcenter() --быстрее чем у всего элемента
					if poi != undefined then 
					(
						id = (poi.x as integer) + 1 + 10 * (poi.y as integer)
						q.selectElement()
						q.setSelectMatID id
						qq = q.getSelectedFaces()
						arr -= qq
					)
				)
			)
			gc light:true
		)
		else
		(
			messagebox ("Select single EditablePoly object with single Unwrap_UVW modifier")
		)
	)

	
/*
	on btn_multimat_table pressed do
	(
		f = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png")
		f_norm = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Normal*" + edt_material_mat_number.text + "*.png")	
		f_erm = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*ERM*" + edt_material_mat_number.text + "*.png")	
	
		if f != undefined then edt_multimat_count.text = f.count as string
		num = edt_multimat_count.text as integer
	
		b = for i in f collect (openBitMap i)
		print #(b)
		
		--b1 = openBitMap f[1]
		--b1n = openBitMap f_norm[1]
		--b1e = openBitMap f_erm[1]
		--b2 = openBitMap f[2]
		--d1 = try (meditMaterials[1].originalMaterial.materialList[3].texmapDiffuse)catch(bitmap 50 50 color:black gamma:1.0 hdr:false)
		--d2 = try (meditMaterials[1].originalMaterial.materialList[2])catch(bitmap 50 50 color:black gamma:1.0 hdr:false)
		
		MatEditor.Close()
		str = ""
		append str ("rollout Bitmaps " + "\"" + "Bitmaps" + "\"" + "width:1000\n" + "(\n")
		
		for i = 1 to selection[1].material.materialList.count where selection.count > 0 do
		(
			path_pic = (getMaterialThumbnail (selection[1].material.materialList[i]) ("C:\\temp\\pic" + i as string + ".png")).filename as string
			if i == 1 then append str ("imgtag img_" + i as string + " " + "\"" + "\"" + " " + "bitmap: @" + "\"" + doubleslash path_pic + "\"" + " width:50 height:50 style:#bmp_stretch across:" + (selection[1].material.materialList.count) as string + "\n")
			else append str ("imgtag img_" + i as string + " " + "\"" + "\"" + " " + "bitmap: @" + "\"" + doubleslash path_pic + "\"" + " width:50 height:50 style:#bmp_stretch \n" )
		)
		for i = 1 to b.count do 
		(
			if i/10 != (i/10 as integer) then append str ("dropdownlist material_id" + i as string + " " + "\""  + "ID" + i as string + "\"" + " items: (for i in (selection[1].material.materialIDList) collect i as string) width:40 across:2 selection:" + i as string + " \n" + "imgtag img_tag" + i as string + " " + "\""+"\"" + " " + "bitmap: @" + "\"" + doubleslash (b[i].filename as string) + "\"" + " width:50 height:50 style:#bmp_stretch \n")
			if i/10 == (i/10 as integer) then append str ("dropdownlist material_id" + i as string + " " + "\""  + "ID" + i as string + "\"" + " items: (for i in (selection[1].material.materialIDList) collect i as string) width:40 across:20 selection:" + i as string + " \n" + "imgtag img_tag" + i as string + " " + "\""+"\"" + " " + "bitmap: @" + "\"" + doubleslash (b[i].filename as string) + "\"" + " width:50 height:50 style:#bmp_stretch \n")		
		)
		append str ("button btn_cr " + "\"" + "Create material and object" + "\"" + "\n")
		append str (")\n")
		append str ("createDialog Bitmaps\n")
		
		print str
		execute (str)
		
		--rollout Bitmaps "Bitmaps" 
		--(
			
			--dropdownlist material_id1 "ID1" items: (for i in (meditMaterials[1].originalMaterial.materialIDList) collect i as string) across:2
			--imgtag img_mat1 "ID1 Diffuse" bitmap:d1 align:#left width:50 height:50 style:#bmp_stretch  
			--imgtag img_mat2 "ID2 Diffuse" bitmap:d2 align:#left width:50 height:50 style:#bmp_stretch  
			
			--imgtag img_tag1 "1001 Diffuse" bitmap:b1 align:#left width:50 height:50 style:#bmp_stretch 
			--imgtag img_tag1n "1001 Normal" bitmap:b1n align:#left width:50 height:50 style:#bmp_stretch 			
			--imgtag img_tag1e "1001 ERM" bitmap:b1e align:#left width:50 height:50 style:#bmp_stretch 	
			
			--imgtag img_tag2 "1002 Diffuse" bitmap:b2 align:#left width:50 height:50 style:#bmp_stretch  
			
			--dropdownlist material_id2 "ID2" items: (for i in (meditMaterials[1].originalMaterial.materialIDList) collect i as string) across:2
			--imgtag img_tag2 "1002 Diffuse" bitmap:b2 align:#left width:50 height:50 style:#bmp_stretch
			--button btn_cr "Create material and object"
			--on img_tag1 mousedown do ()
		--)
		--createDialog Bitmaps
		
		--on btn_cr pressed do
		--(
			--makeit material_id i .selected f[i] f_norm[i] f_erm[i]
		--)
	)
*/	
	
	on btn_multimat_table pressed do
	(
		global sel = if selection.count > 0 then selection[1].name else "None"

		try(destroyDialog ::BitmapsFL)catch()
		try(closeRolloutFloater BitmapsFL)catch()
		BitmapsFL = newRolloutFloater "Bitmaps" 1000 800
		rollout Controls "Controls" autoLayoutOnResize:true width:1000 height:800
		(
			progressbar pb width:950 height:8
			edittext edt_tex "Textures Path: " width:800 fieldWidth:800 across:2 text: udims.edt_multimat_path.text --text:(maxFilePath + "Images\\")
			button bnt_getpath "<- Open Path" align:#right Tooltip:"<- Открыть путь | <- Open Path"
			edittext edt_obj "Selected object: " width:800 fieldWidth:800 text:sel across:2 Tooltip:"Выбранный объект: | Selected object: "
			button bnt_getobj "<- Get Selected" align:#right Tooltip:"<- Взять выранное | <- Get Selected"
			label lb_status "Status: Ready" width:800 style_sunkenedge:true align:#left Tooltip:"Статус | Status"
			button btn_all "All Pictures" width:200 across:4 Tooltip:"Все текстуры | All Pictures"
			button btn_err "Open Errors" width:200 Tooltip:"Ошибки открывания текстур | Open Errors in textures"
			button bnt_low "Only Lowpoly" width:200 Tooltip:"Только текстуры для НПМ | Only Lowpoly textures"
			button bnt_hi "Only Highpoly" width:200 Tooltip:"Только текстуры для ВПМ | Only Highpoly textures"
			
			on Controls open do 
			(
				gc()
			)
			
			on Controls close do
			(
				gc()	
			)
			
			on bnt_getpath pressed do
			(
				edt_tex.text = getSavePath caption:"Select Folder ..." initialDir: maxFilePath
				edt_tex.text += "\\"
			)
			
			on bnt_getobj pressed do 
			(
				sel = if selection.count > 0 then selection[1].name else "None" 
				edt_obj.text = sel
			)				
			
			on btn_all pressed do
			(
				lb_status.text = "Status: Open files"
				f = #()
				f = getFiles (edt_tex.text + "*.png")
				join f (getFiles (edt_tex.text + "*.jpg"))
				join f (getFiles (edt_tex.text + "*.jpeg"))
				join f (getFiles (edt_tex.text + "*.psd"))	
				b = for i in f collect #((try(openBitMap i)catch("undefined")), i)
				--print b
				
				try (removeRollout Bitmaps)catch()
				--try(destroyDialog ::Bitmaps)catch()
				
				if b != undefined then
					if b.count > 0 then
					(
						lb_status.text = "Status: Arrange layout"
						pb.value = 0.0
						str = ""
						append str ("rollout Bitmaps " + "\"" + "Bitmaps" + "\"" + " autoLayoutOnResize:true width:1000 height:800\n" + "(\n")
						
						for i = 1 to b.count do 
						(
							if b[i][1] != undefined then
							(
								append str ("imgtag img_tag" + i as string + " bitmap: @" + "\"" + doubleslash (b[i][1].filename as string) + "\"" + " width:40 height:40 across:2 style:#bmp_stretch \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n")
								--"label lbn" + i as string + " " + "\"" + i as string + "\"" + " width:50 height:40 align:#left across:3\n
							)
							else
							(			
								append str ("label lb" + i as string + "\"" + "Error Open file" + "\"" + " width:50 height:40 color:red align:#left across:2 \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n") 
							)	
							pb.value = (i as float)/(b.count as float)*100
						)
						for i = 1 to b.count do 
						(
							if b[i][1] != undefined then
							(	
								append str ("on img_tag" + i as string + " mousedown do (display (openBitMap (" + "\"" + doubleslash (b[i][1].filename as string) + "\"" + ")))\n")
							)
						)

						append str (")\n")
						append str ("addRollout Bitmaps BitmapsFL\n")

						--print str
						pb.value = 100.0
						lb_status.text = "Status: Create rollout, wait..."
						execute (str)
						
					)
				lb_status.text = "Status: Ready"
			)
			
			on btn_err pressed do
			(
				lb_status.text = "Status: Open files"
				f = getFiles (edt_tex.text + "*.png") 
				b = for i in f collect #((try(openBitMap i)catch("undefined")), i)
				try (removeRollout Bitmaps)catch()
				
				if b != undefined then
					if b.count > 0 then
					(
						lb_status.text = "Status: Arrange layout"
						pb.value = 0.0
						str = ""
						append str ("rollout Bitmaps " + "\"" + "Bitmaps" + "\"" + " autoLayoutOnResize:true width:1000 height:800\n" + "(\n")
						
						for i = 1 to b.count where b[i][1] == undefined do 
						(
							append str ("label lb" + i as string + "\"" + "Error Open file" + "\"" + " width:50 height:40 color:red align:#left across:2 \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n") 
							pb.value = (i as float)/(b.count as float)*100
						)
						append str (")\n")
						append str ("addRollout Bitmaps BitmapsFL\n")

						--print str
						lb_status.text = "Status: Create rollout, wait..."
						pb.value = 100.0
						execute (str)
					)
				lb_status.text = "Status: Ready"
			)
			
			on bnt_low pressed do
			(
				
			)
				
			on bnt_hi pressed do
			(
				gc()
				sel = if selection.count > 0 then selection[1].name else "None" 
				edt_obj.text = sel
				max modify mode
				selmod = modpanel.getcurrentobject()
				if selection.count == 1 and selmod != undefined and ((superclassof selmod == GeometryClass) or (superclassof selmod == Value) or (classof selmod == Unwrap_UVW)) then
				(
					del = false
					dirname_udim = edt_tex.text + "UVs\\" + edt_obj.text + "\\"
					filename_udim = dirname_udim + edt_obj.text + "_udims.png"
					fd_uvs = #()
					fd_uvs_all = #()
					fd_d = #()
					fd_n = #()
					fd_e = #()
					fd_d_udims = #() 
					fd_n_udims = #() 
					fd_e_udims = #()
					fd_u_udims = #()
					
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						del = true
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						lb_status.text = "Status: Searching for UDIMs"
						makedir dirname_udim
						old_files = #()
						old_files = getfiles (dirname_udim + "*.*")
						if old_files.count > 0 then 
							for file in old_files where doesfileexist file do deletefile file
						--print filename_udim
						unwrapmod.renderuv_width = 200
						unwrapmod.renderuv_height = 200
						--unwrapmod.renderuv_edgeColor : color
						--unwrapmod.renderuv_edgealpha : float
						--unwrapmod.renderuv_seamColor : color
						unwrapmod.renderuv_visibleedges = true
						unwrapmod.renderuv_invisibleedges = false
						unwrapmod.renderuv_seamedges = true
						unwrapmod.renderuv_showframebuffer = false
						--unwrapmod.renderuv_force2sided : boolean
						unwrapmod.renderuv_fillmode = 0 --нормальный показ
						--unwrapmod.renderuv_fillalpha : float
						--unwrapmod.renderuv_fillColor : color
						unwrapmod.renderuv_showoverlap = true
						--unwrapmod.renderuv_overlapColor : color
						unwrapmod.edit()
						unwrapmod.fit() 
						--unwrapmod.displayMap = true
						unwrapmod.showTileGridlines = true
						unwrapmod.DisplayPixelUnits = true
						unwrapmod.renderUV filename_udim 
						unwrapmod.renderUVDialog()
	
						--select from dropdownlist all tiles
						for o in UIAccessor.GetChildWindows 0 where (t = UIAccessor.GetWindowText o) != undefined and t == "Render UVs" do
						(
							cc = for c in (windows.getChildrenHWND o) where c[4] == "ComboBox" and c[5] == "Default" collect c[1]
							local CB_SHOWDROPDOWN = 0x014F
							local CB_SETCURSEL = 0x014E 
							local WM_LBUTTONDOWN = 0x0201
							local WM_LBUTTONUP = 0x0202
							windows.sendMessage cc[1] CB_SHOWDROPDOWN 1 0 -- Open combobox dropdown
							windows.sendMessage cc[1] CB_SETCURSEL 1 0 -- Select 2th item
							windows.sendMessage cc[1] WM_LBUTTONDOWN 0 -1  -- Press left mouse button
							windows.sendMessage cc[1] WM_LBUTTONUP 0 -1  -- Raise left mouse button
							windows.sendMessage cc[1] CB_SHOWDROPDOWN 0 0    -- Close dropdown
							--press render button
							UIAccessor.pressButton ((for c in (windows.getChildrenHWND o) where (c[5] == "Render UV Template") collect c)[1])[1]  
						)
						--close dialog
						for o in UIAccessor.GetChildWindows 0 where (t = UIAccessor.GetWindowText o) != undefined and t == "Render UVs" do UIAccessor.CloseDialog o
						
						fd_uvs = getFiles (dirname_udim + "*.png") 					
						--fd_uvs = getFiles (dirname_udim + "_udims*.png") 
						--fd_uvs = getFiles (dirname_udim + "*_udims_U*_V*.png")
						if fd_uvs.count != 0 then
						(
							--print fd_uvs
							for i in fd_uvs where findstring i "udims.png" != undefined do deletefile i
							for i in fd_uvs where findstring i "udims.png" == undefined do renamefile i (uv_file_rename i) --print (uv_file_rename i) 
						)
						--print fd_uvs
					)
					if del then deletemodifier selection[1] 1
					
					lb_status.text = "Status: Parsing name"
					err = 0
					nm = edt_obj.text
					if findstring nm "SM_" == undefined then err += 1
					if findstring nm "_" == undefined then err += 1
					if findstring nm "_Main" == undefined and findstring nm "_Ground" == undefined then err += 1
					if findstring nm "UCX_" != undefined then err += 1	
					if findstring nm "Glass" != undefined then err += 1	
					if err != 0 then lb_status.text = "Status: Name Error, no need textures for this name"
					
					nm = substitutestring nm "_Main" ""
					--nm = substitutestring nm "_Ground" ""
					-- еще номера окс
					
					nm = substitutestring nm "SM_" "T_"
					print nm

					lb_status.text = "Status: Getting files"
					--fd_d = getFiles (edt_tex.text + nm + "*Diffuse*" + ".png")
					--print #(fd_d)
					fd_d = for f in (getFiles (edt_tex.text + nm + "*Diffuse*" + ".png")) where check_file f collect f
					fd_n = for f in (getFiles (edt_tex.text + nm + "*Normal*" + ".png")) where check_file f collect f
					fd_e = for f in (getFiles (edt_tex.text + nm + "*ERM*" + ".png")) where check_file f collect f
					--fd_uvs = getFiles (dirname_udim + "*.png")
					fd_uvs = for f in (getFiles (dirname_udim + "*.png")) where check_file_uv f collect f
					fd_uvs_all = getFiles (dirname_udim + "*.png")
						
					print #(fd_d)
					print #(fd_n)
					print #(fd_e)	
					sort fd_uvs
					print #(fd_uvs)

					if fd_d.count > 0 then fd_d_udims = for file in fd_d collect ((filterstring file ".")[(filterstring file ".").count - 1]) as integer
					if fd_n.count > 0 then fd_n_udims = for file in fd_n collect ((filterstring file ".")[(filterstring file ".").count - 1]) as integer
					if fd_e.count > 0 then fd_e_udims = for file in fd_e collect ((filterstring file ".")[(filterstring file ".").count - 1]) as integer
					if fd_uvs.count > 0 then fd_u_udims = for file in fd_uvs collect ((filterstring file ".")[(filterstring file ".").count - 1]) as integer
						
					if fd_d_udims != #() then sort fd_d_udims
					if fd_n_udims != #() then sort fd_n_udims
					if fd_e_udims != #() then sort fd_e_udims
					if fd_u_udims != #() then sort fd_u_udims
						
					print #(fd_d_udims)
						
					udims_err = 0
					if fd_d_udims != #() then if fd_d_udims.count > 0 then udims_err += if fd_d_udims.count != (fd_d_udims[fd_d_udims.count] - 1000) then 1 else 0
					if fd_n_udims != #() then if fd_n_udims.count > 0 then udims_err += if fd_n_udims.count != (fd_n_udims[fd_n_udims.count] - 1000) then 1 else 0
					if fd_e_udims != #() then if fd_e_udims.count > 0 then udims_err += if fd_e_udims.count != (fd_e_udims[fd_e_udims.count] - 1000) then 1 else 0
					if fd_u_udims != #() then if fd_u_udims.count > 0 then udims_err += if fd_u_udims.count != (fd_u_udims[fd_u_udims.count] - 1000) then 1 else 0
						
					if fd_d_udims.count == fd_n_udims.count == fd_e_udims.count == fd_u_udims.count == 0 then messagebox ("No textures found,\ncheck path!")
					
					if fd_d_udims != #() then 
						for u = 1 to fd_d_udims.count do
						(
							if (u + 1000) != fd_d_udims[u] then udims_err += 1
							--format "% + 1000  == %\n" u fd_d_udims[u]
						)
						
					if fd_n_udims != #() then for u = 1 to fd_n_udims.count do
					(
						if (u + 1000) != fd_n_udims[u] then udims_err += 1
						--format "% + 1000  == %\n" u fd_n_udims[u]
					)
						
					if fd_e_udims != #() then for u = 1 to fd_e_udims.count do
					(
						if (u + 1000) != fd_e_udims[u] then udims_err += 1
						--format "% + 1000  == %\n" u fd_e_udims[u]
					)
						
					if fd_u_udims != #() then for u = 1 to fd_u_udims.count do
					(
						if (u + 1000) != fd_u_udims[u] then udims_err += 1
						--format "% + 1000  == %\n" u fd_e_udims[u]
					)						

					if udims_err != 0 then lb_status.text = "Status: Textures numbers UDIMs error" else lb_status.text = "Status: Textures numbers UDIMs OK"
					print udims_err

					b = #()
					b_n = #()
					b_e = #()
					b_u = #()
					
					if fd_d_udims != #() then b = for i in fd_d_udims collect #((try(openBitMap (for t in fd_d where (findstring (getfilenamefile t + getfilenametype t) (i as string)) != undefined do exit with t))catch(undefined)), i, i)
					if fd_n_udims != #() then b_n = for i in fd_n_udims collect #((try(openBitMap (for t in fd_n where (findstring (getfilenamefile t + getfilenametype t) (i as string)) != undefined do exit with t))catch(undefined)), i, i)
					if fd_e_udims != #() then b_e = for i in fd_e_udims collect #((try(openBitMap (for t in fd_e where (findstring (getfilenamefile t + getfilenametype t) (i as string)) != undefined do exit with t))catch(undefined)), i, i)
					if fd_u_udims != #() then b_u = for i in fd_u_udims collect #((try(openBitMap (for t in fd_uvs where (findstring (getfilenamefile t + getfilenametype t) (i as string)) != undefined do exit with t))catch(undefined)), i, i)
						
					--if fd_d_udims != #() then b = for i = 1 to fd_d.count where (findItem fd_d_udims (i + 1000)) != 0 collect #((try(openBitMap fd_d[i])catch(undefined)), i, fd_d_udims[findItem fd_d_udims (i + 1000)])
					--if fd_n_udims != #() then b_n = for i = 1 to fd_n.count where (findItem fd_n_udims (i + 1000)) != 0 collect #((try(openBitMap fd_n[i])catch(undefined)), i, fd_n_udims[findItem fd_n_udims (i + 1000)])
					--if fd_e_udims != #() then b_e = for i = 1 to fd_e.count where (findItem fd_e_udims (i + 1000)) != 0 collect #((try(openBitMap fd_e[i])catch(undefined)), i, fd_e_udims[findItem fd_e_udims (i + 1000)])
					--if fd_u_udims != #() then b_u = for i = 1 to fd_uvs.count where (findItem fd_u_udims (i + 1000)) != 0 collect #((try(openBitMap fd_uvs[i])catch(undefined)), i, fd_u_udims[findItem fd_u_udims (i + 1000)])
						
					with PrintAllElements on print #(b)
					with PrintAllElements on print #(b_n)
					with PrintAllElements on print #(b_e)
					with PrintAllElements on print #(b_u)	
							
					with PrintAllElements on print #(fd_uvs)
					with PrintAllElements on print #(fd_u_udims)	

					str = ""
					append str ("rollout Bitmaps " + "\"" + "Highpoly Bitmaps" + "\"" + " autoLayoutOnResize:true width:1000 height:800\n" + "(\n")
						
					fd_udims_nums = #()
					join fd_udims_nums fd_d_udims
					join fd_udims_nums fd_n_udims
					join fd_udims_nums fd_e_udims
					join fd_udims_nums fd_u_udims	
					makeUniqueArray fd_udims_nums
					fd_udims_nums_new = #()
					for f in fd_udims_nums do appendIfUnique fd_udims_nums_new f
							
					fd_udims_num = 0
					if fd_udims_nums.count > 0 then fd_udims_num += amax fd_udims_nums	
					with PrintAllElements on print #(fd_udims_nums_new)
					--print (fd_udims_num)
					--fd_d_udims_num = amax (for i in fd_d_udims collect i)
					--fd_n_udims_num = amax (for i in fd_n_udims collect i)
					--fd_e_udims_num = amax (for i in fd_e_udims collect i)
					--fd_udims_num = amax #(fd_d_udims_num, fd_n_udims_num, fd_e_udims_num)
						
					cou = 0
					udim_count = 1000
					udim_count_old = 0
					if fd_udims_nums_new != 0 then
					(
						sort fd_udims_nums_new
						for i in fd_udims_nums_new do  --for i = 1001 to fd_udims_num do 
						(							
							cou += 1
							udim = i as integer 
							--print i		
							
							if i < 1001 then 
							(
								if cou == 1 then append str ("label lbn_udim_out" + cou as string + i as string + " " + "\"" + "Found errors overlaps in UVs UDIMS, see UNWRAP UV EDITOR for details" + "\"" + " width:800 height:20 align:#left offset:[0,0] style_sunkenedge:true \n")
								continue	
							)
							
							if fd_uvs.count != fd_uvs_all.count then --есть другие развертки 
							(
								if cou == 1 then 
								(
									append str ("label lbn_udim_out" + cou as string + i as string + " " + "\"" + "Found errors in UVs UDIMS: " + abs (fd_uvs.count - fd_uvs_all.count) as string + ", see UNWRAP UV EDITOR for details" + "\"" + " width:800 height:20 align:#left offset:[0,0] style_sunkenedge:true \n")
									continue
								)									
							)
							udim_count += 1
							udim_count_old = udim							
							if udim_count != udim_count_old then -- обозначение пропусков юдимов
							(
								append str ("label lbn_udim_err_order" + cou as string + i as string + " " + "\"" + "There are missed udims between these" + "\"" + " width:800 height:20 align:#left offset:[0,0] style_sunkenedge:true \n")
								udim_count = udim_count_old = i
							)

							append str ("label lbn_udim" + cou as string + i as string + " " + "\"" + udim as string + "\"" + " width:50 height:200 align:#left across:5 offset:[0,0] style_sunkenedge:true \n")
								
							for a in b_u where a[3] == udim do  
							(
								if a[1] != undefined then
								(
									--print #(a)
									--append str ("imgtag img_tag_d" + i as string + " bitmap: (bitmap 200 200 gamma:1.0 hdr:false alpha:true filename:@" + "\"" + (doubleslash (a[1].filename as string)) + "\"" + ") width:200 height:200 style:#bmp_stretch \n")
									--(bitmap 200 200 gamma:1.0 hdr:false alpha:true filename:(doubleslash (a[1].filename as string)))
									append str ("imgtag img_tag_u" + cou as string  + i as string + " bitmap: @" + "\"" + doubleslash (a[1].filename as string) + "\"" + " width:200 height:200 style:#bmp_stretch \n")
									--	" \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n")
									--"label lbn" + i as string + " " + "\"" + i as string + "\"" + " width:50 height:40 align:#left across:3\n
								)
								else append str ("label lbn_u" + cou as string + i as string + " " + "\"" + "error: " + i as string + "\"" + " width:200 height:20 offset:[0,0] style_sunkenedge:true \n")
							)
							if (for a in b_u where a[3] == udim collect a).count == 0 then append str ("label lbn_u_err" + cou as string + i as string + " " + "\"" + "none: " + i as string + "\"" + " width:200 height:200 offset:[0,0] style_sunkenedge:true \n")

							for a in b where a[3] == udim do 
							(
								--print #(a)
								if a[1] != undefined then
								(
									--append str ("imgtag img_tag_d" + i as string + " bitmap: (bitmap 200 200 gamma:1.0 hdr:false alpha:true filename:@" + "\"" + (doubleslash (a[1].filename as string)) + "\"" + ") width:200 height:200 style:#bmp_stretch \n")
									--(bitmap 200 200 gamma:1.0 hdr:false alpha:true filename:(doubleslash (a[1].filename as string)))
									append str ("imgtag img_tag_d" + cou as string + i as string + " bitmap: @" + "\"" + doubleslash (a[1].filename as string) + "\"" + " width:200 height:200 style:#bmp_stretch \n")
									--	" \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n")
									--"label lbn" + i as string + " " + "\"" + i as string + "\"" + " width:50 height:40 align:#left across:3\n
								)
								else append str ("label lbn_d" + cou as string + i as string + " " + "\"" + "error: " + i as string + "\"" + " width:200 height:20 offset:[0,0] style_sunkenedge:true \n")
							)
							if (for a in b where a[3] == udim collect a).count == 0 then append str ("label lbn_d_err" + cou as string + i as string + " " + "\"" + "none: " + i as string + "\"" + " width:200 height:200 offset:[0,0] style_sunkenedge:true \n")

							for a in b_n where a[3] == udim do 
							(
								--print #(a)
								if a[1] != undefined then
								(
									append str ("imgtag img_tag_n" + cou as string + i as string + " bitmap: @" + "\"" + doubleslash (a[1].filename as string) + "\"" + " width:200 height:200 style:#bmp_stretch \n")
								)
								else
								(
									append str ("label lbn_n" + cou as string + i as string + " " + "\"" + "error: " + i as string + "\"" + " width:200 height:20 style_sunkenedge:true \n")
								)
							)	
							if (for a in b_n where a[3] == udim collect a).count == 0 then append str ("label lbn_n_err" + cou as string + i as string + " " + "\"" + "none: " + i as string + "\"" + " width:200 height:200 offset:[0,0] style_sunkenedge:true \n")

							for a in b_e where a[3] == udim do 
							(
								--print #(a)
								if a[1] != undefined then
								(
									append str ("imgtag img_tag_e" + cou as string + i as string + " bitmap: @" + "\"" + doubleslash (a[1].filename as string) + "\"" + " width:200 height:200 style:#bmp_stretch align:#right \n")
									--	" \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n")
									--"label lbn" + i as string + " " + "\"" + i as string + "\"" + " width:50 height:40 align:#left across:3\n
								)
								else
								(
									append str ("label lbn_e" + cou as string + i as string + " " + "\"" + "error: " + i as string + "\"" + " width:200 height:20 align:#right style_sunkenedge:true \n")
								)
							)	
							if (for a in b_e where a[3] == udim collect a).count == 0 then append str ("label lbn_e_err" + cou as string + i as string + " " + "\"" + "none: " + i as string + "\"" + " width:200 height:200 offset:[0,0] style_sunkenedge:true \n")
								
							--append str ("label lbn_udim_o" + cou as string + i as string + " " + "\"" + i as string + "\"" + " width:50 height:20 align:#left across:5 offset:[0,0] style_sunkenedge:true \n")
							append str ("label lbn_udim_o" + cou as string + i as string + " " + "\"" + " " + "\"" + " width:50 height:20 align:#left across:5 offset:[0,0] style_sunkenedge:false \n")

							append str ("label lbn_udim_uv" + cou as string + i as string + " " + "\"" + (udim_to_uv_num i) as string + "\"" + " width:180 height:20 align:#left offset:[0,0] style_sunkenedge:true \n")
								
							for a in b where a[3] == udim do append str ("edittext edt_bitmap_d" + cou as string + i as string + " width:180 fieldWidth:180 offset:[0,0] text: " + "\"" + (getfilenamefile a[1].filename) as string + "\"" + "\n")
							if (for a in b where a[3] == udim collect a).count == 0 then append str ("label lbn_d_err_path" + cou as string + i as string + " " + "\"" + "none" + "\"" + " width:180 fieldWidth:180 style_sunkenedge:true \n")
								
							for a in b_n where a[3] == udim do append str ("edittext edt_bitmap_n" + cou as string + i as string + " width:180 fieldWidth:180 offset:[0,0] text: " + "\"" + (getfilenamefile a[1].filename)  as string + "\"" + "\n")
							if (for a in b_n where a[3] == udim collect a).count == 0 then append str ("label lbn_n_err_path" + cou as string + i as string + " " + "\"" + "none" + "\"" + " width:180 fieldWidth:180 style_sunkenedge:true \n")
							
							for a in b_e where a[3] == udim do append str ("edittext edt_bitmap_e" + cou as string + i as string + " width:180 fieldWidth:180 offset:[0,0] align:#right text: " + "\"" + (getfilenamefile a[1].filename) as string + "\"" + "\n")
							if (for a in b_e where a[3] == udim collect a).count == 0 then append str ("label lbn_e_err_path" + cou as string + i as string + " " + "\"" + "none" + "\"" + " width:180 fieldWidth:180 style_sunkenedge:true \n")

							append str ("label lbn_udim_oo" + cou as string + i as string + " " + "\"" + " " + "\"" + " width:50 height:20 align:#left across:5 offset:[0,0] style_sunkenedge:false \n")
							append str ("label lbn_udim_uvv" + cou as string + i as string + " " + "\"" + udim as string + "\"" + " width:180 height:20 align:#left offset:[0,0] style_sunkenedge:true \n")
							for a in b where a[3] == udim do append str ("label lbn_udim_size_b" + cou as string + i as string + " " + "\"" + getsize a[1] + "\"" + " width:180 fieldWidth:180 offset:[0,0] style_sunkenedge:true \n")
							for a in b_n where a[3] == udim do append str ("label lbn_udim_size_n" + cou as string + i as string + " " + "\"" + getsize a[1] + "\"" + " width:180 fieldWidth:180 offset:[0,0] style_sunkenedge:true \n")
							for a in b_e where a[3] == udim do append str ("label lbn_udim_size_e" + cou as string + i as string + " " + "\"" + getsize a[1] + "\"" + " width:180 fieldWidth:180 offset:[0,0] style_sunkenedge:true align:#right \n")
							
							--(			
							--	append str ("label lb" + i as string + "\"" + "Error Open file" + "\"" + " width:50 height:40 color:red align:#left across:3 \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n") 
							--)	

							pb.value = (i as float)/(b.count as float)*100
						)
							
						--for i = 1 to b.count do 
						--(
						--	if b[i][1] != undefined then
						--	(	
						--		append str ("on img_tag" + i as string + " mousedown do (display (openBitMap (" + "\"" + doubleslash (b[i][1].filename as string) + "\"" + ")))\n")
						--	)
						--)

						append str (")\n")
						append str ("addRollout Bitmaps BitmapsFL\n")

						--print str
						pb.value = 100.0
						lb_status.text = "Status: Create rollout, wait..."
						execute (str)	
						lb_status.text = "Status: Done"
					)							
				)
				else
				(
					messagebox ("Select single Editable Poly object to find its textures...")
				)
			)
		)
		addRollout Controls BitmapsFL
	)
	
	on btn_name_from_sel pressed do
	(
		if selection.count > 0 then
		(
			edt_object_name.text = selection[1].name
			edt_tex_diffuse_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_Diffuse_1." + (spn_tex_udim.value as string) + ".png"
			edt_tex_diffuse_name.text = (substitutestring edt_tex_diffuse_name.text "_Main" "")
			edt_tex_normal_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_Normal_1." + (spn_tex_udim.value as string) + ".png"
			edt_tex_normal_name.text = (substitutestring edt_tex_normal_name.text "_Main" "")
			edt_tex_erm_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_ERM_1." + (spn_tex_udim.value as string) + ".png"
			edt_tex_erm_name.text = (substitutestring edt_tex_erm_name.text "_Main" "")
			
			edt_object_addr.text = (substitutestring edt_object_name.text "SM_" "")
			tt = filterstring edt_object_name.text "_"
			if tt.count > 1 then
			(
				edt_object_addr.text = ""
				for t = 1 to tt.count do 
				(
					if tt[t] == "SM" or tt[t] == "M" or tt[t] == "T" then continue
					if (for t1 = 1 to tt.count where tt[t1] == "77" collect tt[t1]).count == 0  and tt[t] == "001" or tt[t] == "002" or tt[t] == "003" or tt[t] == "004" or tt[t] == "005" then continue	
					if tt[t] == "Main" then continue
					if tt[t] == "Ground" then continue
					if tt[t] == "GroundEl" then continue						
					if tt[t] == "Flora" then continue
					if tt[t] == "Glass" or tt[t] == "MainGlass" or tt[t] == "GroundGlass" or tt[t] == "GroundElGlass" then continue	
					if edt_object_addr.text != "" then edt_object_addr.text += "_"
					edt_object_addr.text += tt[t]
				)
			)
		)
	)		
	
	on spn_tex_udim changed val do 
	(
		edt_tex_diffuse_name.text = (filterstring edt_tex_diffuse_name.text ".")[1] + "." + (val as string) + "." + (filterstring edt_tex_diffuse_name.text ".")[3]
		edt_tex_normal_name.text = (filterstring edt_tex_normal_name.text ".")[1] + "." + (val as string) + "." + (filterstring edt_tex_normal_name.text ".")[3]		
		edt_tex_erm_name.text = (filterstring edt_tex_erm_name.text ".")[1] + "." + (val as string) + "." + (filterstring edt_tex_erm_name.text ".")[3]			
	)
	
	on btn_rename pressed do
	(
		--f = getFiles (edt_multimat_path.text + "*Diffuse*.png")
		--f_norm = getFiles (edt_multimat_path.text + "*Normal*.png")	
		--f_erm = getFiles (edt_multimat_path.text + "*ERM*.png")
		--f_new = for i in #{1..(f_other.count)} where (for i2 in #{1..(f.count)} where f_other[i] == f[i2] collect f[i2]).count == 0 and (for i3 in #{1..(f_norm.count)} where f_other[i] == f_norm[i3] collect f_norm[i3]).count == 0 and (for i4 in #{1..(f_erm.count)} where f_other[i] == f_erm[i4] collect f_erm[i4]).count == 0 collect f_other[i]
		ctrl = if keyboard.controlPressed then true else false
		f_other = if ctrl then getFiles (edt_multimat_path.text + "*.*") else getFiles (edt_multimat_path.text + "*.png")
		
		for i in f_other do 
		(
			renamefile i (substitutestring i edt_tex_find.text edt_tex_rename.text) 
		)
	)
	
	on btn_rename rightclick do
	(
		ctrl = keyboard.controlPressed
		alt = keyboard.altPressed
		if ctrl then 
		(
			for mat in scenematerials where classof mat == material or superClassOf mat == material do mat.name = substitutestring mat.name edt_tex_find.text edt_tex_rename.text
			for c in material.classes where c.creatable do 
				for mat in (getClassInstances c processAllAnimatables:true) do 
				(
					mat.name = substitutestring mat.name edt_tex_find.text edt_tex_rename.text	
				)
		)
		
		if alt then 
		(
			texmaps = (GetBitmapTextures selection edt_tex_find.text edt_tex_rename.text)
			print #(texmaps)
			texmaps_paths = (GetBitmapTextures_Paths selection edt_tex_find.text edt_tex_rename.text)
			print #(texmaps_paths)	
		)
		
		if not ctrl and not alt then for i in selection do i.name = substitutestring i.name edt_tex_find.text edt_tex_rename.text
	)
	
	on btn_make_tex_diffuse pressed do 
	(
		rez = case rdo_tex.state of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)			
		filename = edt_multimat_path.text + edt_tex_diffuse_name.text
		
		if not doesDirectoryExist edt_multimat_path.text then makeDir edt_multimat_path.text
		
		b = bitmap rez rez filename:filename color:color_diffuse.color gamma:1 hdr:false alpha:false
		save b gamma:1.0 quiet:true
		close b
		free b
		HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " -alpha remove -alpha off PNG24:" + "\"" + filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
		HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
	)
	
	on btn_make_tex_diffuse rightclick do
	(
		try (display (openbitmap (edt_multimat_path.text + edt_tex_diffuse_name.text)))catch()
	)	
	
	on btn_open_tex_diffuse pressed do 
	(
		ctrl = keyboard.controlPressed
		rez = case rdo_tex.state of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)
		filename = edt_multimat_path.text + edt_tex_diffuse_name.text
		print filename
		sourcepath = getOpenFileName "Select file for diffuse map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
		print sourcepath
		--выдает ошибку print (("convert " + "\"" + sourcepath + "\"" + " -resize " + (rez as string) + "x" + (rez as string) + "! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()))
		if sourcepath != undefined then
		(
			if doesfileexist filename then 
			(
				if queryBox ("перезаписать существующий файл:\n" + filename + "\n\nновым файлом:\n" + sourcepath) then
				(
					deleteFile filename
					if ctrl then 
					(
						resize_texture sourcepath filename rez rez
					)
					else
					(
						HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (rez as string) + "x" + (rez as string) + "^! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())	
					)
				)
			)
			else
			(
				if ctrl then 
				(
					resize_texture sourcepath filename rez rez
				)
				else
				(
					HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (rez as string) + "x" + (rez as string) + "^! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
					HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())	
				)
			)
		)
	)
	
	on btn_open_tex_diffuse rightclick do
	(
		HiddenDOSCommand ("explorer.exe /e,/select, " + "\"" + edt_multimat_path.text + edt_tex_diffuse_name.text + "\"")
	)

	on btn_make_tex_normal pressed do 
	(	
		rez = case rdo_tex.state of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)	
		filename = edt_multimat_path.text + edt_tex_normal_name.text
		if not doesDirectoryExist edt_multimat_path.text then makeDir edt_multimat_path.text
		b = bitmap rez rez filename:filename color:color_normal.color gamma:1.0 hdr:false
		save b gamma:1.0 quiet:true
		close b
		free b
		HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " -alpha remove -alpha off " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
		HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
	)

	on btn_make_tex_normal rightclick do
	(
		try (display (openbitmap (edt_multimat_path.text + edt_tex_normal_name.text)))catch()
	)
	
	on btn_open_tex_normal pressed do 
	(
		rez = case rdo_tex.state of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)
		filename = edt_multimat_path.text + edt_tex_normal_name.text
		sourcepath = getOpenFileName "Select file for normal map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
		print sourcepath
		if sourcepath != undefined then
		(
			if doesfileexist filename then 
			(
				if queryBox ("перезаписать существующий файл:\n" + filename "\n\nновым файлом:\n" + sourcepath) then
				(
					deleteFile filename
					if ctrl then 
					(
						resize_texture sourcepath filename rez rez
					)
					else
					(
						HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez + "x" + rez + "^! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())	
					)
				)
			)
			else
			(
				if ctrl then 
				(
					resize_texture sourcepath filename rez rez
				)
				else
				(
					HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez + "x" + rez + "^! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
					HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())	
				)
			)
		)
	)
	
	on btn_open_tex_normal rightclick do
	(
		HiddenDOSCommand ("explorer.exe /e,/select, " + "\"" + edt_multimat_path.text + edt_tex_normal_name.text + "\"")
	)	
	
	on btn_make_tex_erm pressed do 
	(
		rez = case rdo_tex.state of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)	
		filename = edt_multimat_path.text + edt_tex_erm_name.text
		if not doesDirectoryExist edt_multimat_path.text then makeDir edt_multimat_path.text
		b = bitmap rez rez filename:filename color:color_erm.color gamma:1.0 hdr:false
		save b gamma:1.0 quiet:true
		close b
		free b
		HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " -alpha remove -alpha off " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
		HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
	)	
	
	on btn_make_tex_erm rightclick do
	(
		try (display (openbitmap (edt_multimat_path.text + edt_tex_erm_name.text)))catch()
	)	
	
	on btn_open_tex_erm pressed do 
	(
		rez = case rdo_tex.state of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)
		filename = edt_multimat_path.text + edt_tex_erm_name.text
		sourcepath = getOpenFileName "Select file for ERM map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
		print sourcepath
		if sourcepath != undefined then
		(
			if doesfileexist filename then 
			(
				if queryBox ("перезаписать существующий файл:\n" + filename "\n\nновым файлом:\n" + sourcepath) then
				(
					deleteFile filename
					if ctrl then 
					(
						resize_texture sourcepath filename rez rez
					)
					else
					(
						HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez + "x" + rez + "^! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())	
					)
				)
			)
			else
			(
				if ctrl then 
				(
					resize_texture sourcepath filename rez rez
				)
				else
				(
					HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez + "x" + rez + "^! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
					HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())	
				)			
			)
		)
	)	
	
	on btn_open_tex_erm rightclick do
	(
		HiddenDOSCommand ("explorer.exe /e,/select, " + "\"" + edt_multimat_path.text + edt_tex_erm_name.text + "\"")
	)	
	
	on btn_Streets_List pressed do
	(
		gc()
		excel_file = GetDir #maxroot + "GeoScripts\\ul3.csv"
		excel_file2 = GetDir #maxroot + "GeoScripts\\ul4.csv"
		global dirs_select = #()
		dirs_select_ = #()
		
		stri_pr = #()
		stri_pr = ReadAllLines excel_file	
		stri_pr2 = #()
		stri_pr2 = ReadAllLines excel_file2	
		if stri_pr != "" and stri_pr2 != ""then
		(
			if stri_pr.count > 0 then dirs_select_ = for i in #{1..stri_pr.count} collect (filterstring stri_pr[i] ";" splitEmptyTokens:true)
			if stri_pr2.count > 0 then join dirs_select_ (for i in #{1..stri_pr2.count} collect #((filterstring stri_pr2[i] ";" splitEmptyTokens:true)[1], (filterstring stri_pr2[i] ";" splitEmptyTokens:true)[2], (filterstring stri_pr2[i] ";" splitEmptyTokens:true)[2] + (filterstring stri_pr2[i] ";" splitEmptyTokens:true)[3]))
			--print #(dirs_select_.count)
			for i in #{2..dirs_select_.count} where dirs_select_[i][1] != dirs_select_[i-1][1] do append dirs_select dirs_select_[i-1]
				append dirs_select dirs_select_[dirs_select_.count]
				--for j in #{1..dirs_select_.count} where j > i and dirs_select_[i][1] != dirs_select_[j][1] do append dirs_select dirs_select_[i]
			--print #(dirs_select.count)
					
			try(destroyDialog ::StreetsFL)catch()
			rollout StreetsFL "Streets List" --autoLayoutOnResize:true width:800 height:800 
			(
				fn autoResizeColumn lv columns: = 
				(
					vScrollWidth = 21 -- vertical scrollbar width
					for c = 0 to columns-1 do
					(
						lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
						vScrollWidth += lv.Columns.Item[c].Width
					) 
					vScrollWidth
				)
				
				fn PopulateList lv dirs_select =
				(
					lv.Items.Clear()
					lv.view = (dotNetClass "system.windows.forms.view").details
					lv.HideSelection = true 
					lv.HeaderStyle = (dotNetClass "System.Windows.Forms.ColumnHeaderStyle").clickable
					--lv.height = 390
					lv.FullRowSelect = true    
					lv.MultiSelect = false --true    
					lv.AllowColumnReorder = true
					lv.GridLines = true
					lv.checkBoxes = false --true 
					lv.Scrollable = true
					lv.ShowItemToolTips = true
					columnsAr = #("Street/Place Full Name                                        ", "Street/Place Short Name                   ", "Street/Place Translit Short Name             ")
					lv.columns.Clear()
					for i = 1 to 3 do lv.columns.add columnsAr[i] 0	
					lv.width = autoResizeColumn lv columns:3
					lv.width = 700
					--lv.Update()
					
					rows = #()
					for t = 1 to dirs_select.count do
					(
						li = dotNetObject "System.Windows.Forms.ListViewItem" (dirs_select[t][1])
						li.UseItemStyleForSubItems = true
						li.subitems.add dirs_select[t][2]
						li.subitems.add dirs_select[t][3]
						append rows li
					)
					lv.items.addRange rows
					--lv.Update()
					--lv.width = autoResizeColumn lv columns:3
					--lv.width = 700
					lv.Update()
				)
				
				dotNetControl lv "ListView" pos:[5,5] width:700 height:700 tooltip:""
				button btnSelect "Select and Paste" align:#left offset:[0,0] across:2 tooltip:"Select and Paste"
				button btnClose "Close" align: #right tooltip:"Close this dialog"

				on StreetsFL open do
				(  
					--gc()
					PopulateList lv dirs_select 
				)

				on btnSelect pressed do
				(
					for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected do
					(
						print (dirs_select[val+1][3])
						setclipboardText (dirs_select[val+1][3])
						UDIMs.edt_object_addr.text = (dirs_select[val+1][3]) 
					)
				)

				on btnClose pressed do
				(
					try(destroyDialog ::StreetsFL)catch()
					gc()
				)	
			)
			createDialog StreetsFL width:800 height:800 style:#(#style_titlebar, #style_border, #style_sysmenu, #style_resizing)	
		)
	)

	on btn_color_diffuse_ral pressed do
	(
		excel_file = GetDir #maxroot + "GeoScripts\\ral_classic.csv" -- getFilenamePath(getSourceFileName()) + "ral_classic.csv"
		global arr_excel = #()
		stri_pr = #()
		stri_pr = ReadAllLines excel_file	
		if stri_pr != "" then
			if stri_pr.count > 0 then
			(
				arr_excel = for i = 2 to stri_pr.count collect (filterstring stri_pr[i] ";," splitEmptyTokens:true)
				if arr_excel.count > 0 then for i=1 to arr_excel.count do for j=1 to arr_excel[i].count do arr_excel[i][j] = substitutestring arr_excel[i][j] "\"" ""
			)	
			global sel = #()
			str = ""
			append str ("rollout Bitmaps " + "\"" + "RAL Colors Palette" + "\"" + " autoLayoutOnResize:true width:400 height:800\n" + "(\n")
						
			for i = 1 to arr_excel.count do
			(
				append str ("imgtag img_" + i as string + " " + "\"" + arr_excel[i][1] + "\"" + " " + "bitmap: (bitmap 100 30 color: (color " + (substitutestring arr_excel[i][2] "-" " ") + ") gamma:1 hdr:false alpha:false)" + " width:100 height:30 style:#bmp_stretch across:2 \n" )
				append str ("button btn_" + i as string + " " + "\"" + arr_excel[i][1] + " [" + (substitutestring arr_excel[i][2] "-" ",") + "] " + arr_excel[i][5] + "\"" + "border: false width:250 height:30 align: #left offset: [-70,0] \n")
			)
			for i = 1 to arr_excel.count do
			(
				append str ("on img_" + i as string + " mousedown do ( UDIMs.color_diffuse.color = (color " + (substitutestring arr_excel[i][2] "-" " ") + "); try(closeRolloutFloater BitmapsFL)catch() )\n")
				append str ("on btn_" + i as string + " pressed do ( UDIMs.color_diffuse.color = (color " + (substitutestring arr_excel[i][2] "-" " ") + "); try(closeRolloutFloater BitmapsFL)catch() )\n")
		
			)
			append str (")\n")
			append str ("addRollout Bitmaps BitmapsFL\n")
			
			try(destroyDialog ::BitmapsFL)catch()
			try(closeRolloutFloater BitmapsFL)catch()
			BitmapsFL = newRolloutFloater "RAL Colors Palette" 400 800
			execute (str)

	)
	
	on btn_singlemat pressed do
	(
		f = #()
		f_norm = #()
		f_r = #()
		f_m = #()
		f_o = #()
		mm = edt_material_object_number.text
		ctrl = keyboard.controlPressed
		if ctrl and selection.count == 1 then
		(
			mm = substitutestring selection[1].name "Main" ""
			mm = substitutestring mm "SM_" "T_"
		)
		if edt_material_object_number.text != "Ground" and not ctrl then
		(
			f = getFiles (edt_multimat_path.text + "*" + mm + "*_d_*" + "*.png")
			f_norm = getFiles (edt_multimat_path.text + "*" + mm + "*_n_*" + "*.png")	
			f_r = getFiles (edt_multimat_path.text + "*" + mm + "*_r_*" + "*.png")			
			f_m = getFiles (edt_multimat_path.text + "*" + mm + "*_m_*" + "*.png")			
			f_o = getFiles (edt_multimat_path.text + "*" + mm + "*_o_*" + "*.png")	
		)
		else
		(
			f = getFiles (edt_multimat_path.text + "*" + mm + "_d_*" + "*.png")
			f_norm = getFiles (edt_multimat_path.text + "*" + mm + "_n_*" + "*.png")	
			f_r = getFiles (edt_multimat_path.text + "*" + mm + "_r_*" + "*.png")			
			f_m = getFiles (edt_multimat_path.text + "*" + mm + "_m_*" + "*.png")			
			f_o = getFiles (edt_multimat_path.text + "*" + mm + "_o_*" + "*.png")				
		)
		
		print #(f)	
		print #(f_norm)		
		print #(f_r)	
		print #(f_m)
		print #(f_o)		
		
		if f.count != 1 or f_norm.count != 1 or f_r.count != 1 or f_m.count != 1 or f.count != f_norm.count or f.count != f_r.count or f_norm.count != f_m.count then 
		(
			messageBox ("Some files are missing\n" + "Diffuse: " + (f.count as string) + "\n" + "Normal: " + (f_norm.count as string) + "\n" + "r: " + (f_r.count as string) + "m: " + (f_m.count as string) + "\n")
		)	
		case rdo_type_mat.state of
		(
			2:
			(
				if f.count == 1 then m = Physical_Material name:(substitutestring (substitutestring (getFilenameFile f[1]) "T_" "M_") "_d" "")
				if f.count == 1 then m.base_color_map = BitmapTexture fileName: f[1]
				if f_r.count == 1 then m.roughness_map = BitmapTexture fileName: f_r[1]
				if f_m.count == 1 then m.metalness_map = BitmapTexture fileName: f_m[1]					
				if f_norm.count == 1 then m.bump_map = BitmapTexture fileName: f_norm[1]	
				if f_o.count == 1 then m.cutout_map = BitmapTexture fileName: f_o[1]
			)
			1:
			(
				if f.count == 1 then m = Standard name:(substitutestring (substitutestring (getFilenameFile f[1]) "T_" "M_") "_d" "")
				if f != undefined then if f.count == 1 then if doesfileexist f[1] then m.DiffuseMap = BitmapTexture fileName: f[1]
				if f_norm != undefined then if f_norm.count == 1 then if doesfileexist f_norm[1] then m.BumpMap = BitmapTexture fileName: f_norm[1]
				if f_m != undefined then if f_m.count == 1 then if doesfileexist f_m[1] then m.ReflectionMap = BitmapTexture fileName: f_m[1]
				if f_r != undefined then if f_r.count == 1 then if doesfileexist f_r[1] then m.GlossinessMap = BitmapTexture fileName: f_r[1]
				if f_o != undefined then if f_o.count == 1 then if doesfileexist f_o[1] then m.OpacityMap = BitmapTexture fileName: f_o[1]
			)
		)
		
		if ctrl then selection[1].material = m
		else 
		(
			if selection.count == 1 then
			case of
			(
				(findstring edt_material_object_number.text "Ground" != undefined): meditMaterials[19] = m 
				(findstring edt_material_object_number.text "GroundEl" != undefined): meditMaterials[20] = m
				(findstring edt_material_object_number.text "Flora" != undefined): meditMaterials[21] = m
				default: meditMaterials[12 + (edt_material_object_number.text as integer)] = m
			)
			print m
				--if findstring edt_material_object_number.text "Ground" == undefined then meditMaterials[12 + (edt_material_object_number.text as integer)] = m
				--else 
				--(
				--	if findstring edt_material_object_number.text "GroundEl" != undefined then meditMaterials[20] = m else meditMaterials[19] = m 
				--)
		)
	)
	
	on btn_multimat rightclick do
	(
		/*
		-- create new MultiTile 
		mt = MultiTile()
		mt.tileCount()

		-- set Custom format
		mt.PatternFormat = #custom

		-- find any files to use:
		d = getdir #ui_ln 
		ff = getfiles (d + "\\*.bmp") recurse:on

		-- create Bitmaptexture and set as a tile texture 1
		bt1 = bitmaptexture filename:ff[1]
		mt.setTileTexmap 1 bt1
		tx1 = mt.getTileTexmap 1
		tx1.filename

		-- add new tile slot:
		mt.addTile()
		mt.tileCount()

		-- create Bitmaptexture and set as a tile texture 2
		bt2 = bitmaptexture filename:ff[2]
		mt.setTileTexmap 2 bt2
		tx2 = mt.getTileTexmap 2
		tx2.filename
		*/
		--for i in #{1..$.material.base_color_map.tileCount()} collect ($.material.base_color_map.getTileTexmap i).filename
		
		if selection.count == 1 then
		(
			local ctrl = keyboard.controlPressed
			local alt = keyboard.altPressed
			local sel = selection[1]
			local maps = #()
			local diffuses = #()
			--local diffuses_udims = #()
			local erms = #()
			local normals = #()
			if sel.material != undefined then
			(
				if classof sel.material == Multimaterial then if classof sel.material.materialList[1] == Standardmaterial then sel.material.materialList[1].displacementMap = undefined
				if classof sel.material == Multimaterial then if classof sel.material.materialList[1] == Physical_Material then sel.material.materialList[1].displacement_map = undefined
				
				local maps = usedMaps sel.material 
				if maps.count > 0 then
				(
					--print maps
					for i in maps where findstring i "_Diffuse_" != undefined do appendIfUnique diffuses i --diffuses = for i in maps where findstring i "_Diffuse_" != undefined collect i
					for i in maps where findstring i "_ERM_" != undefined do appendIfUnique erms i --erms = for i in maps where findstring i "_ERM_" != undefined collect i
					for i in maps where findstring i "_Normal_" != undefined do appendIfUnique normals i --normals = for i in maps where findstring i "_Normal_" != undefined collect i
					makeUniqueArray diffuses
					makeUniqueArray erms
					makeUniqueArray normals
					sort diffuses
					sort erms
					sort normals
					print (diffuses)
					
					if diffuses.count == 0 and erms.count == 0 and normals.count == 0 then diffuses = maps
					
					local pattern = "#custom"
					if diffuses.count > 0 and ctrl then
						pattern = for i in diffuses where findstring i ".1001." != undefined or findstring i ".1002." != undefined do exit with "#UDIM" --matchPattern i pattern:"1001"
					--print pattern
						
					/*	
					ViewportQuality   
					0 - #Low (default)
					1 - #Medium
					2 - #High
						
					<boolean>setPatternedImageFile <filename>filePath
					Sets the filename and path to the Patterned Image File.
						
					<boolean>setImageFile <index>tile index <filename>filePath
					Sets the bitmap image to the indexed tile from the Patterned Image File specified by the second argument.
					
					<integer>getTileUOffset <index>tileIndex
					Returns the U offset of the indexed tile.

					<void>setTileUOffset <index>tileIndex <integer>uIndex
					Sets the U offset of the indexed tile to the offset specified by the second argument.

					<integer>getTileVOffset <index>tileIndex
					Returns the V offset of the indexed tile.

					<void>setTileVOffset <index>tileIndex <integer>vIndex
					Sets the V offset of the indexed tile to the offset specified by the second argument.

					<texturemap>getTileTexmap <index>tileIndex
					Returns a bitmapTexture map with the indexed tile.

					<void>setTileTexmap <index>tileIndex <texturemap>texmap
					Sets the indexed tile to the bitmapTexture map supplied as second argument.

					<integer>tileCount()
					Returns the number of tiles.

					<void>addTile()
					Adds a tile.

					Equivalent to pressing the "Add Tile" icon next to the "Number Of Textures" field in the UI.

					<void>deleteTile <index>tile index
					Deletes the indexed tile.

					Equivalent to pressing the "Delete Tile" icon next to the Tile name button in the UI.
					*/
						
					if pattern == "#custom" then 
						if classof sel.material == Multimaterial then
						(
							local mt = MultiTile PatternFormat:#custom ViewportQuality:#Low --#custom --#UDIM
							
							--if diffuses.count > 0 then 
							--(
							--	for file in diffuses appendIfUnique diffuses_udims (((filterstring file ".")[(filterstring file ".").count - 1]) as integer)
							--	sort diffuses_udims
							--)
							if diffuses.count > 0 then 
								for i = 1 to diffuses.count do 
								(
									local uv_num = (((filterstring diffuses[i] ".")[(filterstring diffuses[i] ".").count - 1]) as integer) - 1001
									local U = mod uv_num 10
									local V = ((uv_num - U) / 10) as integer									
									
									if i != 1 then mt.addTile()
									mt.tileCount()
									mt.setTileTexmap i (bitmaptexture filename:diffuses[i])
									mt.setImageFile i diffuses[i]
									mt.setTileUOffset i (U) -- ((mod i 10))
									mt.setTileVOffset i (V) --(((i / 10) as integer))
									mt.tileCount()
								)
							--print (mt.tileCount())
							if classof sel.material.materialList[1] == Standardmaterial then sel.material.materialList[1].displacementMap = mt
							if classof sel.material.materialList[1] == Physical_Material then sel.material.materialList[1].displacement_map = mt
						)
					
					if pattern == "#UDIM" then 
						if classof sel.material == Multimaterial then
						(
							local mt = MultiTile PatternFormat:#UDIM ViewportQuality:#Low --#custom --#UDIM 
							if diffuses.count > 0 then 
							(
								mt.tileCount()
								mt.setPatternedImageFile diffuses[1]
								mt.tileCount()
								--mt.setTileTexmap 1 (bitmaptexture filename:diffuses[1])
								--mt.setImageFile 1 diffuses[1]
								--mt.tileCount()
							)
							
							--print (mt.tileCount())

							if classof sel.material.materialList[1] == Standardmaterial then sel.material.materialList[1].displacementMap = mt
							if classof sel.material.materialList[1] == Physical_Material then sel.material.materialList[1].displacement_map = mt
						)
				)
			)
		)
	)		
	
	on btn_multimat pressed do 
	(
		f = #()
		f_norm = #()
		f_erm = #()
		if keyboard.controlPressed then
		(
			mm = substitutestring selection[1].name "Main" ""
			mm = substitutestring mm "SM_" "T_"
			print (edt_multimat_path.text + mm + "Diffuse*" + ".png")	
			f = getFiles (edt_multimat_path.text + mm + "Diffuse*" + ".png")
			print f
			f_norm = getFiles (edt_multimat_path.text + mm + "Normal*" + ".png")	
			f_erm = getFiles (edt_multimat_path.text + mm + "ERM*" + ".png")	
		)
		else
		(
			if edt_material_object_number.text != "" then
			(
				--fd_d = for f in (getFiles (edt_tex.text + nm + "*Diffuse*" + ".png")) where check_file f collect f
				--fd_n = for f in (getFiles (edt_tex.text + nm + "*Normal*" + ".png")) where check_file f collect f
				--fd_e = for f in (getFiles (edt_tex.text + nm + "*ERM*" + ".png")) where check_file f collect f
						
				f = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png")
				f_norm = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Normal*" + edt_material_mat_number.text + "*.png")	
				f_erm = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*ERM*" + edt_material_mat_number.text + "*.png")
			)
			else
			(
				f = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png")
				f_norm = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Normal*" + edt_material_mat_number.text + "*.png")	
				f_erm = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*ERM*" + edt_material_mat_number.text + "*.png")

				f = for i in f where findstring (tolower i) "flora" == undefined collect i
				--f = for i in f where findstring (tolower i) "ground" == undefined collect i
				f = for i in f where findstring (tolower i) "groundel" == undefined collect i
				
				f_norm = for i in f_norm where findstring (tolower i) "flora" == undefined collect i
				--f_norm = for i in f_norm where findstring (tolower i) "ground" == undefined collect i	
				f_norm = for i in f_norm where findstring (tolower i) "groundel" == undefined collect i
				
				f_erm = for i in f_erm where findstring (tolower i) "flora" == undefined collect i
				--f_erm = for i in f_erm where findstring (tolower i) "ground" == undefined collect i
				f_erm = for i in f_erm where findstring (tolower i) "groundel" == undefined collect i				
			)
		)		
		
		if f != undefined then edt_multimat_count.text = f.count as string
		num = if f != #() then f.count else 0
		
		if f.count != f_norm.count or f.count != f_erm.count or f_norm.count != f_erm.count then 
		(
			messageBox ("Some files are missing\n" + "Diffuse: " + (f.count as string) + "\n" + "Normal: " + (f_norm.count as string) + "\n" + "ERM: " + (f_erm.count as string) + "\n")
		)
			if selection.count > 0 and num > 0 then
			(
				local ff = #()
				local ids = #()
				join ff f
				join ff f_norm
				join ff f_erm
				print #(ff)
				local sym = "."
				if (for aa in ff where (filterstring (getFilenameFile aa) ".").count > 1 collect aa).count > 0 then 
				(
					ids = for a in ff collect trim ((filterstring (getFilenameFile a) ".")[(filterstring (getFilenameFile a) ".").count])
					sym = "."
				)
				else 
				(
					ids = for a in ff collect trim ((filterstring (getFilenameFile a) "_")[(filterstring (getFilenameFile a) "_").count])
					sym = "_"
				)
				makeUniqueArray ids
				print #(ids)
								
				if ids.count > 0 then 
				(
						sel = selection[1]
						m = multiSubMaterial name:(substitutestring sel.name "SM_" "M_") --numsubs:ids.count materialIDList:ids
						--m.materialList.count = ids.count
						case rdo_type_mat.state of
						(
							1:
							(
								for i in #{1..f.count} do 
								(				
									if f != #() then 
										if f[i] != undefined then 
											if doesfileexist f[i] then 
												if (filterstring (getFilenameFile f[i]) sym)[(filterstring (getFilenameFile f[i]) sym).count] != undefined then
												(
													local id = trim ((filterstring (getFilenameFile f[i]) sym)[(filterstring (getFilenameFile f[i]) sym).count])
													--print id
													if id >= 1 then 
													(
														if classof m.materialList[id] != Standard then m.materialList[id] = Standard name:((substitutestring sel.name "SM_" "M_") + "_" + id as string)								
														if m.materialList[id].DiffuseMap == undefined then m.materialList[id].DiffuseMap = BitmapTexture fileName: f[i]
														try
														(
															bm = openbitmap f[i]
															if bm.hasAlpha then m.materialList[id].OpacityMap = BitmapTexture fileName: f[i] monoOutput:1 alphasource:0 RGBOutput:1
															close bm 
															free bm
														)catch()
													)
												)

								)		
								for i in #{1..f_norm.count} do
								(
									if f_norm != #() then 
										if f_norm[i] != undefined then 
											if doesfileexist f_norm[i] then
												if (filterstring (getFilenameFile f_norm[i]) sym)[(filterstring (getFilenameFile f_norm[i]) sym).count] != undefined then
												(
													local id = trim ((filterstring (getFilenameFile f_norm[i]) sym)[(filterstring (getFilenameFile f_norm[i]) sym).count])
													if id >= 1 then 
													(
														if classof m.materialList[id] != Standard then m.materialList[id] = Standard name:((substitutestring sel.name "SM_" "M_") + "_" + i as string)		
														m.materialList[id].BumpMap = BitmapTexture fileName: f_norm[i]
													)
												)
								)
								for i in #{1..f_erm.count} do
								(
									if f_erm != #() then 
										if f_erm[i] != undefined then 
											if doesfileexist f_erm[i] then 
												if (filterstring (getFilenameFile f_erm[i]) sym)[(filterstring (getFilenameFile f_erm[i]) sym).count] != undefined then
												(
													local id = trim ((filterstring (getFilenameFile f_erm[i]) sym)[(filterstring (getFilenameFile f_erm[i]) sym).count])
													if id >= 1 then 
													(
														if classof m.materialList[id] != Standard then m.materialList[id] = Standard name:((substitutestring sel.name "SM_" "M_") + "_" + i as string)								
														m.materialList[id].ReflectionMap = BitmapTexture fileName: f_erm[i]
													)
												)
								)						
							)
							
							2:
							(
								for i in #{1..f.count} do 
								(
									if f != #() then 
										if f[i] != undefined then 
											if doesfileexist f[i] then 
											(
												local id = trim ((filterstring (getFilenameFile f[i]) sym)[(filterstring (getFilenameFile f[i]) sym).count])
												if id >= 1 then 
												(
													if classof m.materialList[id] != Physical_Material then m.materialList[id] = Physical_Material name:((substitutestring sel.name "SM_" "M_") + "_" + i as string)								
													if m.materialList[id].base_color_map == undefined then m.materialList[id].base_color_map = BitmapTexture fileName: f[i]
													try
													(
														bm = openbitmap f[i]
														if bm.hasAlpha then m.materialList[id].cutout_map = BitmapTexture fileName: f[i] monoOutput:1 alphasource:0 RGBOutput:1
														close bm 
														free bm
													)catch()
												)
											)
								)
								for i in #{1..f_norm.count} do
								(
									if f_norm != #() then 
										if f_erm[i] != undefined then 
											if doesfileexist f_erm[i] then 
											(
												local id = trim ((filterstring (getFilenameFile f_erm[i]) sym)[(filterstring (getFilenameFile f_erm[i]) sym).count])
												if id >= 1 then 
												(
													if classof m.materialList[id] != Physical_Material then m.materialList[id] = Physical_Material name:((substitutestring sel.name "SM_" "M_") + "_" + i as string)								
													m.materialList[id].metalness_map = BitmapTexture fileName: f_erm[i]	--if f_erm != #() then if doesfileexist f_erm[i] then m.materialList[i].roughness_map = BitmapTexture fileName: f_erm[i]				
												)
											)
								)	
								for i in #{1..f_erm.count} do	
								(							
									if f_erm != #() then 
										if f_norm[i] != undefined then 
											if doesfileexist f_norm[i] then 
											(
												local id = trim ((filterstring (getFilenameFile f_norm[i]) sym)[(filterstring (getFilenameFile f_norm[i]) sym).count])
												if id >= 1 then 
												(
													if classof m.materialList[id] != Physical_Material then m.materialList[id] = Physical_Material name:((substitutestring sel.name "SM_" "M_") + "_" + i as string)								
													m.materialList[id].bump_map = BitmapTexture fileName: f_norm[i]	
												)
											)
												
									--bm = openbitmap f[i]
									--if bm.hasAlpha then 
									--(
									--	HiddenDOSCommand ("convert " + "\"" + f[i] + "\"" + " -alpha extract " + "\"" + (getfilenamepath f[i] + "_" + getFilenameFile f[i] + "_Alpha" + getFilenameType f[i]) + "\"") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
									--	m.materialList[i].cutout_map = BitmapTexture fileName: (getfilenamepath f[i] + "_" + getFilenameFile f[i] + "_Alpha" + getFilenameType f[i]) 
									--)
									--close bm
									--m.materialList[i].emit_color_map = BitmapTexture fileName: f_erm[i]							
								)
							)
						)
						for i in #{1..m.materialList.count} where (usedMaps m.materialList[i]).count == 0 do m.materialList[i] = undefined
						sel.material = m
						meditMaterials[24] = m

				)
			)
			else
			(
				messageBox ("None object selected or no files found")
			)
	)
	
	on btn_multimat_read pressed do 
	(
		print (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png")
		f = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png")
		if f != undefined then edt_multimat_count.text = f.count as string
	)
	
	on btn_make_all_tex pressed do
	(
		btn_make_tex_diffuse.pressed()
		btn_make_tex_normal.pressed()
		btn_make_tex_erm.pressed()
	)
	
	on btn_MakePlanes pressed do
	(
		if selection.count > 0 then
		(
			i = selection[1]
			p = plane pos:i.pos length: (i.max.z-i.min.z) width: (i.max.x-i.min.x) lengthsegs:1 widthsegs:1 
			rotate p (eulerangles 90 0 0)
			p.pivot.z = p.min.z
			p.pos.z = i.pos.z
			addmodifier p (mirror mirror_axis:2 Mirror_Offset:-0.01 copy: true)
		)
	)
	
	on btn_Udim_Rescale pressed do --with undo "Rescale To Density" on 
	(	
		if selection.count == 1 then
		(
			local theMapSize = case (ddl_texture_Rescale_size.selection as integer) of
			(
				1: 256
				2: 512
				3: 1024
				4: 2048
				5: 4096
			)
			local textureArea = theMapSize^2 -- Calculate the total texture area
			unwrapmod = modpanel.getcurrentobject()
			faces = #{} 
		
			max modify mode
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(
				faces = unwrapmod.getselectedfaces()
				unwrapmod.setPolygonMode true
				unwrapmod.setTVSubObjectMode 3	
				if faces.count > 0 then
				(
					unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
					usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
					texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
				)
				local sc = spn_Udim_Rescale_Density.value / texelDensity
				local pos = unwrapmod.getSelCenter()
				unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter (sc) 0
				local pos_post = unwrapmod.getSelCenter()
				format "scale=% pos=% posnew=%\n" sc pos pos_post
			)
		)
		else messageBox ("Select single object")

	)
	
	on btn_MakeLowpolyPlant pressed do
	(
		global items_pl = #()
		global items_br = #()
		global dir_path = ""
		
		if selection.count > 0 then 
		(
			for i in selection where classof i.baseobject == Plane do
			(
				if i.parent != undefined then 
					if classof (i.parent).baseobject != Plane then appendIfUnique items_pl i.name
			)
			
			for i in selection where classof i.baseobject != Plane and findstring i.name "_branch" != undefined do
			(
				if i.children != undefined then
					if (for j in i.children where classof j.baseobject == plane collect j).count == 0 then append items_br i.name 
			)
			for i in selection do 
			(
				if i.parent == undefined then dir_path = i.name + "\\"
				if i.parent != undefined then
				(
					if (i.parent).parent != undefined then
					(
						if ((i.parent).parent).parent != undefined then dir_path = (((i.parent).parent).parent).name + "\\" 
						else dir_path = ((i.parent).parent).name + "\\"
					)
					else
					(
						dir_path = (i.parent).name + "\\"
					)
				)
				else dir_path = i.name + "\\"
			) 
		)
		
		try(destroyDialog ::Tree)catch()
		rollout Tree "Lowpoly Tree maker" width:300 height:830
		(
			group "Branches Detector"
			(
				--button start "Find IDs" align:#left width:100 across:2 enabled:false tooltip:"в работе. Find IDs in selected Tree (by form of elements of Tree and material)"
			
				checkbox chk_fruits "Have fruits-blossom" checked:false across:2 width:80 align:#left tooltip:"Отметьте, если дерево имеет плоды или цветки | Check it if tree have fruits or blossom"
				edittext edt_fruits "IDs" text:"7" width:80 fieldwidth:70 align:#left offset:[-45,0] tooltip:"IDs плодов или цветков | IDs fruits or blossom"

				checkbox chk_leafs "Have leaves" checked:true across:3 width:80 align:#left tooltip:"Отметьте, если дерево имеет листья | Check it if tree have leaves"
				edittext edt_leafs "IDs" text:"3,4,5" width:80 fieldwidth:70 align:#left offset:[0,0] tooltip:"IDs листьев | IDs leaves"
				--radiobuttons rdo labels:#("Use IDs", "Use Material") default:1 columns:1 rows:2 offset:[10,-28] align:#right tooltip:""
				checkbox chk_leafs_from_trunks "tr>lv" checked:false width:45 align:#right tooltip:"Отметьте, если дерево имеет прямой переход от больших веток к листьям, если нет мелких веточек | Check it if tree have leaves near trunks without twigs"	
				
				checkbox chk_twigs "Have twigs" checked:true across:3 width:80 align:#left tooltip:"Отметьте, если дерево имеет маленькие веточки между ветками и листьями, даже если ID одинаковые | Check it if tree have small twigs between trunks and leafs, even if have the same IDs"
				edittext edt_twigs "IDs" text:"2" width:80 fieldwidth:70 align:#left offset:[0,0] tooltip:"IDs twigs\nIDs маленьких веточек"
				spinner spn_twigs_Cycles "Cycles" range:[1, 10, 1] type:#integer offset:[0,0] fieldWidth:15 align:#right tooltip:"Количество циклов поиска | Searching cycles"
	
				checkbox chk_trunks "Have trunks" checked:true across:3 width:80 align:#left enabled:false tooltip:"Предполагается, что дерево всегда имеет ветки, отключить нельзя | Suppose that tree have trunks"
				edittext edt_trunks "IDs" text:"1" width:80 fieldwidth:70 align:#left tooltip:"IDs веток | IDs trunks"
				button btn_find_set_trunks "Find & Set ID" width:80 align:#right tooltip:"Найти в дереве ветки и поставить им ID | Find & Set IDs for trunks"
				
				checkbox chk_stems "Have stems" checked:true across:3 width:80 align:#left tooltip:"Отметьте, если дерево имеет ствол(ы) | Check it if tree have stem(s)"
				edittext edt_stems "IDs" text:"6" width:80 fieldwidth:70 align:#left tooltip:"IDs стволов | IDs stems"
				button btn_find_set_stems "Find & Set ID" width:80 align:#right tooltip:"Найти в дереве стволы и поставить им ID | Find & Set IDs for stems"
				
				spinner spn_distance "Seaching Distance" range:[0.0, 100.0, 0.05] type:#float fieldWidth:40 align:#left across:3 tooltip:"Радиус поиска соединённых элементов (в метрах), большие значения приведут к захвату элементов от соседних веток | Searching distance between elements of tree, larger values may take bad elements from other branches"
				checkbox chk_use_stems_distance "Stem" checked:true width:15 offset:[45,0] tooltip:"Не отмечено: нет разделения веток рядом со стволом\nОтмечено: разделение близких веток от ствола | When unchecked, do not separates brunches near stem\nWhen checked, separates very close branches to stem"
				spinner spn_distance_stem "Stem Diameter" range:[0.0, 100.0, 0.2] type:#float fieldWidth:40 align:#right tooltip:"Ориентировочный диаметр ствола, нужно для отделения веток от ствола | Guess diameter of central stem, need to separation very close branches to stem"	
				spinner spn_distance_far "Far" range:[0.5, 100000, 2.0] type:#float width:50 fieldWidth:30 align:#left across:4 tooltip:"Максимальная длина поиска веток (ставить чуть больше самой длинной ветки) | Far distance range"
				checkbox chk_separate_trunks "Separate" checked:false offset:[-10,0] tooltip:"Включать/отключать попытку разбиения пересекающихся веток друг от друга | When checked, try separate trunks from each other"
				spinner spn_branches_top_distance "Top" range:[0.0, 10000, 1.0] offset:[-10,0] type:#float width:50 fieldWidth:30 tooltip:"Расстояние от верха дерева (до ствола), нужно для корректного поиска верхних веток | Distance from top of the tree"	
				spinner spn_rubbish "Rubbish" range:[0.001, 10000, 0.2] type:#float width:50 fieldWidth:30 align:#right tooltip:"Все ветки меньше этого значения трактуются как мусорные и игнорируются | All branches smaller treated as rabish"	

				checkbox chk_branches_all "Find All branches" checked:true across:3 width:100 align:#left tooltip:"Попытка поиска как можно большего количества веток | Try to find as lot of branches as possible"
				spinner spn_branches_count "Find Only" enabled: false range:[1, 10000, 4] type:#integer width:50 offset: [20,0] fieldWidth:20 tooltip:"Попытка поиска пер??ых нескольких самых длинных веток из всех веток | Should find only firsts number of all branches"	
				button btn_tree "Tree" align:#right width:80 tooltip:"Найти и отделить копии веток в выделенном дереве\nНайти и отделить копии только первых n самых длинных веток, как отмечено | Find and create Branches in selected Tree\nFind all or only first few longest, as selected"

				progressBar pb "ProgressBar" align:#center width:280 height:5
				label lbl "Idle" width:280 align:#left style_sunkenedge:false	
			)
			group "Branches Planes Creation and Render"
			(		
				button rotate_obj_parallel_y "Rotate to Y" align:#left width:60 across:4 tooltip:"Повернуть ветку к оси Y (обычно не надо нажимать, используется скриптом) | Rotate branch to Y AXIS"
				button rotate_obj_parallel_z "Rotate to Z" width:60 tooltip:"Повернуть ветку к оси Z (обычно не надо нажимать, используется скриптом) | Rotate branch to Z AXIS"
				button create_plane_branch "Create planes" align:#right width:70 tooltip:"ЛКМ: отрендерить одну выделенную ветку и создать плоскости\nПКМ: отрендерить все выделенные ветки и создать им плоскости | LMB: Render single Branch and Create Plane(s)\nRMB: Render few selected Branches and Create Planes with parameters"
				spinner spn_multy_render "Mult." range:[0.01, 1000, 2.0] type:#float fieldWidth:30 align:#right tooltip:"Множитель размера картинки для рендеринга веток | Multipler for render size of branches"
		
				checkbox chk_hor_planes "Horizontal planes" checked:true across:3 width:100 align:#left tooltip:"Создавать горизонтальные плоскости для веток | Make horizontal planes from branches"	
				checkbox chk_vert_planes "Vertical planes" checked:true offset:[10,0] width:100 enabled:false tooltip:"Создавать вертикальные плоскости для веток | Make also vertical planes from branches"	
				spinner spn_angle_rotation "Accuracy" range:[0.1, 45.0, 5.0] type:#float fieldWidth:30 align:#right tooltip:"Точность угла поворота веток, в градусах | Accuracy angle for branches rotation"
					
				checkbox chk_dual_planes "Dual planes" checked:true across:3 width:80 align:#left tooltip:"Создавать двойные плоскости с противоположными нормалями (лучше) | Make dual planes with opposite normals (better)"
				checkbox chk_dual_planes_render "Render other side" checked:true width:110 offset:[-10,0] tooltip:"Если отмечено, дублирующая (нижняя) плоскость будет отреднерена в отдельную текстуру (лучше)\nЕсли не отмечена - текстура будет скопирована с верхней плоскости с зеркальным отражением (хуже) | Dual (bottom) plane should be render to another texture (better)\nWhen unchecked - texture will be copied and mirrored from top side (worse)"
				spinner spn_rot_ang "Angle" range:[0.0, 180.0, 0.0] type:#float fieldWidth:40 align:#right toolTip:"Интерактивный поворот (наклон) веток | Interactive changing for branches rotation"   
				
				spinner spn_plane_count_h "Plane hor. segments" range:[1, 1000, 2] type:#integer fieldWidth:20 align:#left across:2 tooltip:"Интерактивное изменение числа сегментов плоскости веток по горизонтали (поперечное деление) | Interactive changing of horizontal segments number for planes branches"
				spinner spn_plane_count_v "Plane ver. segments" range:[1, 1000, 3] type:#integer fieldWidth:20 align:#right tooltip:"Интерактивное изменение числа сегментов плоскости веток по вертикали (продольное деление) | Interactive changing of vertical segments number for planes branches"
				
				spinner spn_bend_h "Bend hor. angle" range:[0.0, 180.0, 10.0] type:#float fieldWidth:40 across:2 align:#left toolTip:"Интерактивное изменение поперечного угла сгиба в модификаторах веток | Interactive changing for bend modifiers"   
				spinner spn_bend_v "Bend ver. angle" range:[0.0, 180.0, 30.0] type:#float fieldWidth:40 align:#right toolTip:"Интерактивное изменение продольного угла сгиба в модификаторах веток | Interactive changing for bend modifiers"   

				button btn_tex_path "Path" across:2 align:#left width:30 tooltip:""
				edittext edt_tex_path "" text:(udims.edt_multimat_path.text + dir_path) align:#right width:240 fieldwidth:260 align:#right
			)
			group "Distribution FEW Planes to All other Branches"
			(
				MultiListBox mlbList_pl "List of planes:" items:items_pl width:138 height:10 selection:#() across:2 toolTip:"Уникальные отрендеренные ветки-плоскости для размножения, список | List of unique planes-branches to be copied"
				MultiListBox mlbList_br "List of branches:" items:items_br width:138 height:10 selection:#() toolTip:"3D ветки, на которые надо размножать, список | List of 3D branches"	
	
				button btn_Add_pl "Add" across:6 align:#left toolTip:"Выберите объекты и нажмите добавить, добавляются только разрешенные объекты плоскости-ветки | Select objects and press Add, adds only valid planes" 
				button btn_Remove_pl "Remove" align:#left offset:[-8,0] toolTip:"Удалить выделенные пункты из списка | Remove selected items from list" 
				button btn_Clear_pl "Clear" align:#left toolTip:"Очистить список | Clear all items from list" 
				button btn_Add_br "Add" align:#right toolTip:"Выберите объекты и нажмите добавить, добавляются только разрешенные объекты 3D веток | Select objects and press Add, adds only valid branches"
				button btn_Remove_br "Remove" align:#right offset:[8,0] toolTip:"Удалить выделенные пункты из списка | Remove selected items from list" 	
				button btn_Clear_br "Clear" align:#right offset:[2,0] toolTip:"Очистить список | Clear all items from list" 
				button btn_box_branches "Bound boxes" across:3 align:#left toolTip:"Отобразить все выделенные ветки в виде габаритных контейнеров | Set all selected branches as bounding boxes" 	
				button btn_select_branches_planes "Select planes" offset:[-15,0] toolTip:"ЛКМ: выделить все плоскости от всего выделения объектов\nЛКМ+ЛКМ: выделить только детей из выделенных плоскостей\nЛКМ+CTRL: выделить детей объектов\nЛКМ+ALT: выделить родителей\nЛКМ+CRTL+ALT: убрать выделение дочерних объектов\nПКМ: вделить только уникальные плоскости из всех выделенных плоскостей\nПКМ+CTRL: убрать выделение с уникальных плоскостей из всех выделенных плоскостей | LMB: Select all planes from all selected\nLMB+LMB: Select children from selected planes\nLMB+CTRL: Select children\nLMB+ALT: Select parents\nLMB+CRTL+ALT: Deselect children\nRMB: Select only unique planes from selected\nRMB+CTRL: Deselect unique planes from selected"
				button btn_Distribute "Distribute Planes" align:#right width:100 tooltip:"Размножить список плоскостей на список 3D веток, это происходит путем подбора ближайших размеров, избегайте натягивания больших плоскостей на маленькие ветки и наоборот, что ведет к ошибке плотности текселей | Distribute left list to right list"	
				progressBar pb2 "ProgressBar" align:#center width:280 height:5
			)
			group "Unwrap Branches Planes"
			(
				button btn_Del_Unwrap "Delete Unwraps" width:90 align:#left across:3 tooltip:"Удалить все модификаторы развертки со всех плоскостей | Delete all unwrap modifiers from all planes"
				button btn_Unwrap "Unwrap together" offset:[5,0] width:90 tooltip:"Развернуть все выделенные плоскости-ветки вместе в один UDIM с общим одним атласом диффузных и прозрачных текстур и целевой плотностью текселя | Unwrap selected plane-branches to one UDIM with one diffuse and opacity texture with target texels density"
				button btn_Collapse "Collapse together" width:90 align:#right tooltip:"Cвести все выделенные развернутые плоскости-ветки в одну крону (без ствола), назначить общий материал | Collapse selected planes to whole tree (without stems), get common material"
				label lbl_tex_size "Texture Size" align:#left across:3 tooltip:"Размер текстуры | Texture Size"
				dropdownlist ddl_Tex_size "" items: #("256","512","1024","2048","4096") selection:5 height:20 width:60 fieldWidth:60 offset:[-10,0] align:#left toolTip:"Целевой размер текстуры | Target texture size"
				spinner spn_target_density "Target Density" range:[512.0, 1706.0, 520.0] type:#float fieldWidth:45 align:#right toolTip:"Целевая плотность текселя | Target texels density" 
			)	
			group "Remesh and Unwrap Stems"
			(
				button btn_Stem_Remesh_Unwrap "Remesh Stem" width:80 align:#left across:3 tooltip:"Выделите только объект ствола и нажмите кнопку переработки сетки и развертки ствола | Select only stems object and press Remesh Unwrap Stem"	
				spinner spn_target_density_stem "Density" enabled:false range:[512.0, 1706.0, 1700.0] type:#float fieldWidth:43 offset:[-12,0] toolTip:"Целевая плотность текселя для ствола | Target texels density stem" 
				spinner spn_target_polys "Polycount" range:[1, 100000, 1000] type:#integer fieldWidth:40 align:#right toolTip:"Целевое число полигонов ствола | Target count of poly of stem" 
				button btn_paste_stem "Blend Tex" width:80 align:#left toolTip:"Свести вместе несколько диффузных карт материалов соответсвенно развертке, нужно для сведения текстур ствола и кроны | Blend together few material's diffuse textures according to unwrap, need to blend stem texture to branches texture" 
			)
			button btn_save "Save" across:3 width:60 align:#left tooltip:"Сохранить настройки в файл | Save options to file"
			button btn_load "Load" width:60 tooltip:"Загрузить настройки из файла | Load options from file"
			button btn_close "Close" width:60 align:#right toolTip:"Закрыть этот диалог | Close this dialog" 
			
			fn qpos i j = --сортировка по высотам, первый эл-т самый высокий
			(
				o = 0
				if i[5] > j[5] then o = -1
				if i[5] < j[5] then o = 1
				o
			)
			
			fn qgab i j = --сортировка по вытянутостям
			(
				o = 0
				if abs(i[3]-i[4]) > abs(j[3]-j[4]) then o = -1
				if abs(i[3]-i[4]) < abs(j[3]-j[4]) then o = 1
				o
			)
		
			fn to_elements s faces =
			(
				elems = #()
				part_of_faces = faces
				while not part_of_faces.isempty do with redraw off
				(
					if keyboard.escPressed then exit
					for i in part_of_faces where not keyboard.escPressed do 
					(
						elem = polyOp.getElementsUsingFace s #{i}
						vv = polyop.getVertsUsingFace s elem
						pp = for v in vv collect polyop.getVert s v
						xx = 0
						yy = 0
						zz = 0
						nn = pp.count
						for p in pp do 
						(
							xx += p.x
							yy += p.y
							zz += p.z
						)
						xx /= nn
						yy /= nn
						zz /= nn
						
						if pp != undefined then 
						(
							append elems #(elem, pp, [xx,yy,zz]) 
						)
						part_of_faces -= elem
						exit
					)
					pb.value = (100 - (100*part_of_faces.numberset/faces.count)) as integer
				)
				elems
			)	

			fn find_largestXY elems =
			(
				maxi = 0
				el = 1
				if elems.count > 0 then
				(
					for i in #{1..elems.count} do
					(
						xx = for j in elems[i][2] collect j.x
						yy = for j in elems[i][2] collect j.y
						zz = for j in elems[i][2] collect j.z
						--max_xx = amax xx
						--max_yy = amax yy
						--max_zz = amax zz
						--min_xx = amin xx
						--min_yy = amin yy
						--min_zz = amin zz
						--x = abs(max_xx - min_xx)
						--y = abs(max_yy - min_yy)
						--z = abs(max_zz - min_zz)
						--w = sqrt (x*x + y*y + z*z)
						--w = amax #(abs(amax(xx)-amin(xx)), abs(amax(yy)-amin(yy)), abs(amax(zz)-amin(zz)) ) 
						w = amax #(abs(amax(xx)-amin(xx)), abs(amax(yy)-amin(yy)) ) 	
							--sqrt(abs(amax(xx)-amin(xx))^2 + abs(amax(yy)-amin(yy))^2)
						if w > maxi then 
						(
							maxi = w
							el = i
						)
						pb.value = (100 - (100 * i / elems.count)) as integer
					)
				)
				el
			)
			
			fn find_largestZ elems =
			(
				size = 0
				el = 1
				if elems.count > 0 then 
				(
					for i in #{1..elems.count} where (w = abs(amax(ww = for j in elems[i][2] collect j.z) - amin(ww))) > size do
					(			
						size = w
						el = i
					)
				)
				el
			)
			
			fn find_point_nearest_stem elems poi =
			(
				pos = poi
				if elems.count > 0 then
				(
					d = for p in elems[2] collect #(distance [poi.x, poi.y, p.z] p, p)
					mind = amin (for p in d collect p[1])
					pos = for i in #{1..d.count} where d[i][1] == mind do exit with d[i][2] --el = d[findItem d (amin d)]
				)
				pos
			)
/*			
			fn by_distance elems1 elems2 e1 t =
			(		
				arr = #()
				if elems1.count > 0 and elems2.count > 0 and e1 <= elems1.count then
				(
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100*e2/elems2.count) as integer
						for v in elems1[e1][2] where not found do --перебираем вершины первой ветки 
						(
							for w in elems2[e2][2] where distance v w <= t do 
							(
								appendIfUnique arr #(elems2[e2][1], elems2[e2][2])
								exit with found = true
							)
						)
					)
				)
				arr
			)	
*/
			fn by_distance_ex_ elems1 elems2 e1 t po m far =
			(		
				arr = #()	
				nums = #{}
				if elems1.count > 0 and elems2.count > 0 and e1 <= elems1.count then
				(				
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100 * e2 / elems2.count) as integer
						for v in elems1[e1][2] where not found do --перебираем вершины первой ветки 
						(
							if distance v elems2[e2][3] > far then continue
							for w in elems2[e2][2] where distance v w <= t and distance w [po.x, po.y, w.z] >= m do 
							(
								append arr #(elems2[e2][1], elems2[e2][2], elems2[e2][3])
								append nums e2
								exit with found = true
							)
						)
					)
					elems2 = for i in (#{1..elems2.count} - nums) collect #(elems2[i][1], elems2[i][2], elems2[i][3])
				)
				#(arr, elems2)
			)	
			
			fn by_distance_ex_3 elems1 elems2 e1 t po m top_z far =
			(		
				arr = #()	
				nums = #{}
				if elems1.count > 0 and elems2.count > 0 and e1 <= elems1.count then
				(				
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100 * e2 / elems2.count) as integer
						for v in elems1[e1][2] where not found do --перебираем вершины первой ветки 
						(
							if distance v elems2[e2][3] > far then continue
							--for w in elems2[e2][2] where distance v w <= t and distance w [po.x, po.y, w.z] >= m do 
							for w in elems2[e2][2] where distance v w <= t and distance w [po.x, po.y, (if w.z >= top_z then top_z else w.z) ] >= m do 
							(
								append arr #(elems2[e2][1], elems2[e2][2], elems2[e2][3])
								append nums e2
								exit with found = true
							)
						)
					)
					elems2 = for i in (#{1..elems2.count} - nums) collect #(elems2[i][1], elems2[i][2], elems2[i][3])
				)
				#(arr, elems2)
			)	
			
			fn by_distance_ex_2 elems1 elems2 e1 t far =
			(		
				arr = #()	
				nums = #{}
				if elems1.count > 0 and elems2.count > 0 and e1 <= elems1.count then
				(				
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100 * e2 / elems2.count) as integer
						for v in elems1[e1][2] where not found do --перебираем вершины первой ветки 
						(
							if distance v elems2[e2][3] > far then continue
							for w in elems2[e2][2] where distance v w <= t do 
							(
								append arr #(elems2[e2][1], elems2[e2][2], elems2[e2][3])
								append nums e2
								exit with found = true
							)
						)
					)
					elems2 = for i in (#{1..elems2.count} - nums) collect #(elems2[i][1], elems2[i][2], elems2[i][3])
				)
				#(arr, elems2)
			)	
/*			
			fn by_distance_ex elems1 elems2 e1 t po m =
			(		
				arr = #()	
				if elems1.count > 0 and elems2.count > 0 and e1 <= elems1.count then
				(		
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100 * e2 / elems2.count) as integer
						for v in elems1[e1][2] where not found do --перебираем вершины первой ветки 
						(
							for w in elems2[e2][2] where distance v w <= t and distance w [po.x, po.y, w.z] >= m do 
							(
								append arr #(elems2[e2][1], elems2[e2][2])
								found = true
								exit
							)
						)
					)
				)
				arr
			)
*/			
			fn by_distance_all_ elems1 elems2 t far =
			(		
				arr = #()	
				nums = #{}
				if elems1.count > 0 and elems2.count > 0 then
				(				
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100 * e2 / elems2.count) as integer
						for e1 in #{1..elems1.count} where not found and not keyboard.escPressed do
						(
							if distance elems1[e1][3] elems2[e2][3] > far then continue
							for v in elems1[e1][2] where not found do 
							(
								for w in elems2[e2][2] where distance v w <= t do 
								(
									append arr #(elems2[e2][1], elems2[e2][2], elems2[e2][3])
									append nums e2
									exit with found = true
								)
							)
						)
					)
					elems2 = for i in (#{1..elems2.count} - nums) collect #(elems2[i][1], elems2[i][2], elems2[i][3])
				)
				#(arr, elems2)
			)			
/*
			fn by_distance_all elems1 elems2 t =
			(		
				arr = #()	
				if elems1.count > 0 and elems2.count > 0 then
				(				
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100*e2/elems2.count) as integer
						for e1 in #{1..elems1.count} where not found and not keyboard.escPressed do
						(
							for v in elems1[e1][2] where not found do 
							(
								for w in elems2[e2][2] where distance v w <= t do 
								(
									append arr #(elems2[e2][1], elems2[e2][2])
									exit with found = true
								)
							)
						)
					)
				)
				--print elems1.count
				--print arr.count
				--print #(arr)
				arr
			)
*/			
			fn subarray b =
			(
				a = #{}				
				if b.count > 0 then 
					for i in #{1..b.count} do a += b[i][1]
				a
			)
			
			fn delete_elems_arr a b =
			(
				c = #()
				if a.count > 0 then
				(
					if b.count > 0 then
					(
						for j in #{1..a.count} do 
						(
							found = false
							for i in #{1..b.count} where (b[i][1] - a[j][1]).isempty do exit with found = true
							if not found then append c #(a[j][1], a[j][2]) 
						)
					)
					else c = a
				)
				c
			)
			
			fn rotate_to_Y s step =  			
			(
				gc()
				angles = 0.0 
				if s != undefined then
				(
					max create mode
					ss = copy s
					ResetXForm ss
					converttopoly ss
					mY = ss.max.y --abs(ss.max.y - ss.min.y)
					delete ss
					for ang = -180 to 180 by step where not keyboard.escPressed do
					(
						ss = copy s
						ResetXForm ss
						converttopoly ss
						in coordsys world rotate ss (eulerangles 0 0 ang)
						ResetXForm ss
						converttopoly ss
						--mX = abs(ss.max.x - ss.min.x)
						mmY = ss.max.y --abs(ss.max.y - ss.min.y)
						--format "mY=% mmY=% angle=%\n" mY mmY ang
						if mmY > mY then
						(
							mY = mmY 
							angles = ang
						)
						delete ss
					)
					--print angles
					--rotate s (eulerangles 0 0 angles)
				)
				angles
			)
			
			fn rotate_to_Z s step angleY =  			
			(
				gc()
				angles = 0.0 
				if s != undefined then
				(
					max create mode
					sss = copy s
					ResetXForm sss
					converttopoly sss
					rotate sss (eulerangles 0 0 angleY)
					ResetXForm sss
					converttopoly sss
					mZ = sss.max.y --abs(sss.max.z - sss.min.z) mZ = abs(s.max.z - s.min.z)
					for ang = -180 to 180 by step where not keyboard.escPressed do
					(
						ss = copy sss
						ResetXForm ss
						converttopoly ss
						in coordsys world rotate ss (eulerangles ang 0 0)
						ResetXForm ss
						converttopoly ss
						mmZ = ss.max.y --abs(ss.max.z - ss.min.z)
						--format "mZ=% mmZ=% angle=%\n" mZ mmZ ang
						if mmZ > mZ then
						(
							mZ = mmZ 
							angles = ang
						)
						delete ss
					)
					delete sss
					--print angles
					--rotate s (eulerangles angles 0 0)
				)
				angles
			)
			
			fn create_plane s normal = 
			(
				gc()
				pl = undefined
				if s != undefined then
				(
					ss = copy s
					select ss	
					
					ResetXForm ss
					converttopoly ss
					angleY = rotate_to_Y ss (spn_angle_rotation.value)
					in coordsys world rotate ss (eulerangles 0 0 angleY)
					ResetXForm ss
					converttopoly ss
					angleZ = rotate_to_Z ss (spn_angle_rotation.value) 0.0
					in coordsys world rotate ss (eulerangles angleZ 0 0)
					ResetXForm ss
					converttopoly ss

					mX = abs(ss.max.x - ss.min.x)
					mY = abs(ss.max.y - ss.min.y)
					mZ = abs(ss.max.z - ss.min.z)	
					
					size = if mX > mY then mX else mY
						
					pl = plane name:(s.name + "_Plane") length:mY width:mX pos:[ss.center.x, ss.center.y, ss.pos.z] rotation:ss.rotation lengthsegs:spn_plane_count_v.value widthsegs:spn_plane_count_h.value
					pl.pivot = ss.pos
					delete ss		
					
					addmodifier pl (uvwmap length:size width:size maptype:0 axis:2) --addmodifier pl (uvwmap length:mY width:mX maptype:0 axis:2)
					addmodifier pl (MaterialModifier materialID: 1)
					
					if normal then 
					(
						addmodifier pl (MaterialModifier materialID: 2)
						addmodifier pl (Normalmodifier flip: true)
						--in coordsys local 
							move pl [0, 0, -0.01]
						pl.name += "002"
					)
					else pl.name += "001"

					in coordsys local rotate pl (eulerangles 0 0 -angleY)
					in coordsys local rotate pl (eulerangles -angleZ 0 0)
				)
				pl	
			)
			
			fn bend_plane pl =
			(
				if pl != undefined then
				(
					addModifier pl (bend BendAngle:spn_bend_h.value BendDir:90 BendAxis:1 Center:[0, pl.min.y - pl.center.y, 0])
					addModifier pl (bend BendAngle:-spn_bend_v.value BendDir:0 BendAxis:0 Center:[0, pl.min.y - pl.center.y, 0])
				)	
				pl			
			)
			
			fn render_branch ss filename dual_render dual multy =
			(
				gc()
				mat = undefined
				if ss != undefined then
				(
					ResetXForm ss
					converttopoly ss
					
					mX = abs(ss.max.x - ss.min.x)
					mY = abs(ss.max.y - ss.min.y)
					mZ = abs(ss.max.z - ss.min.z)
					size = if mX > mY then mX else mY
						
					ss.receiveShadows = false
					ss.castShadows = false
					
					cam = freeCamera fov: ((1.013 * 2.0 * (atan (size / 2.0))) as float) name:"Camera001" pos:[ss.center.x, ss.center.y, ss.center.z + (mZ * 10)] dir:[0,0,1] orthoProjection:true targetDistance:1.0
					select ss
					
					max hide inv
					viewport.setLayout #layout_4 
					viewport.activeViewportEx 4
					viewport.setCamera cam
					IsolateSelection.EnterIsolateSelectionMode()
					setRenderType #view
					
					renderSceneDialog.close()
					pngio.setAlpha true
					pngio.setType #true24
					
					rendSaveFile = true
					rendOutputFilename = (udims.edt_multimat_path.text + dir_path + filename)
					backgroundColor = color 0 0 0
					FileInGamma = 1
					FileOutGamma = 2.2
					displayGamma = 2.2
					rendTimeType = 1 --single frame
					renderWidth = (size * multy * 1000) as integer --(mX / mY) * 4096 as integer
					renderHeight = (size * multy * 1000) as integer --4096 --mY as integer
					pngio.setAlpha true
					pngio.setType #true24

					if Renderers.Production != "Corona:Corona" then for rnd in 1 to (rendererClass.classes).count where matchPattern ((rendererClass.classes)[rnd] as string) pattern:"Corona" do Renderers.Production = RendererClass.Classes[rnd]()
					
					if ((maxversion())[1] / 1000) - 2 + 2000 == 2025 then ColorPipelineMgr.mode = #gamma 
					else 
					(
						IDisplayGamma.colorCorrectionMode = #gamma 	
						IDisplayGamma.colorCorrectionPrefMode = #gamma
					)
					
					vr = renderers.current
					try
					(					
						vr.bg_source = 1 --single map
						vr.bg_texmapUseDirect = true
						vr.bg_overrideDirect = true
						vr.bg_colorDirect = color 0 0 0
						vr.bg_color = color 255 255 255 

						vr.adaptivity_targetError = 3.0 
						vr.progressive_passLimit = 50
						vr.lights_useAdaptiveSolver = true 
					)catch()
		
					try 
					(
						renderers.current.colorMap_pipeline = IdentityOperatorPlugin() --delete all operators
						op = ReinhardOperatorPlugin()
						setProperty op "colorMappingOperator.id" 1
						setProperty op "colorMappingOperator.enabled" true
						setProperty op "colorMappingOperator.highlightCompression" 1.0
						setProperty renderers.current "colorMap.pipeline" op
						
						pipeline = getProperty renderers.current "colorMap.pipeline"
						while pipeline != undefined do
						(
							operatorClass = classOf pipeline
							if operatorClass == ReinhardOperatorPlugin then exit
							pipeline = getProperty pipeline "colorMappingOperator.nextOperator"
						)
						if pipeline != undefined then setProperty pipeline "colorMappingOperator.highlightCompression" 1.0

					)
					catch()
					
					if not doesDirectoryExist (udims.edt_multimat_path.text + dir_path) then makedir (udims.edt_multimat_path.text + dir_path) all:true	
					--if doesFileExist rendOutputFilename do deleteFile rendOutputFilename
					
					max quick render
					CoronaRenderer.CoronaFp.showvfb false
					--HiddenDOSCommand ("magick " + "\"" + rendOutputFilename + "\"" + " -background none -gravity Center -extent 4096x4096 -background none -alpha Background -define png:color-type=6 " + "\""+ rendOutputFilename + "\"") startpath:(GetINI_ImageMagick())
					--HiddenDOSCommand ("magick " + "\"" + rendOutputFilename + "\""+ " PNG24:" + "\""+ rendOutputFilename + "\"") startpath:(GetINI_ImageMagick())	
					delete cam
						
					if dual_render then
					(
						rendOutputFilename = (udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename) 
						cam = freeCamera fov: ((1.013 * 2.0 * (atan (size / 2.0))) as float) name:"Camera001" pos:[ss.center.x, ss.center.y, ss.center.z - (mZ * 10)] dir:[0,0,-1] orthoProjection:true targetDistance:1.0
						rotate cam (eulerangles 0 0 180) 
						viewport.setCamera cam
						max quick render
						CoronaRenderer.CoronaFp.showvfb false
						HiddenDOSCommand ("magick " + "\"" + rendOutputFilename + "\"" + " -background none -gravity Center -flop -background none -alpha Background -define png:color-type=6 " + "\""+ rendOutputFilename + "\"") startpath:(GetINI_ImageMagick())
						--HiddenDOSCommand ("magick " + "\"" + rendOutputFilename + "\"" + " -background none -gravity Center -flop -extent 4096x4096 -background none -alpha Background -define png:color-type=6 " + "\""+ rendOutputFilename + "\"") startpath:(GetINI_ImageMagick())
						--HiddenDOSCommand ("magick " + "\"" + rendOutputFilename + "\""+ " PNG24:" + "\""+ rendOutputFilename + "\"") startpath:(GetINI_ImageMagick())	
						delete cam
					)
					
					if not dual_render and dual then
					(
						HiddenDOSCommand ("magick " + "\"" + (udims.edt_multimat_path.text + dir_path + filename) + "\"" + " -background none -gravity Center -flop -background none -alpha Background -define png:color-type=6 " + "\""+ (udims.edt_multimat_path.text + dir_path + filename) + "\"") startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + (udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename) + "\""+ " PNG24:" + "\""+ (udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename) + "\"") startpath:(GetINI_ImageMagick())	
					)
					
					IsolateSelection.ExitIsolateSelectionMode()						
					max unhide all			
					
					case of
					(
						(dual_render and dual):
						(
							mat = multimaterial numsubs:2 name:ss.name
							mat.materialList[1] = standard DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + filename)) OpacityMap: (BitmapTexture fileName: (udims.edt_multimat_path.text + dir_path + filename) preMultAlpha: false rgbOutput:1 ) name:(dir_path + filename)
							mat.materialList[2] = standard DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename)) OpacityMap: (BitmapTexture fileName: (udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename) preMultAlpha: false rgbOutput:1 ) name:(dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename)
						)
						(not dual_render and dual): 
						(
							mat = multimaterial numsubs:2 name:ss.name
							mat.materialList[1] = standard DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + filename)) name:(dir_path + filename)
							mat.materialList[2] = standard DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename)) name:(dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename)
						)					
						(dual_render and not dual): --нельзя такое допускать
						(
							mat = multimaterial numsubs:2 name:ss.name
							mat.materialList[1] = standard DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + filename)) name:(dir_path + filename)
							mat.materialList[2] = standard DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename)) name:(dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename)
						)					
						(not dual_render and not dual):
						(
							mat = multimaterial numsubs:1 name:ss.name
							mat.materialList[1] = standard name:ss.name DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + filename)) name:(dir_path + filename)
						)
					)				
				)
				mat
			)	
			
			on Tree open do 
			(
				for i in Tree.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_Tree.ini") i.name "Tree" (syssetup.rdo_lang.state))
			)
			
			on btn_tex_path pressed do 
			(
				case udims.rdo_path.state of
				(
					1: edt_tex_path.text = maxFilePath + "Maps\\" + dir_path
					2: edt_tex_path.text = maxFilePath + "Images\\" + dir_path
					3: edt_tex_path.text = maxFilePath + udims.edt_path_end.text + dir_path
				)
			)
			
			on btn_tex_path rightclick do 
			(
				try
				(
					edt_tex_path.text = getSavePath caption:"Select Folder ..." initialDir: maxFilePath
					edt_tex_path.text += "\\"
				)catch()
			)
			
			on btn_Stem_Remesh_Unwrap pressed do with undo "Remesh and Unwrap Stem" on
			(
				if selection.count > 0 then
				(
					for o in selection where not keyboard.escPressed do
					(
						max modify mode
						addmodifier o (RetopologyComponent engineType:0 numFacesTarget:((spn_target_polys.value/2) as integer) outputMeshType:2  doAutomatedRemesh:true) ui:on
						o.modifiers[RetopologyComponent].ComputeRetopology()
						addmodifier o (uvwmap maptype:0 axis:2)
						addmodifier o (Turn_to_Poly limitPolySize:true maxPolySize:3)
					)
				)
			)
			
			on btn_Collapse pressed do with undo "Collapse Planes to One" on
			(
				if selection.count > 0 then
				(
					sel = for i in selection collect copy i
					--sel = selection as array
					for i in #{1..sel.count} where (classof sel[i].baseobject == Plane) and (sel[i].modifiers[Unwrap_UVW]) != undefined do 
						case i of 
						(
							1: 
							(
								addmodifier sel[1] (Edit_poly())
								collapsestack sel[1]
							)
							
							default:
							(
								polyop.attach sel[1] sel[i] 
							)
						)
					sel[1].material = meditMaterials[1]	
					sel[1].parent = undefined 
					resetxform sel[1]
					converttopoly sel[1]
					worldalignpivot sel[1]
					addmodifier sel[1] (Unwrap_UVW())
					sel[1].pivot = [sel[1].center.x, sel[1].center.y, sel[1].min.z]
					select sel[1]
				)
			)
			
			on btn_box_branches pressed do
			(
				if selection.count > 0 then 
					for i in selection where findstring i.name "branch" != undefined and i.parent != undefined /* and (for j in i.children where classof j.baseobject == Plane collect j).count != 0*/ do i.boxmode = true
			)
		
			on btn_select_branches_planes pressed do with undo "Select planes" on
			(
				ctrl = keyboard.controlPressed
				alt = keyboard.altPressed
				
				if selection.count > 0 then 
				(
					if not alt and not ctrl then
					(
						sel = #()
						for i in selection where findstring i.name "_branch" != undefined and i.parent != undefined and (for j in i.children where classof j.baseobject == Plane collect j).count != 0 do 
						(
							for j in i.children where classof j.baseobject == Plane do 
							(
								appendIfUnique sel j
								for k in j.children where classof k.baseobject == Plane do appendIfUnique sel k
							)
						)
						select sel
					)
					if alt and not ctrl then 
					(
						selectmore (for i in selection where i.parent != undefined collect i.parent)
					)

					if ctrl and not alt then
					(
						for i in selection where i.children != undefined do 
							for o in i.children do selectmore o
					)	
					
					if ctrl and alt then
					(
						for i in selection where i.children != undefined do 
							for o in i.children do deselect o
					)						
					
				)
			)	
			
			on btn_select_branches_planes rightclick do with undo "Select planes" on
			(
				if selection.count > 0 then 
				(
					ctrl = keyboard.controlPressed
					sel = #()
					mats = #()
					
					for i in selection where findstring i.name "branch" != undefined and i.parent != undefined and classof i.baseobject == Plane do appendIfUnique mats i.material
					if  mats.count > 0 then
					for m in mats do
					(
						ss = for s in selection where findstring (m.materialList[1].name) ((s.parent).name) != undefined collect s
						--for nm in s where s.material.materialList[(s.modifiers[MaterialModifier].materialID)] == m then 
						for s in ss do join sel s.children
						join sel ss
					)
					print #(sel)
					print sel.count
					if ctrl then deselect sel else select sel
				)
			)

			on btn_Distribute pressed do with undo "Distribute planes" on
			(
				if mlbList_pl.items.count > 0 and mlbList_br.items.count > 0 then
				(
					obj_items_pl = #()
					obj_items_br = #()
					
					items_pl = mlbList_pl.items as array
					items_br = mlbList_br.items as array
					
					obj_items_pl = for j in objects where (for i in items_pl where i == j.name collect i).count > 0 collect j  
					obj_items_br = for j in objects where (for i in items_br where i == j.name collect i).count > 0 collect j  
					
					print #(obj_items_pl)
					print #(obj_items_br)
					
					cou = 0
					for br in obj_items_br where not keyboard.escPressed do
					(
						cou += 1
						pb2.value = (100 * cou / obj_items_br.count) as integer
												
						--print pl_ini
						--print obj_items_pl[ind].material
						--pl1 = instance obj_items_pl[ind]
						--pl2 = pl1
						--if obj_items_pl[ind].children != undefined then 
						--	for i in obj_items_pl[ind].children do 
						--	(
						--		pl2 = instance i
						--	)
						--try(pl1.parent = undefined)catch() 
						--try(pl2.parent = undefined)catch()
						--try(pl1.children = #())catch()
						--try(pl2.children = #())catch()
						
						--pl1.pos = pl.pos
						--pl1.rotation = pl.rotation
						--try(append br.children pl1)catch()	
						--try(append pl1.children pl2)catch()	
						
						--in coordsys local pl1.scale.x *= pl1.baseobject.width / pl.baseobject.width 
						--in coordsys local pl1.scale.y *= pl1.baseobject.length / pl.baseobject.length 
						--delete pl
						
						local pl, pl2
						pl = create_plane br false 
						pl = bend_plane pl
						
						ind = random 1 (obj_items_pl.count) --надо не рандомную а ближе по размеру подбирать
						
						val = amin (for p in obj_items_pl where classof p.baseobject == Plane collect (abs(pl.baseobject.length - p.baseobject.length))) --abs(pl.baseobject.width - p.baseobject.width) 
						ind = for p in #{1..(obj_items_pl.count)} where classof obj_items_pl[p].baseobject == Plane do 
							if (abs(pl.baseobject.length - obj_items_pl[p].baseobject.length)) == val do exit with p
						--local pl_ini = obj_items_pl[ind]	
						
						pl.material = obj_items_pl[ind].material
						append br.children pl
						if chk_dual_planes.checked then 
						(
							pl2 = create_plane br true
							pl2 = bend_plane pl2
							pl2.material = obj_items_pl[ind].material	
							append pl.children pl2				
						)
						pl.baseobject.width = (obj_items_pl[ind].baseobject.width / obj_items_pl[ind].baseobject.length) * pl.baseobject.length
						pl2.baseobject.width = (obj_items_pl[ind].baseobject.width / obj_items_pl[ind].baseobject.length) * pl2.baseobject.length
					)
				)
				pb2.value = 100
			)
			
			on btn_close pressed do try(destroyDialog ::Tree)catch() --try(closeRolloutFloater Tree)catch()
			
			on btn_paste_stem pressed do
			(
				max modify mode
				sel = selection as Array
				info = #()
				if sel.count > 1 then 
				(
					for s in sel where s.material != undefined do
					(
						m = s.material
						ss = copy s
						convertToPoly ss
						
						sourcepath = ""
						case ((classof m) as string) of 
						(
							default: continue 
							"Standardmaterial": if m.DiffuseMap != undefined then if m.DiffuseMap.filename != undefined then sourcepath = m.DiffuseMap.fileName
							"Physical_Material": if m.base_color_map != undefined then if m.base_color_map.filename != undefined then sourcepath = m.base_color_map.fileName
							"CoronaLegacyMtl": if m.texmapDiffuse != undefined then if m.texmapDiffuse.filename != undefined then sourcepath = m.texmapDiffuse.filename
						)				
						print sourcepath
						faces = #{1..(polyop.getnumfaces ss)} --faces = polyOp.getFaceSelection ss
						if faces.count > 0 then
						(
							select ss
							addmodifier ss (Unwrap_UVW())
							unwrapmod = modpanel.getcurrentobject()
							unwrapmod.selectFaces faces	
							unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							if sourcepath != "" then
							(
								bm = openbitmap sourcepath
								if bm != undefined then
								(
									append info #(s, sourcepath, bm.width, bm.height, mX, mY, mWidth, mHeight)	
									close bm
									free bm
								)
							)
						)	
						delete ss	
					)
					--print #(info)
					select sel
				)
				if info.count > 1 then
				(
					mwid = amax (for i in info where findstring i[2] "all_branches_diffuse.png" != undefined collect i[3]) --width
					mhei = amax (for i in info where findstring i[2] "all_branches_diffuse.png" != undefined collect i[4]) --height
					file = (for i in info where findstring i[2] "all_branches_diffuse.png" != undefined do exit with i[2])
					filename = (getfilenamepath file) + (getfilenamefile file) + "+.png" --"C:\\Temporary Files\\!.png"
					print filename
					HiddenDOSCommand ("magick -size " + mwid as string + "x" + mhei as string + " xc:transparent -define png:color-type=6 " + "\"" + filename + "\"") startpath:(GetINI_ImageMagick())

					for i in info do
					(
						sourcepath = i[2]
						sourcepath_temp = (getfilenamepath sourcepath) + (getfilenamefile sourcepath) + "_.png" --"C:\\Temporary Files\\!!.png"
						wid = i[3]
						hei = i[4]
						
						mWidth = i[7]
						mHeight = i[8]
						mX = i[5]
						mY = i[6]
						
						sw = mwid / wid
						sh = mhei / hei
						wid_r = (mWidth * mwid) as integer + 20
						hei_r = (mHeight * mhei) as integer + 20
						poi_x = (mX * mwid) as integer - 10
						poi_y = (mY * mhei) as integer - 10
						
						if findstring sourcepath "all_branches_diffuse.png" != undefined then
						(
							mWidth = 1
							mHeight = 1
							mX = 0
							mY = 0
							poi_x = 0
							poi_y = 0	
						)
						if findstring sourcepath "all_branches_diffuse.png" == undefined then 
						(
							HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -alpha Background -background none -resize " + wid_r as string + "x" + hei_r as string + "^! -define png:color-type=6 " + "\"" + sourcepath_temp + "\"") startpath:(GetINI_ImageMagick())
						)
						else 
						(
							if doesFileExist sourcepath_temp then deleteFile sourcepath_temp
							copyfile sourcepath sourcepath_temp
						)
						--composite {overlay} {background} [{mask}] [-compose {method}]   {result}
						HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + sourcepath_temp + "\"" + " " + "\"" + filename + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + filename + "\"") startpath:(GetINI_ImageMagick())
						if doesFileExist sourcepath_temp then deleteFile sourcepath_temp
					)
				)
			)
						
			on btn_Remove_pl pressed do
			(		
				if mlbList_pl.items.count > 0 then
				(				
					items_pl = mlbList_pl.items as array
					items_pl = for j in #{1..(mlbList_pl.items as array).count} where (for i in mlbList_pl.selection where mlbList_pl.items[i] == mlbList_pl.items[j] collect i).count == 0 collect mlbList_pl.items[j] 	
					mlbList_pl.items = items_pl as array
				)
			)

			on btn_Remove_br pressed do
			(		
				if mlbList_br.items.count > 0 then
				(
					items_br = mlbList_br.items as array
					items_br = for j in #{1..(mlbList_br.items as array).count} where (for i in mlbList_br.selection where mlbList_br.items[i] == mlbList_br.items[j] collect i).count == 0 collect mlbList_br.items[j] 	
					mlbList_br.items = items_br as array
				)
			)
			
			on btn_Clear_pl pressed do
			(		
				if mlbList_pl.items.count > 0 then
				(				
					mlbList_pl.items = #()
				)
			)	

			on btn_Clear_br pressed do
			(		
				if mlbList_br.items.count > 0 then
				(				
					mlbList_br.items = #()
				)
			)				
			
			on btn_Add_pl pressed do 
			(
				items_pl = mlbList_pl.items as array
				if selection.count > 0 then 
				(
					for i in selection where i.baseobject != undefined do
					(
						if classof i.baseobject == Plane then
							if i.parent != undefined then 
								if classof (i.parent).baseobject != Plane then appendIfUnique items_pl i.name
							--if findstring i.parent.name "_branch" != undefined then 
								--if i.children != undefined then
								--(
								--	for j in i.children where classof j.baseobject == Plane do appendIfUnique items_pl i.name
								--)
					)
					mlbList_pl.items = items_pl as array 
				)
			)
			
			on btn_Add_br pressed do 
			(
				items_br = mlbList_br.items as array
				if selection.count > 0 then 
				(
					for i in selection where i.baseobject != undefined do 
					(
						if classof i.baseobject != Plane and findstring i.name "_branch" != undefined then
							if i.children != undefined then
								if (for j in i.children where classof j.baseobject == plane collect j).count == 0 then appendIfUnique items_br i.name 
					)
					mlbList_br.items = items_br as array 
				)
			)

			on chk_branches_all changed arg do spn_branches_count.enabled = not chk_branches_all.checked 
			on chk_use_stems_distance changed arg do spn_distance_stem.enabled = chk_use_stems_distance.checked 
					
			on spn_plane_count_h changed val do 
			(
				sel = if selection.count > 0 then selection else objects
				for o in sel where o.modifiers[Unwrap_UVW] == undefined and findstring o.name "_Plane" != undefined and findstring o.name "_branch" != undefined and classof o.baseobject == Plane do o.baseobject.widthsegs = val 
			)
				
			on spn_plane_count_v changed val do 
			(
				sel = if selection.count > 0 then selection else objects
				for o in sel where o.modifiers[Unwrap_UVW] == undefined and findstring o.name "_Plane" != undefined and findstring o.name "_branch" != undefined and classof o.baseobject == Plane do o.baseobject.lengthsegs = val 
			)
			
			on spn_bend_h changed val do 
			(
				sel = if selection.count > 0 then selection else objects
				for o in sel where findstring o.name "_Plane" != undefined and findstring o.name "_branch" != undefined and classof o.baseobject == Plane and classof o.modifiers[2] == bend do o.modifiers[2].BendAngle = val 
			)
			
			on spn_bend_v changed val do 
			(
				sel = if selection.count > 0 then selection else objects
				for o in sel where findstring o.name "_Plane" != undefined and findstring o.name "_branch" != undefined and classof o.baseobject == Plane and classof o.modifiers[1] == bend do o.modifiers[1].BendAngle = -val 
			)
			
			on spn_rot_ang changed val do 
			(
				sel = if selection.count > 0 then selection else objects
				for o in sel where o.modifiers[bend] != undefined and findstring o.name "_Plane" != undefined and findstring o.name "_branch" != undefined and classof o.baseobject == Plane do in coordsys local o.rotation.y = val 
			)

			on btn_Del_Unwrap pressed do
			(
				sel = if selection.count > 0 then selection else objects
				for o in sel where findstring o.name "_Plane" != undefined and findstring o.name "_branch" != undefined and classof o.baseobject == Plane do for i in o.modifiers where classof i == unwrap_uvw do deletemodifier o i  
			)
			
			on btn_load pressed do
			(
				setIniForceUTF16Default true
				local filenameIni = getOpenFileName  caption:"Select INI File to Load presets" types: "INI|*.ini|ALL|*.*" 
				if filenameIni != undefined then 
					for i in Tree.controls do
					(
						case classof i of 
						(
							CheckBoxControl: 
							(
								local params = filterstring  (getINISetting filenameIni "TreeMaker2" i.name) ";"
								if params != undefined then
									if params.count > 0 then
									(
										i.checked = params[1] as booleanClass
										i.enabled = params[2] as booleanClass
									)
							)
							
							SpinnerControl: 
							(
								local params = filterstring  (getINISetting filenameIni "TreeMaker2" i.name) ";"
								if params != undefined then
									if params.count > 0 then
									(
										i.value = params[1] as float
										i.enabled = params[2] as booleanClass
									)								
								--i.value = (getINISetting filenameIni "TreeMaker2" i.name) as float
							)
							
							ComboBoxControl: i.selection = (getINISetting filenameIni "TreeMaker2" i.name) as integer
							
							EditTextControl: i.text = (getINISetting filenameIni "TreeMaker2" i.name)
							
							MultiListBoxControl: i.items = for j in (filterstring (getINISetting filenameIni "TreeMaker2" i.name) ";") collect j   
						)
					)					
			)
			
			on btn_save pressed do
			(
				--print #(Tree.controls)
				--for i in Tree.controls do print (classof i)
				--for i in Tree.controls where classof i == CheckBoxControl do print i.checked
				--for i in Tree.controls where classof i == SpinnerControl do print i.value	
				--for i in Tree.controls where classof i == ComboBoxControl do print i.selection	
				--for i in Tree.controls where classof i == EditTextControl do print i.text		
				--for i in Tree.controls where classof i == MultiListBoxControl do print #(i.items)	
				
				setIniForceUTF16Default true
				--local filenameIni = GetDir #maxroot + "\\GeoScripts\\Tree.ini"
				local filenameIni = getSaveFileName caption:"Select INI File to Save presets" types: "INI|*.ini|ALL|*.*" 
				if filenameIni != undefined then 
					for i in Tree.controls do
					(
						case classof i of 
						(
							CheckBoxControl: (setINISetting filenameIni "TreeMaker2" i.name (i.checked as string + ";" + i.enabled as string))
							SpinnerControl: (setINISetting filenameIni "TreeMaker2" i.name (i.value as string + ";" + i.enabled as string))
							ComboBoxControl: (setINISetting filenameIni "TreeMaker2" i.name (i.selection as string))
							EditTextControl: (setINISetting filenameIni "TreeMaker2" i.name (i.text as string))
							MultiListBoxControl: 
							(
								local str = ""
								for j in i.items do str += j as string + ";"
								setINISetting filenameIni "TreeMaker2" i.name str
							)
						)
					)
			)
			
			/*			
			on btn_Unwrap pressed do
			(
				sel = selection
				if sel.count > 0 then 
				(
					num = sel.count
					mats = for m in sel collect m.material
					texes = #()
					for m in mats do
					(
						if classof m == multimaterial then 
						(
							append texes #(m.materialList[1].DiffuseMap.fileName, m.materialList[2].DiffuseMap.fileName)
						)
						if classof m == standard then
						(
							append texes #(m.DiffuseMap.fileName)
						)
					)
					count = 0
					width_all = 0
					texes_all = #()
					for tt in texes do 
						for t in tt do 
						(
							appendIfUnique texes_all t
						)
					count = texes_all.count		
				
					for t in texes_all do
					(
						a = openBitMap t
						if a != undefined then 
						(
							hei = a.height
							wid = a.width 
							close a
							free a
							width_all += wid
						)
					)
					print count
					print width_all
					stri = ""
					for t in texes_all do stri += "\"" + t + "\"" + " -trim +repage -alpha Background -bordercolor none -background none -border 20 "
					--stri += "\"" + t + "\"" + " -trim +repage -alpha Background -bordercolor none -background none -border 20 "
		
					--HiddenDOSCommand ("magick ( " + stri + " ) -background none -alpha Background +append -define png:color-type=6 " + "\""+ (maxFilePath + "all_branches_diffuse" + ".png") + "\"") startpath:(GetINI_ImageMagick())
					HiddenDOSCommand ("magick montage ( " + stri + " ) -background none -alpha Background -geometry +0+0 -define png:color-type=6 " + "\""+ (maxFilePath + "all_branches_diffuse" + ".png") + "\"") startpath:(GetINI_ImageMagick())

						-- magick montage font_[0-9].gif  -geometry 16x16+1+1  tile_0.gif
						-- magick montage  font_*.gif  -tile 4x1  -geometry +2+2  multi_%d.gif
						--magick montage font_[1-7].gif  -tile 4x  -geometry 16x16+1+1  tile_9x1.gif
						--magick montage balloon.gif medical.gif present.gif logo: -geometry 48x48+2+2   montage_geom_size.jpg
						--convert ( Img1.jpg Img2.jpg +append ) ( Img3.jpg Img4.jpg +append ) -background none -append   append_array.jpg
						--montage -resize 400x *  -mode Concatenate -tile 2x  AnotherDir/montage_array.jpg
					
				)
			)

			*/	
			/*
					fn have_mat mat1 mat2 =
					(
						local mats = #()
						if classof mat1.material == multiSubMaterial then
						(
							for m in mat1.material.materialList do appendIfUnique mats m
						)
						else
						(
							appendIfUnique mats mat1
						)
						have = false
						for m in mats where m == mat2 do (have = true; exit)
						print have
						have
					)
			*/
			
			fn havemat s mat =
			(
				if mat != undefined then
				(
					if s != undefined then
					(
						if s.material != undefined then
						(
							if classof s.material == multiSubMaterial then
							(
								if s.modifiers[MaterialModifier] != undefined then 
								(
									if s.material.materialList[(s.modifiers[MaterialModifier].materialID)] == mat then return true else return false
								)
								else return false
							)
							else return false
						)
						else return false
					)
					else return false
				)
				else return false
			)
			
			on btn_Unwrap pressed do with undo "Unwrap planes together" on
			(
				gc()
				if selection.count > 0 then
				(
					ctrl = keyboard.controlPressed
					max modify mode
					--elems = selection as array
					elems = for o in selection where classof o.baseobject == Plane collect o
					--theMapSize = 4096 
					theMapSize = case (ddl_Tex_size.selection as integer) of
					(
						1: 256
						2: 512
						3: 1024
						4: 2048
						5: 4096
					)
					textureArea = theMapSize ^ 2

					--надо по числу уникальных матов разворачивать
					mats = #()
					for el in elems where el.material != undefined do 
					(
						if classof el.material == multiSubMaterial then
							for m in el.material.materialList do appendIfUnique mats m
						else
							appendIfUnique mats el.material
					)

					quant = if mats.count == 0 then elems.count else mats.count
					print quant
					--print mats.count
					
					size_h_row = 1.0
					size_g_col = 1.0	
					quota_g = 1.0 / size_g_col
					quota_h = 1.0 / size_h_row	
					
					--padding
					--quota_g *= 0.95 
					--quota_h *= 0.95 
					
					case of
					(
						(quant == 1):
						(
							size_h_row = 1
							size_g_col = 1							
						)
						
						(quant == 2):
						(
							size_h_row = 1
							size_g_col = 2							
						)
						
						(quant == 3):
						(
							size_h_row = 1
							size_g_col = 3							
						)		

						(quant == 4):
						(
							size_h_row = 1
							size_g_col = 4							
						)

						(quant == 5):
						(
							size_h_row = 1
							size_g_col = 5							
						)						
						
						(quant == 6):
						(
							size_h_row = 2
							size_g_col = 3							
						)							
						
						(quant == 7 or quant == 8):
						(
							size_h_row = 2
							size_g_col = 4							
						)	
						
						(quant == 9):
						(
							size_h_row = 3
							size_g_col = 3							
						)	
						
						(quant == 10):
						(
							size_h_row = 2
							size_g_col = 5							
						)	
						
						(quant == 11 or quant == 12):
						(
							size_h_row = 2
							size_g_col = 6							
						)							
						
						(quant == 13 or quant == 14):
						(
							size_h_row = 2
							size_g_col = 7							
						)	
						
						(quant == 15):
						(
							size_h_row = 3
							size_g_col = 5							
						)

						(quant == 16 or quant == 17 or quant == 18):
						(
							size_h_row = 3
							size_g_col = 6							
						)

						(quant == 19 or quant == 20 or quant == 21):
						(
							size_h_row = 3
							size_g_col = 7							
						)
						
						(quant == 22 or quant == 23 or quant == 24):
						(
							size_h_row = 3
							size_g_col = 8							
						)	

						default: 
						(
							size = ceil (sqrt quant)
							size_g_col = size * 2
							size_h_row = ceil (quant/(size * 2))	
							--size_h_row = size_g_col = ceil (sqrt quant)
						)
					)

					quota_g = 1.0 / size_g_col
					quota_h = 1.0 / size_h_row	
					
					--padding
					--quota_g *= 0.95 
					--quota_h *= 0.95 
					
					size_g = 0.0
					size_h = 0.0

					page = 0.0
					sc_h = 1.0
					sc_g = 1.0
					sc = 1.0	
					
					filename = udims.edt_multimat_path.text + dir_path + "all_branches_diffuse.png" --maxFilePath + "all_branches_diffuse.png"
					
					if not doesDirectoryExist (udims.edt_multimat_path.text + dir_path) then makedir (udims.edt_multimat_path.text + dir_path) all:true
					
					if doesFileExist filename then deleteFile filename
					b = bitmap theMapSize theMapSize filename: filename color:(color 0 0 0 0) gamma:1.0 hdr:false
					save b gamma:1.0 quiet:true
					close b
					free b
					
					for mm in mats where not keyboard.escPressed do
					(
						local tex, m
						local uv_h, uv_hs = #()
						local uv_w, uv_ws = #()
						local poi_x, poi_xs = #()
						local poi_y, poi_ys = #()
						
						local scale_density	= 1.0	
						local texelDensities = #() 	
						local mWidths = #(), mHeights = #()
						
						for s in elems where havemat s mm /*s.material.materialList[(s.modifiers[MaterialModifier].materialID)] == mm*/ and not keyboard.escPressed do  --where (have_mat s.material mm) do
						(
							--print s
							select s
							if classof s.modifiers[1] == bend and classof s.modifiers[2] == bend then addmodifier s (Unwrap_UVW()) before:2 else addmodifier s (Unwrap_UVW())
							unwrapmod = s.modifiers[Unwrap_UVW] --modpanel.getcurrentobject() --s.modifiers[1]
							unwrapmod.setPolygonMode true
							unwrapmod.setTVSubObjectMode 3
							faces = #{1..unwrapmod.numberPolygons()}
							unwrapmod.selectFaces faces
								
							sc_h = 1.0
							sc_g = 1.0
										
							unwrapmod.selectFaces faces
							unwrapmod.getarea faces &mXX &mYY &mWidth &mHeight &mAreaUVW &mAreaGeom
							
							case of
							(
								(mHeight > quota_h and mWidth > quota_g): (sc_h = quota_h / mHeight; sc_g = quota_g / mWidth)
								(mHeight > quota_h and mWidth <= quota_g): sc_h = quota_h / mHeight
								(mHeight <= quota_h and mWidth > quota_g): sc_g = quota_g / mWidth
								(mHeight <= quota_h and mWidth <= quota_g):	(sc_h = 1.0; sc_g = 1.0) --if mHeight > mWidth then sc_h = quota_h / mHeight else sc_g = quota_g / mWidth
							)

							sc = if sc_h < sc_g then sc_h else sc_g
								
							pos = unwrapmod.getSelCenter()
							unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter (sc) 0
							pos = unwrapmod.getSelCenter()
							posX = (size_g * quota_g) + (0.5 / size_g_col) - pos.x
							posY = (size_h * quota_h) + (0.5 / size_h_row) - pos.y
							unwrapmod.moveSelected [posX, posY, 0]
							unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							--textureArea = theMapSize ^ 2		
							usedAreaPixels = mAreaUVW * textureArea
							texelDensity = sqrt (usedAreaPixels / mAreaGeom)	
							append texelDensities texelDensity
							append mWidths mWidth
							append mHeights mHeight
							format "t=% sc_h=% sc_g=% sc=% quota_g=% quota_h=% size_g=% size_h=% size_g_col=% size_h_row=% posX=% posY=% \n" texelDensity sc_h sc_g sc quota_g quota_h size_g size_h size_g_col size_h_row (posX+pos.x) (posY+pos.y)

							--id = 1
							--if findstring s.name "Plane001" != undefined then id = 1 --unwrapmod.getSelectMatID()
							--if findstring s.name "Plane002" != undefined then id = 2
							--tex = undefined
							--m = s.material
							--if classof m == multimaterial then tex = m.materialList[id].DiffuseMap.fileName
							--if classof m == standard then tex = m.DiffuseMap.fileName
								
							--uv_h = (mHeight * theMapSize) as integer
							--uv_w = (mWidth * theMapSize) as integer
							--poi_x = (mX * theMapSize) as integer 
							--poi_y = (mY * theMapSize) as integer
						)
						if (amin texelDensities) != undefined and (amin texelDensities) != 0 then 
						(
							scale_density = (spn_target_density.value as float) / (amin texelDensities) --устанавливаем масштаб к минимальной плотности из всех, т.е. к самой большой ветке из набора плейнов и значит материала

							if ((scale_density * (amax mWidths)) / quota_g) > ((scale_density * (amax mHeights)) / quota_h) then
							(
								if (scale_density * (amax mWidths)) >= quota_g then 
								(
									scale_density = (amax mWidths) / quota_g
									scale_density *= 0.98
								)								
							)
							else
							(
								if (scale_density * (amax mHeights)) >= quota_h then
								(
									scale_density = (amax mHeights) / quota_h
									scale_density *= 0.98	
								)
							)
						)
						else scale_density = 1.0
						
						--print #(texelDensities)
						--print spn_target_density.value
						print scale_density
						--сделать ограничение по квоте, чтобы не масштабировало за пределы квадранта
						--(mHeight > quota_h and mWidth > quota_g)
						for s in elems where s.material.materialList[(s.modifiers[MaterialModifier].materialID)] == mm and not keyboard.escPressed do 
						(
							select s
							unwrapmod = s.modifiers[Unwrap_UVW]
							unwrapmod.setPolygonMode true
							unwrapmod.setTVSubObjectMode 3
							faces = #{1..unwrapmod.numberPolygons()}
							unwrapmod.selectFaces faces
							unwrapmod.getarea faces &mXX &mYY &mWidthh &mHeightt &mAreaUVW_this &mAreaGeom_this						
							usedAreaPixels = mAreaUVW_this * textureArea 
							texelDensity = sqrt (usedAreaPixels / mAreaGeom_this) 	
							if faces.count > 0 and texelDensity > 0.0 then unwrapmod.scaleSelectedCenter scale_density 0 --(scale_density * (GetMetersFromGU()) / texelDensity) 0
							unwrapmod.getarea faces &mXXX &mYYY &mWidth_now &mHeight_now &mAreaUVW &mAreaGeom									
							
							uv_h = (mHeight_now * theMapSize) as integer
							uv_w = (mWidth_now * theMapSize) as integer
							poi_x = (mXXX * theMapSize) as integer 
							poi_y = (mYYY * theMapSize) as integer	

							append uv_hs uv_h
							append uv_ws uv_w
							append poi_xs poi_x
							append poi_ys poi_y
						)
						
						if size_g + 1.0 >= size_g_col then 
						(
							if size_h + 1.0 >= size_h_row then 
							(
								page += 1.0
								size_h = 0.0
								size_g = 0.0
							)
							else
							(
								size_h += 1.0
								size_g = 0.0
							)
						)
						else
						(
							size_g += 1.0
						)
						
						--print #(uv_hs)
						--print #(uv_ws)
						--print #(poi_xs)
						--print #(poi_ys)
						
						uv_h = amax uv_hs
						uv_w = amax uv_ws
						poi_x = amax poi_xs
						poi_y = amax poi_ys
						
						tex = mm.DiffuseMap.fileName
						
						if uv_w != undefined and uv_h != undefined and poi_x != undefined and poi_y != undefined then format "uv_w=% uv_h=% poi_x=% poi_y=% size_w=% size_h=% \n" uv_w uv_h poi_x poi_y (uv_w + poi_x) (uv_h + poi_y)
						
									--HiddenDOSCommand ("magick " + "\"" + tex + "\"" + " -trim +repage -alpha Background -background none -resize " + uv_h as string + "x" + uv_w as string + " -gravity southeast -geometry +" + poi_x as string + "+" + poi_y as string + " -extent 4096x4096 -define png:color-type=6 " + "\""+ tex + "\"") startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + tex + "\"" + " -trim +repage -alpha Background -background none -bordercolor none -border 10x10 -resize " + uv_w as string + "x" + uv_h as string + " -define png:color-type=6 " + "\"" + tex + ".png" + "\"") startpath:(GetINI_ImageMagick())
						
						--composite {overlay} {background} [{mask}] [-compose {method}]   {result}
						--magick {background} {overlay} [{mask}] [-compose {method}] -composite   {result}
						-- -compose src-over modulate -define compose:args=100 -composite 
						HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + tex + ".png" + "\"" + " " + "\"" + filename + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + filename + "\"") startpath:(GetINI_ImageMagick())
						if doesFileExist (tex + ".png") then deleteFile (tex + ".png")
							
						--HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( " + "\"" + tex + "\"" + " -trim +repage -alpha Background -background none -resize " + uv_w as string + "x" + uv_h as string + " ) " + "\"" + filename + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + filename + "\"") startpath:(GetINI_ImageMagick())
		
					/*	
						a = bitmap uv_w uv_h color:(color 0 0 0 0) gamma:1.0 hdr:false		
						c = openbitmap tex gamma:1.0
						if c != undefined then (a = copy c; print "copied good")
						close c
						free c
						if a != undefined and b != undefined then
						(
							--print a
							pasteBitmap a b [0,0] [poi_x, poi_y] type:#blend alphaMultiplier:1.0
						)							
						close a
						free a
					*/	
					)
					--save b gamma:1.0 quiet:true
					--close b
					--free b
					--надо делать еще opacity в виде чб маски
					meditmaterials[1] = standard DiffuseMap: (BitmapTexture fileName:(filename)) OpacityMap: (BitmapTexture fileName:filename preMultAlpha:false rgbOutput:1 ) name:(filename)
					--for e in elems do e.material = mat	
					select elems
				)
			)
			
			on create_plane_branch pressed do with undo "Create branch" on
			(
				gc()
				if selection.count == 1 then
				(
					local pl, pl2
					local angleY, angleZ
					se = selection[1]
					select se
					ss = copy se
					select ss
					
					--rotate_obj_parallel_Z.pressed()
					angleY = rotate_to_Y ss (spn_angle_rotation.value)
					angleZ = rotate_to_Z ss (spn_angle_rotation.value) angleY
					in coordsys world rotate ss (eulerangles 0 0 angleY)
					in coordsys world rotate ss (eulerangles angleZ 0 0)

					mat = render_branch ss (se.name + ".png") chk_dual_planes_render.checked chk_dual_planes.checked spn_multy_render.value
					delete ss
						
					pl = create_plane se false 
					pl = bend_plane pl
					pl.material = mat
					append se.children pl
					if chk_dual_planes.checked then 
					(
						pl2 = create_plane se true
						pl2 = bend_plane pl2
						pl2.material = mat	
						append pl.children pl2				
					)
					select se
				)
			)
			
			on create_plane_branch rightclick do
			(
				sss = selection as array
				for sel in sss do
				( 
					select sel
					create_plane_branch.pressed()
				)
				gc()
			)
			
			on rotate_obj_parallel_y pressed do with undo "Rotate to Y" on with redraw off
			(
				if selection.count == 1 then
				(	
					angleY = rotate_to_Y selection[1] (spn_angle_rotation.value)
					in coordsys world rotate selection[1] (eulerangles 0 0 angleY)
				)				
			)
			
			on rotate_obj_parallel_Z pressed do with undo "Rotate to Z" on with redraw off
			(
				if selection.count == 1 then
				(	
					angleY = rotate_to_Y selection[1] (spn_angle_rotation.value)
					angleZ = rotate_to_Z selection[1] (spn_angle_rotation.value) angleY
					in coordsys world rotate selection[1] (eulerangles 0 0 angleY)
					in coordsys world rotate selection[1] (eulerangles angleZ 0 0)
				)				
			)
/*			
			on rdo changed state do 
			(
				case rdo.state of
				(
					1:
					(
						edt_fruits.enabled = true
						edt_leafs.enabled = true
						edt_twigs.enabled = true
						edt_trunks.enabled = true
						edt_stems.enabled = true 					
						
					)
					2:
					(
						edt_fruits.enabled = false
						edt_leafs.enabled = false
						edt_twigs.enabled = false
						edt_trunks.enabled = false
						edt_stems.enabled = false 
					)
				)
			)
*/			
			on btn_tree pressed do
			(
				gc()
				t = spn_distance.value as float --0.05
				fruits = #{}
				fruits_elems = #()
				leafs = #{}
				leafs_elems = #()
				twigs = #{}
				twigs_elems = #()
				trunks = #{}
				trunks_elems = #()
				stems = #{}
				stems_elems = #()
				branches = #()
				arr = #()
				points = #()
				bb = 1
				old_count = 0
				new_count = 0
				
				if selection.count == 1 and classof selection[1] == Editable_Poly then
				(	
					s = selection[1]
					max modify mode
					subObjectLevel = 0
					FacesSelection = #{1..(polyop.getnumfaces s)}
					lbl.text = "Analize tree"
					ids = #()
			
					fr = filterstring edt_fruits.text ","
					lf = filterstring edt_leafs.text ","
					tw = filterstring edt_twigs.text ","
					tr = filterstring edt_trunks.text ","
					st = filterstring edt_stems.text ","
/*					
					if s.material == undefined then rdo.state = 1 else if not (hasproperty s.material "materialIDList") then rdo.state = 1 

					case rdo.state of
					(
						2:
						(
							ids = s.material.materialIDList
						)
						
						1:	
						(		
*/							
							local ids_ = #()
							if chk_fruits.checked then join ids_ fr
							if chk_leafs.checked then join ids_ lf
							if chk_twigs.checked then join ids_ tw
							if chk_trunks.checked then join ids_ tr
							if chk_stems.checked then join ids_ st
							ids = for i in ids_ collect (i as integer)
--						)
--					)
					--print #(ids)
					for id in ids where not keyboard.escPressed do 
					(
						pb.value = (100 * id / ids.count) as integer
						s.selectbymaterial id 
						faceSel = polyOp.getFaceSelection s
						if chk_fruits.checked then for l in fr where (l as integer) == id do fruits += faceSel
						if chk_leafs.checked then for l in lf where (l as integer) == id do leafs += faceSel
						if chk_twigs.checked then for l in tw where (l as integer) == id do twigs += faceSel
						if chk_trunks.checked then for l in tr where (l as integer) == id do trunks += faceSel
						if chk_stems.checked then for l in st where (l as integer) == id do stems += faceSel					
					)
					--print #(trunks)
					
					lbl.text = "Finding elements"
					if chk_fruits.checked then fruits_elems = to_elements s fruits
					if chk_leafs.checked then leafs_elems = to_elements s leafs
					if chk_twigs.checked then twigs_elems = to_elements s twigs
					if chk_trunks.checked then trunks_elems = to_elements s trunks
					if chk_stems.checked then stems_elems = to_elements s stems
					lbl.text = "Finding elements done"
					
					bb = 1
					old_count = trunks_elems.count
					new_count = 0
					
					while old_count != new_count and trunks_elems.count > 0 and not keyboard.escPressed do
					(
						
						if not chk_branches_all.checked and bb > spn_branches_count.value then exit
						old_count = trunks_elems.count
						lbl.text = "Search largest trunk " + bb as string
						e = find_largestXY trunks_elems --самая длинная ветка 
						--e = find_largestZ trunks_elems --самая высокая ветка 
						append points (find_point_nearest_stem trunks_elems[e] s.pos)
						--branch = trunks_elems[e] --начало формирования ветки с ростками
						branch = #()
						branch2 = #()
						branch3 = #()
						branch4 = #()
						
						lbl.text = "Build branch: trunks " + bb as string
						--сначала искать среди trunks_elems, потом среди twigs_elems, потом среди leafs_elems и также fruits_elems

						if chk_separate_trunks.checked then --если надо разделять ветки, не ищем среди этого же массива, просто берем длинную ветку и ищем дальше
						(
							append branch #(trunks_elems[e][1], trunks_elems[e][2], trunks_elems[e][3])
							trunks_elems = for i in (#{1..trunks_elems.count} - #{e}) collect #(trunks_elems[i][1], trunks_elems[i][2], trunks_elems[i][3])
						)	
						else
						(
							arr = case of
							(
								(chk_use_stems_distance.checked and spn_branches_top_distance.value == 0.0): by_distance_ex_ trunks_elems trunks_elems e t s.pos (spn_distance_stem.value as float) (spn_distance_far.value as float)
								(chk_use_stems_distance.checked and spn_branches_top_distance.value != 0.0): by_distance_ex_3 trunks_elems trunks_elems e t s.pos (spn_distance_stem.value as float) (s.max.z - spn_branches_top_distance.value) (spn_distance_far.value as float) --саму себя добавит из второго массива
								(not chk_use_stems_distance.checked): by_distance_ex_2 trunks_elems trunks_elems e t (spn_distance_far.value as float)
							)
							branch = arr[1]
							trunks_elems = arr[2]
							--branch = by_distance_ex trunks_elems trunks_elems e t s.pos (spn_distance_stem.value as float) --саму себя добавит из второго массива
							--после поиска первой ветки, надо удалить ее из списка элементов ветки, так делать с остальными массивами эл-тов
							--trunks_elems = delete_elems_arr trunks_elems branch
						)
						
						if chk_twigs.checked then
						(		
							lbl.text = "Build branch: twigs " + bb as string
							arr = by_distance_all_ branch twigs_elems t (spn_distance_far.value as float)
							branch2 = arr[1]
							twigs_elems = arr[2]
							if spn_twigs_Cycles.value > 1 then
							(
								for c = 2 to spn_twigs_Cycles.value do
								(
									arr = by_distance_all_ branch2 twigs_elems t (spn_distance_far.value as float)
									for cc in arr[1] do append branch2 cc
									twigs_elems = arr[2]
								)
							)								
							--branch2 = by_distance_all branch twigs_elems t
							--twigs_elems = delete_elems_arr twigs_elems branch2
						)
						else
						(
							branch2 = branch
						)
						
						if chk_leafs.checked then
						(					
							lbl.text = "Build branch: leafs " + bb as string
							arr = by_distance_all_ branch2 leafs_elems t (spn_distance_far.value as float)
							branch3 = arr[1]
							leafs_elems = arr[2]
							--branch3 = by_distance_all branch2 leafs_elems t
							--leafs_elems = delete_elems_arr leafs_elems branch3
							if chk_leafs_from_trunks.checked then
							(
								arr = by_distance_all_ branch leafs_elems t (spn_distance_far.value as float)
								for cc in arr[1] do append branch3 cc
								leafs_elems = arr[2]
							)
						)
						else
						(
							branch3 = branch2
						)
						
						if chk_fruits.checked then
						(
							lbl.text = "Build branch: fruits " + bb as string
							arr = by_distance_all_ branch2 fruits_elems t (spn_distance_far.value as float)
							branch4 = arr[1]
							fruits_elems = arr[2]
							--branch4 = by_distance_all branch2 fruits_elems t
							--fruits_elems = delete_elems_arr fruits_elems branch4
						)
						else
						(
							branch4 = branch3
						)

						polyop.detachfaces s (subarray branch + subarray branch2 + subarray branch3 + subarray branch4) asNode:true delete:false name:(s.name + "_branch001")
						br = maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))
						if abs(br.max.x - br.min.x) < spn_rubbish.value and abs(br.max.y - br.min.y) < spn_rubbish.value and abs(br.max.z - br.min.z) < spn_rubbish.value then 
						(
							delete br
						)								
						else 
						(
							try
							(							
								append branches br
								branches[bb].pivot = points[bb]
								append s.children br
								bb += 1
							)
							catch(print ("errored branch found: " + br.name))
						)
						--bb += 1 --перевел в try выше
						new_count = trunks_elems.count
						format "elems counts: tr=% tw=% lf=% fr=%\n" trunks_elems.count twigs_elems.count leafs_elems.count fruits_elems.count
					)
					lbl.text = "Done..."
					pb.value = 100
					gc()
					print #(branches)
					print #(points)
				)	
				else messageBox "select one Editable poly object"			
			)
			
			on btn_find_set_stems pressed do
			(
				t = spn_distance.value
				if selection.count > 0 then
				(	
					s = selection[1]
					lbl.text = "Analize tree"
					FacesSelection = #{1..(polyop.getnumfaces s)}
					elems_poly = #()
					part_of_faces = FacesSelection
					max create mode
					while not part_of_faces.isempty do with redraw off
					(
						if keyboard.escPressed then exit
						for i in part_of_faces where not keyboard.escPressed do 
						(
							elem = polyOp.getElementsUsingFace s #{i} --fence:<fence_facelist>
							--vv = polyop.getVertsUsingFace s elem
							--pp = for v in vv collect polyop.getVert s v
							if pp != undefined then 
							(
								append elems_poly #(elem, elem.numberset) --, pp) --, abs(ss.max.x - ss.min.x), abs(ss.max.y - ss.min.y), abs(ss.max.z - ss.min.z))
							)
							part_of_faces -= elem
							exit
							
						)
						pb.value = (100 - (100*part_of_faces.numberset/FacesSelection.count)) as integer
					)

					if elems_poly.count > 0 then with redraw off
					(
						size_st = 0
						el_stvol = 1
						--maxi = amax (for i in #{1..elems_poly.count} collect elems_poly[i][2])
						--el_stvol = for i in #{1..elems_poly.count} where elems_poly[i][2] == maxi do exit with elems_poly[i][1] 
						--/*
						for i in #{1..elems_poly.count} where not keyboard.escPressed do
						(		
							w = abs(amax(for j in elems_poly[i][2] collect j.z) - amin(for j in elems_poly[i][2] collect j.z)) 
							if w > size_stvol then
							(
								size_stvol = w
								el_stvol = i
							)
						)
						print size_st
						print el_stvol
						--*/
						polyop.setFaceSelection s el_stvol
						if (filterstring edt_stems.text ",")[1] as integer then polyop.setFaceMatID s el_stvol ((filterstring edt_stems.text ",")[1] as integer)
					)
				)	
			)	

			on btn_find_set_trunks pressed do
			(
				t = spn_distance.value
				if selection.count > 0 then
				(	
					s = selection[1]
					lbl.text = "Analize tree"
					FacesSelection = #{1..(polyop.getnumfaces s)}
					elems_poly = #()
					part_of_faces = FacesSelection
					max create mode
					while not part_of_faces.isempty do with redraw off
					(
						for i in part_of_faces where not keyboard.escPressed do 
						(
							elem = polyOp.getElementsUsingFace s #{i} --fence:<fence_facelist>
							vv = polyop.getVertsUsingFace s elem
							pp = for v in vv collect polyop.getVert s v
							if pp != undefined then 
							(
								append elems_poly #(elem, pp) --, abs(ss.max.x - ss.min.x), abs(ss.max.y - ss.min.y), abs(ss.max.z - ss.min.z))
							)
							part_of_faces -= elem
							exit
							
						)
						pb.value = (100 - (100*part_of_faces.numberset/FacesSelection.count)) as integer
					)
					xx = abs (s.max.x - s.min.x) / 6
					yy = abs (s.max.y - s.min.y) / 6
					dd = amax #(xx, yy) --sqrt(xx^2 + yy^2)
					print dd
					if elems_poly.count > 0 then with redraw off
					(
						size_stvol = 0
						el_stvol = 0
						for i = #{1..elems_poly.count} where (w = abs(amax(for j in elems_poly[i][2] collect j.z) - amin(for j in elems_poly[i][2] collect j.z))) > size_stvol do
						(			
							size_stvol = w
							el_stvol = i
						)
						for i = #{1..elems_poly.count} where i != el_stvol do
						(
							x1 = amax (for j in elems_poly[i][2] collect j.x)
							x2 = amin (for j in elems_poly[i][2] collect j.x) 
							y1 = amax (for j in elems_poly[i][2] collect j.y)
							y2 = amin (for j in elems_poly[i][2] collect j.y)
							z1 = amax (for j in elems_poly[i][2] collect j.z)
							z2 = amin (for j in elems_poly[i][2] collect j.z)
							
							w = sqrt((abs(x1 - x2)) ^ 2 + (abs(y1 - y2)) ^ 2 + (abs(z1 - z2)) ^ 2)
							print w
							if w >= dd then --большая, значит ветка
							(
								--polyop.setFaceSelection s elems_poly[i][1]
								if (filterstring edt_trunks.text ",")[1] as integer then polyop.setFaceMatID s elems_poly[i][1] ((filterstring edt_trunks.text ",")[1] as integer)
							)
						)
					)
				)
			)
		)
		createDialog Tree style:#(#style_sunkenedge,#style_titlebar,#style_sysmenu,#style_minimizebox)
	)
)

rollout Obj_Spln "Objects operations" autoLayoutOnResize:true
(
	group "Check Tools"
	(
		button btn_xViewCheckerVerts "xView Verts" width:70 across:4 align:#left tooltip:"Показывать задвоенные группы вершин, расстояния между которыми меньше выбранного порогового значения | Shows doubled and more groups of verts, which have distances less then selected treshold"
		button btn_xViewCheckerFaces "xView Faces" width:70 offset:[15,0] tooltip:"Показывать задвоенные группы граней, расстояние между которыми меньше выбранного порогового значения | Shows doubled and more groups of faces, which have distances less then selected treshold"
		checkbox chk_autoupdate "Auto" checked:true offset:[20,0] tooltip:"Автообновление XView, установите флажок, чтобы предотвратить автоматическое обновление на больших моделях | Auto update xView, check off to prevent auto update on huge models"
		button btn_xViewDisable "Disable All" align:#right tooltip:"Отключить все процедуры XView | Disables all xView procedures"
	
		edittext edt_xViewVerts "Verts" fieldwidth:70 width:70 offset:[0,0] across:3 align:#left
		edittext edt_xViewFaces "Faces" fieldwidth:70 width:70 offset:[-10,0] 
		button btn_xViewSelect "Select Result\Hide" offset:[0,0] align:#right tooltip:"LMB: Выбрать текущие грани или вершины с обнаруженными ошибками и показать количество \n\nRMB: Скрыть невыбранные грани или вершины. Нажмите Unhide All, чтобы отобразить всё обратно | LMB: Selects current founded errored faces or verts and shows count\n\nRMB: Hide unselected faces or verts. Press Unhide All to show all back"

		button btn_FindFaces "Find Faces" width:60 across:3 align:#left tooltip:"Устаревшее\nLMB: Поиск граней, расположенных очень близко друг к другу, вблизи отметки 0,005м\nLMB+CTRL: Поиск копланарных (не перекрывающихся) граней в диапазоне [0,005-0,02]\nLMB+ALT: Поиск по всем вершинам, длиннее | Obsolete\nLMB: Find very close to each other faces near treshhold 0.005m\nLMB+CTRL: Find coplanar (none overlapping) faces in range [0.005-0.02]\nLMB+ALT: Find by all vertices, longer"
		spinner spn_Tresh_xViewChecker "Range" range:[0.0, 1000.0, 0.002] scale:0.001 type:#float offset:[0,0] fieldwidth:40 width:40 tooltip:"Максимальный диапазон задвоек для XView, обычно [0.0 - 0.002] | Maximum of Range of doubles for XView, usually [0.0 - 0.002]"
		button btn_VertexWeld "Guess\VertexWeld" width:95 offset:[0,0] align:#right tooltip:"LMB: Попытка сварить вершины в пределах порога, если они существуют, показать их. Модификатор VertexWeld не применяется, это только для отображения ошибок\n\nRMB: Применить модификатор VertexWeld с текущим порогом treshold | LMB: Try to weld vertices with treshold, if they exist - show them. The modifier VertexWeld do not applies, this only for showing errors\n\nRMB: apply modifier VertexWeld with treshold"	
		--spinner spn_Tresh "" range:[0.0, 1000.0, 0.002] scale:0.001 type:#float fieldwidth:40 width:30 tooltip:""
		--button btn_xViewAll "Autocheck" offset:[30,0] enabled:false 

		button btn_MoveFaces "Move Faces" width:64 across:4 align:#left offset:[0,0] tooltip:"LMB: Раздвинуть все или выбранные задвоенные грани на желаемое расстояние. Нормали граней - направление сдвига\nLMB+CTRL: Только выбрать\nLMB+ALT: Использовать нормали вершин вместо нормалей граней\nLMB+SHIFT: Двигать элементы целиком\nRMB: Другой метод | LMB: Find and move coplanar dual faces in current range to desired distance\nLMB+CTRL: Select only\nLMB+ALT: Use verts normals instead of face normals\nLMB+SHIFT: Move while elements\nRMB: alternative method"
		button btn_MoveEdges "Move Edges" width:64 offset:[4,0] tooltip:"LMB: Раздвинуть все или выбранные задвоенные ребра на желаемое расстояние. Учитываются нормали вершин элемента для направления сдвига\nLMB+CTRL: Только выбрать\nLMB+ALT: Сдвигать только близкие вершины, а не ребра целиком | LMB: Move the selected doubled edges to the desired distance\nLMB+CTRL: Select only\nLMB+ALT: Move only the nearby vertices, not the entire edges"
		button btn_MoveVerts "Move Verts" width:64 offset:[2,0] tooltip:"LMB: Раздвинуть все или выбранные задвоенные вершины на желаемое расстояние. Учитываются нормали вершин для направления сдвига\nLMB+CTRL: Только выбрать\nLMB+ALT: Вектора из задвоенных вершин вместо нормалей вершин\nRMB: Другой метод | LMB: Find and move dual verts\nLMB+CTRL: Select only\nRMB+ALT: Use dual verts as vector instead of using verts normals"
		button btn_MoveXView "Move xView" width:64 offset:[0,0] align:#right tooltip:"LMB: Раздвинуть найденные xView задвоенные вершины или грани на желаемое расстояние (следует выбрать текущий режим xView) | LMB: Move the duplicated vertices and faces found by xView to the desired distance"
		checkbox chk_MoveFacesEdgesVerts_acuracy "Accuracy" checked:true offset:[0,0] across:3 align:#left tooltip:"Использовать высокую точность (поиск по дополнительным вершинам, к центрам граней), потребуется больше времени | Use high accuracy (search with verts positions additional to face centers), need more time"
		checkbox chk_MoveFacesEdgesVerts_bidirectional "Bi-directional" checked:true offset:[-20,0] tooltip:"Искать ТОЛЬКО с противоположно направленными гранями, наложенными друг на друга или разделенными, как заборы, стекла, деревья | Find ONLY with opposite directional faces, overlapped inside each other or pared like fences, glasses, trees"
		checkbox chk_MoveFacesEdgesVerts_codirectional "Co-directional" checked:false offset:[0,0] align:#right tooltip:"Искать ТОЛЬКО с сонаправленными гранями, близкими копланарными гранями с одинаковыми нормалями | Find ONLY with co-directional faces, near coplanar faces with same normals"
		spinner spn_MoveFacesEdgesVerts_angle "Angle" range:[0.0, 360.0, 0.01] scale:0.001 type:#float offset:[0,0] fieldwidth:40 width:40 across:3 align:#left tooltip:"Угол, близкий к параллельности | Angle of near parallelism"
		spinner spn_MoveFacesEdgesVerts_distance "To:" range:[0.0, 1000.0, 0.003] scale:0.001 type:#float offset:[-10,0] fieldwidth:40 width:40 tooltip:"Расстояние, на которое необходимо переместить | Distance to be moved"
		dropdownList ddl_MoveFacesEdgesVerts_range "" items:#("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]") selection:1 fieldwidth:100 width:100 offset:[0,0] align:#right tooltip:"Искать в диапазоне:\n[0,0 - 0,002] подходит для двойных граней и вершин\n [0,0 - 0,005] подходит для почти копланарных граней \n[0,005 - 0,02] подходит для копланарных граней с противоположными нормалями\n[0,01 - 0,02] подходит для моделей UCX\nДругие диапазоны только для целей тестирования\nВсе методы определяют расстояние от одной грани до другой вслепую, поэтому используйте большие диапазоны с выбранными и отсоединенными в отдельный объект, поскольку они могут быть смещены из-за неизвестных ошибок при тестировании расстояния | Find in range:\n[0.0 - 0.002] suitable for dual faces and verts\n[0.0 - 0.005] suitable for near coplanar faces\n[0.005 - 0.02] suitable for coplanar faces with opposite normals\n[0.01 - 0.02] suitable for UCX models\n\nOther ranges for tests purpose only.\n\nAll methods just find the distance from one face to another blindly, so use large ranges with selected and detached isolated faces, overwise they may be moved out due unknown errors distance tests"
		
		button btn_FlipFaces "Flip Faces" enabled:false width:60 offset:[0,0] across:5 tooltip:"Найти копланарные грани c нормалями смотрящими друг на друга и направить их в противоположные стороны | Find coplanar faces with wrong normals and direct them in opposite sides"
		button btn_DoubleFaces "Double Faces" width:70 offset:[18,0] tooltip:"Выделить элементы одной половины из набора двойных граней, нужно для Flora преобразования ВПМ в НПМ | To select elements from one half of a set of double faces, needful for Flora to convert HighPoly to Lowpoly models"
		button btn_View_Normals "View Normals" width:78 offset:[50,0] align:#right tooltip:"LMB: Просмотр нормалей в окне проекций. Синий - передняя сторона полигонов - правильно, оранжевый - задняя сторона полигонов - неправильно\nCTRL+LMB: цвета - зеленый и синий\nALT+LMB: цвета - серый и синий\n\nНажать еще раз - вернуть просмотр обратно | LMB: View normals in viewport by assigning a new double-sided material. Blue - the front side of the polygons - correct, orange - the back side of the polygons - incorrect\nCTRL+LMB: alternate colors - green and blue\nALT+LMB: alternate colors - gray and blue\n\nClick again to return the usual view back"
		button btn_UnhideVertsFaces2 "Unhide All" offset:[50,0] width:56 align:#left tooltip:"Отобразить все скрытые части объекта EDITABLE POLY и после UVW_Unwrap | Unhide all hidden parts of EDITABLE POLY object and after UVW_Unwrap"
		edittext edt_View_Normals "" width:0 height:0 fieldwidth:0 align:#left
	)
	
	group "Modeling Tools"
	(		
		button btn_TriangulateRight "Triangulate" offset:[0,0] across:3 align:#left tooltip:"LMB: Аналог кнопки Connect всех вершин в EDITABLE POLY, но работает не создавая наложенных ребер\nRMB: Проверить триангуляцию выбранного объекта | LMB: Analog of All-vertices Connect button in Editable poly, but working better, do not produce overlayed edges\nRMB: Check Triangulation of selected object"
		button btn_TurnToPoly "TurnToPoly Mod" align:#left offset:[-10,0] tooltip:"Модификатор TurnToPoly - может приводить к ошибкам | 3ds max TurnToPoly modifier - may couse errors"  
		button btn_ConnectVerts "Connect Verts" offset:[0,0] align:#right tooltip:"Модификатор Verts Connect - может приводить к ошибкам | 3ds max Verts Connect modifier - may couse errors"  

		button btn_RemoveErrEdges "Remove Overlay Edges" align:#left across:2 tooltip:"LMB: Удалить ребра с наложенными ребрами\nCTRL+LMB: Только выбрать | LMB: Try to remove errored-overlayed edges\nCTRL+LMB: only select"		
		button btn_RemoveVerts "Remove 2-edged Verts" offset:[0,0] align:#right tooltip:"Удалить вершины с ошибками (после модификаторов Slice и ShapeMerge). Это копия кнопки из свитка Slicers. Смотрите дополнительные опции по RMB и treshold | Try to Remove two-edged error vertices\n(after Slice and ShapeMerge modifiers)\nThis is the copy of button from Slicers Rollout\nSee there for more options by RMB and treshold" --btn_remove
	
		button btn_TargetWeld "Nearest Weld" offset:[0,0] width:70 across:4 align:#left tooltip:"Сварить выбранные вершины к другим на ближайших расстояниях | Welds selected vertexes with nearest distance"		
		button btn_EdgeWeld "Edges Weld" offset:[5,0] width:60 align:#left tooltip:"Сварить все наложенные ребра в выделенных моделях, работает также только на выделении ребер | Weld all overlayed edges in selected objects, also work only on selected edges"
		button btn_ResetXform "ResetXform" offset:[3,0] width:60 tooltip:"Модификатор ResetXform | 3ds max ResetXform modifier"
		button btn_DetachFaces "Detach Elems" offset:[0,0] width:70 align:#right tooltip:"Отсоединить все элементы, чтобы разделить EDITABLE POLY объекты | Detach all elements to separate objects EDITABLE POLY"
		
		--button btn_UnhideVertsFaces "Unhide Errors" offset:[0,0] align:#right tooltip:"Unhide all verts and faces in Editable Poly object after UVW_Unwrap"

		button btn_Detriangulate "Detriangulate" align:#left across:4 tooltip:"LMB: Детриангулировать выбранные объекты, только выбранные грани в них\nLMB+CTRL: Только выбрать триангулированные ребра\nLMB+Alt: Выбор не триангулированных ребер | LMB: Detriangulate Selection of objects, only selected faces in objects\nLMB+CTRL: Only select triangulated edges\nLMB+Alt: Select none triangulated edges"
		checkbox chk_DetriangulateSel "Invert" checked:false offset:[25,0] tooltip:"Выбрать не триангулированные ребра | Select none triangulated edges" 
		checkbox chk_DetriangulateUV "UV" checked:true offset:[15,0] tooltip:"Не детриангулировать ребра, которые находятся в разных UV-островах | Do not detriangulate edge which in different UV islands" 
		checkbox chk_DetriangulateSM "SM Groups" checked:true offset:[0,0] align:#right tooltip:"Не детриангулировать ребра, которые находятся на границах разных групп сглаживания | Do not detriangulate edge which on border of different Smoothing Groups"
		checkbox chk_DetriangulateDisputed "Disputed" across:3 checked:false offset:[0,0] align:#left tooltip:"Не детриангулировать ребра в спорных местах | Do not detriangulate edges in Disputed places"
		checkbox chk_DetriangulateAn "Use angle" checked:true offset:[0,0] tooltip:"Не детриангулировать ребра с углом между соседними гранями меньше выбранного порогового значения | Do not detriangulate edges with angle between neighbour faces less then choosen treshold" 
		spinner spn_DetriangulateAngle "" range:[0.0, 360.0, 10.0] scale:0.001 type:#float fieldwidth:50 align:#right tooltip:"Угол между соседними гранями | Angle between neighbour faces"
		--button btn_CreatePoly "Create Polygon" tooltip:"Try to create polygon from selected vertices"	
	
		button btn_Autosmooth "AutoSmooth" across:4 width:65 align:#left tooltip:"LMB: Автоматическое сглаживание выбранных объектов по выбранному углу\nRMB: Очистка всех групп сглаживания выбранных объектов | LMB: Autosmooth selected objects by selected angle\nRMB: Clear all smoothing groups of selected objects"
		spinner spn_AutosmoothAngle "" range:[0.0, 360.0, 30.0] scale:0.001 type:#float width:35 fieldwidth:35 offset:[-13,2] tooltip:"Угол между соседними гранями | Angle between neighbour faces"
		button btn_DeleteIso "DeleteIsolated" offset:[-10,0] width:73 tooltip:"Удалить изолированные вершины и мертвые структуры во всех выбранных объектах, объекты будут переведены в Editable Poly | Delete isolated verts and dead structs in all selected objects, will be collapsed to Editable Poly objects"
		button btn_DeleteColorAttributes "ColorAttributes" offset:[0,0] width:75 align:#right tooltip:"Удалить изолированные вершины и мертвые структуры во всех выбранных объектах, объекты будут переведены в Editable Poly | Delete isolated verts and dead structs in all selected objects, will be collapsed to Editable Poly objects"

		button btn_select_Outer_edges "Select Outer Edges" across:3 align:#left tooltip:"Выбрать ребра, лежащие по периметру объекта | Select object edges laying by perimeter of object"
		checkbox chk_ignoreHardEdges "Hard Edges" checked:false offset:[18,0] tooltip:"Игнорировать жесткие ребра (ребра разных групп сглаживания) | Ignore Hard edges (edges on different smoothing groups)"
		checkbox chk_ignoreOpenEdges "Open Edges" checked:false offset:[5,0] align:#right tooltip:"Игнорировать открытые ребра | Ignore Open edges"

		button btn_Projection "Surface Projection" align:#right width:260 tooltip:"LMB: Спроецировать выбранные объекты на поверхность базового объекта по оси Z\nLMB+CTRL: Создать новую поверхность из базового объекта\n\nRMB: Пометить объект как базовый\nRMB+CTRL: Вытянуть границы в стороны и пометить объект как базовый | LMB: Project selected objects to surface of base object by Z-Axis\nLMB+CTRL: Create new surface from baseobject for projection\n\nRMB: Mark selected object as baseobject\nRMB+CTRL: for selected object extrude edges as padding edges and set it as baseobject"
	)	
	
	on Obj_Spln open do
	(
		for i in Obj_Spln.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_objs.ini") i.name "Obj_Spln" (syssetup.rdo_lang.state))
	)
	
	on ddl_MoveFacesEdgesVerts_range selected arg do 
	(
		spn_MoveFacesEdgesVerts_distance.value = case ddl_MoveFacesEdgesVerts_range.items[arg] of
		(
			--("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]")
			"[0.0 - 0.002]": 0.003
			"[0.0 - 0.005]": 0.01
			"[0.005 - 0.02]": 0.01
			"[0.01 - 0.02]": 0.015
			"[0.0 - 0.02]": 0.01
			"[0.0 - 0.03]": 0.01
			"[0.0 - 0.05]": 0.01
			"[0.0 - 0.1]": 0.01
			"[0.0 - 1.0]": 0.01
		)			
	)
	
	on btn_View_Normals pressed do with undo "View Normals" on
	(
		if selection.count > 0 then
		(
			local ctrl = keyboard.controlPressed
			local alt = keyboard.altPressed
			for i in selection do
			(
				if i.material != undefined then
				(			
					if i.material.name == "ViewNormals" then 
					(
						try(subObjectLevel = 0)catch()
						i.material = i.material.originalMaterial
						local arr = #()
						if edt_View_Normals.text != "" then
						(
							if ((maxversion())[1] / 1000) >= 26 then --27 ver = max 2025
							(
								--showinterfaces (NitrousGraphicsManager.GetActiveViewportSetting())
								if NitrousGraphicsManager.IsEnabled() then
								(
									arr = filterstring edt_View_Normals.text ";"
									--print edt_View_Normals.text
									local method = NitrousGraphicsManager.GetActiveViewportSetting()
									try
									(
										method.ViewportPreset = arr[1]
										method.DefaultLightMode = arr[2]
										method.LightOption = arr[3]
										method.TransparencyEnabled = arr[4] as booleanClass
										method.ShowEdgedFacesEnabled = arr[5] as booleanClass
										method.SelectedEdgedFacesEnabled = arr[6] as booleanClass
										method.ShadeSelectedObjectsEnabled = arr[7] as booleanClass
										method.ShowSelectionBracketsEnabled = arr[8] as booleanClass
										method.ShadeSelectedFacesEnabled = arr[9] as booleanClass
										method.ProgressiveRenderingEnabled = arr[10] as booleanClass
										method.VisualStyleMode = arr[11]
										method.ShadowsEnabled = arr[12] as booleanClass
										method.AmbientOcclusionEnabled = arr[13] as booleanClass
										method.OverrideMaterialOption = arr[14] 
										method.ShowMaterialOption = arr[15] 	
										method.ReflectionEnabled = arr[16] as booleanClass
										method.UseSimplifiedSkyLight = arr[17] as booleanClass
										method.ShowHighlightEnabled = arr[18] as booleanClass
									)catch(print "parameters do not returned back right")
								)
							)
						)
						redrawViews()
					)
					else
					(
						--if not ctrl and not alt then Синий - видна передняя сторона полигонов - правильно, оранжевый - видна задняя сторона полигонов - неправильно
						--if ctrl then альтернативные цвета - зеленый и синий
						--if alt then альтернативные цвета - серый и синий
						
						try(subObjectLevel = 0)catch()
						
						if ctrl then i.material = Shell_material name:"ViewNormals" originalMaterial: i.material bakedMaterial: (DoubleSided name:"ViewNormals" isTwoSidedMaterial:true material1: (PhysicalMaterial name:"FrontFaces" base_color:green emit_color:green emission:0.13) material2: (PhysicalMaterial name:"BackFaces" base_color:blue emit_color:blue emission:0.13)) viewportMtlIndex:1 renderMtlIndex:1
						if alt then i.material = Shell_material name:"ViewNormals" originalMaterial: i.material bakedMaterial: (DoubleSided name:"ViewNormals" isTwoSidedMaterial:true material1: (PhysicalMaterial name:"FrontFaces" base_color:(color 170 170 170) emit_color:(color 170 170 170) emission:0.13) material2: (PhysicalMaterial name:"BackFaces" base_color:blue emit_color:blue emission:0.13)) viewportMtlIndex:1 renderMtlIndex:1	
						if not alt and not ctrl then i.material = Shell_material name:"ViewNormals" originalMaterial: i.material bakedMaterial: (DoubleSided name:"ViewNormals" isTwoSidedMaterial:true material1: (PhysicalMaterial name:"FrontFaces" base_color:blue emit_color:blue emission:0.13) material2: (PhysicalMaterial name:"BackFaces" base_color:orange emit_color:orange emission:0.13)) viewportMtlIndex:1 renderMtlIndex:1	

						--Shell_material name:"ViewNormals" originalMaterial: i.material bakedMaterial: (DoubleSided name:"ViewNormals" isTwoSidedMaterial:true material1: (StandardMaterial name:"FrontFaces" diffuse:red material2: (StandardMaterial name:"BackFaces" diffuse:blue) selfIllumAmount:100)) viewportMtlIndex:1 renderMtlIndex:1
						if ((maxversion())[1] / 1000) >= 26 then --27 ver = max 2025
						(
							--showinterfaces (NitrousGraphicsManager.GetActiveViewportSetting())
							if NitrousGraphicsManager.IsEnabled() then
							(
								local method = NitrousGraphicsManager.GetActiveViewportSetting()
								local str = ""
								str += method.ViewportPreset as string + ";" 
								str += method.DefaultLightMode as string + ";" 
								str += method.LightOption as string + ";" 
								str += method.TransparencyEnabled as string + ";" 
								str += method.ShowEdgedFacesEnabled as string + ";" 
								str += method.SelectedEdgedFacesEnabled as string + ";"
								str += method.ShadeSelectedObjectsEnabled as string + ";"
								str += method.ShowSelectionBracketsEnabled as string + ";"
								str += method.ShadeSelectedFacesEnabled as string + ";"
								str += method.ProgressiveRenderingEnabled as string + ";"
								str += method.VisualStyleMode as string + ";"
								str += method.ShadowsEnabled as string + ";"
								str += method.AmbientOcclusionEnabled as string + ";"
								str += method.OverrideMaterialOption as string + ";"
								str += method.ShowMaterialOption as string + ";"
								str += method.ReflectionEnabled as string + ";"
								str += method.UseSimplifiedSkyLight as string + ";" 
								str += method.ShowHighlightEnabled as string 
								
								edt_View_Normals.text = str
								--print edt_View_Normals.text
								
								method.ViewportPreset = #Quality -- {#Quality|#Standard|#Performance|#DXMode|#Customize}
								method.DefaultLightMode = #OneLight
								method.LightOption = #DefaultLight
								method.TransparencyEnabled = true
								method.ShowEdgedFacesEnabled = false 
								method.SelectedEdgedFacesEnabled = false
								method.ShadeSelectedObjectsEnabled = false
								method.ShowSelectionBracketsEnabled = false
								method.ShadeSelectedFacesEnabled = true --false
								method.ProgressiveRenderingEnabled = false
								method.VisualStyleMode = #Realistic  -- VisualStyleMode enums: {#Realistic|#Shaded|#Facets|#ConsistentColors|#HiddenLine|#Wireframe|#BoundingBox|#Clay|#ModelAssist|#Ink|#ColorInk|#Acrylic|#Tech|#Graphite|#ColorPencil|#Pastel}
								method.ShadowsEnabled = false
								method.AmbientOcclusionEnabled = false
								method.OverrideMaterialOption = #None
								method.ShowMaterialOption = #Realistic --{#Default|#Shaded|#Realistic}	
								method.ReflectionEnabled = false
								method.UseSimplifiedSkyLight = false
								method.ShowHighlightEnabled = false
							)
						)
						redrawViews()
					)
				)
				else
				(
					try(subObjectLevel = 0)catch()
					if ctrl then i.material = Shell_material name:"ViewNormals" originalMaterial: i.material bakedMaterial: (DoubleSided name:"ViewNormals" isTwoSidedMaterial:true material1: (PhysicalMaterial name:"FrontFaces" base_color:green emit_color:green emission:0.13) material2: (PhysicalMaterial name:"BackFaces" base_color:blue emit_color:blue emission:0.13)) viewportMtlIndex:1 renderMtlIndex:1
					if alt then i.material = Shell_material name:"ViewNormals" originalMaterial: i.material bakedMaterial: (DoubleSided name:"ViewNormals" isTwoSidedMaterial:true material1: (PhysicalMaterial name:"FrontFaces" base_color:(color 170 170 170) emit_color:(color 170 170 170) emission:0.13) material2: (PhysicalMaterial name:"BackFaces" base_color:blue emit_color:blue emission:0.13)) viewportMtlIndex:1 renderMtlIndex:1	
					if not alt and not ctrl then i.material = Shell_material name:"ViewNormals" originalMaterial: i.material bakedMaterial: (DoubleSided name:"ViewNormals" isTwoSidedMaterial:true material1: (PhysicalMaterial name:"FrontFaces" base_color:blue emit_color:blue emission:0.13) material2: (PhysicalMaterial name:"BackFaces" base_color:orange emit_color:orange emission:0.13)) viewportMtlIndex:1 renderMtlIndex:1	
				
					--i.material = Shell_material name:"ViewNormals" originalMaterial: i.material bakedMaterial: (DoubleSided name:"ViewNormals" isTwoSidedMaterial:true material1: (PhysicalMaterial name:"FrontFaces" base_color:(if ctrl then green else blue) emit_color:(if ctrl then green else blue) emission:0.13) material2: (PhysicalMaterial name:"BackFaces" base_color:(if ctrl then blue else yellow) emit_color:(if ctrl then blue else yellow) emission:0.13)) viewportMtlIndex:1 renderMtlIndex:1
					--Shell_material name:"ViewNormals" originalMaterial: undefined bakedMaterial: (DoubleSided name:"ViewNormals" isTwoSidedMaterial:true material1: (StandardMaterial name:"FrontFaces" diffuse:red) material2: (StandardMaterial name:"BackFaces" diffuse:blue selfIllumAmount:100)) viewportMtlIndex:1 renderMtlIndex:1
					if NitrousGraphicsManager.IsEnabled() then --/*(color 255 0 143)*/ 
					(
						local method = NitrousGraphicsManager.GetActiveViewportSetting()
						local str = ""
						str += method.ViewportPreset as string + ";" 
						str += method.DefaultLightMode as string + ";" 
						str += method.LightOption as string + ";" 
						str += method.TransparencyEnabled as string + ";" 
						str += method.ShowEdgedFacesEnabled as string + ";" 
						str += method.SelectedEdgedFacesEnabled as string + ";"
						str += method.ShadeSelectedObjectsEnabled as string + ";"
						str += method.ShowSelectionBracketsEnabled as string + ";"
						str += method.ShadeSelectedFacesEnabled as string + ";"
						str += method.ProgressiveRenderingEnabled as string + ";"
						str += method.VisualStyleMode as string + ";"
						str += method.ShadowsEnabled as string + ";"
						str += method.AmbientOcclusionEnabled as string + ";"
						str += method.OverrideMaterialOption as string + ";"
						str += method.ShowMaterialOption as string + ";"
						str += method.ReflectionEnabled as string + ";"
						str += method.UseSimplifiedSkyLight as string + ";" 
						str += method.ShowHighlightEnabled as string 
								
						edt_View_Normals.text = str
						--print edt_View_Normals.text
						
						method.ViewportPreset = #Quality -- {#Quality|#Standard|#Performance|#DXMode|#Customize}
						method.DefaultLightMode = #TwoLights
						method.LightOption = #DefaultLight
						method.TransparencyEnabled = true
						method.ShowEdgedFacesEnabled = false 
						method.SelectedEdgedFacesEnabled = false
						method.ShadeSelectedObjectsEnabled = false
						method.ShowSelectionBracketsEnabled = false
						method.ShadeSelectedFacesEnabled = true --false
						method.ProgressiveRenderingEnabled = false
						method.VisualStyleMode = #Realistic  -- VisualStyleMode enums: {#Realistic|#Shaded|#Facets|#ConsistentColors|#HiddenLine|#Wireframe|#BoundingBox|#Clay|#ModelAssist|#Ink|#ColorInk|#Acrylic|#Tech|#Graphite|#ColorPencil|#Pastel}
						method.ShadowsEnabled = false
						method.AmbientOcclusionEnabled = false
						method.OverrideMaterialOption = #None
						method.ShowMaterialOption = #Realistic --{#Default|#Shaded|#Realistic}	
						method.ReflectionEnabled = false
						method.UseSimplifiedSkyLight = false
						method.ShowHighlightEnabled = false
					)
					redrawViews()	
				)
				--<void>viewport.SetRenderLevel <render_level> 
				--<void>viewport.SetShowEdgeFaces <boolean> 
				--<void>viewport.SetRenderLevel <render_level> 
				--<void>viewport.SetTransparencyLevel <transp_level> 
			)
		)
		else messagebox "Select some object first"
	)
	
	on btn_DeleteColorAttributes pressed do with undo "Delete Color Attributes" on
	(
		if selection.count > 0 then
			for i in selection do
			(
				channelInfo.ClearChannel $ 0
				channelInfo.ClearChannel $ -1
				channelInfo.ClearChannel $ -2
			)
	)
	
	on btn_select_Outer_edges pressed do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then getConvexEdges selection[1] true 45 chk_ignoreHardEdges.checked chk_ignoreOpenEdges.checked
		else messagebox "Select single Editable Poly object" 
	)
	
	on btn_Projection rightclick do with undo "Padding border" on
	(
		ctrl = keyboard.controlPressed
		if selection.count == 1 then
		(
			if ctrl then 
			(
				s = selection[1] 
				if classof s != Editable_Poly then convertToPoly s
				select s
				max modify mode
				subObjectLevel = 3
				max select all
				--polyop.createShape s (polyop.getEdgeSelection s) smooth:false name:(s.name + "Shape01") node:$spl
				s.edgeExtrudeHeight = -0.001
				s.edgeExtrudeWidth = 0.0
				s.EditablePoly.buttonOp #Extrude
				s.edgeExtrudeHeight = 0.5
				s.edgeExtrudeWidth = 0.0
				s.EditablePoly.buttonOp #Extrude	
				subObjectLevel = 0		
				btn_Projection.text = selection[1].name				
			)
			else btn_Projection.text = selection[1].name
		)
	)
	
	on btn_Projection pressed do with undo "Projection" on
	(		
		ctrl = keyboard.controlPressed
		
		if ctrl then
		(
			s = (for i in objects where i.name == btn_Projection.text collect i)[1] 
			if s != undefined then	
			(
				if classof s != Editable_Poly then convertToPoly s
				select s
				max modify mode
				subObjectLevel = 3
				max select all				
				polyop.setEdgeSelection $ #all
				$.EditablePoly.SelectBorder()
				polyop.createShape s #selection smooth:false name:(s.name + "_Shape001") --node:&spl
				subObjectLevel = 0
				select (maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))) --(s.name + "_Shape001")
				spl = selection[1]
					
				flatten()					
				addmodifier spl (uvwmap length:2.5 width:2.5 maptype:0 axis:2)

				spl.pos = s.pos 	
				spl.pivot = spl.center
					
				slicers.spn_gor_X.value = 2.5
				slicers.spn_gor_Xoffset.value = 0.0
				slicers.chk_gor_Xfuses.checked = false
				slicers.spn_gor_Y.value = 2.5
				slicers.spn_gor_Yoffset.value = 0.0
				slicers.chk_gor_Yfuses.checked = false
					
				slicers.btn_slice.pressed()
				slicers.btn_conv.pressed()
				slicers.btn_remove.pressed()
					
				spl.pos.z += 10	
			)
		)
		else
		(
			BaseObject = (for i in objects where i.name == btn_Projection.text collect i)[1] 
			Axiz = [0,0,-1]
			if BaseObject != undefined then
				for GluedObject in selection do
				(
					if classof GluedObject != Editable_Poly then convertTo GluedObject PolyMeshObject
					for v in GluedObject.verts do
					(
						IntersectedRay = intersectRay BaseObject (ray v.pos Axiz)
						if IntersectedRay != undefined then v.pos = IntersectedRay.pos
					)
				)
		)
	)
	
	on btn_Autosmooth pressed do with undo "Autosmooth selected" on with redraw off
	(
		sel = selection as array
		max modify mode
		for i in sel do 
		(
			converttopoly i 
			polyop.setFaceSelection i #{1..(polyop.getNumFaces i)}
			i.autoSmoothThreshold = spn_AutosmoothAngle.value
			polyop.autoSmooth i 
		)
		select sel
	)
	
	on btn_Autosmooth rightclick do with undo "Clear smoothing groups" on with redraw off	
	(
		sel = selection as array
		max modify mode
		for i in sel do 
		(
			addmodifier i (edit_poly ()) 	
			i.modifiers[#Edit_Poly].SetSelection #Face #{1..(i.modifiers[#Edit_Poly].GetNumFaces())}
			i.modifiers[#Edit_Poly].SetOperation #SetSmooth
			i.modifiers[#Edit_Poly].smoothingGroupsToSet = 0
			i.modifiers[#Edit_Poly].smoothingGroupsToClear = -1
			converttopoly i 	
			--children = windows.getChildrenHWND (windows.getDesktopHWND())
			--pickBaseButton = (for c in (windows.getChildrenHWND (windows.getDesktopHWND())) where (c[5] == "Clear All") collect (c))[1]
			--UIAccessor.pressButton pickBaseButton[1]
		)
		select sel
	)	
		
	on btn_DeleteIso pressed do with undo "Delete isolated verts and dead structs" on 
	(
		sel = selection as array
		max modify mode
		for i in sel do 
		(
			converttopoly i 
			polyop.deleteIsoVerts i
			polyop.CollapseDeadStructs i
		)
		select sel
	)
	
	on btn_ConnectVerts pressed do with undo "Connect all verts" on 
	(
		sel = selection as array
		for i in sel where classof i == editable_poly do 
		(
			select i
			max modify mode
			subObjectLevel = 1
			i.unhideAll #Vertex
			i.unhideAll #Face
			max select all 
			i.ConnectVertices vertexFlag:1
			subObjectLevel = 0
		)
		select sel
	)
	
	on btn_Detriangulate pressed do with redraw off
	(
		sel = selection
		ctrl = keyboard.controlPressed
		alt = keyboard.altPressed
		if selection.count > 0 then
			for poly in selection do
			(
				if classof poly == Editable_Poly then
				(
					panel_mode = getCommandPanelTaskMode()
					sub_level = subObjectLevel
					max create mode 					
					numEdges = polyop.getNumEdges poly
					numFaces = polyop.getNumFaces poly
					faces_sel = #{}
					faces_sel = polyop.getFaceSelection poly
					faces = if not faces_sel.isempty and faces_sel.numberset < numFaces then faces_sel else #{1..numFaces}
					edges = polyop.getEdgesUsingFace poly faces
					if not alt then edges -= (polyop.getEdgesUsingFace poly (#{1..numFaces} - faces)) --вычитаем граничные ребра с невыделенными полигонами
					
					polyOp.setEdgeSelection poly edges
					--print #(edges)
						
					del = not ctrl
					uv = chk_DetriangulateUV.checked
					sm = chk_DetriangulateSM.checked
					ang = chk_DetriangulateAn.checked	
					an = spn_DetriangulateAngle.value
					disputed = chk_DetriangulateDisputed.checked
					inv = chk_DetriangulateSel.checked	
					
					if not alt then 
						detriangulate poly edges faces uv sm ang an disputed del inv --детриангуляция или выделение согласно галкам
					else 
						detriangulate poly edges faces uv sm ang an disputed del true --выделение почти параллельных эджей
						--select_edges poly edges faces uv sm ang an 10.0

					setCommandPanelTaskMode panel_mode
					if sub_level != undefined then subObjectLevel = sub_level
				)
				else messagebox ("Selected object is not an Editable Poly.")			
			)
	)
	
	on chk_autoupdate changed arg do
	(
		xViewChecker.autoUpdate = chk_autoupdate.checked
	)		
	
	on btn_xViewCheckerVerts pressed do
	(
		xViewChecker.on = true
		xViewChecker.seeThrough = true
		xViewChecker.activeIndex = 6
		xViewChecker.autoUpdate = chk_autoupdate.checked --true
		OverlappingVertices.tolerance = spn_Tresh_xViewChecker.value
		xViewChecker.runCheck currentTime
		--edt_xViewVerts.text = xViewChecker.getCurrentOutputCount() as string
	)

	on btn_xViewCheckerFaces pressed do
	(
		xViewChecker.on = true
		xViewChecker.seeThrough = true
		xViewChecker.activeIndex = 2
		xViewChecker.autoUpdate = chk_autoupdate.checked --true
		OverlappingFaces.tolerance = spn_Tresh_xViewChecker.value
		xViewChecker.runCheck currentTime
		--edt_xViewFaces.text = xViewChecker.getCurrentOutputCount() as string
	)
	
	on btn_xViewSelect pressed do
	(
		if xViewChecker.activeIndex == 6 then try
		(
			edt_xViewVerts.text = xViewChecker.getCurrentOutputCount() as string
			subobjectlevel = 1
		)catch()
		if xViewChecker.activeIndex == 2 then try
		(
			edt_xViewFaces.text = xViewChecker.getCurrentOutputCount() as string
			subobjectlevel = 4
			
		)catch()
		xViewChecker.selectResults currentTime
	)
	
	on btn_xViewSelect rightclick do
	(
		if xViewChecker.activeIndex == 6 then try
		(
			subobjectlevel = 1
			polyop.setHiddenVerts $ (#{1..(polyop.getNumVerts $)} - (polyOp.getvertselection $)) --$.Hide #Vert
		)catch()
		if xViewChecker.activeIndex == 2 then try
		(
			subobjectlevel = 4
			polyop.setHiddenFaces $ (#{1..(polyop.getNumFaces $)} - (polyOp.getfaceselection $)) --$.Hide #Face
		)catch()
	)
	
	on btn_xViewDisable pressed do
	(
		xViewChecker.on = false
	)
	
	on btn_UnhideVertsFaces2 pressed do
	(
		max modify mode
		sel = selection as array
		for i in sel where classof i == editable_poly do 
		(
			select i
			i.unhideAll #Vertex
			i.unhideAll #Face
		)
	)
	
	on btn_UnhideVertsFaces pressed do
	(
		max modify mode
		sel = selection as array
		for i in sel where classof i == editable_poly do 
		(
			select i
			--subObjectLevel = 1
			i.unhideAll #Vertex
			i.unhideAll #Face
			--subObjectLevel = 0
		)
		select sel
	)

/*	
	on btn_DetachFaces pressed do with undo "Explode All Faces" on with redraw off
	(
		ctrl = keyboard.controlPressed
		if not ctrl then 
		(
			max modify mode
			selmod = modpanel.getcurrentobject()
			if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
			(
				while (faces = selmod.GetSelection #Face) != 0 do polyOp.detachFaces selmod #{(faces as array)[1]} asNode:false delete:false node:editable_poly
			)		
		)
		else
		(
			if selection.count == 1 and classof selection[1] == Editable_Poly then	
			(
				max create mode 
				while polyOp.getNumFaces selection[1] != 0 do polyOp.detachFaces selection[1] #{1} asNode:false delete:false node:editable_poly
			)
		)
	)
*/	

	on btn_DetachFaces pressed do UCX.btn_UCX_explode.pressed()

	on btn_FlipFaces pressed do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			s = selection[1]
			max modify mode
			err = #()
			points = #()
			verts = #{}
			selfaces = #{}
			selfaces = polyOp.getfaceselection s
			if selfaces.isempty then selfaces = #{1..(polyOp.getNumFaces s)}
			
			if not selfaces.isempty then 
			(		
				--("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]")		
				minimum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.0
					2: 0.0
					3: 0.005
					4: 0.01
					5: 0.0
					6: 0.0
					7: 0.0
					8: 0.0
					9: 0.0
				)
				maximum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.002
					2: 0.005
					3: 0.02
					4: 0.02
					5: 0.02
					6: 0.03
					7: 0.05
					8: 0.1					
					9: 1.0
				)
				dist = spn_MoveFacesEdgesVerts_distance.value 
				do_verts = chk_MoveFacesEdgesVerts_acuracy.checked
				near_perpendicular = spn_MoveFacesEdgesVerts_angle.value 
				
				invert_face = false
				direction = 1.0
				join err (get_hits s selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular)
				
				print #(err)
				
				if err.count > 0 then
				(
					/*
					vv_done = #{}
					border = #{}
					max modify mode
					for e in err where not keyboard.escPressed do
					(
						ee = polyop.getEdgesUsingFace s #{e[1]}
						for a in ee do border += polyop.getBorderFromEdge s a
						
					)
					*/
					polyOp.setFaceSelection s ((for e in err collect e[1]) as bitarray)
					redrawViews()
				)
				
			)
		)				
	)

	on btn_FindFaces pressed do --плохо работает на противоположных нормалях и сонаправленных нормалях
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			s = selection[1]
			max modify mode
			err = #{}
			points = #()
			verts = #{}
			selfaces = #{}
			selfaces = polyOp.getfaceselection s
			if selfaces.isempty then selfaces = #{1..(polyOp.getNumFaces s)}
			for i in selfaces where not keyboard.escPressed do
			(
				vec_A = polyop.getFaceNormal s i
				points = #()
				append points (polyop.getFaceCenter s i)
				if alt then 
				(
					verts = polyop.getVertsUsingFace s #{i}
					join points (for v in verts collect	(polyop.getvert s v))
				)
				vec = polyop.getFaceNormal s i
				if points.count > 0 then 
					for poi_A in points where poi_A != undefined do
					(
						hits = intersectRayScene (ray poi_A vec_A)  -- collecting intersections	
						--hits2 = intersectRayScene (ray poi_A -vec_A) collecting inversed intersections			
						--print #(hits)
						if hits.count > 0 then
						(				
							for h in hits where h[1] == s do 
							(
								if ctrl then 
								(
									if distance poi_A h[2].pos < 0.02 then 
									(
										if (abs(dot vec_A hits[1][2].dir) >= 0.99 or abs(dot vec_A hits[1][2].dir) <= 0.01) then 
										(
											--print (dot vec_A hits[1][2].dir)
											append err i 
										)
									)
								)
								else
								(
									if distance poi_A h[2].pos <= 0.005 then append err i
								)
							)
						)
						/*
						if hits2.count > 0 then
						(				
							for h in hits2 where h[1] == s do 
							(
								if ctrl then 
								(							
									if ctrl then if distance poi_A h[2].pos < 0.02 and distance poi_A h[2].pos != 0.0 and abs(dot vec_A hits2[1][2].dir) >= 0.99 then append err i 
								)
								else
								(
									if distance poi_A h[2].pos <= 0.005 and distance poi_A h[2].pos != 0.0 then append err i --исключая саму себя
								)
							)
						)
						*/					
					)
			)
			print #(err)
			max modify mode
			subObjectLevel = 4
			polyOp.setFaceSelection s err
			redrawViews()
		)				
	)	

	on btn_MoveEdges pressed do with undo "Move Duals of Edges" on 
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			local ctrl = keyboard.controlPressed
			local alt = keyboard.altPressed
			
			local sel = selection as array
			
			local minimum_range = case ddl_MoveFacesEdgesVerts_range.selection of
			(
				1: 0.0
				2: 0.0
				3: 0.005
				4: 0.01
				5: 0.0
				6: 0.0
				7: 0.0
				8: 0.0
				9: 0.0
			)
			
			local maximum_range = case ddl_MoveFacesEdgesVerts_range.selection of
			(
				1: 0.002
				2: 0.005
				3: 0.02
				4: 0.02
				5: 0.02
				6: 0.03
				7: 0.05
				8: 0.1					
				9: 1.0
			)
			--minimum_range = (minimum_range ^ 2)
			--maximum_range = (maximum_range ^ 2)
			
			local dist = spn_MoveFacesEdgesVerts_distance.value 

			for s in sel do
			(		
				local edges_points = #{}	
				local edges = #{}
				local heights = #()
				if classof s != Editable_Poly then convertToPoly s
				s.unhideAll #Vertex
				s.unhideAll #Face
				--s.ConnectVertices vertexFlag:1
				local sel_edges = polyOp.getEdgeSelection s
				local sel_faces = polyOp.getFaceSelection s
				if sel_edges.isempty then 
				(
					if not sel_faces.isempty then sel_edges = polyop.getEdgesUsingFace s sel_faces
					else sel_edges = #{1..polyop.getNumEdges s}
				)
				for e1 in sel_edges where not keyboard.escPressed do
				(
					local vv1 = polyop.getVertsUsingEdge s #{e1} 
					local pp1 = for v in vv1 collect polyop.getVert s v
					local a = for v in vv1 do exit with v
					local b = for v in vv1 where v != a do exit with v
					if a > b then (local o = b; b = a; a = o)
					for e2 in sel_edges where e2 > e1 and not keyboard.escPressed do
					(
						local vv2 = polyop.getVertsUsingEdge s #{e2} 
						local pp2 = for v in vv2 collect polyop.getVert s v
										
						local c = for v in vv2 do exit with v
						local d = for v in vv2 where v != c do exit with v					
						if c > d then (local o = d; d = c; c = o)
						
						if edgesdistA pp1[1] pp1[2] pp2[1] pp2[2] minimum_range maximum_range then 
						(
							local h = edgesdistA_ pp1[1] pp1[2] pp2[1] pp2[2] minimum_range maximum_range
							if h[1] then 
							(
								edges_points += #{c, d}  --vv2
								edges += #{e1, e2}
								join heights #(#(e1, h[2]), #(e2, h[3]))
								--format "distA = %  %\n" h[2] h[3]
							)
						)
						if edgesdistB pp1[1] pp1[2] pp2[1] pp2[2] minimum_range maximum_range then 
						(
							local h = edgesdistB_ pp1[1] pp1[2] pp2[1] pp2[2] minimum_range maximum_range
							if h[1] then 
							(
								edges_points += #{a, b} --vv1 
								edges += #{e1, e2}
								join heights #(#(e1, h[2]), #(e2, h[3]))
								--format "distB = %  %\n" h[2] h[3]
							)
						)
							
						if edgesdistC pp1[1] pp1[2] pp2[1] pp2[2] minimum_range maximum_range then 
						(
							local h = edgesdistC_ pp1[1] pp1[2] pp2[1] pp2[2] minimum_range maximum_range
							if h[1] then 
							(							
								edges_points += #{b, c} 
								edges += #{e1, e2}
								join heights #(#(e1, h[2]), #(e2, h[3]))
								--format "distC = %  %\n" h[2] h[3]
							)	
						)
						if edgesdistD pp1[1] pp1[2] pp2[1] pp2[2] minimum_range maximum_range then 
						(
							local h = edgesdistD_ pp1[1] pp1[2] pp2[1] pp2[2] minimum_range maximum_range
							if h[1] then 
							(		
								edges_points += #{a, d}
								edges += #{e1, e2}
								join heights #(#(e1, h[2]), #(e2, h[3]))
								--format "distD = %  %\n" h[2] h[3]
							)
						)	
						
						if edgesdistC pp2[1] pp2[2] pp1[1] pp1[2] minimum_range maximum_range then 
						(
							local h = edgesdistC_ pp2[1] pp2[2] pp1[1] pp1[2] minimum_range maximum_range
							if h[1] then 
							(	
								edges_points += #{d, a}
								edges += #{e1, e2}
								join heights #(#(e1, h[3]), #(e2, h[2]))
								--format "distC = %  %\n" h[2] h[3]
							)
						)
						if edgesdistD pp2[1] pp2[2] pp1[1] pp1[2] minimum_range maximum_range then 
						(
							local h = edgesdistD_ pp2[1] pp2[2] pp1[1] pp1[2] minimum_range maximum_range
							if h[1] then 
							(	
								edges_points += #{c, b}
								edges += #{e1, e2}
								join heights #(#(e1, h[3]), #(e2, h[2]))
								--format "distD = %  %\n" h[2] h[3]
							)
						)
						
						--if edgesdist pp1[1] pp1[2] pp2[1] pp2[2] vv1[1] vv1[2] vv2[1] vv2[2] t or edgesdist pp2[1] pp2[2] pp1[1] pp1[2] vv1[1] vv1[2] vv2[1] vv2[2] t then 
						--	append edges_points #(e1, e2, pp1[1], pp1[2], pp2[1], pp2[2], vv1[1], vv1[2], vv2[1], vv2[2])
					)
				)
				
				--print heights
				--print edges_points
				--print edges		
				
				if alt then
				(
					if not ctrl then
					(
						if not edges_points.isempty then
							for v in edges_points do polyop.moveVert s #{v} (0.5 * dist * (vertvec s v))
					)
					else 
					(
						max modify mode
						subObjectLevel = 1
						polyOp.setVertSelection s edges_points
					)
				)
				else
				(
					--done = #{}
					if not edges.isempty then
					(
						if not ctrl then
						(
							for e in edges do 
							(
								vv = polyop.getVertsUsingEdge s #{e}
								--vv = vv - done
								for v in vv do 
								(
									local vect = vertvec_ s v e
									local ind = for i in #{1..heights.count} where e == heights[i][1] do exit with i
									local old_dist = heights[ind][2]	
									--format "old=% to=%\n" old_dist (dist - old_dist)
									polyop.moveVert s #{v} -(0.5 * (dist - old_dist) * vect)	
									--done += #{v}
								)
							)
						)
						else
						(
							max modify mode
							subObjectLevel = 2
							polyOp.setEdgeSelection s edges
						)
					)
				)
			)
		)	
 		else messagebox "Select Editable_Poly object"	 
	)

	on btn_DoubleFaces pressed do with undo "Move Duals of Faces" on  
	(	
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			local ctrl = keyboard.controlPressed
			local alt = keyboard.altPressed
			local shift = keyboard.shiftPressed
			local s = selection[1]
			max modify mode
			
			local errfaces = #{}
			local selfaces = #{}
			local vv_done = #{}
			selfaces = polyOp.getfaceselection s
			if selfaces.isempty then selfaces = #{1..(polyOp.getNumFaces s)}
			
			if not selfaces.isempty then 
			(		
				--("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]")	
				local minimum_range = 0.0
				local maximum_range = 0.02
				/*				
				local minimum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.0
					2: 0.0
					3: 0.005
					4: 0.01
					5: 0.0
					6: 0.0
					7: 0.0
					8: 0.0
					9: 0.0
				)
				local maximum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.002
					2: 0.005
					3: 0.02
					4: 0.02
					5: 0.02
					6: 0.03
					7: 0.05
					8: 0.1					
					9: 1.0
				)
				*/

				local near_perpendicular = spn_MoveFacesEdgesVerts_angle.value 
				
				part_of_faces = selfaces
				
				while not part_of_faces.isempty do 
				(
					if keyboard.escPressed then exit
					--print #(part_of_faces)

					i = for ss in part_of_faces do exit with ss
					vec_i = polyop.getFaceNormal s i
					eli = polyop.getElementsUsingFace s #{i} --fence:<fence_facelist>
					
					if not (part_of_faces - eli).isempty then
					(
						j = for ss in (part_of_faces - eli) where i < ss do exit with ss
						if j != OK then
						(							
							vec_j = polyop.getFaceNormal s j
							dott = (dot vec_i vec_j) --abs(dot vec_i vec_j)
							--print ((dot vec_i vec_j))
							--print dott
							--dot: 0 - перпендикулярны, 1 - параллельны, отрицательные - значит номали в разные стороны = bidirectional, положительные = codirectional
							--if (abs dott >= (1.0 - near_perpendicular) and dott < 0) or (abs dott >= (1.0 - near_perpendicular) and dott > 0) then  
							if abs dott >= (1.0 - near_perpendicular) then  
							(
								--print (dott)
								vvi = polyop.getVertsUsingFace s #{i} --polyop.getfaceverts s i
								vvj = polyop.getVertsUsingFace s #{j}
								ppi = polyop.getverts s vvi
								ppj = polyop.getverts s vvj
								
								--надобы перебирать все точки полика а не три первые
								--построение уравнений плоскостей
								arri = equation_plane ppi[1].x ppi[1].y ppi[1].z ppi[2].x ppi[2].y ppi[2].z ppi[3].x ppi[3].y ppi[3].z  --x1 y1 z1 x2 y2 z2 x3 y3 z3 
								arrj = equation_plane ppj[1].x ppj[1].y ppj[1].z ppj[2].x ppj[2].y ppj[2].z ppj[3].x ppj[3].y ppj[3].z  --x1 y1 z1 x2 y2 z2 x3 y3 z3 
												
								--Чтобы вычислить расстояние между параллельными плоскостями
								--проще всего взять на любой плоскости произвольную точку и
								--определить расстояние от этой точки до другой плоскости.
								--Нам потребуется следующая формула: расстояние от точки до плоскости
								--frac{|Ax+By+Cz+D|}{\sqrt{A^2+B^2+C^2}}
								
								p_plane_i = polyop.getFaceCenter s i
								p_plane_j = polyop.getFaceCenter s j
								d_other_i = abs(arrj[1] * p_plane_i.x + arrj[2] * p_plane_i.y + arrj[3] * p_plane_i.z + arrj[4]) / sqrt(arrj[1]^2 + arrj[2]^2 + arrj[3]^2)
								d_other_j = abs(arri[1] * p_plane_j.x + arri[2] * p_plane_j.y + arri[3] * p_plane_j.z + arri[4]) / sqrt(arri[1]^2 + arri[2]^2 + arri[3]^2)
								--print d_other_j
								--print d_other_i							
								d = amin #(d_other_i, d_other_j)
								--print d
								
								vvv = 0
								for p_i in ppi do
									for p_j in ppj do 
									(
										di = distance p_j p_i
										--print di
										if di <= 0.04 then vvv += 1
										--if di >= (minimum_range/2) and di <= (maximum_range*2) then vvv += 1
									)
								--print vvv
								if d >= minimum_range and d <= maximum_range and vvv > 0 then
								(
									--eli = polyop.getElementsUsingFace s #{i} 
									elj = polyop.getElementsUsingFace s #{j}
									part_of_faces -= eli
									part_of_faces -= elj
									errfaces += eli
									
								)
								else part_of_faces -= #{i,j}
							)
							else part_of_faces -= #{i,j}
						) 
						else exit
					)
					else exit
				)
				--print #(errfaces)
				polyOp.setFaceSelection s errfaces
				redrawViews()
			)
		)				
	)	
	
	on btn_MoveXView pressed do with undo "Move XView Duals of Faces or Verts" on  
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			local ctrl = keyboard.controlPressed
			local alt = keyboard.altPressed
			local shift = keyboard.shiftPressed
			local s = selection[1]
			max modify mode
			
			if xViewChecker.on then
			(
				if xViewChecker.activeIndex == 6 then try
				(
					edt_xViewVerts.text = xViewChecker.getCurrentOutputCount() as string
					subobjectlevel = 1
				)catch()
				if xViewChecker.activeIndex == 2 then try
				(
					edt_xViewFaces.text = xViewChecker.getCurrentOutputCount() as string
					subobjectlevel = 4
				)catch()
				xViewChecker.selectResults currentTime

				local errfaces = #{}
				local selfaces = #{}
				local selverts = #{}
				local vv_done = #{}
				
				selfaces = polyOp.getfaceselection s
				selverts = polyOp.getVertselection s
				
				--if selfaces.isempty then selfaces = #{1..(polyOp.getNumFaces s)} --это готовое выделение Xview, не надо брать все грани
				
				--("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]")		
				local minimum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.0
					2: 0.0
					3: 0.005
					4: 0.01
					5: 0.0
					6: 0.0
					7: 0.0
					8: 0.0
					9: 0.0
				)
				local maximum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.002
					2: 0.005
					3: 0.02
					4: 0.02
					5: 0.02
					6: 0.03
					7: 0.05
					8: 0.1					
					9: 1.0
				)
				local dist = spn_MoveFacesEdgesVerts_distance.value 
				local near_perpendicular = spn_MoveFacesEdgesVerts_angle.value 
		
				if not selfaces.isempty then 
				(		
					for i in selfaces where not keyboard.escPressed do
					(
						vec_i = polyop.getFaceNormal s i
						for j in selfaces where i < j and not keyboard.escPressed do
						(
							vec_j = polyop.getFaceNormal s j
							dott = (dot vec_i vec_j) --abs(dot vec_i vec_j)
							--print ((dot vec_i vec_j))
							
							--dot: 0 - перпендикулярны, 1 - параллельны, отрицательные - значит номали в разные стороны = bidirectional, положительные = codirectional
							--перпендикулярные задваиваются если рядом стоят
							--надо еще учитывать сонаправленные рядом
							
							
							cond = false
							if not chk_MoveFacesEdgesVerts_bidirectional.checked and not chk_MoveFacesEdgesVerts_codirectional.checked then
							(
								if (abs dott >= (1.0 - near_perpendicular) and dott < 0) or (abs dott >= (1.0 - near_perpendicular) and dott > 0) or (abs dott <= near_perpendicular) then cond = true
							)
							
							if chk_MoveFacesEdgesVerts_bidirectional.checked and not chk_MoveFacesEdgesVerts_codirectional.checked then
							(
								if (abs dott >= (1.0 - near_perpendicular) and dott < 0) then cond = true
							)

							if not chk_MoveFacesEdgesVerts_bidirectional.checked and chk_MoveFacesEdgesVerts_codirectional.checked then
							(
								if (abs dott >= (1.0 - near_perpendicular) and dott > 0) then cond = true
							)

							if cond then
							--if (abs dott >= (1.0 - near_perpendicular) and dott < 0) or (abs dott >= (1.0 - near_perpendicular) and dott > 0) or (abs dott <= near_perpendicular) then	
							(
								vvi = polyop.getVertsUsingFace s #{i} --polyop.getfaceverts s i
								vvj = polyop.getVertsUsingFace s #{j}
								
								eei = polyop.getEdgesUsingFace s #{i}
								eej = polyop.getEdgesUsingFace s #{j}
								
								ppi = polyop.getverts s vvi
								ppj = polyop.getverts s vvj
								
								--надо бы перебирать все точки полика а не три первые
								--построение уравнений плоскостей
								arri = equation_plane ppi[1].x ppi[1].y ppi[1].z ppi[2].x ppi[2].y ppi[2].z ppi[3].x ppi[3].y ppi[3].z  
								arrj = equation_plane ppj[1].x ppj[1].y ppj[1].z ppj[2].x ppj[2].y ppj[2].z ppj[3].x ppj[3].y ppj[3].z  
								
								--нормальный вектор плоскости A B C из уравнения плоскости
								--print #(arri)
								--print #(arrj)
								--print vec_i
								
								--опускание перпендикуляров на плоскости из точек
								p_plane_i = polyop.getFaceCenter s i
								p_plane_j = polyop.getFaceCenter s j
								d_other_i = abs(arrj[1] * p_plane_i.x + arrj[2] * p_plane_i.y + arrj[3] * p_plane_i.z + arrj[4]) / sqrt(arrj[1]^2 + arrj[2]^2 + arrj[3]^2)
								d_other_j = abs(arri[1] * p_plane_j.x + arri[2] * p_plane_j.y + arri[3] * p_plane_j.z + arri[4]) / sqrt(arri[1]^2 + arri[2]^2 + arri[3]^2)
								--print d_other_j
								--print d_other_i							
								d = amin #(d_other_i, d_other_j)								
								--print d
								
								--пересечение луча из центра треугольника до треугольника, если отрицательный - параллелен, если 0 - не попадает, больше 0 - расстояние - реальный треугольник
								d_real_center1 = ray_triangle_intersection p_plane_i vec_i ppj[1] ppj[2] ppj[3]
								d_real_center2 = ray_triangle_intersection p_plane_i -vec_i ppj[1] ppj[2] ppj[3]
								
								if (d_real_center1 >= 0 or d_real_center2 >= 0) and d >= minimum_range and d <= minimum_range then 
								(
									d_real_points = for p in ppi collect ray_triangle_intersection p vec_i ppj[1] ppj[2] ppj[3]
									arrp = #()
									for ei in eei do
									(
										vvvi = polyop.getVertsUsingEdge s #{ei}
										pppi = polyop.getVerts s vvvi
										for mm = 0.1 to 0.9 by 0.1 do append arrp (line_proportions pppi[1] pppi[2] mm)
									)
									--with printallelements on print #(arrp)
									for p in arrp do 
									(
										--point pos:p size:0.05
										append d_real_points (ray_triangle_intersection p vec_i ppj[1] ppj[2] ppj[3])
										append d_real_points (ray_triangle_intersection p -vec_i ppj[1] ppj[2] ppj[3])
									)
									--with printallelements on print #(d_real_points)
									--print #(d_real_points)
									--print d_real_center
									d_real = amin (d_real_points)
									if d_real >= 0 then 
									(
										--print d_real
										veli = #{}
										velj = #{}
										if shift then 
										(
											eli = (polyop.getElementsUsingFace s #{i}) - errfaces  --fence:<fence_facelist>
											elj = (polyop.getElementsUsingFace s #{j}) - errfaces
											veli = (polyop.getVertsUsingFace s eli) - vv_done
											velj = (polyop.getVertsUsingFace s elj) - vv_done
										)
										if not alt then 
										(
											if dott < 0 then
											(
												polyop.moveVert s (vvi - vv_done + veli) ((d/2 - dist/2) * vec_i)
												vv_done += vvi
												polyop.moveVert s (vvj - vv_done + velj) ((d/2 - dist/2) * vec_j) 
												vv_done += vvj
											)
													
											if dott > 0 then 
											(
												polyop.moveVert s (vvi - vv_done + veli) ((d/2 + dist/2) * vec_i)
												vv_done += vvi
												polyop.moveVert s (vvj - vv_done + velj) (-(d/2 + dist/2) * vec_j) 
												vv_done += vvj
											)												
														
											if dott == 0 then 
											(
												polyop.moveVert s (vvi - vv_done + veli) (-(d/2 - dist/2) * (cross vec_i vec_j))
												vv_done += vvi
												polyop.moveVert s (vvj - vv_done + velj) ((d/2 - dist/2) * (cross vec_i vec_j))
												vv_done += vvj
											)
											errfaces += #{i,j}	
										)	
										else 
										(										
											vec1 = getVertNormal s #{i}
											vec2 = getVertNormal s #{j}
											dott = dot vec1 vec2
											if dott < 0 then
											(
												polyop.moveVert s (vvi - vv_done + veli) (((d/2) - dist/2) * getVertNormal s vvi) 
												vv_done += vvi 
												polyop.moveVert s (vvj - vv_done + velj) (((d/2) - dist/2) * getVertNormal s vvj) 
												vv_done += vvj 
											)
											if dott > 0 then 
											(
												polyop.moveVert s (vvi - vv_done + veli) (((d/2) + dist/2) * getVertNormal s vvi) 
												vv_done += vvi 
												polyop.moveVert s (vvj - vv_done + velj) (-((d/2) + dist/2) * getVertNormal s vvj) 
												vv_done += vvj
											)
											if dott == 0 then 
											(
												polyop.moveVert s (vvi - vv_done + veli) (-((d/2) - dist/2) * cross (getVertNormal s vvi) (getVertNormal s vvj) ) 
												vv_done += vvi 
												polyop.moveVert s (vvj - vv_done + velj) (((d/2) - dist/2) * cross (getVertNormal s vvi) (getVertNormal s vvj) ) 
												vv_done += vvj
											)
											errfaces += #{i,j}
										)
									)
								)
							)
						)
					)
					--print #(errfaces)
					polyOp.setFaceSelection s #{}
					--if ctrl then polyOp.setFaceSelection s errfaces else xViewChecker.selectResults currentTime
					redrawViews()
				)
				
				if not selverts.isempty then 
				(	
					verts_near = #{}
					for v1 in selverts where not keyboard.escPressed do
					(
						local p1 = polyop.getvert s v1
						for v2 in selverts where v2 > v1 and not keyboard.escPressed do
						(
							local p2 = polyop.getvert s v2
							local d = distance p1 p2
							if d >= minimum_range and d <= maximum_range then 
							(
								if not ctrl then
								(
									vec1 = getVertNormal s #{v1}
									vec2 = getVertNormal s #{v2}
									dott = dot vec1 vec2
														
									if alt then
									(
										if dott >= 0 then 
										(
											polyop.moveVert s (#{v1} - verts_near) (-(d/2 - dist/2) * (normalize (p1 - p2)))
											verts_near += #{v1}
											polyop.moveVert s (#{v2} - verts_near) ((d/2 - dist/2) * (normalize (p2 - p1)))
											verts_near += #{v2}
										)
										if dott < 0 then 
										(
											polyop.moveVert s (#{v1} - verts_near) (-(d/2 + dist/2) * (normalize (p1 - p2)))
											verts_near += #{v1}
											polyop.moveVert s (#{v2} - verts_near) (-(d/2 + dist/2) * (normalize (p2 - p1)))
											verts_near += #{v2}										
										)
									)	
									else
									(
										if dott >= 0 then 
										(
											polyop.moveVert s (#{v1} - verts_near) (-(d/2 - dist/2) * (getVertNormal s #{v1}))
											verts_near += #{v1}
											polyop.moveVert s (#{v2} - verts_near) ((d/2 - dist/2) * (getVertNormal s #{v2}))
											verts_near += #{v2}		
										)	
										if dott < 0 then 
										(
											polyop.moveVert s (#{v1} - verts_near) (-(d/2 + dist/2) * (getVertNormal s #{v1}))
											verts_near += #{v1}
											polyop.moveVert s (#{v2} - verts_near) (-(d/2 + dist/2) * (getVertNormal s #{v2}))
											verts_near += #{v2}		
										)	
									)
								)
								else
								(
									verts_near += #{v1,v2}
								)
							)
						)
					)
					--print #(verts_near)
					polyOp.setVertSelection s #{}
					redrawViews()
				)					
			)
			else messagebox ("Turn on xView Faces or xView Verts first")
		)	
		else messagebox "Select Editable_Poly object"			
	)
	
	on btn_MoveFaces pressed do with undo "Move Duals of Faces" on  
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			local ctrl = keyboard.controlPressed
			local alt = keyboard.altPressed
			local shift = keyboard.shiftPressed
			local s = selection[1]
			max modify mode
			
			local errfaces = #{}
			local selfaces = #{}
			local vv_done = #{}
			selfaces = polyOp.getfaceselection s
			if selfaces.isempty then selfaces = #{1..(polyOp.getNumFaces s)}
			
			if not selfaces.isempty then 
			(		
				--("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]")		
				local minimum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.0
					2: 0.0
					3: 0.005
					4: 0.01
					5: 0.0
					6: 0.0
					7: 0.0
					8: 0.0
					9: 0.0
				)
				local maximum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.002
					2: 0.005
					3: 0.02
					4: 0.02
					5: 0.02
					6: 0.03
					7: 0.05
					8: 0.1					
					9: 1.0
				)
				local dist = spn_MoveFacesEdgesVerts_distance.value 
				local near_perpendicular = spn_MoveFacesEdgesVerts_angle.value 
				local ddd
				local near = false
			
				for i in selfaces where not keyboard.escPressed do
				(
					vec_i = polyop.getFaceNormal s i
					for j in selfaces where i < j do
					(
						vec_j = polyop.getFaceNormal s j
						dott = (dot vec_i vec_j) --abs(dot vec_i vec_j)
						--print ((dot vec_i vec_j))
						
						--dot: 0 - перпендикулярны, 1 - параллельны, отрицательные - значит номали в разные стороны = bidirectional, положительные = codirectional
						--перпендикулярные задваиваются если рядом стоят
						--надо еще учитывать сонаправленные рядом
						
						cond = false
						
						if not chk_MoveFacesEdgesVerts_bidirectional.checked and not chk_MoveFacesEdgesVerts_codirectional.checked then
						(
							if (abs dott >= (1.0 - near_perpendicular) and dott < 0) or (abs dott >= (1.0 - near_perpendicular) and dott > 0) or (abs dott <= near_perpendicular) then cond = true
						)
						
						if chk_MoveFacesEdgesVerts_bidirectional.checked and not chk_MoveFacesEdgesVerts_codirectional.checked then
						(
							if (abs dott >= (1.0 - near_perpendicular) and dott < 0) then cond = true
						)

						if not chk_MoveFacesEdgesVerts_bidirectional.checked and chk_MoveFacesEdgesVerts_codirectional.checked then
						(
							if (abs dott >= (1.0 - near_perpendicular) and dott > 0) then cond = true
						)
						
						--if (abs dott >= (1.0 - near_perpendicular) and dott < 0) or (abs dott >= (1.0 - near_perpendicular) and dott > 0) or (abs dott <= near_perpendicular) then  
						if cond then
						(
							--print (dott)
							vvi = polyop.getVertsUsingFace s #{i} --polyop.getfaceverts s i
							vvj = polyop.getVertsUsingFace s #{j}
							ppi = polyop.getverts s vvi
							ppj = polyop.getverts s vvj
							
							--надобы перебирать все точки полика а не три первые
							--построение уравнений плоскостей
							arri = equation_plane ppi[1].x ppi[1].y ppi[1].z ppi[2].x ppi[2].y ppi[2].z ppi[3].x ppi[3].y ppi[3].z  --x1 y1 z1 x2 y2 z2 x3 y3 z3 
							arrj = equation_plane ppj[1].x ppj[1].y ppj[1].z ppj[2].x ppj[2].y ppj[2].z ppj[3].x ppj[3].y ppj[3].z  --x1 y1 z1 x2 y2 z2 x3 y3 z3 
							--print #(arri)
							--print #(arrj)
							--par = false
							--if (abs arri[1]) - (abs arrj[1]) < 0.001 and (abs arri[2]) - (abs arrj[2]) < 0.001 and (abs arri[3]) - (abs arrj[3]) < 0.001 and (abs arri[4]) - (abs arrj[4]) < 0.001 then par = true
							
							--Чтобы вычислить расстояние между параллельными плоскостями
							--проще всего взять на любой плоскости произвольную точку и
							--определить расстояние от этой точки до другой плоскости.
							--Нам потребуется следующая формула: расстояние от точки до плоскости
							--frac{|Ax+By+Cz+D|}{\sqrt{A^2+B^2+C^2}}
							
							p_plane_i = polyop.getFaceCenter s i
							p_plane_j = polyop.getFaceCenter s j
							d_other_i = abs(arrj[1] * p_plane_i.x + arrj[2] * p_plane_i.y + arrj[3] * p_plane_i.z + arrj[4]) / sqrt(arrj[1]^2 + arrj[2]^2 + arrj[3]^2)
							d_other_j = abs(arri[1] * p_plane_j.x + arri[2] * p_plane_j.y + arri[3] * p_plane_j.z + arri[4]) / sqrt(arri[1]^2 + arri[2]^2 + arri[3]^2)
							--print d_other_j
							--print d_other_i							
							d = amin #(d_other_i, d_other_j)

							--другой работает не правильно из-за несовпаения коэф уравнения
							--Расстояние между параллельными плоскостями 
							--ax+by+cz+d_1=0; ax+by+cz+d_2=0 
							--вычисляется так: frac{\left|d_2-d_1 \right|}{\sqrt{a^2+b^2+c^2}}
							--local d = dist_plane arri[1] arri[2] arri[3] arri[4] arrj[4]  --a b c d1 d2 
							--print d
														
							if d >= minimum_range and d <= maximum_range then
							(
								--print d
								--могут находиться в разных местах сцены тк параллельные прямые могут быть друг от друга далеко
								--перебираем все ребра на поиск расстояния от каждого из четырех концов, чтобы найти минимальное расстояние для непересекающихся отрезков
								
								near = false
								eei = polyop.getedgesUsingFace s #{i}
								eej = polyop.getedgesUsingFace s #{j}
								cou = 0
								for ei in eei where not near do
									for ej in eej where not near do 
									(
										vvi_ = polyop.getVertsUsingEdge s #{ei}
										ppi_ = polyop.getverts s vvi_
										vvj_ = polyop.getVertsUsingEdge s #{ej}
										ppj_ = polyop.getverts s vvj_										
										if (ddd = LineLineIntersect ppi_[1] ppi_[2] ppj_[1] ppj_[2]) != false then 
										(
											if ddd >= minimum_range and ddd <= maximum_range then (cou += 1)  --; near = true
											--print ddd
										)
									)
								--print cou
								if chk_MoveFacesEdgesVerts_codirectional.checked then (if cou > 0 then near = true)
								if cou > 2 then near = true
								if near then 
								(
									
								/*
								Как найти кратчайшее расстояние между двумя отрезками?
								Во-первых, для нахождения расстояния от точки (x, y) до отрезка (ax, ay)-(bx, by) не нужна никакая "бинарка". Использовать поисковый алгоритм для нахождения этого расстояния - безобразие. Это элементарная задача вычислительной геометрии. Например, в целых числах (не выжимая процессорные такты и не беспокоясь о переполнениях)
								int point_to_segment_distance_sq(int x, int y, int ax, int ay, int bx, int by)
								{
								  // Обеспечим, чтобы наш отрезок был более горизонтальным, чем вертикальным
								  int dx = bx - ax, dy = by - ay;
								  if (std::abs(dx) < std::abs(dy))
								  {
									std::swap(x, y);
									std::swap(ax, ay);
									std::swap(bx, by);
									std::swap(dx, dy);
								  }
								  // Обеспечим, чтобы наш отрезок шел слева направо
								  if (dx < 0)
								  {
									std::swap(ax, bx);
									std::swap(ay, by);
									dx = -dx;
									dy = -dy;
								  }
								  // Действия, выполненные выше, нужны только для того, чтобы впоследствии
								  // мы могли проверить, попадает ли точка (px, py) (см. ниже) внутрь нашего
								  // отрезка (ax, ay)-(bx, by). Теперь это можно сделать простым сравнением
								  // `px < ax` и `px > bx`
								  // Строим уравнение прямой
								  int A = dy, B = -dx, C = -(A * ax + B * bx);
								  // Вычисляем ненормированное ориентированное расстояние от точки до прямой
								  int d = A * x + B * y + C;
								  // Находим проекцию нашей точки на прямую
								  int absq = A * A + B * B;
								  int px = x - A * d / absq, py = y - B * d / absq;
								  // Проверяем, не попали ли мы за пределы отрезка
								  if (px < ax)
								  {
									px = ax;
									py = ay;
								  }
								  else if (px > bx)
								  {
									px = bx;
									py = by;
								  }
								  // Возвращаем квадрат расстояния
								  x -= px;
								  y -= py;
								  return x * x + y * y;
								}
								Во-вторых, достаточно применить эту функцию четыре раза - для поиска расстояния от каждого из четырех концов, чтобы найти минимальное расстояние для непересекающихся отрезков. А вот именно этот особый случай - пересекающиеся отрезки - и надо еще уметь отлавливать и обрабатывать. (На самом деле вышеприведенная функция вычисляет всю необходимую информацию для такой проверки.)
																

								Алгоритм Моллера — Трумбора — алгоритм для определения пересечения прямой (луча) и треугольника в трёхмерном пространстве, для работы которого не требуется предварительное вычисление уравнения плоскости, содержащей треугольник
								
								// orig и dir задают начало и направление луча. v0, v1, v2 - вершины треугольника.
								// Функция возвращает расстояние от начала луча до точки пересечения или 0.
								float
								triangle_intersection(const vec3& orig,
													  const vec3& dir,
													  const vec3& v0,
													  const vec3& v1,
													  const vec3& v2) {
									vec3 e1 = v1 - v0;
									vec3 e2 = v2 - v0;
									// Вычисление вектора нормали к плоскости
									vec3 pvec = cross(dir, e2);
									float det = dot(e1, pvec);

									// Луч параллелен плоскости
									if (det < 1e-8 && det > -1e-8) {
										return 0;
									}

									float inv_det = 1 / det;
									vec3 tvec = orig - v0;
									float u = dot(tvec, pvec) * inv_det;
									if (u < 0 || u > 1) {
										return 0;
									}

									vec3 qvec = cross(tvec, e1);
									float v = dot(dir, qvec) * inv_det;
									if (v < 0 || u + v > 1) {
										return 0;
									}
									return dot(e2, qvec) * inv_det;
								}
								*/

									if not ctrl then
									(			
										veli = #{}
										velj = #{}
										if shift then 
										(
											eli = polyop.getElementsUsingFace s #{i} --fence:<fence_facelist>
											elj = polyop.getElementsUsingFace s #{j}
											veli = polyop.getVertsUsingFace s eli
											velj = polyop.getVertsUsingFace s elj
										)
										if not alt then 
										(
											if dott < 0 then
											(
												polyop.moveVert s (vvi - vv_done + veli) ((d/2 - dist/2) * (polyop.getFaceNormal s i))
												--vv_done += vvi
												polyop.moveVert s (vvj - vv_done + velj) ((d/2 - dist/2) * (polyop.getFaceNormal s j)) 
												--vv_done += vvj
											)
											
											if dott > 0 then 
											(
												polyop.moveVert s (vvi - vv_done + veli) ((d/2 - dist/2) * (polyop.getFaceNormal s i))
												if chk_MoveFacesEdgesVerts_codirectional.checked then polyop.moveVert s (vvj - vv_done + velj) (-(d/2 - dist/2) * (polyop.getFaceNormal s j)) 
												else polyop.moveVert s (vvj - vv_done + velj) ((d/2 - dist/2) * (polyop.getFaceNormal s j)) 
											)												
											
											if dott == 0 then 
											(
												polyop.moveVert s (vvi - vv_done + veli) ((d/2 - dist/2) * (cross (polyop.getFaceNormal s i) (polyop.getFaceNormal s j) ))
												polyop.moveVert s (vvj - vv_done + velj) (-(d/2 - dist/2) * (cross (polyop.getFaceNormal s i) (polyop.getFaceNormal s j) ))
											)	
											/*
											if par then 
											(
												polyop.moveVert s (vvi - vv_done + veli) ((d/2 - dist/2) * (cross (polyop.getFaceNormal s i) (polyop.getFaceNormal s j) ))
												polyop.moveVert s (vvj - vv_done + velj) (-(d/2 - dist/2) * (cross (polyop.getFaceNormal s i) (polyop.getFaceNormal s j) ))
											)
											*/
											errfaces += #{i,j}	
										)	
										else 
										(
											if dott < 0 then
											(
												polyop.moveVert s (vvi - vv_done + veli) (((d/2) - dist/2) * getVertNormal s vvi) 
												--vv_done += vvi 
												polyop.moveVert s (vvj - vv_done + velj) (((d/2) - dist/2) * getVertNormal s vvj) 
												--vv_done += vvj 
											)
											if dott > 0 then 
											(
												polyop.moveVert s (vvi - vv_done + veli) (((d/2) - dist/2) * getVertNormal s vvi) 
												if chk_MoveFacesEdgesVerts_codirectional.checked then polyop.moveVert s (vvj - vv_done + velj) (-((d/2) - dist/2) * getVertNormal s vvj) 
												else polyop.moveVert s (vvj - vv_done + velj) (((d/2) - dist/2) * getVertNormal s vvj) 
											)
											if dott == 0 then 
											(
												polyop.moveVert s (vvi - vv_done + veli) (((d/2) - dist/2) * cross (getVertNormal s vvi) (getVertNormal s vvj) ) 
												polyop.moveVert s (vvj - vv_done + velj) (-((d/2) - dist/2) * cross (getVertNormal s vvi) (getVertNormal s vvj) ) 
											)
											
											errfaces += #{i,j}
										)
									)
									else errfaces += #{i,j}
								)
							)
						)
					)
				)
				--print #(errfaces)
				if ctrl then polyOp.setFaceSelection s errfaces
				redrawViews()
			)
		)
		else messagebox "Select Editable_Poly object"		
	)
	
	on btn_MoveFaces rightclick do with undo "Move Duals of Faces" on  
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			s = selection[1]
			max modify mode
			err = #()
			points = #()
			verts = #{}
			selfaces = #{}
			selfaces = polyOp.getfaceselection s
			if selfaces.isempty then selfaces = #{1..(polyOp.getNumFaces s)}
			
			if not selfaces.isempty then 
			(		
				--("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]")		
				minimum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.0
					2: 0.0
					3: 0.005
					4: 0.01
					5: 0.0
					6: 0.0
					7: 0.0
					8: 0.0
					9: 0.0
				)
				maximum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.002
					2: 0.005
					3: 0.02
					4: 0.02
					5: 0.02
					6: 0.03
					7: 0.05
					8: 0.1					
					9: 1.0
				)
				dist = spn_MoveFacesEdgesVerts_distance.value 
				do_verts = chk_MoveFacesEdgesVerts_acuracy.checked
				near_perpendicular = spn_MoveFacesEdgesVerts_angle.value 
				
				if not chk_MoveFacesEdgesVerts_bidirectional.checked and not chk_MoveFacesEdgesVerts_codirectional.checked then
				(
					invert_face = false
					direction = 1.0
					join err (get_hits s selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular)
				)
				if chk_MoveFacesEdgesVerts_bidirectional.checked then
				(
					polyop.flipNormals s selfaces
					direction = -1.0
					invert_face = false --true --false
					join err (get_hits s selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular)
					polyop.flipNormals s selfaces
				)
				if chk_MoveFacesEdgesVerts_codirectional.checked then
				(
					invert_face = true
					direction = -1.0
					join err (get_hits s selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular)
				)
				
				print #(err)
				if err.count > 0 then
				(
					vv_done = #{}
					max modify mode
					subObjectLevel = 4
					if not ctrl then
						for e in err where not keyboard.escPressed do
						(
							vv = polyop.getVertsUsingFace s #{e[1]}
								--if ctrl then polyop.moveVert s vv ((-0.003/2 + e[2]/2) * getVertNormal s vv)
								--polyop.moveVert s vv ((-dist/2 + e[2]/2) * (normalize (polyop.getFaceNormal s e[1])))
							if not alt then polyop.moveVert s (vv - vv_done) ((e[2]/2 - dist/2) * (normalize e[3])) --good working
							else polyop.moveVert s vv ((abs(e[2]/2) - dist/2) * getVertNormal s vv) 
								--polyop.moveVert s vv ((dist/2 - e[2]/2) * (normalize e[3])) 
								--polyop.moveVert s vv ((abs(e[2]/2) - dist/2) * (normalize e[3]))
								--e = #(i, direction * (distance poi h[2].pos), vec, h[2].pos, h[2].dir)
								--polyop.moveVert s vv ((abs(e[2]/2) - dist/2) * e[5]) 
								--polyop.moveVert s vv ((e[2]/2 - dist/2) * e[5]) 
							vv_done += vv --исключаем уже подвинутые точки, чтобы не двигать их опять, очень важно!
						)
					polyOp.setFaceSelection s ((for e in err collect e[1]) as bitarray)
					redrawViews()
				)
			)
			
			/*
			if alt then
			(
				verts_near = #()
				vv = polyop.getVertsUsingFace s selfaces
				for v1 in vv do
				(
					p1 = polyop.getvert s v1
					for v2 in vv where v1 < v2 do
					(
						p2 = polyop.getvert s v2
						if distance p1 p2 <= 0.002 then 
						(
							appendIfUnique verts_near #(v1, distance p1 p2, normalize (p1 - p2))
							appendIfUnique verts_near #(v2, distance p1 p2, normalize (p2 - p1))
						)
					)
				)
				
				if verts_near.count > 0 then
				(
					for v in verts_near do
					(
						polyop.moveVert s #{v[1]} ((0.003/2 - v[2]) * v[3])
					)
				)
				
				polyOp.setVertSelection s ((for v in verts_near collect v[1]) as bitarray)
			)
			redrawViews()
			*/
		)
		else messagebox "Select Editable_Poly object"			
	)	
	
	on btn_MoveVerts rightclick do with undo "Move Duals of Verts" on  
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			s = selection[1]
			max modify mode

			selverts = #{}
			selverts = polyOp.getvertselection s
			if selverts.isempty then selverts = #{1..(polyOp.getNumVerts s)}
			
			if not selverts.isempty then 
			(		
				--("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]")		
				minimum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.0
					2: 0.0
					3: 0.005
					4: 0.01
					5: 0.0
					6: 0.0
					7: 0.0
					8: 0.0
					9: 0.0
				)
				maximum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.002
					2: 0.005
					3: 0.02
					4: 0.02
					5: 0.02
					6: 0.03
					7: 0.05
					8: 0.1					
					9: 1.0
				)
				
				dist = spn_MoveFacesEdgesVerts_distance.value 

				verts_near = #()
				--polyop.moveVert s vv ((-0.003/2 + e[2]/2) * getVertNormal s vv)
				for v1 in selverts where not keyboard.escPressed do
				(
					local p1 = polyop.getvert s v1
					for v2 in selverts where v2 > v1 and not keyboard.escPressed do
					(
						local p2 = polyop.getvert s v2
						local d = distance p1 p2
						if d >= minimum_range and d <= maximum_range then 
						(
							appendIfUnique verts_near #(v1, d, normalize (p1 - p2), getVertNormal s #{v1})
							appendIfUnique verts_near #(v2, d, normalize (p2 - p1), getVertNormal s #{v2})
						)
					)
				)
				print #(verts_near)
				if verts_near.count > 0 then
				(
					if not ctrl then
					(
						vv_done = #{}
						if alt then
							for v in verts_near do
							(
								polyop.moveVert s (#{v[1]} - vv_done) ((dist/2 - v[2]/2) * v[3])
								vv_done += #{v[1]}
							)	
						else
							for v in verts_near do
							(
								polyop.moveVert s (#{v[1]} - vv_done) ((dist/2 - v[2]/2) * v[4])
								vv_done += #{v[1]}
							)
					)
				)
				
				polyOp.setVertSelection s ((for v in verts_near collect v[1]) as bitarray)
				redrawViews()
			)
		)
		else messagebox "Select Editable_Poly object"	
	)
	
	on btn_MoveVerts pressed do with undo "Move Duals of Verts" on  
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			s = selection[1]
			max modify mode

			selverts = #{}
			selverts = polyOp.getvertselection s
			if selverts.isempty then selverts = #{1..(polyOp.getNumVerts s)}
			
			if not selverts.isempty then 
			(		
				--("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]")		
				minimum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.0
					2: 0.0
					3: 0.005
					4: 0.01
					5: 0.0
					6: 0.0
					7: 0.0
					8: 0.0
					9: 0.0
				)
				maximum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.002
					2: 0.005
					3: 0.02
					4: 0.02
					5: 0.02
					6: 0.03
					7: 0.05
					8: 0.1					
					9: 1.0
				)
				
				dist = spn_MoveFacesEdgesVerts_distance.value 

				verts_near = #{}
				vv_done = #{}
				for v1 in selverts where not keyboard.escPressed do
				(
					local p1 = polyop.getvert s v1
					for v2 in selverts where v2 > v1 and not keyboard.escPressed do
					(
						local p2 = polyop.getvert s v2
						local d = distance p1 p2
						if d >= minimum_range and d <= maximum_range then 
						(
							if not ctrl then
							(
								vec1 = getVertNormal s #{v1}
								vec2 = getVertNormal s #{v2}
								dott = dot vec1 vec2
													
								if alt then
								(
									if dott >= 0 then 
									(
										polyop.moveVert s (#{v1} - verts_near) ((d/2 - dist/2) * (normalize (p1 - p2)))
										verts_near += #{v1}
										polyop.moveVert s (#{v2} - verts_near) ((d/2 - dist/2) * (normalize (p2 - p1)))
										verts_near += #{v2}
									)
									else
									(
										polyop.moveVert s (#{v1} - verts_near) (-(d/2 + dist/2) * (normalize (p1 - p2)))
										verts_near += #{v1}
										polyop.moveVert s (#{v2} - verts_near) (-(d/2 + dist/2) * (normalize (p2 - p1)))
										verts_near += #{v2}										
									)
								)	
								else
								(
									if dott >= 0 then 
									(
										polyop.moveVert s (#{v1} - verts_near) ((d/2 - dist/2) * (getVertNormal s #{v1}))
										verts_near += #{v1}
										polyop.moveVert s (#{v2} - verts_near) ((d/2 - dist/2) * (getVertNormal s #{v2}))
										verts_near += #{v2}		
									)	
									else
									(
										polyop.moveVert s (#{v1} - verts_near) (-(d/2 + dist/2) * (getVertNormal s #{v1}))
										verts_near += #{v1}
										polyop.moveVert s (#{v2} - verts_near) (-(d/2 + dist/2) * (getVertNormal s #{v2}))
										verts_near += #{v2}		
									)	
								)
							)
							else
							(
								verts_near += #{v1,v2}
							)
						)
					)
				)
				--print #(verts_near)
				polyOp.setVertSelection s verts_near
				redrawViews()
			)
		)
		else messagebox "Select Editable_Poly object"	
	)
	
/*
	on btn_FindFaces rightclick do with undo "Convert to mesh" on
	(
		if selection.count == 1 then --and classof selection[1] == Editable_Poly then
		(
			ctrl = keyboard.controlPressed
			s = selection[1]
			max modify mode
			converttomesh s
			err = #{}
			verts = #{}
			points = #()	
			arr = #()	
			a = #()					
			for i in #{1..(meshop.getNumFaces s)} where not keyboard.escPressed do
			(
				verts = meshop.getVertsUsingFace s #{i} -- polyop.getVertsUsingFace s #{i}
				points = for v in verts collect	(meshop.getVert s v) --(polyop.getvert s v)
				vec = getFaceNormal s i --polyop.getFaceNormal s i
				--meshop.getFaceRNormals <Mesh mesh> <int faceIndex> node:<node=unsupplied>

				if points.count > 0 then
				(
					for p in points do 
					(
						arr = (intersectRayEx s (ray p vec))
						if arr != undefined then 
							if arr.count > 0 then
							(
								--print #(arr)
								if distance p arr[1].pos <= 0.005 then 
								if distance p arr[1].pos >= 0.02 and distance p arr[1].pos <= 0.1 and abs(dot vec arr[1].dir) >= 0.99 then join err #{i, arr[2]}
							)
					)
				)					
			)
			print #(err)
			max modify mode
			subObjectLevel = 4
			setFaceSelection s err  --polyOp.setFaceSelection s err
		)
		else messagebox "Select single object"		
	)	
*/
	
/*	
	on btn_FindFaces_old pressed do --working bad now, need to rework
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			max modify mode
			err = #{}
			vertsA = #{}
			vertsB = #{}
			vertsAP = #()
			vertsBP = #()
			matches = #()
			matches_near = #()
			for i in #{1..(polyOp.getNumFaces $)} where not keyboard.escPressed do
			(
				vertsA = polyop.getVertsUsingFace $ #{i}
				vertsAP = for v in vertsA collect (polyop.getvert $ v)
				--print #(vertsAP)
				for j in #{1..(polyOp.getNumFaces $)} where j > i do
				(
					vertsB = polyop.getVertsUsingFace $ #{j}
					--print #(vertsA - vertsB)
					if (vertsA - vertsB).count < vertsA.count then continue --число пересечения вершин меньше числа вершин (исключение соседних фейсов)
					vertsBP = for v in vertsB collect (polyop.getvert $ v)
					--print #(vertsBP)
					--print #(vertsA)
					--print #(vertsB)
					matches = #()
					matches_near = #()
					for b in vertsBP do --where vertsB.count == vertsA.count do 
						for a in vertsAP do
						(
							--if a.x == b.x and a.y == b.y and a.z == b.z then append matches a 
							if distance a b == 0.0 then append matches a 
							if distance a b <= 0.005 then append matches a
							if distance a b > 0.02 then append matches_near a
						)
					--print "matches:"
					--print matches.count
					--print " " 

					if matches != undefined then 
					(
						if vertsA.count > vertsB.count then 
						(
							if matches.count == vertsB.count then append err j
						)
						else
						(
							if matches.count == vertsA.count then append err i
						)
					)
					
					if matches_near != undefined then 
					(
						if vertsA.count > vertsB.count then 
						(
							if matches_near.count == vertsB.count then append err j
						)
						else
						(
							if matches_near.count == vertsA.count then append err i
						)
					)					
					
				)
			)
			print #(err)
			max modify mode
			subObjectLevel = 4
			polyOp.setFaceSelection $ err
		)				
	)		
*/

	on btn_RemoveVerts pressed do btn_remove.pressed()

	on btn_TriangulateRight pressed do with undo "Triangulate Geo" on with redraw off
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly and selection[1].modifiers.count == 0 then
		(
			btn_UnhideVertsFaces2.pressed()
			
			arr = #()
			arr_err = #()
			edges_ = #{}
			edges = #{}
			faces = #{}
			faces = polyop.getfaceselection selection[1]
			if faces.isempty then faces = #{1..(polyOp.getNumFaces selection[1])}
			max create mode
			for i in faces where not keyboard.escPressed do
			(
				edges = polyop.getEdgesUsingFace $ #{i}
				edges_ = for j in edges collect (polyop.getEdgeVerts $ j)
				verts = polyop.getVertsUsingFace $ #{i}
				for v1 in verts do
				(
					p1 = polyop.getvert $ v1
					for v2 in verts where v2 != v1 and not keyboard.escPressed do
					(
						p2 = polyop.getvert $ v2
						vec1 = p2 - p1
						for v3 in verts where v3 != v1 and v3 != v2 and not keyboard.escPressed do
						(
							p3 = polyop.getvert $ v3
							vec2 = p3 - p1
							if (acos (dot (normalize vec1) (normalize vec2))) <= 0.001 then
							(
								if finditem arr_err #{v1, v2} == 0 then append arr_err #{v1, v2}
								if finditem arr_err #{v2, v1} == 0 then append arr_err #{v2, v1}
								if finditem arr_err #{v1, v3} == 0 then append arr_err #{v1, v3}
								if finditem arr_err #{v3, v1} == 0 then append arr_err #{v3, v1}
								/*
								if distance p1 p2 >= distance p1 p3 then 
								(
									if finditem arr_err #{v1, v2} == 0 then append arr_err #{v1, v2}
									if finditem arr_err #{v2, v1} == 0 then append arr_err #{v2, v1}
								)
								else
								(
									if finditem arr_err #{v1, v3} == 0 then append arr_err #{v1, v3}
									if finditem arr_err #{v3, v1} == 0 then append arr_err #{v3, v1}
								)
								*/
							)
						)
					)
				)					
			)
			
			for i in faces where not keyboard.escPressed do
			(
				edges = polyop.getEdgesUsingFace $ #{i}
				edges_ = for j in edges collect (polyop.getEdgeVerts $ j)
				verts = polyop.getVertsUsingFace $ #{i}
				for v1 in verts where not keyboard.escPressed do
				(
					for v2 in verts where v2 > v1 and not keyboard.escPressed do
					(
						if finditem edges_ #{v1, v2} == 0 and finditem edges_ #{v2, v1} == 0 and finditem arr #{v1, v2} == 0 and finditem arr #{v2, v1} == 0 and finditem arr_err #{v1, v2} == 0 and finditem arr_err #{v2, v1} == 0 then 
						(
							max modify mode
							subobjectlevel = 1
							polyOp.setVertSelection $ #{v1, v2}
							--undo "connect verts" on 
							--нужно добавить проверку прямой видимости вершины одной к другой через полигон, чтобы не делались ребра вне полигона
							if ($.ConnectVertices vertexFlag:1) then append arr #{v1, v2} --$.buttonOp #ConnectVertices
						)
					)
				)					
			)
			print #(arr)
			print #(arr_err)
		)
		else
		(
			messageBox ("Select single collapsed Editable Poly object")
		)
	)
	
	on btn_TriangulateRight rightclick do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			sel = selection[1]
			sel_copy = copy sel
			select sel_copy
			max modify mode
			subObjectLevel = 1
			sel_copy.unhideAll #Vertex
			sel_copy.unhideAll #Face
			max select all 
			sel_copy.ConnectVertices vertexFlag:1
			subObjectLevel = 0
			select sel	
			numfaces = polyop.getNumFaces sel 
			numfaces_copy = polyop.getNumFaces sel_copy 
			delete sel_copy
			messagebox("Now faces: " + numfaces as string + "\nFaces after triangulation: " + numfaces_copy as string + "\nNot triangulated: " + (numfaces_copy - numfaces) as string)
		)
		else
		(
			messageBox ("Select single collapsed Editable Poly object")
		)
	)		
	
	on btn_RemoveErrEdges pressed do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly and selection[1].modifiers.count == 0 then
		(
			max create mode
			ctrl = keyboard.controlPressed
			arr = #{}
			faces = #{}
			faces = polyop.getfaceselection $
			if faces.isempty then faces = #{1..(polyOp.getNumFaces selection[1])}		
			
			for i in faces do --for i in #{1..(polyOp.getNumVerts $)} do
			(
				if keyboard.escPressed then exit
				edges = polyop.getEdgesUsingVert $ #{i}
				verts = #{}
				for j in edges do join verts (polyop.getVertsUsingEdge $ #{j})
				p1 = polyop.getvert $ i
				verts = verts - #{i}
				for k in verts do 
				(
					p2 = polyop.getvert $ k
					for l in verts where l > k do 
					(
						if keyboard.escPressed then exit
						p3 = polyop.getvert $ l
						v1 = p2 - p1
						v2 = p3 - p1
						if (acos(dot (normalize v1) (normalize v2))) <= 0.001 then --== 0.0
						(
							edge_k = 0
							edge_l = 0
							for m in edges do
							(
								pp = polyop.getVertsUsingEdge $ #{m}
								if finditem pp i > 0 and finditem pp k > 0 then edge_k = m
								if finditem pp i > 0 and finditem pp l > 0 then edge_l = m
							)
							if (distance p2 p1) >= (distance p3 p1) then append arr edge_k else append arr edge_l
						)

					)
				)		
			)
			polyOp.setEdgeSelection $ arr
			
			print arr
			
			if not ctrl then
				undo "Remove Overlay Edges" on $.remove selLevel:#edge
			else
			(
				max modify mode
				subObjectLevel = 2
			)
			
			if arr != undefined then 
			(
				if arr.count != 0 then messageBox ((arr.count as string) + " problematic edges found") 
				else messageBox ("No problematic edges found")
			)
		)
		else
		(
			messageBox ("Select single collapsed Editable Poly object")
		)
	)

/*	
	on btn_CreatePoly pressed do
	(
		arr = polyop.getVertSelection $
		if (polyop.createPolygon $ (arr as array)) == undefined then messagebox "Polygon do not created"
	)
*/
	
	on btn_VertexWeld rightclick do
	(
		for i in selection do addModifier i (VertexWeld threshold: spn_Tresh_xViewChecker.value)
	)
	
	on btn_VertexWeld pressed do
	(
		ctrl = if keyboard.controlPressed then true else false 
		for i in selection do
		(
			a = copy i
			b = copy i
			addModifier a (VertexWeld threshold: spn_Tresh_xViewChecker.value)
			convertToPoly a
			convertToPoly b
			if (va = polyop.getNumVerts a) != (vb = polyop.getNumVerts b) then 
			(
				if querybox ("There are: " + (vb-va) as string + " from " + (vb as string) +  " unwelded vertexes in current treshold\n\nContinue to show unwelded verticles?") then
				(
					--messagebox ("There are: " + (vb-va) as string + " from " + (vb as string) +  " unwelded vertexes in current treshold")
					arr = #{}
					for j in #{1..(vb-1)} do for k in #{(j+1)..vb} where k != j and distance (polyOp.getVert b j) (polyOp.getVert b k) <= spn_Tresh_xViewChecker.value do 
					(
						appendifunique arr k
						appendifunique arr j
					)
					print #(arr)
					
					addModifier i (Edit_poly())
					subObjectLevel = 1
					i.modifiers[#Edit_Poly].SetOperation #UnhideAllVertex --i.ButtonOp #UnhideAll
					i.modifiers[#Edit_Poly].SetSelection #Vertex arr --i.SetSelection #Vertex arr
					i.SetSelection #Vertex arr
					if ctrl then i.modifiers[#Edit_Poly].SetOperation #HideUnselectedVertex
				)
			)
			else
			(
				messagebox "There are no unwelded vertexes in current treshold"
			)
			delete a
			delete b
		)
	)
	
	on btn_TargetWeld pressed do with undo "Weld To Near" on 
	(
		if selection.count == 1 and classof selection[1] == editable_poly and selection[1].modifiers.count == 0 then
		(	
			max modify mode
			sel = modpanel.getcurrentobject()
			panel_mode = getCommandPanelTaskMode()
			sub_level = subObjectLevel
			max create mode
			verts_pos_near = #()
			vert_pos = #()			
			verts = sel.GetSelection #Vertex
			print verts
			for vert in verts do
			(
				vert_pos = polyOp.getVert sel vert 
				edges = polyop.getEdgesUsingVert sel #{vert} --face = polyOp.getFaceVerts selmod i
				verts_near = polyop.getVertsUsingEdge sel edges --polyop.getVertsUsedOnlyByFaces <Poly poly> <facelist>-
				verts_near = verts_near - #{vert}
				print verts_near
				verts_pos_near = for v in verts_near collect polyOp.getVert sel v
				print verts_pos_near
				nearest_dist = amin (for v in verts_pos_near collect (distance vert_pos v))
				need_verts = for v in verts_near where (distance (polyOp.getVert sel v) vert_pos) == nearest_dist collect v
				need_pos = for v in verts_near where v == need_verts[1] collect polyOp.getVert sel v
				print need_verts[1]
				print need_pos[1]
				polyop.weldVerts sel vert need_verts[1] need_pos[1]
			)	
			setCommandPanelTaskMode panel_mode
			if sub_level != undefined then subObjectLevel = sub_level
		) 
		else messagebox ("Collapse it first to Editable Poly")
	)	

	on btn_EdgeWeld pressed do with undo "Weld Edges" on 
	(
		if selection.count > 0 then
		(
			local ctrl = keyboard.controlPressed
			local alt = keyboard.altPressed
			local modmode = false
			local sublvl = 0	
			if getCommandPanelTaskMode() == #modify then modmode = true 
			--max create mode
			local spn = if ctrl then 0.1 else 0.01
			local sel = selection as array
			
			for i in sel where not keyboard.escPressed do
			(
				max modify mode
				if classof i == editable_poly and i.modifiers.count == 0 then 
				(
					if subObjectLevel != 0 and modmode then sublvl = subObjectLevel
				) 
				else converttopoly i
				
				local verts_new = #{}
				local edges_new = #{}
				local sel_edges = polyop.getEdgeSelection i
				if sel_edges.isempty then sel_edges = #{1..polyop.getNumEdges i}
				--max create mode
				--local sel_verts = polyop.getVertsUsingEdge i sel_edges
/*
				if sel_edges.numberset == 2 then 
				(
					local e1 = for e in sel_edges do exit with e
					local e2 = for e in sel_edges where e != e1 do exit with e
					local vv1 = polyop.getVertsUsingEdge i #{e1} --polyop.getedgeverts i e1
					local vv2 = polyop.getVertsUsingEdge i #{e2} --polyop.getedgeverts i e2
						
					local vv_v = vv1 * vv2
					--print vv_v
					
					if not vv_v.isempty then
					(	
						local vvv = vv1 + vv2 - vv_v	
						--print vvv
						local p = polyop.getvert i (for v in vv_v do exit with v)
						local pp = for v in vvv collect (polyop.getvert i v)

						if par pp p spn then 
						(
							local dist = distance pp[1] pp[2]
								
							local d1 = distance p pp[1]
							local d2 = distance p pp[2]
							local p1 = d1 / dist
							local p2 = d2 / dist		
							print p1
							print p2
							if p1 > 0.0 and p1 < 1.0 then
							(
								local vert_new = polyop.divideEdge i e1 p1
								sel_edges += polyop.getEdgesUsingVert i #{vert_new}
							)
							if p2 > 0.0 and p2 < 1.0 then
							(
								local vert_new = polyop.divideEdge i e2 p2
								sel_edges += polyop.getEdgesUsingVert i #{vert_new}		
							)
						)
					)
				)
*/
				do 
				(
					if keyboard.escPressed then exit
					local cut = false

					for e in sel_edges where not keyboard.escPressed do
					(
						--local vv = polyop.getedgeverts i e
						local vv = polyop.getVertsUsingEdge i #{e}
						
						local pp = for v in vv collect (polyop.getvert i v)
						local v1 = for v in vv do exit with v
						local v2 = for v in vv where v1 != v do exit with v
						local po1 = polyop.getvert i v1
						local po2 = polyop.getvert i v2

						for vert in polyop.getVertsUsingEdge i sel_edges /*#{1..polyop.getNumVerts i}*/ /*where vert != vv[1] and vert != vv[2]*/ where (vert != v1 and vert != v2) and not keyboard.escPressed do
						(
							local p = polyop.getvert i vert
							if par pp p spn then 
							(
								
								--нужна проверка что лежат на одной прямой, а не просто паралельны
								--нужно проверять порядок вершин, откуда считать отношение, чтобы делить правильно p1 или (1.0 - p1), p2 или (1.0 - p2)
								--добавка spn не нужна при сравении попадания в интервал [0,1]
								
								local dist = distance po1 po2
								
								local d1 = distance p po1
								local d2 = distance p po2
								
								if (d1 + d2 - dist) <= spn then 
								(
									local p1 = d1 / dist
									local p2 = d2 / dist
									
									format "dist=% d1=% d2=% p1=% p2=%\n" dist d1 d2 p1 p2
									
									/*
									if p1 >= (0.0 + spn) and p1 <= (1.0 - spn) and p2 >= (0.0 + spn) and p2 <= (1.0 - spn) then
									(
										local vert_new = polyop.divideEdge i e p1
										if distance (polyop.getvert i vert_new) p >= spn then 
										(
											polyop.setVertSelection i #{vert_new} 
											i.EditablePoly.Remove selLevel:#Vertex
										)
										else
										(
											
											--local vert_new = if p1 < p2 then polyop.divideEdge i e p1 else polyop.divideEdge i e p2
											--format "dist=% d1=% d2=% p1=% p2=%\n" dist d1 d2 p1 p2
											--if vv[1] < vv[2] then polyop.divideEdge $ e p1 else polyop.divideEdge $ e p2
											--local vert_new = if v1 > vert then polyop.divideEdge i e p1 else polyop.divideEdge i e p2	
											--verts_new += #{vert_new}
											sel_edges += polyop.getEdgesUsingVert i #{vert_new}
											cut = true
											exit	
										)
									)
									*/
									/*
									if p1 > 0.0 and p1 < 1.0 and p2 > 1.0 and dist > spn then
									(
										local vert_new = polyop.divideEdge i e p1
										sel_edges += polyop.getEdgesUsingVert i #{vert_new}
										cut = true
										exit
									)
									
									if p2 > 0.0 and p2 < 1.0 and p1 > 1.0 and dist > spn then
									(
										local vert_new = polyop.divideEdge i e p2
										sel_edges += polyop.getEdgesUsingVert i #{vert_new}
										cut = true
										exit	
									)
									*/
									local t = 0.0001
									if p1 >= (0.0 + t) and p1 <= (1.0 - t) and p2 >= (0.0 + t) and p2 <= (1.0 - t) then
									--if p1 > 0.0 and p1 < 1.0 and p2 > 0.0 and p2 < 1.0 then
									(
										--local vert_new = if v1 > v2 then polyop.divideEdge i e p1 else polyop.divideEdge i e p2
										--local vert_new = if v1 > vert then polyop.divideEdge i e p1 else polyop.divideEdge i e p2
										local vert_new = polyop.divideEdge i e p1
										if distance (polyop.getvert i vert_new) p >= spn then 
										(
											polyop.setVertSelection i #{vert_new} 
											i.EditablePoly.Remove selLevel:#Vertex
											
											local vert_new2 = polyop.divideEdge i e p2
											if distance (polyop.getvert i vert_new2) p >= spn then
											(											
												polyop.setVertSelection i #{vert_new2} 
												i.EditablePoly.Remove selLevel:#Vertex
											)
											else
											(
												sel_edges += polyop.getEdgesUsingVert i #{vert_new2}
												cut = true
												exit	
											)
										)
										else
										(
											sel_edges += polyop.getEdgesUsingVert i #{vert_new}
											cut = true
											exit	
										)
										
									)									
									
									if alt then
									(
										/*
										if p1 > 0.0 and p1 < 1.0 and p2 > 0.0 and p2 < 1.0 then
										(
											local vert_new = polyop.divideEdge i e p1
											sel_edges += polyop.getEdgesUsingVert i #{vert_new}
											cut = true
											exit	
										)
										*/

										if p1 > 0.0 and p1 < 1.0 then
										(
											local vert_new = polyop.divideEdge i e p1 --polyop.divideEdge i e (1.0 - p1)
											sel_edges += polyop.getEdgesUsingVert i #{vert_new}
											cut = true
											exit	
										)
										
										if p2 > 0.0 and p2 < 1.0 then
										(
											local vert_new = polyop.divideEdge i e p2 --polyop.divideEdge i e (1.0 - p2)
											sel_edges += polyop.getEdgesUsingVert i #{vert_new}
											cut = true
											exit									
										)
									)		
								)
							)
						)	
					)

				) while cut
				addmodifier i (VertexWeld threshold: 0.001)	
				converttopoly i
				if modmode then 
				(
					max modify mode 
					if sublvl != 0 then subObjectLevel = sublvl
				)
			)
		)
	)

	on btn_EdgeWeld rightclick do with undo "Weld Edges" on 
	(
		if selection.count > 0 then
		(
			local modmode = false
			local sublvl = 0	
			if getCommandPanelTaskMode() == #modify then modmode = true 
			--max create mode
			local spn = 0.01
			local sel = selection as array
			
			for i in sel where not keyboard.escPressed do
			(
				max modify mode
				if classof i == editable_poly and i.modifiers.count == 0 then 
				(
					if subObjectLevel != 0 and modmode then sublvl = subObjectLevel
				)
				else converttopoly i
				
				local verts_new = #{}
				local edges_new = #{}
				local sel_edges = polyop.getEdgeSelection i
				if sel_edges.isempty then sel_edges = #{1..polyop.getNumEdges i}
				--max create mode
				--local sel_verts = polyop.getVertsUsingEdge i sel_edges
				do 
				(
					if keyboard.escPressed then exit
					local cut = false
					for e1 in sel_edges where not keyboard.escPressed do
					(
						local vv1 = polyop.getedgeverts i e1
						local pp1 = for v in vv1 collect (polyop.getvert i v)
						local vec_A = pp1[1] - pp1[2]
						for e2 in sel_edges where e1 < e2 and not keyboard.escPressed do
						(
							local vv2 = polyop.getedgeverts i e2
							local pp2 = for v in vv2 collect (polyop.getvert i v)
							local vec_B = pp2[1] - pp2[2]
							local paral = if abs(dot (normalize vec_A) (normalize vec_B)) >= (1 - spn) then true else false
			
							if paral then
							(
								local A = pp1[1]
								local B = pp1[2]
								
								local C = pp2[1]
								local D = pp2[2]
								
								local AB = distance A B
								local CD = distance C D
								local AD = distance A D
								local AC = distance A C
								local BD = distance B D
								local BC = distance B C
								
								local paral_otr = false
								--для ABC и ABD
								if (AC + BC - AB) < spn and (AD + BD - AB) < spn then 
								(
									paral_otr = true
									--if AB/CD >= 1 then 
								)
								
								--для ACD и BCD
								if (AC + AD - CD) < spn and (BC + BD - CD) < spn then 
								(
									paral_otr = true
									--if AB/CD >= 1 then 
								)
							
								if paral_otr then
								(
									--local vert_new = polyop.divideEdge i e p1
									--sel_edges += polyop.getEdgesUsingVert i #{vert_new}
									--cut = true
									--exit
								)									
							)								
						)
					)

				) while cut
				addmodifier i (VertexWeld threshold: 0.001)	
				converttopoly i
				if modmode then 
				(
					max modify mode 
					if sublvl != 0 then subObjectLevel = sublvl
				)
			)
		)
	)
	
	on btn_TurnToPoly pressed do
	(
		for i in selection do addmodifier i (Turn_to_Poly limitPolySize:true maxPolySize:3)
		messagebox "May be errors now with overlayed edges"
	)
	
	on btn_ResetXform pressed do
	(
		for i in selection do resetxform i
	)
)

rollout Obj_tools "Objects tools" autoLayoutOnResize:true
(
	group "Selection and View Tools"
	(
		button btn_sel_vert "Select Vert" across:3 width:80 align:#left tooltip:"Выбрать вершину | Select Vert"
		button btn_sel_edge "Select Edge" width:80 align:#center tooltip:"Выбрать ребро | Select Edge"
		button btn_sel_face "Select Face" width:80 align:#right tooltip:"Выбрать грань | Select Face"
		spinner spn_sel_vert "" range:[1, 10000000, 1] scale:1 type:#integer fieldwidth:40 width:30 across:3 align:#left tooltip:""
		spinner spn_sel_edge "" range:[1, 10000000, 1] scale:1 type:#integer fieldwidth:40 width:30 align:#center tooltip:""	
		spinner spn_sel_face "" range:[1, 10000000, 1] scale:1 type:#integer fieldwidth:40 width:30 align:#right tooltip:""	
		button btn_show_verts "Show\Off Verts Nums" across:2 align:#left tooltip:"Отобразить\отключить номера вершин | Show\Off Verts Nums"
		--button btn_unshow_verts "UnShow Verts Nums" width:110 
		button btn_show_faces "Show\Off Faces Nums" align:#right tooltip:"Отобразить\отключить номера граней | Show\Off Faces Nums"
		--button btn_unshow_faces "UnShow Faces Nums" width:110 align:#right
		button btn_Sel_Thin "Select Thin Faces" offset:[0,0] width:90 across:3 align:#left tooltip:"LMB: Выберать тонкие грани из выбранных граней многоугольного объекта, толщина которых не превышает пороговое значение | LMB: Select thin faces from selected faces of poly object, thinner than treshold"
		spinner spn_Sel_Thin "Thinner" range:[0.0, 100.0, 0.02] scale:0.001 type:#float fieldwidth:35 offset:[0,0] 
		button btn_Points "Make points" offset:[0,0] width:70 align:#right tooltip:"LMB: Создать объекты-точки из буфера обмена, чтобы показать места ошибок, указываемых сервисом checkmodel.mos.ru\n\nRMB: Удалить все объекты-точки | LMB: Create Points from Clipboard to show error in places from service checkmodel.mos.ru\n\nRMB: Delete all Point-objects"
		button btn_objects "Select Heavy Objects" across:2 offset:[0,0] align:#left tooltip:"LMB: Создать объекты-точки из буфера обмена, чтобы показать места ошибок, указываемых сервисом checkmodel.mos.ru\n\nRMB: Удалить все объекты-точки | LMB: Create Points from Clipboard to show error in places from service checkmodel.mos.ru\n\nRMB: Delete all Point-objects"
		spinner spn_Sel_Heavy "More Verts than" range:[0, 10000000, 300] scale:10 type:#integer fieldwidth:50
	)
	group "Blueprints Tools"
	(
		button btn_clean_dwg "Clean DWG" align:#left across:4 width:60 tooltip:"Очистить сплайн с помощью порогов | Clean spline with tresholds"
		spinner spn_clean_dwg_tr "Angle" range:[0.0, 360.0, 1.0] scale:0.001 fieldwidth:25 offset:[-5,0] tooltip:"Порог угла очистки вершин | Angle clean knots treshhold"
		spinner spn_clean_dwg_dist "Dist" range:[0.0, 100000.0, 0.005] scale:0.001 fieldwidth:35 offset:[-5,0] tooltip:"Порог расстояния очистки вершин | Less than distance knots deletion treshold"
		spinner spn_clean_dwg_weld "Weld" range:[0.0, 100000.0, 0.002] scale:0.001 fieldwidth:35 align:#right tooltip:"Порог сварки вершин | Weld treshhold"

		button btn_pic_dwg "Load Pic & Make Plane" align:#left across:3 tooltip:"Откройте и загрузите изображение в виде плоскости на видовой экран | Open and Load Image as Plane to viewport"
		button btn_TapeIt "Create Tape" width:70 offset:[28,0] tooltip:"Создать Tape объект для ручной установки и измерения расстояния на рисунке | Create Tape object to manual set and measure distance on Pic"	
		button btn_Match "Rescale Pic" align:#right tooltip:"Изменить масштаб выбранного изображения (плоскость изображения) с помощью установленной ленты Tape в соответствии с указанным реальным расстоянием | Rescales selected Pic (Image-Plane) with set Tape to match specified real distance"	
		button btn_flatten "Flatten Spline to Zero" align:#left across:2 tooltip:"Сгладить DWG как редактируемый сплайн по оси Z до нуля | Flatten DWG as Editable Spline in Z-axis to zero"		
		spinner spn_DWG "Real Pic Distance" range:[-100000.0, 100000.0, 2.0] scale:0.1 fieldwidth:40 width:80 align:#right tooltip:""
	)
	group "Grid Tools"
	(
		button btn_create_grid "Create & Activate Grid" align:#left across:2 tooltip:"Создать вспомогательный объект сетки, выровняйте по зданию, активируйте сетку для отображения на экране | Create Grid helper object, align to building, activate grid to viewport"
		button btn_inactivate_grid "Inactivate Grid" align:#right tooltip:"Деактивировать сетку в окне просмотра | Inactivate Grid from viewport"

		spinner spn_eu_x "X" range:[-360.0, 360.0, 0.0] fieldWidth:40 across:3 align:#left tooltip:""
		spinner spn_eu_y "Y" range:[-360.0, 360.0, 0.0] fieldWidth:40 align:#center tooltip:""
		spinner spn_eu_z "Z" range:[-360.0, 360.0, 0.0] fieldWidth:40 align:#right tooltip:""
	)	
	
	on Obj_tools open do
	(
		for i in Obj_tools.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_tools.ini") i.name "Obj_tools" (syssetup.rdo_lang.state))
	)
	
	on btn_objects pressed do
	(	
		local sel = #()
		local tr = spn_Sel_Heavy.value
		sel = for o in objects where o.mesh.verts.count >= tr collect o
		select sel
	)
	
	on btn_objects rightclick do
	(	
		local sel = #()
		sel = for o in helpers collect o
		select sel
	)
	
	on btn_Points pressed do
	(
		--[{"x":0.698974609375,"y":0.003002166748046875,"z":-8.569031715393066},{"x":0.47660064697265625,"y":0.003002166748046875,"z":-8.677207946777344},{"x":0.47660064697265625,"y":0.003002166748046875,"z":-8.677207946777344},{"x":0.8009681701660156,"y":0.003002166748046875,"z":-8.498865127563477},{"x":1.0582389831542969,"y":0.08300209045410156,"z":-8.232723236083984},{"x":0.981501579284668,"y":0.003002166748046875,"z":-8.329870223999023},{"x":1.0582389831542969,"y":0.003002166748046875,"z":-8.232723236083984},{"x":0.8009681701660156,"y":0.08300209045410156,"z":-8.498865127563477},{"x":1.18084716796875,"y":0.003002166748046875,"z":-8.017970085144043},{"x":0.2371845245361328,"y":0.08300209045410156,"z":-8.739108085632324},{"x":1.2583999633789062,"y":0.003002166748046875,"z":-7.7831573486328125},{"x":-1.1434803009033203,"y":0.0800018310546875,"z":-7.856436729431152},{"x":-1.0517215728759766,"y":0.0800018310546875,"z":-8.086071014404297},{"x":-1.1434803009033203,"y":0.0000019073486328125,"z":-7.856436729431152},{"x":-1.1717443466186523,"y":0.0800018310546875,"z":-7.735908508300781},{"x":-1.1622161865234375,"y":0.0000019073486328125,"z":-7.243887901306152},{"x":-1.191634178161621,"y":0.0800018310546875,"z":-7.4894208908081055},{"x":-1.1830615997314453,"y":0.0800018310546875,"z":-7.365920066833496},{"x":-1.1878490447998047,"y":0.0000019073486328125,"z":-7.613161087036133},{"x":-1.1293087005615234,"y":0.0800018310546875,"z":-7.124544143676758},{"x":-0.9891395568847656,"y":0.000001430511474609375,"z":-8.192888259887695},{"x":-1.028726577758789,"y":0.0800018310546875,"z":-6.898634910583496},{"x":1.2254924774169922,"y":0.003002166748046875,"z":-7.90250301361084},{"x":-1.0846633911132812,"y":0.0800018310546875,"z":-7.009075164794922}]

		local s = substitutestring (getclipboardText()) "\"" ""
		s = substitutestring s "[" "#("
		s = substitutestring s "]" ")"	
		s = substitutestring s "{" "["	
		s = substitutestring s "}" "]"	
		s = substitutestring s "x:" ""		
		s = substitutestring s "y:" ""		
		s = substitutestring s "z:" ""
		
		if s.count > 0 then 
		(	
			local arr = #()
			arr = execute (s)
			--print #(arr)
			if arr != ok then
				if arr.count > 0 then 
					for p in arr do point pos:[p.x, -p.z, p.y] size:0.1 color:orange
		)
	)
	
	on btn_Points rightclick do
	(
		--for i in geometry where classof i == Point do delete i
		--for i in geometry where findstring i.name "Point" != undefined do delete i
		delete $Point*	
	)
	
	on btn_sel_vert pressed do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			if spn_sel_vert.value <= polyOp.getnumverts $ then
			(
				max modify mode
				subobjectlevel = 1
				polyOp.setVertSelection $ #{spn_sel_vert.value}
				forcecompleteredraw()
			)
		)			
	)
	
	on btn_sel_edge pressed do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			if spn_sel_edge.value <= polyOp.getnumedges $ then
			(
				max modify mode
				subobjectlevel = 2
				polyOp.setEdgeSelection $ #{spn_sel_edge.value}
				forcecompleteredraw()
			)
		)			
	)
	
	on btn_sel_face pressed do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			if spn_sel_face.value <= polyOp.getnumfaces $ then
			(
				max modify mode
				subobjectlevel = 4
				polyOp.setFaceSelection $ #{spn_sel_face.value}
				forcecompleteredraw()
			)
		)			
	)
	
	on btn_unshow_verts pressed do 
	(
		unregisterRedrawviewscallback VertexShow
		forcecompleteredraw()		
	)

	on btn_show_verts pressed do
	(
		local VertexIndexShow = false
		local lastviewport
		global Laca_callbacks
		global redrawscr_laca()
	
		if VertexIndexShow then 
		(
			Laca_callbacks -= 1
			unregisterRedrawviewscallback VertexShow
			if Laca_callbacks == 0 then unregisterRedrawViewsCallback redrawscr_laca
		)
		else 
		(
			if Laca_callbacks != undefined then Laca_callbacks += 1
			if Laca_callbacks == undefined then Laca_callbacks = 1
			registerRedrawviewscallback VertexShow
			unregisterRedrawViewsCallback redrawscr_laca
			registerRedrawviewsCallback redrawscr_laca
		)
		VertexIndexShow = not VertexIndexShow
		forcecompleteredraw()
		updateToolbarbuttons()
	)

	on btn_unshow_faces pressed do 
	(
		unregisterRedrawviewscallback FaceShow
		forcecompleteredraw()		
	)
	
	on btn_show_faces pressed do
	(
		local FaceIndexShow = false
		local lastviewport
		global Laca_callbacks
		global redrawscr_laca()		
		
		if FaceIndexShow then 
		(
			Laca_callbacks -= 1
			unregisterRedrawviewscallback FaceShow
			if Laca_callbacks == 0 then unregisterRedrawViewsCallback redrawscr_laca
		)
		else 
		(
			if Laca_callbacks != undefined then Laca_callbacks += 1
			if Laca_callbacks == undefined then Laca_callbacks = 1
			registerRedrawviewscallback FaceShow
			unregisterRedrawviewsCallback redrawscr_laca
			registerRedrawviewsCallback redrawscr_laca
		)
		FaceIndexShow = not FaceIndexShow
		forcecompleteredraw()
		updateToolbarbuttons()
	)

	on btn_Sel_Thin pressed do
	(
		if selection.count == 1 then
		(
			t = spn_Sel_Thin.value
			s = selection[1]
			ff = polyop.getFaceSelection s
			faces = #{}
			for i in ff do
			(
				vv = polyop.getvertsusingface s #{i}
				pp = for v in vv collect polyop.getvert s v
				for p1 in pp do 
					for p2 in pp where p1 != p2 and (p1.x == p2.x or p1.z == p2.z or p1.y == p2.y) and distance p1 p2 <= t do faces += #{i}
			)
			polyop.setFaceSelection s faces
		)
	)
	
	on btn_Sel_Thin rightclick do
	(
		if selection.count == 1 then
		(
			local t = spn_Sel_Thin.value
			local s = selection[1]
			local ff = #{}
			local vv = #{}
			local pp = #{}
			ff = polyop.getFaceSelection s
			if ff.isempty then ff = #{1..polyop.getnumfaces s}
			local faces = #{}
			for i in ff do
			(
				vv = polyop.getvertsusingface s #{i}
				--pp = for v in vv collect polyop.getvert s v
				found = false 
				for v1 in vv where not found do
				(
					p1 = polyop.getvert s v1
					for v2 in vv where v1 < v2 and distance p1 (p2 = polyop.getvert s v2)  <= t and not found do 
					(
						faces += #{i}
						found = true 
						exit
					)
				)
			)
			polyop.setFaceSelection s faces
		)
	)
		
	
	on btn_pic_dwg pressed do
	(
		try 
		(	
			filename = getBitmapOpenFileName()
			--btn_pic_dwg.caption = getNameFromPath(filename)
			create_plane filename
		) 
		catch (messagebox "Something Wrong!")
	)	
	
	on btn_clean_dwg pressed do
	(
		for i in selection where classof i == LinkComposite do delete i
		tol = spn_clean_dwg_tr.value	
		for spl in selection do 
		(
				if classof spl == SplineShape or classof spl == line do
				(
					sub = subobjectlevel
					numLine = numSplines spl
					subSplinesArr = for i in 1 to numLine collect i
					for iLine in subSplinesArr do
					(
						bl = isClosed spl iLine
						iKnots = numKnots spl iLine
						if iKnots < 3 do continue
						i = 1
						while (i+2) <= iKnots do
						(
							p1 = getKnotpoint spl iLine i
							p2 = getKnotpoint spl iLine (i+1)
							p3 = getKnotpoint spl iLine (i+2)
							v1 = p1-p2
							v2 = p3-p2
							Angle = acos (dot (normalize v1) (normalize v2))
							comAng = int(Angle*100)/100.0							
							if comAng >= 180.0 - tol then (deleteKnot spl iLine (i+1)) else i+=1
							iKnots = numKnots spl iLine
						)
						if bl do
						(
							p1 = getKnotPoint spl iLine (iKnots-1)
							p2 = getKnotPoint spl iLine iKnots
							p3 = getKnotPoint spl iLine 1
							v1 = p1-p2
							v2 = p3-p2
							Angle = acos (dot (normalize v1) (normalize v2))
							comAng = int(Angle*100)/100.0
							if comAng >= 180.0 - tol then deleteKnot spl iLine iKnots
						)
					)
					updateShape spl
					allKnotPoints = #()
					closeKnots = #()
					subobjectLevel = 0
					for s = 1 to numSplines spl do for k = 1 to numKnots spl s do append allKnotPoints #(s, k, (getKnotPoint spl s k))
					for i = 1 to allKnotPoints.count do for j = i + 1 to allKnotPoints.count where i != j do 
						if distance allKnotPoints[i][3] allKnotPoints[j][3] <= spn_clean_dwg_dist.value do
						(
							appendifunique closeKnots #(allKnotPoints[i][1],allKnotPoints[i][2])
							appendifunique closeKnots #(allKnotPoints[j][1],allKnotPoints[j][2])
						)
					for s = 1 to numSplines spl do setKnotSelection spl s #() -- deselect all
					for a in closeKnots do setKnotSelection spl a[1] #(a[2]) keep:true -- select from array
					updateshape spl
					subobjectLevel = 1
					weldSpline spl spn_clean_dwg_weld.value
					updateshape spl
					subobjectLevel = 0
					opensplines = #()
					for i = 1 to numSplines spl where (isClosed spl i == false) do
					( 
						append opensplines i
						knotmax = numKnots spl i
						--knotindxarr = "#("+"1"+ "," +(knotmax as string)+")"
						setKnotSelection spl i (#(1,knotmax))
						--setKnotSelection spl i (execute knotindxarr)
						updateShape spl	
					)--end loop
					subobjectlevel = 1
					for s = 1 to numSplines spl do for k = 1 to numKnots spl s do setKnotType spl s k #corner
					updateShape spl	
					--max select all
					--subobjectlevel = 0
					subobjectlevel=sub
				) --endif
		) --end spl	
	)
	
	on btn_flatten pressed do flatten()
	
	on btn_TapeIt pressed do 
	(
		if selection.count > 0 then 
			tp = Tape pos:[selection[1].min.x,selection[1].center.y,selection[1].max.z] target:(targetObject pos:[selection[1].max.x,selection[1].center.y,selection[1].max.z]) 
		else
			tp = Tape pos:[-10,0,0] target:(targetObject pos:[10,0,0])
	)
			
	on btn_Match pressed do 
	(
		tp = $Tape001
		td = $Tape001.Target
		dist = distance tp.pos td.pos
		sc = dist/spn_DWG.value
		tp.parent = selection[1]
		td.parent = selection[1]
		selection[1].scale = selection[1].scale/sc
		tp.parent = undefined
		td.parent = undefined
		max zoomext sel
	)	
	
	on btn_create_grid pressed do
	(
		gr = grid length:1.0 width:1.0 grid:10.0 pos:[0,0,0] rotation: (EulerAngles spn_eu_x.value spn_eu_y.value spn_eu_z.value)
		if selection.count == 1 then
		(
			gr.pos = selection[1].pos 
			gr.dir = selection[1].dir --rotation
		)
		activegrid = gr 
		
	)
)

rollout UCX "UCX operations" autoLayoutOnResize:true
(
	button btn_UCX_make "UCX Make Form" width:80 across:3 offset:[0,0] align:#left tooltip:"LMB: Создать UCX-контейнеры выпуклых произвольных форм, описывающих силуэты вокруг выбранных частей объектов\nLMB+CTRL: Делать сначала Remesh выделению с указанной максимальной длинной ребер\nLMB+ALT: Не обводить объекты\nLMB+SHIFT: Добавить Push в стек\n\nRMB: Создать UCX-контейнер вокруг выбранных граней-элементов объекта\n\nRMB+CTRL: габариты +0,005м | RMB: Make UCX box around selected faces-elements of object\n\nLMB+CTRL: make gabarites offset 0.005m"
	spinner spn_UCX_make "E-Lenght" range:[0.0, 1000.0, 0.0] offset:[-5,0] fieldWidth:35 tooltip:"Максимальная длинна ребер для операции Remesh. По умолчанию 0 - оставлять модель как есть. При подобранных положительных значениях происходит Remesh выбранной части модели на эту величину длинны ребер, таким образом, что уменьшенный полигонаж Remesh модели влияет на полигонаж создаваемой UCX формы вокруг Remesh модели | Maximum edge length for the Remesh operation. The default value is 0, which leaves the model as it is. When a positive value is selected, the selected part of the model is remeshed by the specified edge length, resulting in a reduced polygon count for the Remesh model, which affects the polygon count of the UCX shape created around the Remesh model"
	button btn_UCX_makeground "UCX Make Ground" width:90 offset:[0,0] align:#right tooltip:"Создать контейнеры UCX из выбранных граней Ground объекта. Используется автоматическое разбиение для выпукло-вогнутых мест, зазоры и выдавливание вниз | Make UCX containers from selected faces from Ground object. Use automatic Convex-Concave subdivision, gaps and extrusions"	
	--button btn_UCX_pivot "UCX Pivot" tooltip: "Place Pivots to Zero"

	button btn_UCX_rename "UCX Rename" width:85 align:#left across:3 tooltip: "Переименовать выбранные объекты UCX по номерам | Rename selected UCX objects by numbers"
	button btn_UCX_Clear_Mat "UCX Clear Mat" width:85 offset:[0,0] tooltip:"Удалить материал у выбранных UCX объектов | Delete UCX Material on selected objects"
	button btn_UCX_connect "UCX Triangulate" width:85 align:#right offset:[0,0] tooltip:"Триангулировать выбранные объекты UCX | Triangulate selected UCX objects"

	button btn_UCX_check "UCX Check" width:85 offset:[0,0] across:3 align:#left tooltip:"LMB: Проверить UCXы на максимальное количество треугольников\nLMB+CTRL: Не триангулировать при проверке\n\nRMB: Проверить UCXы на наличие пересечений\nRMB+ALT: Детальная проверка\nRMB+CTRL: Проверить UCX-формы на ВЫПУКЛОСТЬ (правильную) и ВОГНУТОСТЬ (неправильную) | LMB: Check UCXs for maximum triangles\nLMB+CTRL: Don't triangulate\n\nRMB: Check UCXs for intersections\nRMB+ALT: Detailed check\nRMB+CTRL: Check UCXs forms for CONVEX (right) and CONCAVE (wrong)"
	button btn_UCX_move "UCX Move Faces" width:85 offset:[5,0] tooltip:"LMB: Раздвинуть параллельные грани на расстояние [0,01 - 0,02], обычно на расстояние 0,015 м друг от друга\n\nLMB+ALT: также раздвинуть близкие вершины и ребра\n\nLMB+CTRL: дополнительно использовать точки с нормалями к центрам граней, для большей точности | LMB: Move parallel faces to range [0.01 - 0.02], usually to 0.015m from each other\n\nLMB+ALT: also moves near verts and edges (do not use with faces - will move twice)\n\nLMB+CTRL: additional use verts points with face centers normals, for more accuracy"
	button btn_UCX_gaps "UCX Make Gaps" width:85 offset:[0,0] align:#right tooltip:"LMB: Сделать зазоры между несколькими выделенными объектами путем булевых операций с отступом, могут продуцироваться вогнутые формы, возможно придется повторно создавать UCX-контейнеры выпуклых форм | LMB: Make gaps between multiple selected UCX objects using Boolean operations with padding, which may produce concave shapes and may require re-creating UCX containers for convex shapes"
	
	button btn_UCX_Select "UCX Select" width:55 offset:[0,0] across:4 align:#left tooltip:"LMB: Выбрать все UCX (поиск по имени) для предварительно выбранной ВПМ модели\n\nRMB: Выбрать все UCX модели из одного или нескольких выбранных UCX | LMB: Select all UCXs for preselected model (by name)\n\nRMB: Select all the same UCXs from one or few selected UCX"	
	button btn_UCX_explode "UCX Explode-Attach" width:100 offset:[15,0] tooltip: "LMB: Разделить Editable Poly (UCX) на элементы\n\nRMB: Объединить все объекты в один Editable Poly | LMB: Explode Editable Poly to elements\n\nRMB: attach all objects in one Editable Poly"
	button btn_UCX_Hide "UCX Hide" width:50 offset:[25,0] tooltip:"Скрыть все объекты UCX (поиск по имени) | Hide all UCX objects by name"
	button btn_UCX_Unhide "Unhide" width:40 offset:[0,0] align:#right tooltip:"Показать все объекты UCX (поиск по имени) | Unhide all UCX objects by name"
	
	on UCX open do
	(
		for i in UCX.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_UCX.ini") i.name "UCX" (syssetup.rdo_lang.state))
	)	
	
	on btn_UCX_check pressed do
	(
		error = "Select one object or UCX object(s)"
		ctrl = keyboard.controlPressed
		error = "Something wrong"
		error_open_edges = ""
		if selection.count > 0 then
		(
			sel = selection as array
			ucx = for o in objects where findstring o.name "UCX_" != undefined collect o
			
			if selection.count == 1 then
			(				
				if findstring selection[1].name "UCX_" == undefined then 
				(
					sel = #(selection[1])
					ucx = for o in objects where findstring o.name "UCX_" != undefined and findstring o.name sel[1].name != undefined collect o 
				)
				else 
				(
					ucx = #(selection[1])
					sel = for o in objects where findstring o.name "UCX_" == undefined and o.name == (substitutestring ucx[1].name "UCX_" "") collect o
				)
			)
			else
			(
				sel = for s in selection where findstring s.name "UCX_" == undefined collect s
				ucx = #()
				for s in sel do 
					for o in objects where findstring o.name "UCX_" != undefined and findstring o.name s.name != undefined do appendIfUnique ucx o 	
			)
			
			case of
			(
				(sel.count == 0 and ucx.count == 1): error = "Can't find source object for selected UCX model"
				(sel.count > 1 and ucx.count == 1): error = "Can't find SINGLE source object for selected UCX model"
				(sel.count == 1 and ucx.count > 0):
				(
					if ctrl then --для основного объекта без доп триангуляции
					(
						ss = copy sel[1]
						convertTopoly ss
						select ss	
						num = polyop.getnumfaces ss
						delete ss						
					)
					else --для основного объекта доп триангуляция
					(
						ss = copy sel[1]
						convertTopoly ss
						select ss
						max modify mode
						subObjectLevel = 1
						ss.unhideAll #Vertex
						ss.unhideAll #Face
						max select all 
						ss.ConnectVertices vertexFlag:1
						subObjectLevel = 0								
						num = polyop.getnumfaces ss
						delete ss
					)
					num_ucx = 0
					if ctrl then --для ucx объекта нет доп триангуляции
					(
						for u in ucx where not keyboard.escPressed do
						(
							max create mode
							u_copy = copy u
							convertTopoly u_copy
							num_ucx += polyop.getnumfaces u_copy
							delete u_copy
						)
					)						
					else --для ucx объекта доп триангуляция
					(
						for u in ucx where not keyboard.escPressed do
						(
							u_copy = copy u
							convertTopoly u_copy
							select u_copy
							max modify mode
							subObjectLevel = 1
							u_copy.unhideAll #Vertex
							u_copy.unhideAll #Face
							max select all 
							u_copy.ConnectVertices vertexFlag:1
							subObjectLevel = 0				
							num_ucx += polyop.getnumfaces u_copy
							delete u_copy
						)
					)
					
					--error_open_edges = ""
					for u in ucx where not keyboard.escPressed do
					(	
						u_copy = copy u
						convertTopoly u_copy
						--local edges = #{1..u_copy.getNumEdges()} 
						--for e in edges where u_copy.GetEdgeFace e 1 == 0 or u_copy.GetEdgeFace e 2 == 0 do (error_open_edges += ("Open edges: " + u.name + "\n"); exit)
						if not (polyop.getOpenEdges u_copy).isempty then error_open_edges += "Open edges: " + u.name + "\n"
						delete u_copy
					)						
					
					if num <= 50000 then 
					(
						if num_ucx > 15000 then error = "UCXs have too high number of triangles.\n"
						else error = "UCXs have good number of triangles.\n"
						error += "For model with less than 50000 polys,\nLimit UCX triangles: 15000\nModel have triangles: " + num as string + "\nUCXs triangles: " + num_ucx as string + "\nNumber to limit triangles: " + (abs(15000 - num_ucx)) as string
					)
					else
					(
						if num_ucx > ceil (num * 0.05) then error = "UCXs have too high number of triangles.\n" --"For current model with " + num as string + " triangles after triangulation\nthe maximum number of triangles for UCX objects is " + ((ceil (num * 0.05)) as integer) as string + ",\nbut the current number of UCX triangles is:" + num_ucx as string
						else error = "UCXs have good number of triangles.\n" --"For current model with " + num as string + " triangles after triangulation\nthe maximum number of triangles for UCX objects is " + ((ceil (num * 0.05)) as integer) as string + ",\nthe current number of UCX triangles " + num_ucx as string + " less than upper limit." 
						error += "Model triangles: " + num as string + "\nLimit UCX triangles (5%): " + ((ceil (num * 0.05)) as integer) as string + "\nNow UCX triangles: " + num_ucx as string + "\nNumber to limit triangles: " + ((abs(ceil (num * 0.05) - num_ucx)) as integer) as string
					)
					if not ctrl then error += "\nAdditional triangulation done."
					else error += "\nAdditional triangulation NOT done.\nData may be wrong!\n"
				)
				(sel.count > 1 and ucx.count > 0): error = "Select single base object for one or multiple UCX objects"
			)
		)
		messagebox (error + "\n" + error_open_edges)
		select ucx
		selectmore sel
		gc()
	)
	
	on btn_UCX_check rightclick do with undo off
	(
		error = "Select one or few UCX objects"
		ctrl = keyboard.controlPressed
		alt = keyboard.altPressed
		error = "Something wrong"
		error_open_edges = ""
		if selection.count > 0 then
		(
			ucx = for o in selection where findstring o.name "UCX_" != undefined collect o

			case of
			(
				(ucx.count == 0): error = "No UCX objects in selection"
				(ucx.count == 1): --search within
				(
					if ctrl then 
					(
						s = if classOf ucx[1] != Editable_Poly then converttopoly (copy ucx[1]) else ucx[1]
						
						--opens = #{}
						--opens = polyop.getOpenEdges s
						if not (polyop.getOpenEdges s).isempty then error_open_edges += "There are open edges."
						
						--convex-concave test for faces of single poly
						selfaces = #{} 
						selfaces = polyop.getFaceSelection s --#{1..(polyop.getNumFaces s)}
						if selfaces.isempty then selfaces = #{1..(polyOp.getNumFaces s)}

						--проверка на convex concave отдельных граней (не триангулированных)
						concaves = #{}
						concaves = convex_concave s selfaces
												
						if not concaves.isempty then 
						(
							if classOf ucx[1] != Editable_Poly then select s else select ucx[1]
							max modify mode								
							polyOp.setfaceselection selection[1] concaves
							error = "UCX object is not good, have concave faces, selected.\n"
						)
						else
						(
							select ucx[1]
							error = "UCX object is good, hasn't concave faces!\n"
						)
							
						--метод проверки формы объекта на convex concave через dot нормалей граней, если отрицательны, значит вогнуты, если 0 параллельны, если положительны, значит выпуклые
						concave_faces = #{}
						for f in selfaces where not keyboard.escPressed do
						(
							local n = polyop.getFaceNormal s f
							--local ee = polyop.getEdgesUsingFace s #{f} --получить ребра грани
							--local ff = (polyop.getFacesUsingEdge s ee) - #{f} --получить грани ребер
							local vv = polyop.getVertsUsingFace s #{f} --получить вершины грани
							local ff = (polyop.getFacesUsingVert s vv) - #{f} --получить соседние грани вершин, кроме исходной

							for f_ in ff where dot (polyop.getFaceNormal s f_) n < 0.0 do --если dot отрицательна, значит вогнутые грани
							(
								--format "% % % % % %\n" f f_ n m ff d
								concave_faces += #{f_, f}
							)
						)						
						
						--метод проверки формы на прострел соседних фейсов
						--пока не понятно как выпускать нормали из эджей: из середины эджей выпускать лучи во внешние стороны в плоскости z=0, если попадут в себя - concave
						--можно выдавливать из эджей полики по периметру, проверять уже готовым методом
						/*
						points = #()
						hits = #()
						concave = #()
						--concave_faces = #{} --ранее использовалось и добавится
						for i in selfaces where not keyboard.escPressed do
						(
							vec = polyop.getFaceNormal s i
							--vec_projection = [vec.x, vec.y, 0] --не очень понятно, правильно ли так брать проекцию
							points = #()
							append points (polyop.getSafeFaceCenter s i) -- + (0.001*vec))
							if points.count > 0 and vec != undefined then --and vec_projection != undefined then 
							(
								for poi in points where poi != undefined do
								(
									hits = intersectRayScene (ray poi vec)
									--join hits (intersectRayScene (ray poi vec_projection))
									if hits.count > 0 then
									(		
										concave = #()
										concave = for h in hits where h[1] == s collect h 
										if concave.count > 0 then concave_faces += #{i}
									)
								)
							)
							else error += "\nThere were error.\n"
						)
						*/	
						
						--метод проверки по уравнению плоскости, составляем уравнение из первого треугольника грани и подстановка остальных вершин объекта в уравнение, если знак больше 0, значит выше грани, значит вогнутая форма
						vv_all = polyop.getVertsUsingFace s selfaces
						concave_faces_new = #{}
						for i in selfaces where not keyboard.escPressed do
						(
							arri = ()
							vvi = polyop.getVertsUsingFace s #{i} --polyop.getfaceverts s i
							ppi = polyop.getverts s vvi
							--построение уравнения плоскости из первых 3 точек
							arri = equation_plane ppi[1].x ppi[1].y ppi[1].z ppi[2].x ppi[2].y ppi[2].z ppi[3].x ppi[3].y ppi[3].z  --x1 y1 z1 x2 y2 z2 x3 y3 z3 
							
							vvj = vv_all - vvi
							ppj = polyop.getverts s vvj
							signs = #()
							for pj in ppj do
							(
								append signs (arri[1] * pj.x + arri[2] * pj.y + arri[3] * pj.z + arri[4])
								ax = amax signs
								am = amin signs
								--format "max=% min=%\n" ax am
								if (ax < 0 and am < 0) or (ax > 0 and am > 0) then () else concave_faces_new += #{i}
							)
						)
						if not concave_faces_new.isempty then error += "\nThere were error.\n"
						concave_faces += concave_faces_new	
						
						if not concave_faces.isempty then 
						(
							error += "UCX object is not good, have whole concave form, error faces selected.\n"
							polyOp.setfaceselection selection[1] (concaves + concave_faces)
						)
						if classOf ucx[1] != Editable_Poly then delete s
					)
					else
					(
						--explode first
						u_copy_1 = copy ucx[1]
						ucx_copy = #()
						converttopoly u_copy_1
					
						--local edges = #{1..u_copy_1.getNumEdges()} 
						--for e in edges where u_copy_1.GetEdgeFace e 1 == 0 or u_copy_1.GetEdgeFace e 2 == 0 do (error_open_edges += "Open edges: " + ucx[1].name + "\n"; exit)
						if not (polyop.getOpenEdges u_copy_1).isempty then error_open_edges += "Open edges: " + ucx[1].name + "\n"

						while u_copy_1.getNumFaces() != 0 do 
						(
							if keyboard.escPressed then exit
							polyop.detachFaces u_copy_1 (polyOp.getElementsUsingFace u_copy_1 #{1}) asNode:true delete:true name:(uniqueName (u_copy_1.name + "_"))
							append ucx_copy (maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle)))
						)
						delete u_copy_1	
						
						if ucx_copy.count == 1 then 
						(
							delete ucx_copy 
							select ucx						
							error = "Only one UCX object in selection, no intersections."
						)
						else
						(
							max modify mode
/*
							for u in ucx_copy where not keyboard.escPressed do
							(	
								convertTopoly u
								local edges = #{1..u.getNumEdges()} 
								for e in edges where u.GetEdgeFace e 1 == 0 or u.GetEdgeFace e 2 == 0 do (error_open_edges += "Open edges: " + u.name + "\n"; exit)
							)	
*/							
							if not alt then
							(
								u_copy_1 = ucx_copy[1]
								addmodifier u_copy_1 (BooleanMod method:0 disableInteractiveUpdates:true)
								u_copy_1.modifiers[1].SetOperationType 1 #union
								u_copy_1.modifiers[1].AppendOperand	2
								u_copy_1.modifiers[1].SetOperationType 2 #intersection
								select u_copy_1	
								for u in #{2..ucx_copy.count} where not keyboard.escPressed do u_copy_1.modifiers[1].AppendFolderOperand 2 ucx_copy[u]
							
								convertTopoly u_copy_1
								if polyop.getnumfaces u_copy_1 != 0 then error = "UCX objects have intersections.\nSee intersection model for details." 
								else
								(
									delete u_copy_1
									error = "UCX objects have no intersections!" 
									select ucx
								)
							)
							else
							(
								error = "For individual detailed test for UCX objects intersections, explode them first to elements" 
							)
						)
					)	
				)
				(ucx.count > 1):
				(
					if ctrl then --convex-concave test 
					(
						--не работает
						/*
						err = #()
						for u in ucx where not keyboard.escPressed do
						(
							u_copy = copy u
							convertTopoly u_copy
							select u_copy
							subObjectLevel = 1
							polyop.setVertSelection u_copy #all
							PolyToolsSelect.ConvexConcave 0.001 1
							--baking AO to vertex colour
							--<boolean>nvpx.IsConvex <node>inode
							--PolyToolsSelect.ConvexConcave 0.001 1 --Select Concave Faces
							--PolyToolsSelect.ConvexConcave 0.001 2 --Select Convex Faces 	
							temp_true = #{}
							temp_true = polyop.getVertSelection u_copy	
							delete u_copy
							if not temp_true.isempty then append err u
						)
						if err.count > 0 then 
						(
							select err
							error = "Some UCX bad and Concave, are selected."
						)
						else
						(
							select ucx
							error = "All UCX good and Convex."
						)
						*/
						max create mode
						selfaces = #{}
						concave = #()
						concaves = #()
						for u in ucx where not keyboard.escPressed do
						(
							s = copy u
							convertToPoly s

							selfaces = #{1..(polyOp.getNumFaces s)}
							
							/*
							--selfaces = polyOp.getfaceselection s
							points = #()
							hits = #()
							--if selfaces == #{} then selfaces = #{1..(polyOp.getNumFaces s)}
							selfaces = #{1..(polyOp.getNumFaces s)}
							for i in selfaces where not keyboard.escPressed do
							(
								vec = polyop.getFaceNormal s i
								--vec_projection = [vec.x, vec.y, 0]
								points = #()
								append points (polyop.getSafeFaceCenter s i) -- + (0.1*vec)
								if points.count > 0 and vec != undefined then --and vec_projection != undefined then 
								(
									for poi in points where poi != undefined do
									(
										hits = intersectRayScene (ray poi vec)
										--join hits (intersectRayScene (ray poi vec_projection))
										if hits.count > 0 then
										(		
											concave = #()
											concave = for h in hits where h[1] == s collect h 
											if concave.count > 0 then appendIfUnique concaves u
										)
									)
								)
							)	
							*/
							
							--метод проверки по уравнению плоскости, составляем уравнение из первого треугольника грани и подстановка остальных вершин объекта в уравнение, если знак больше 0, значит выше грани, значит вогнутая форма
							vv_all = polyop.getVertsUsingFace s selfaces
							concave_faces_new = #{}
							for i in selfaces where not keyboard.escPressed do
							(
								arri = ()
								vvi = polyop.getVertsUsingFace s #{i} --polyop.getfaceverts s i
								ppi = polyop.getverts s vvi
								--построение уравнения плоскости из первых 3 точек
								arri = equation_plane ppi[1].x ppi[1].y ppi[1].z ppi[2].x ppi[2].y ppi[2].z ppi[3].x ppi[3].y ppi[3].z  --x1 y1 z1 x2 y2 z2 x3 y3 z3 
								
								vvj = vv_all - vvi
								ppj = polyop.getverts s vvj
								signs = #()
								for pj in ppj do
								(
									append signs (arri[1] * pj.x + arri[2] * pj.y + arri[3] * pj.z + arri[4])
									ax = amax signs
									am = amin signs
									--format "max=% min=%\n" ax am
									if (ax < 0 and am < 0) or (ax > 0 and am > 0) then () else concave_faces_new += #{i}
								)
							)
							if not concave_faces_new.isempty then appendIfUnique concaves u
								
							
							if not (polyop.getOpenEdges s).isempty then error_open_edges += "There are open edges: " + u.name + "\n"
							delete s
							
							--метод проверки формы объекта на convex concave через dot нормалей граней, если отрицательны, значит вогнуты, если 0 параллельны, если положительны, значит выпуклые
							--selfaces = #{1..(polyOp.getNumFaces s)}
							/*
							found = false
							for f in selfaces where not keyboard.escPressed and not found do
							(
								local n = polyop.getFaceNormal s f
								local vv = polyop.getVertsUsingFace s #{f} --получить вершины грани
								local ff = (polyop.getFacesUsingVert s vv) - #{f} --получить соседние грани вершин, кроме исходной

								for f_ in ff where dot (polyop.getFaceNormal s f_) n < 0.0 do --если dot отрицательна, значит вогнутые грани
								(
									--format "% % % % % %\n" f f_ n m ff d
									appendIfUnique concaves u
									found = true
									exit 
								)
							)					
							delete s
							*/
						)
						if concaves.count > 0 then 
						(
							error = "UCX objects are not good, have concave forms.\n"
							for concave in concaves do error += concave.name + "\n"
							select concaves
						)
						else 
						(
							error = "UCX objects are good, do not have concave forms!"
							select ucx
						)
					)
					else
					(
						max modify mode
						for u in ucx where not keyboard.escPressed do
						(
							u_copy_other = copy u 
							convertTopoly u
							--local edges = #{1..u_copy_other.getNumEdges()} 
							--for e in edges where u_copy_other.GetEdgeFace e 1 == 0 or u_copy_other.GetEdgeFace e 2 == 0 do (error_open_edges += ("Open edges: " + u.name + "\n"); exit)
							if not (polyop.getOpenEdges u_copy_other).isempty then error_open_edges += "Open edges: " + u.name + "\n"
							delete u_copy_other
							free u_copy_other
						)	
						
						if not alt then
						(
							u_copy_1 = copy ucx[1]
							convertTopoly u_copy_1
							--ProBoolean.CreateBooleanObject  b c 2 0 1; --2 mean Subtraction ,0  mean Reference, 1 mean Retain Original Material
							--try (ProBoolean.createBooleanObjects (u_copy_1) (#(top,top2)) 2 2 0)catch(messagebox("ошибка булевой операции над плинтом и потолком"))
							--ProBoolean.SetBoolOp u_copy_1 2
							--ProBoolean.setoperandA u_copy_1
							addmodifier u_copy_1 (BooleanMod method:0 disableInteractiveUpdates:true)
							u_copy_1.modifiers[1].SetOperationType 1 #union
							u_copy_1.modifiers[1].AppendOperand	2
							u_copy_1.modifiers[1].SetOperationType 2 #intersection
							select u_copy_1
							/*
							  .Operands : paramBlock2 array
							  .pivotAlign : boolean
							  .useOperandMaterial : boolean
							  .method : integer
							  .hideReference : boolean
							  .retainNonPlanarFaces : boolean
							  .preserveNormalData : boolean
							  .displayType : integer
							  .displayShading : integer
							  .selectedOpacity : float
							  .unselectedOpacity : float
							  .voxelSize : worldUnits
							  .operandItems : paramBlock2 array
							  .toleranceFactor : worldUnits
							  .hideBooleanOnCreate : boolean
							  .Transform : maxObject array
							  .useLiveReference : boolean
							  .disableInteractiveUpdates : boolean
							  .doDeterministicEdgeSort : boolean
							  .operationVersion : integer
							  .doTinyFragmentCleanup : boolean
							  .doCloneCoplanarSplitOverlappedFaces : boolean
							  .bevelDistance : worldUnits
							  .bevelDepth : float
							  .bevelNumSegments : integer

								showInterfaces     $.modifiers[1]
							 Interface: BooleanModifier
							   Properties:
							   Methods:
								<integer>GetNumOperands()
								<boolean>GetRootOperandName <index>operandIndex <&string>nameout
								   nameout is Out parameter
								<boolean>SetRootOperandName <index>operandIndex <string>name
								<boolean>GetFlatOperandName <index>operandIndex <&string>nameout
								   nameout is Out parameter
								<boolean>SetFlatOperandName <index>operandIndex <string>name
								<boolean>GetFolderOperandName <index>operandIndex <index>subOperandIndex <&string>nameout
								   nameout is Out parameter
								<boolean>SetFolderOperandName <index>operandIndex <index>subOperandIndex <string>name
								<boolean>GetRootOperandType <index>operandIndex <&enum>type
								   type enums: {#modified|#single|#folder}
								   type is Out parameter
								<boolean>GetNumFolderOperands <index>operandIndex <&integer>count
								   count is Out parameter
								<boolean>GetOperationType <index>operandIndex <&enum>type
								   type enums: {#union|#intersection|#subtraction|#merge|#attach|#insert|#split}
								   type is Out parameter
								<boolean>SetOperationType <index>operandIndex <enum>type
								   type enums: {#union|#intersection|#subtraction|#merge|#attach|#insert|#split}
								<boolean>GetOperationOption <index>operandIndex <&enum>option
								   option enums: {#none|#imprint|#cookie}
								   option is Out parameter
								<boolean>SetOperationOption <index>operandIndex <enum>option
								   option enums: {#none|#imprint|#cookie}
								<boolean>GetDisable <index>operandIndex <&boolean>disable
								   disable is Out parameter
								<boolean>SetDisable <index>operandIndex <boolean>disable
								<boolean>RemoveOperand <index>operandIndex
								<boolean>AppendOperand <enum>operandtype operandNode:<node> operationType:<enum> operationOption:<enum>
								   operandtype enums: {#modified|#single|#folder}
								   operandNode default value: undefined
								   operationType enums: {#union|#intersection|#subtraction|#merge|#attach|#insert|#split}
								   operationType default value: #union
								   operationOption enums: {#none|#imprint|#cookie}
								   operationOption default value: #none
								<boolean>InsertOperand <enum>operandtype <index>where operandNode:<node> operationType:<enum> operationOption:<enum>
								   operandtype enums: {#modified|#single|#folder}
								   operandNode default value: undefined
								   operationType enums: {#union|#intersection|#subtraction|#merge|#attach|#insert|#split}
								   operationType default value: #union
								   operationOption enums: {#none|#imprint|#cookie}
								   operationOption default value: #none
								<boolean>RemoveFolderOperand <index>operandIndex <index>subOperandIndex
								<boolean>AppendFolderOperand <index>operandIndex <node>operandNode
								<boolean>InsertFolderOperand <index>operandIndex <index>where <node>operandNode
								<boolean>AlignPivot <index>operandIndex
								<boolean>ExtractAsObject <index>operandIndex
								<boolean>CutOperand()
								<boolean>PasteOperand <index>operandIndex
								<boolean>PasteToNewModifier()
								<boolean>ExtractSeams <index>operandIndex
								<boolean>CreateObjects <&node array>createdNodes
								   createdNodes is In and Out parameter
								<boolean>SelectFlatOperands <&index array>operandIndexes
								   operandIndexes is In and Out parameter
								<boolean>ClearClipboard()
							*/
							for u in #{2..ucx.count} where not keyboard.escPressed do
							(
								u_copy = copy ucx[u]
								convertTopoly u_copy
								u_copy_1.modifiers[1].AppendFolderOperand 2 u_copy
								
								--ProBoolean.createBooleanObjects u_copy_1 u_copy 1 2 0
								--ProBoolean.SetBoolOp u_copy_1 1
								--ProBoolean.setoperandB u_copy_1 u_copy 0 1
								--try (ProBoolean.createBooleanObjects u_copy_1 u_copy 1 2 0)catch()
							)	
							
							convertTopoly u_copy_1
							if polyop.getnumfaces u_copy_1 != 0 then error = "UCX objects have intersections.\nSee intersection model for details." 
							else
							(
								delete u_copy_1
								free u_copy_1
								error = "UCX objects have no intersections!" 
								select ucx
							)
						)
						else --поиск пересечений другим алгоритмом 
						(
							error = ""
							for u in #{1..ucx.count} where not keyboard.escPressed do
							(
								print ucx[u].name
								for w in #{1..ucx.count} where w > u and not keyboard.escPressed do
								(
									local u_copy = copy ucx[u]
									local w_copy = copy ucx[w]
									convertToPoly u_copy
									convertToPoly w_copy
									local nam_u = (filterstring ucx[u].name "_")[(filterstring ucx[u].name "_").count]
									local nam_w = (filterstring ucx[w].name "_")[(filterstring ucx[w].name "_").count]
									--local v_copy = u_copy - w_copy
									--convertToPoly v_copy
									
									addmodifier u_copy (BooleanMod method:0 disableInteractiveUpdates:true)
									u_copy.modifiers[1].SetOperationType 1 #union
									u_copy.modifiers[1].AppendOperand 2
									u_copy.modifiers[1].SetOperationType 2 #intersection	
									u_copy.modifiers[1].AppendFolderOperand 2 w_copy
									convertToPoly u_copy
									
									if polyop.getnumfaces u_copy != 0 then (error += nam_u + " and " + nam_w + " intersects\n"; print (nam_u + " and " + nam_w + " intersects") ) 
									delete u_copy
									free u_copy
								)	
								gc()								
							)
							gc()
							if error == "" then error = "UCX objects do not intersect"					
							select ucx
						)
					)
				)
			)
		)
		gc()
		messagebox (error + "\n" + error_open_edges)
	)

	on btn_UCX_Select pressed do
	(
		if selection.count > 0 then
		(
			sel = selection as Array
			ucx = #()
			for i in sel do
				for o in objects where findstring o.name "UCX_" != undefined and findstring o.name i.name != undefined do appendifunique ucx o
			for i in sel where findstring i.name "UCX_" != undefined do
				for o in objects where findstring o.name "UCX_" != undefined and findstring o.name (trimright i.name "0123456789_") != undefined do appendifunique ucx o
			selectmore ucx
		)
	)
	
	on btn_UCX_Select rightclick do
	(
		if selection.count > 0 then
		(
			sel = selection as Array
			ucx = #()
			obj = #()
			ucx = for s in sel where findstring s.name "UCX_" != undefined collect s
			obj = for s in sel where findstring s.name "UCX_" == undefined collect s
			if obj.count > 0 then
				for i in obj do
					for o in objects where findstring o.name "UCX_" != undefined and findstring o.name i.name != undefined do appendifunique ucx o
			if ucx.count > 0 then
				for i in ucx do 
					for o in objects where findstring o.name "UCX_" != undefined and findstring o.name (trimright i.name "0123456789_") != undefined do appendifunique ucx o 
			selectmore ucx
		)
	)	
	
	on btn_UCX_move pressed do with undo "Move Faces" on  
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			s = selection[1]
			max modify mode
			err = #()
			points = #()
			verts = #{}
			selfaces = #{}
			selfaces = polyOp.getfaceselection s
			if selfaces.isempty then selfaces = #{1..(polyOp.getNumFaces s)}
			for i in selfaces where not keyboard.escPressed do
			(
				vec_A = polyop.getFaceNormal s i
				points = #()
				append points (polyop.getFaceCenter s i)
				if ctrl then 
				(
					verts = polyop.getVertsUsingFace s #{i}
					join points (for v in verts collect	(polyop.getvert s v))
				)
				if points.count > 0 then 
				(
					for poi_A in points do
					(
						if ctrl then
						(
							hits = intersectRayScene (ray poi_A vec_A)
							--print #(hits)
							if hits.count > 0 then
							(				
								for h in hits where h[1] == s do 
								(
									if distance poi_A h[2].pos < 0.01 or (distance poi_A h[2].pos > 0.01 and distance poi_A h[2].pos <= 0.02) and (abs(dot vec_A h[2].dir) >= 0.99 or abs(dot vec_A h[2].dir) <= 0.01) then 
									(
										appendIfUnique err #(i, distance poi_A h[2].pos) 
									)
								)
							)
						)
						else
						(
							hits = intersectRay s (ray poi_A vec_A) 
							--print #(hits)
							if hits != undefined then
							(				
								if distance poi_A hits.pos < 0.01 or (distance poi_A hits.pos > 0.01 and distance poi_A hits.pos <= 0.02) and (abs(dot vec_A hits.dir) >= 0.99 or abs(dot vec_A hits.dir) <= 0.01) then 
								(
									appendIfUnique err #(i, distance poi_A hits.pos) 
								)
							)
						)						
					)
				)
			)
			polyop.flipNormals s selfaces
			for i in selfaces where not keyboard.escPressed do
			(
				vec_A = polyop.getFaceNormal s i
				points = #()
				append points (polyop.getFaceCenter s i)
				if ctrl then 
				(
					verts = polyop.getVertsUsingFace s #{i}
					join points (for v in verts collect	(polyop.getvert s v))
				)
				if points.count > 0 then 
				(
					for poi_A in points do
					(
						if ctrl then
						(
							hits = intersectRayScene (ray poi_A vec_A)  -- collecting intersections
							--print #(hits)
							if hits.count > 0 then
							(				
								for h in hits where h[1] == s do 
								(
									--if distance poi_A h[2].pos < 0.01 or (distance poi_A h[2].pos > 0.01 and distance poi_A h[2].pos <= 0.02) and (abs(dot vec_A hits[1][2].dir) >= 0.99 or abs(dot vec_A hits[1][2].dir) <= 0.01) then 
									if distance poi_A h[2].pos < 0.01 or (distance poi_A h[2].pos > 0.01 and distance poi_A h[2].pos <= 0.02) and (abs(dot vec_A h[2].dir) >= 0.99 or abs(dot vec_A h[2].dir) <= 0.01) then 
									(
										appendIfUnique err #(i, -(distance poi_A h[2].pos)) 
									)
								)
							)
						)
						else
						(
							hits = intersectRay s (ray poi_A vec_A) 
							--print #(hits)
							if hits != undefined then
							(				
								if distance poi_A hits.pos < 0.01 or (distance poi_A hits.pos > 0.01 and distance poi_A hits.pos <= 0.02) and (abs(dot vec_A hits.dir) >= 0.99 or abs(dot vec_A hits.dir) <= 0.01) then 
								(
									appendIfUnique err #(i, -distance poi_A hits.pos) 
								)
							)
						)			
					)
				)
			)	
			polyop.flipNormals s selfaces
			print #(err)
			max modify mode
			subObjectLevel = 4
			--polyOp.setFaceSelection s err
			vv_done = #{}
			for e in err do
			(
				vv = polyop.getVertsUsingFace s #{e[1]}
				if alt then polyop.moveVert s (vv - vv_done) ((-0.015/2 + e[2]/2) * getVertNormal s vv)
				else polyop.moveVert s (vv - vv_done) ((-0.015/2 + e[2]/2) * (normalize (polyop.getFaceNormal s e[1])))
				vv_done += vv
			)
			
			polyOp.setFaceSelection s ((for e in err collect e[1]) as bitarray)
			
			if alt then
			(
				verts_near = #()
				vv = polyop.getVertsUsingFace s selfaces
				for v1 in vv do
				(
					p1 = polyop.getvert s v1
					for v2 in vv where v1 < v2 do
					(
						p2 = polyop.getvert s v2
						if distance p1 p2 <= 0.02 then 
						(
							appendIfUnique verts_near #(v1, distance p1 p2, normalize (p1 - p2))
							appendIfUnique verts_near #(v2, distance p1 p2, normalize (p2 - p1))
						)
					)
				)
				
				if verts_near.count > 0 then
				(
					for v in verts_near do
					(
						polyop.moveVert s #{v[1]} ((0.015/2 - v[2]) * v[3])
					)
				)
				
				polyOp.setVertSelection s ((for v in verts_near collect v[1]) as bitarray)
			)
			redrawViews()
		)
		else messagebox "Select one UCX object as Editable Poly with few attached elements"
	)	

/*	
	on btn_UCX_move rightclick do with undo "Move Faces" on  
	(
		if selection.count == 2 and classof selection[1] == Editable_Poly and classof selection[2] == Editable_Poly then
		(
			if findstring selection[1].name "UCX_" != undefined then 
			(
				s_ucx = selection[1]
				if findstring selection[2].name "UCX_" == undefined then s = selection[2]
			)
			if findstring selection[2].name "UCX_" != undefined then 
			(
				s_ucx = selection[2]
				if findstring selection[1].name "UCX_" == undefined then s = selection[1]				
			)
				
			if s != undefined and s_ucx != undefined then
			(
				ctrl = keyboard.controlPressed
				alt = keyboard.altPressed
				max modify mode
			
				selfaces = #{}
				selfaces = polyOp.getfaceselection s
				if selfaces == #{} then selfaces = #{1..(polyOp.getNumFaces s)}
			
				selfaces_ucx = #{}
				selfaces_ucx = polyOp.getfaceselection s_ucx
				if selfaces_ucx == #{} then selfaces_ucx = #{1..(polyOp.getNumFaces s_ucx)}
				--polyop.flipNormals s_ucx selfaces_ucx
				err = #()	
				for f in selfaces_ucx do
				(
					polyop.detachFaces s_ucx #{f} asNode:true delete:false name:(uniqueName (s_ucx.name + "_" + f as string))
					s_ucx_temp = maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))
					addmodifier s_ucx_temp (shell innerAmount:0.5 outerAmount:0.5)
					addmodifier s_ucx_temp (push Push_Value:0.5)
					vol = volumeselect level:2 type:1 method:0 volume:3 node:s_ucx_temp 	
					addmodifier s vol
					addModifier s (Edit_poly())
					max modify mode
					modPanel.setCurrentObject s.modifiers[#Edit_Poly]
					sel = s.modifiers[#Edit_Poly].getSelection #Face	
					--sel = polyOp.getfaceselection s.modifiers[#Edit_Poly]
					--print #(sel)
					--collapseStack s	
					deletemodifier s 1	
					deletemodifier s 1		
					deletemodifier s_ucx_temp 1
					deletemodifier s_ucx_temp 1
	
					points = #()
					verts = #{}
					--polyop.flipNormals s_ucx_temp #{1..(polyOp.getNumFaces s_ucx_temp)}
					for i in sel where not keyboard.escPressed do
					(
						vec = polyop.getFaceNormal s i
						points = #()
						append points (polyop.getFaceCenter s i)
						if ctrl then 
						(
							verts = polyop.getVertsUsingFace s #{i}
							join points (for v in verts collect	(polyop.getvert s v))
						)
						
						if points.count > 0 then 
						(
							for poi in points do
							(
								hits = intersectRayScene (ray poi vec) --collecting intersections
								--print #(hits)
								if hits.count > 0 then
								(	
									for h in hits where h[1] == s_ucx_temp do 
									(
										print #(h)
										if distance poi h[2].pos < 0.01 or (distance poi h[2].pos > 0.01 and distance poi h[2].pos <= 0.1) and (abs(dot vec hits[1][2].dir) >= 0.99 or abs(dot vec hits[1][2].dir) <= 0.01) then 
										(
											appendIfUnique err #(i, distance poi h[2].pos) 
										)
									)
								)
							)
						)
					)
					print #(err)
					delete s_ucx_temp
				)
				
				--polyop.flipNormals s_ucx selfaces_ucx
			)

			print #(err)
			max modify mode
			subObjectLevel = 4
			--polyOp.setFaceSelection s err
			for e in err do
			(
				vv = polyop.getVertsUsingFace s #{e[1]}
				if ctrl then polyop.moveVert s vv ((-0.015/2 + e[2]/2) * getVertNormal s vv)
				else polyop.moveVert s vv ((-0.015/2 + e[2]/2) * (normalize (polyop.getFaceNormal s e[1])))
			)
			
			polyOp.setFaceSelection s ((for e in err collect e[1]) as bitarray)
			

		)	
	)	
*/		

	on btn_UCX_Hide pressed do
	(
		for i in objects where findstring i.name "UCX_" != undefined do i.isHidden = true
	)
	
	on btn_UCX_Unhide pressed do
	(
		for i in objects where findstring i.name "UCX_" != undefined do i.isHidden = false
	)
	
	on btn_UCX_Clear_Mat pressed do
	(
		for i in selection do i.material = undefined
	)
	
	on btn_UCX_connect pressed do
	(
		sel = selection as array
		for i in sel where classof i == editable_poly do 
		(
			select i
			max modify mode
			subObjectLevel = 1
			i.unhideAll #Vertex
			i.unhideAll #Face
			max select all 
			i.ConnectVertices vertexFlag:1
			subObjectLevel = 0
		)
		select sel
	)

	on btn_UCX_rename pressed do
	(
		num = 0
		for i in selection do
		(
			i.name = trimright i.name "_0123456789"
			i.name = trimleft i.name "_0123456789"
			i.name = substitutestring i.name "UCX_" "" 
		)
		for i in selection do
		(
			i.name = uniqueName ("UCX_" + i.name + "_")
		)
	)
	
	/*
	on btn_UCX_pivot pressed do
	(
		for i in selection do i.pivot = [0,0,0]
	)
	*/
	
	on btn_UCX_makeground pressed do with undo "Make UCX" on -- with redraw off
	(
		if selection != undefined and selection.count == 1 and classof selection[1] == editable_poly then
		(
			max modify mode
			if subObjectLevel == 4 then
			(
				sel = selection[1]
				selFaces = polyop.getFaceSelection sel
				if selFaces.count > 0 then
				(
					selnew = copy sel
					selnew.name = "UCX_"+ sel.name
					select selnew
					subObjectLevel = 4
					max select invert
					max delete
					max select invert
					
					--polyop.splitEdges selnew (polyop.getEdgesUsingFace selnew (polyop.getFaceSelection selnew)) --selnew.SetSelection #Edge (polyop.getEdgesUsingFace selnew (polyop.getFaceSelection selnew))

					--subObjectLevel = 4
					--max select all 
					polyop.setFaceSelection selnew #all
					selectedFaces = polyop.getFaceSelection selnew
					
					--PolyToolsSelect.ConvexConcave 0.0 1
					--selectedFaces = polyop.getFaceSelection selnew	

					larges = #{}
					larges = convex_concave selnew selectedFaces --находим только те, которые надо дополнительно разбивать, concave, вогнутые

					--for ff in selectedFaces where (polyop.getFaceDeg selnew ff) > 4 do join larges #{ff} 
					--надо триангулировать фейсы с более 4 вершин
					--larges = for f in #{1..polyop.getnumfaces selnew} where (polyop.getFaceDeg selnew f) > 4 collect f
					--print #(larges)
					
					--selectedFaces -= larges
					--polyop.setFaceSelection selnew selectedFaces
/*
					while larges.count > 0 do
					(
						if keyboard.escPressed then exit
						for f in larges do
						(
													
							arr = #()
							--edges = #{1..polyop.getnumedges selnew}
							ee = polyop.getEdgesUsingFace selnew #{f}
							vv = polyop.getVertsUsingFace selnew #{f}
							--otheredges = edges - vv
							pp = for v in vv collect #(v, polyop.getVert selnew v)
							for p1 in pp do
								for p2 in pp where p1[1] != p2[1] and ((polyop.getEdgesUsingVert selnew #{p1[1],p2[1]})).numberset > 3 do append arr #(p1[1], p2[1], (distance p1[2] p2[2]))
							--лучше всего делить, где разность площадей минимальная у двух разделенных фейсов
						
							
							--на фейсах не работает
							--polyop.setFaceSelection #{f}
							--subObjectLevel = 4 --switch to Facelevel
							--PolyToolsSelect.ConvexConcave 0.001 1 --Select Concave Faces
							--PolyToolsSelect.ConvexConcave 0.001 2 --Select Convex Faces 
							
						
								select selnew
								polyop.setFaceSelection selnew #{f}
								polyop.detachFaces selnew #{f} asNode:true name:(uniqueName (selnew.name + "_" + f as string))
								sel_temp = maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))
								select sel_temp
								subObjectLevel = 3
								max select all 		
								sel_temp.extrusionType = 2			
								sel_temp.extrudeFaces -10.0 faceFlags:1
								sel_temp.MakePlanarIn #Z selLevel:#Face flag:1					
								subObjectLevel = 3
								max select all 
								sel_temp.capHoles #Edge flags:1
								subObjectLevel = 4	
								PolyToolsSelect.ConvexConcave 0.0 1
								sel_temp_true = #{}
								sel_temp_true = polyop.getFaceSelection sel_temp
								print #(sel_temp_true)
								subObjectLevel = 0
								--delete sel_temp
							if sel_temp_true != #{} then 
							(
							
								subObjectLevel == 1	
								polyop.setVertSelection selnew (polyop.getVertsUsingFace selnew #{f}) 
							
								selnew.ConnectVertices vertexFlag:1 --selnew.buttonOp #ConnectVertices 
								polyop.splitEdges selnew #{1..polyop.getnumedges selnew}
						
							)
							else
							(
								selectedFaces -= #{f}
							)
							
							larges = #{}
							--if selectedFaces.count > 0 then
								for ff in selectedFaces where (polyop.getFaceDeg selnew ff) > 4 do join larges #{ff}
							--larges = for f in #{1..polyop.getnumfaces selnew} where (polyop.getFaceDeg selnew f) > 4 collect f 
						)
					)						
*/

/*
					vv_sel = #{}
					if not larges.isempty then
					(
						for f in larges do
						(							
							vv_large = polyop.getVertsUsingFace selnew #{f}	
							pp_large = for v in vv_large collect #(v, polyop.getVert selnew v)
							
							--select selnew
							--polyop.setFaceSelection selnew #{f}
							polyop.detachFaces selnew #{f} asNode:true name:(uniqueName (selnew.name + "_" + f as string))
							sel_temp = maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))
							--select sel_temp				
							vv = polyop.getVertsUsingFace sel_temp #{1..polyop.getnumfaces sel_temp}
							
							vv_sel_copy = #{}	
							for v1 in vv do
								for v2 in vv where v1 < v2 do
								(
									sel_temp_copy = copy sel_temp				
									polyop.setVertSelection sel_temp_copy #{v1, v2}
									sel_temp_copy.ConnectVertices vertexFlag:1 
									polyop.setFaceSelection sel_temp_copy #all
									sel_copy = polyop.getFaceSelection sel_temp_copy
									larges_copy = convex_concave sel_temp_copy sel_copy
									if larges_copy.isempty then vv_sel_copy += #{v1, v2}
									--delete sel_temp_copy
								)
							pp = for v in vv_sel_copy collect #(v, polyop.getVert sel_temp v)
							for p_large in pp_large where (for p in pp where p_large[2] == p[2] collect p).count > 0 do vv_sel += #{p_large[1]}
							--delete sel_temp
						)
						print #(vv_sel)
						subObjectLevel == 1	
							--polyop.setVertSelection selnew (polyop.getVertsUsingFace selnew #{f}) 
						polyop.setVertSelection selnew vv_sel 
						selnew.ConnectVertices vertexFlag:1 --selnew.buttonOp #ConnectVertices 
					)
*/					
					
					if not larges.isempty then
					(
						subObjectLevel == 1
						for f in larges do
						(
							polyop.setVertSelection selnew (polyop.getVertsUsingFace selnew #{f}) 	
							selnew.ConnectVertices vertexFlag:1 --selnew.buttonOp #ConnectVertices
						)

					)	
					
					polyop.splitEdges selnew #{1..polyop.getnumedges selnew}	
					-- Inset
					select selnew
					subObjectLevel = 4
					max select all 
					selnew.EditablePoly.SetSelection #Face (polyop.getFaceSelection selnew) --$.Select #Face selectedFaces invert:false select:true --$.EditablePoly.SetSelection #Face selectedFaces
					selnew.extrusionType = 2 --by polygon
					selnew.extrudeFaces 0.0 faceFlags:1 --polyop.extrudeFaces $ selectedFaces 0.0
					selnew.outlineAmount = -0.01
					selnew.EditablePoly.Outline() --$.outline flag:1
					redrawViews()
					
					max select invert
					max delete
					max select all 
					subObjectLevel = 3
					max select all 			
					
					if keyboard.controlPressed then 
					(
						selnew.extrusionType = 2			
						selnew.extrudeFaces -10.0 faceFlags:1 --polyop.extrudeFaces $ selectedFaces -2.0
						selnew.MakePlanarIn #Z selLevel:#Face flag:1					
						subObjectLevel = 3
						max select all 
						selnew.capHoles #Edge flags:1
						subObjectLevel = 5
						max select all 
						selnew.flipNormals 1
						subObjectLevel = 0
						selnew.material = undefined
					)
					else
					(
						polyop.createShape selnew (polyop.getEdgeSelection selnew) smooth:false name:("!UCX_"+ sel.name) --node:&shp selnew.createShape "UCX_"+ sel.name false &shp edgeFlags:1
						shp = (maxOps.getNodeByHandle (amax (for o in shapes collect o.inode.handle))) --shp = getnodebyname ("!UCX_"+ sel.name)
						
						resetxform shp
						convertToSplineShape shp 
						addmodifier shp (extrude amount: -10.0 smooth:false capStart:false capEnd:true mapcoords:true useShapeIDs: false segs:1 matIDs:false)
						convertToPoly shp
						shp.material = undefined
						select shp
						subObjectLevel = 3
						max select all 	
						--subObjectLevel = 2	
						shp.MakePlanarIn #Z selLevel:#Edge flag:1					
						--subObjectLevel = 3
						max select all 
						shp.capHoles #Edge flags:1	
						shp.name = selnew.name
						delete selnew
						subObjectLevel = 0
					)
	--*/				
					redrawViews()	
				)
			)
			else messagebox "Select Horizontal faces from Ground object, do not change subobject level"
			/*
			max select invert
			max delete
			max select all 
			subObjectLevel = 3
			max select all 		
			selectedFaces = polyop.getFaceSelection $		
			$.extrusionType = 2			
			$.extrudeFaces -2.0 faceFlags:1 --polyop.extrudeFaces $ selectedFaces -2.0
			$.MakePlanarIn #Z selLevel:#Face flag:1	
			--$.SelectBorder()
			subObjectLevel = 3
			max select all 
			$.capHoles #Edge flags:1
			subObjectLevel = 5
			max select all 
			--$.flipNormals 1
			redrawViews()
			*/
			/*
			i.insetType = 1
			i.insetAmount = 0.01
			i.EditablePoly.buttonOp #Inset
 
			i.extrusionType = 2
			i.faceExtrudeHeight = -2.0
			i.EditablePoly.buttonOp #Extrude
			*/
		)
	)

	on btn_UCX_explode pressed do with undo "Explode UCX" on
	(
		if selection.count > 0 then
		(
			for i in selection where (superclassof i == GeometryClass) and (not isgrouphead i) do
			(
				converttopoly i
				while i.getNumFaces() != 0 do 
				(
					polyop.detachFaces i (polyOp.getElementsUsingFace $ #{1}) asNode:true name:(uniqueName ($.name + "_")) --(num as string)
				)
			)
			delete selection
		)
		else messagebox "Select few objects"
	)
	
	on btn_UCX_explode rightclick do with undo "Attach All in one UCX" on	
	(
		s = selection as array
		if selection.count > 0 then
		(
			if selection.count == 1 then 
			(
				converttopoly selection[1]
			)
			else
			(
				converttopoly selection[1]
				for w in #{2..s.count} where (superclassof s[w] == GeometryClass) and (not isgrouphead s[w]) do polyop.attach s[1] s[w] 
				s[1].name = trimright (s[1].name) "0123456789_"
			)
		)
		else messagebox "Select few objects"
	)

/*	
	on btn_UCX_explode rightclick do with redraw off
	(
		max create mode 
		obj0 = objects as array
		cur = $
		n = 0
		while (getFaceSelection $.mesh).numberset != 0 do 
		(
			El = polyOp.getElementsUsingFace $ #{1}
			polyOp.detachFaces $ El asNode:true name: (uniqueName ($.name + "_"))
			select cur
			n += 1
		)
		if n==1 then 
		(
			max undo 
			macros.run "Editable Polygon Object" "EPoly_Detach"
		)
		else 
		(
			delete $
			Exploded_objects = for i in objects where findItem obj0 i == 0 collect i
			for i in Exploded_objects do 
			(
				centerPivot i
				worldAlignPivot i 
				i.wirecolor = color 0 0 225 
			)
		)
	)
*/

	on btn_UCX_gaps pressed do with undo "Make UCX Gaps" on
	(
		local ctrl = keyboard.controlPressed
		local alt = keyboard.altPressed
		local shift = keyboard.shiftPressed		
		if selection.count > 1 then
		(
			/*
			local dir = GetDir #maxroot + "GeoScripts\\mesh\\"
			local filename = "1.obj"
			local filename_in = "2.obj" 
			local filename_out = "3.obj"
			--print filename	
			local start = GetDir #maxroot + "GeoScripts\\mesh\\"		
			
			--obj
			--theINI = objimp.getIniName()
			theINI = objexp.getIniName() --objExp.getPresetIniName()
			--getIniSetting theINI
			--getIniSetting theINI "General"
			setIniSetting theINI "General" "UseLogging" "0"
			setIniSetting theINI "General" "Preset" "<NONE>"
			setIniSetting theINI "General" "MapSearchPath" ""
			setIniSetting theINI "Geometry" "FlipZyAxis" "0"
			setIniSetting theINI "Geometry" "Shapes" "0"
			setIniSetting theINI "Geometry" "ExportHiddenObjects" "0"
			setIniSetting theINI "Geometry" "FaceType" "0"
			setIniSetting theINI "Geometry" "Normals" "1"
			setIniSetting theINI "Geometry" "SmoothingGroups" "1"
			setIniSetting theINI "Geometry" "TextureCoords" "0"
			setIniSetting theINI "Geometry" "ObjScale" "1.000000"
			setIniSetting theINI "Material" "UseMaterial" "0"
			setIniSetting theINI "Material" "CreateMatLibrary" "0"
			setIniSetting theINI "Material" "ForceBlackAmbient" "0"
			setIniSetting theINI "Material" "UseMapPath" "./"
			setIniSetting theINI "Material" "AutoMapChannel" "0"
			setIniSetting theINI "Material" "MapChannel" "1"
			setIniSetting theINI "Material" "ExtendedParams" "1"
			setIniSetting theINI "Material" "ConvertBitmaps" "0"
			setIniSetting theINI "Material" "RenderProcedural" "0"
			setIniSetting theINI "Material" "ResizeMaps" "0"
			setIniSetting theINI "Material" "ResizeMaps2n" "0"
			setIniSetting theINI "Material" "MapFormat" "3"
			setIniSetting theINI "Material" "MapSizeX" "512"
			setIniSetting theINI "Material" "MapSizeY" "512"
			setIniSetting theINI "Output" "RelativeIndex" "0"
			setIniSetting theINI "Output" "Target" "0"
			setIniSetting theINI "Output" "Precision" "6"
			setIniSetting theINI "Optimize" "optVertex" "1"
			setIniSetting theINI "Optimize" "optNormals" "1"
			setIniSetting theINI "Optimize" "optTextureCoords" "0"
			theClasses = exporterPlugin.classes
			*/
			
			local sel = selection as array
			for i in #{1..sel.count} where not keyboard.escPressed do
			(
				--select sel[i]
				--j = copy sel[i]
				--j.name = sel[i].name
				
				if classof sel[i] != Editable_Poly then converttopoly sel[i]
				--select j	
				
				--if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\1.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\1.obj")
				--if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\2.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\2.obj")
				--if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\3.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")				

				--exportFile (dir + filename) #noPrompt selectedOnly:true using:ObjExp -- using:theClasses[findItem theClasses ObjExp]
				--delete j
				
				for k in #{1..sel.count} where k > i do
				(
					l = copy sel[k]
					l.name = sel[k].name
				
					if classof l != Editable_Poly then converttopoly l
					addmodifier l (push Push_Value: 0.005)
					converttopoly l
					sel[i] = sel[i] - l
					delete l
					
				/*		
					select l
					exportFile (dir + filename_in) #noPrompt selectedOnly:true using:ObjExp -- using:theClasses[findItem theClasses ObjExp]
					delete l

					local cmd = "meshconv --input-file " + "\"" + filename + "\"" + " --intersect=" + "\"" + filename_in + "\"" + " --output-file " + "\"" + filename_out + "\""
					HiddenDOSCommand cmd startpath:start prompt:"Generating Gaps for UCX Forms..."
					importFile (dir + filename_out) #noPrompt
					local ucx_new = selection[1]
					ucx_new.name = "Int_UCX_" + sel[i].name
					centerpivot ucx_new	
					addmodifier ucx_new (push Push_Value: 0.005)
					converttopoly ucx_new
					if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\3.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")
					if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\2.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\2.obj")
					select ucx_new
					exportFile (dir + filename_in) #noPrompt selectedOnly:true using:ObjExp -- using:theClasses[findItem theClasses ObjExp]
					delete ucx_new
					local cmd = "meshconv --input-file " + "\"" + filename + "\"" + " --subtract=" + "\"" + filename_in + "\"" + " --output-file " + "\"" + filename_out + "\""
					HiddenDOSCommand cmd startpath:start prompt:"Generating Gaps for UCX Forms..."
					importFile (dir + filename_out) #noPrompt
					if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\3.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")
					local ucx_done = selection[1]
					ucx_done.name = sel[i].name
					centerpivot ucx_done	
					delete sel[i]
					sel[i] = ucx_done

					local cmd = "meshconv --input-file " + "\"" + filename + "\"" + " --subtract=" + "\"" + filename_in + "\"" + " --output-file " + "\"" + filename_out + "\""
					HiddenDOSCommand cmd startpath:start prompt:"Generating Gaps for UCX Forms..."
					importFile (dir + filename_out) #noPrompt
					local ucx_done = selection[1]
					ucx_done.name = sel[i].name
					centerpivot ucx_done	
					delete sel[i]
					sel[i] = ucx_done					
				*/	
				)
				
				--if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\1.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\1.obj")
				--if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\2.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\2.obj")
				--if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\3.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")				
			)	
			select sel	
		)
		else messagebox "Select more than one objects to generate Gaps between UCX forms"		
	)

	on btn_UCX_make pressed do with undo "Make UCX Forms" on
	(
		local ctrl = keyboard.controlPressed
		local alt = keyboard.altPressed
		local shift = keyboard.shiftPressed
		if selection.count > 0 then
		(
			local filename = GetDir #maxroot + "GeoScripts\\mesh\\1.obj" --pathConfig.GetDir #temp + "\\temp.obj" --GetDir #maxroot + "GeoScripts\\temp.obj"
			local filename_ = "1.obj"
			local filename_in = "2.obj" --pathConfig.GetDir #temp + "\\temp_in.obj" --"temp_in.obj"
			local filename_out = "3.obj" --pathConfig.GetDir #temp + "\\temp_out.obj" --"temp_out.obj"
			local filename_out_ = GetDir #maxroot + "GeoScripts\\mesh\\3.obj" --pathConfig.GetDir #temp + "\\temp_out.obj" --"temp_out.obj"
			--print filename	
			local start = GetDir #maxroot + "GeoScripts\\mesh\\"		
			
			--obj
			--theINI = objimp.getIniName()
			theINI = objexp.getIniName() --objExp.getPresetIniName()
			--getIniSetting theINI
			--getIniSetting theINI "General"
			setIniSetting theINI "General" "UseLogging" "0"
			setIniSetting theINI "General" "Preset" "<NONE>"
			setIniSetting theINI "General" "MapSearchPath" ""
			setIniSetting theINI "Geometry" "FlipZyAxis" "0"
			setIniSetting theINI "Geometry" "Shapes" "0"
			setIniSetting theINI "Geometry" "ExportHiddenObjects" "0"
			setIniSetting theINI "Geometry" "FaceType" "0"
			setIniSetting theINI "Geometry" "Normals" "1"
			setIniSetting theINI "Geometry" "SmoothingGroups" "1"
			setIniSetting theINI "Geometry" "TextureCoords" "1.000000"
			setIniSetting theINI "Geometry" "ObjScale" "1.000000"
			setIniSetting theINI "Material" "UseMaterial" "0"
			setIniSetting theINI "Material" "CreateMatLibrary" "0"
			setIniSetting theINI "Material" "ForceBlackAmbient" "0"
			setIniSetting theINI "Material" "UseMapPath" "./"
			setIniSetting theINI "Material" "AutoMapChannel" "0"
			setIniSetting theINI "Material" "MapChannel" "1"
			setIniSetting theINI "Material" "ExtendedParams" "1"
			setIniSetting theINI "Material" "ConvertBitmaps" "0"
			setIniSetting theINI "Material" "RenderProcedural" "0"
			setIniSetting theINI "Material" "ResizeMaps" "0"
			setIniSetting theINI "Material" "ResizeMaps2n" "0"
			setIniSetting theINI "Material" "MapFormat" "3"
			setIniSetting theINI "Material" "MapSizeX" "512"
			setIniSetting theINI "Material" "MapSizeY" "512"
			setIniSetting theINI "Output" "RelativeIndex" "0"
			setIniSetting theINI "Output" "Target" "0"
			setIniSetting theINI "Output" "Precision" "6"
			setIniSetting theINI "Optimize" "optVertex" "1"
			setIniSetting theINI "Optimize" "optNormals" "1"
			setIniSetting theINI "Optimize" "optTextureCoords" "1"
			theClasses = exporterPlugin.classes
			
			local sel = selection as array
			local ucxs = #()
			for i in sel where not keyboard.escPressed do
			(
				--select i
				j = copy i
				j.name = i.name
				
				if classof j != Editable_Poly then converttopoly j
				select j
				
				local sel_faces = #{}
				local sel_faces = polyop.getFaceSelection j
				
				if not sel_faces.isempty then polyop.deleteFaces j (#{1..(polyop.getNumFaces j)} - sel_faces) delIsoVerts:true
				
				if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\1.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\1.obj")
				if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\2.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\2.obj")
				if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\3.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")				

				exportFile filename #noPrompt selectedOnly:true using:ObjExp -- using:theClasses[findItem theClasses ObjExp]
					
				delete j
				--print ("meshconv.exe --input-file " + "\"" + filename + "\"" + " --remesh=" + (substitutestring (spn_UCX_make.value as string) "," ".") + " --output-file " + "\"" + filename_in + "\"")
				--print ("meshconv.exe --input-file " + "\"" + filename_in + "\"" + "--convex-hull --output-file " + "\"" + filename_out + "\"")
				--print start
				
				--cmd1 = "meshconv --input-file " + "\"" + filename_ + "\"" + " --remesh --output-file " + "\"" + filename_in + "\""
				local cmd1 = if spn_UCX_make.value == 0.0 then "meshconv --input-file " + "\"" + filename_ + "\"" + " --remesh --output-file " + "\"" + filename_in + "\""
					else "meshconv --input-file " + "\"" + filename_ + "\"" + " --remesh=" + (substitutestring (spn_UCX_make.value as string) "," ".") + " --output-file " + "\"" + filename_in + "\""
				local cmd2 = "meshconv --input-file " + "\"" + filename_in + "\"" + " --convex-hull --output-file " + "\"" + filename_out + "\""
				--print cmd1
				--print cmd2
				
				if ctrl then 
					HiddenDOSCommand cmd1 startpath:start prompt:"Processing Remeshing..."
				else 
					copyfile (GetDir #maxroot + "GeoScripts\\mesh\\1.obj") (GetDir #maxroot + "GeoScripts\\mesh\\2.obj")
				
				if not alt then 
					HiddenDOSCommand cmd2 startpath:start prompt:"Generating UCX Form..."
				else 
					copyfile (GetDir #maxroot + "GeoScripts\\mesh\\2.obj") (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")
				
				importFile filename_out_ #noPrompt
				
				--if doesFileExist filename_in then deletefile filename_in
				--if doesFileExist filename_out then deletefile filename_out	

				if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\1.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\1.obj")
				if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\2.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\2.obj")
				if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\3.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")				
					
				if selection.count ==1 then
				(
					local ucx_new = selection[1]
					ucx_new.name = "UCX_" + i.name
					centerpivot ucx_new
					if shift then addmodifier ucx_new (push Push_Value: 0.0)
					append ucxs ucx_new
				)					
			)
			select ucxs
		)
		else messagebox "Select one or few objects to generate UCX forms"
	)		
	
	on btn_UCX_make rightclick do with undo "Make UCX Box" on
	(
		sel = selection[1]
		ctrl = keyboard.controlPressed
		t = 0.005
		if sel != undefined and classof sel == editable_poly then
		(
			max modify mode
			faces = polyop.getFaceSelection sel 
			polyop.detachFaces sel faces asNode:true delete:false name:"Test" node:j --editable_poly 
			j = maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))
				
			ang = rotate_to_min_Y_gab j 2.0 -360 360
			ang = rotate_to_min_Y_gab j 0.1 (ang - 1.0) (ang + 1.0)

			j.pivot = [j.center.x, j.center.y, j.min.z]
			in coordsys world rotate j (eulerangles 0 0 ang) 
			resetxform j
			converttopoly j	
			j.pivot = [j.center.x, j.center.y, j.min.z]
			if ctrl then b = box width:(abs(j.max.x - j.min.x) + t) length:(abs(j.max.y - j.min.y) + t) height:(abs(j.max.z - j.min.z) + t) pos:[j.center.x, j.center.y, j.min.z] name:(uniquename ("UCX_" + sel.name + "_")) 
			else b = box width:(abs(j.max.x - j.min.x)) length:(abs(j.max.y - j.min.y)) height:(abs(j.max.z - j.min.z)) pos:[j.center.x, j.center.y, j.min.z] name:(uniquename ("UCX_" + sel.name + "_")) 
			in coordsys world rotate b (eulerangles 0 0 -ang)
			b.pos = [j.center.x, j.center.y, j.min.z]
			delete j
			select b
			converttopoly b
			Obj_Spln.btn_ConnectVerts.pressed()	
			select sel
			max modify mode
		)
	)
)

rollout Geojson "Geojson operations" autoLayoutOnResize:true
(
	group "Pivot operations"
	(
		button btn_combine_two_models "Combine two models near zero" width:260 tooltip:"Сопоставить две модели около нуля координат, чтобы совместить их точки отсчета Pivot | Combine two models near zero to combine their Pivots "		
		editText edt_pivot_pos_x "X position" text:"" fieldwidth:80 width:85 labelOnTop:true align:#left offset:[0,0] across:3 tooltip:""
		editText edt_pivot_pos_y "Y position" text:"" fieldwidth:80 width:85 labelOnTop:true offset:[0,0] tooltip:""
		editText edt_pivot_pos_z "Z Height position" text:"" fieldwidth:80 width:85 labelOnTop:true offset:[0,0] tooltip:""

		editText edt_pivot_rot_x "X rotation" text:"" fieldwidth:80 width:85 labelOnTop:true align:#left offset:[0,0] across:3 tooltip:""
		editText edt_pivot_rot_y "Y rotation" text:"" fieldwidth:80 width:85 labelOnTop:true offset:[0,0] tooltip:""
		editText edt_pivot_rot_z "Z rotation" text:"" fieldwidth:80 width:85 labelOnTop:true offset:[0,0] tooltip:""

		button btn_pivot_get "Get Pivot Pos & Rot" width:130 align:#left across:2 tooltip:"Получить координаты положения и поворота и записать их в поля | Get Pivot Position and Rotation and write to fields"
		button btn_pivot_set "Set Pivot to Down Center" width:130 align:#right tooltip:"Установить Pivot в положение снизу и по центру объекта, если были выбраны грани или вершины, использовать их для определения нулевой отметки высоты проекта | Set Pivot to Down and Center of object\nIf faces or verts have been selected then use them as height of project Zero"
		button btn_pivot_pos "Set Position To" width:85 align:#left across:3 tooltip:"Поместить объект в соответствии с координатами, указанными в полях | Place object to coordinates shown in fields"
		button btn_find_rot "Find Rotation" width:85 tooltip:"Повернуть объект параллельно оси координат, полезно после сброса трансформаций, записать угол в поле поворота | Try to Rotate object to parallel of axis, useful after transformations have been reseted, write angle to field"
		button btn_resetXForm "Reset Transforms" width:85 align:#right tooltip:"Сброс преобразований объектов и обновление полей | Reset Transformations of objects and update fields"
		button btn_load_moscow "Check with Moscow borders" width:260 tooltip:"LMB: Загрузить карту границ Москвы для сверки координат с пападанием в район\nRMB: Удалить карту границ Москвы | LMB: Load the Moscow boundary map to verify coordinates with the district\nRMB: Delete the Moscow boundary map"		

	)
	group "Geojson operations"
	(		
		editText edt_pic_dims "Dims" text:"" fieldwidth:40 width:100 align:#right offset:[0,0] tooltip:"Габариты загруженной картинки | Dimensions of loaded picture"
		button btn_pic_open "Load Picture" across:2 align:#right tooltip:"Загрузить изображение, чтобы изменить размер на 256x256 и закодировать в Base64, необходимо для вставки в Geojson | Load picture to resize to 256x256 and encode to Base64, neccessary to paste to Geojson"
		button btn_convert_to_base "Base64 to Clipboard" align:#right tooltip:"Поместить код Base64 в буфер обмена | Put Base64 code to Clipboard"
		imgtag img_tag_pic "Picture" bitmap:(bitmap 50 50 color:(color 50 50 50)) align:#left width:50 height:50 style:#bmp_stretch offset:[0,-50] tooltip:""
		button btn_create_geojson "Create file"	across:3 align:#left offset:[0,0] enabled:false
		button btn_save_geojson "Save file" align:#center offset:[0,0] enabled:false
		button btn_load_geojson "Load file"	align:#right offset:[0,0] enabled:false 
	)	

	on Geojson open do
	(
		for i in Geojson.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_Geojson.ini") i.name "Geojson" (syssetup.rdo_lang.state))
	)
	
	on btn_load_moscow pressed do
	(
		local sel = #()
		sel = selection as array
		if (mergeMAXFile (GetDir #maxroot + "GeoScripts\\Moscow_boundaries_MSK.max") #noRedraw #deleteOldDups #useMergedMtlDups quiet:true) then 
		(
			print "Moscow_boundaries_MSK.max"	
			converttomesh $bounds_MSK
			if sel.count > 0 then
			(
				local err = ""
				for s in selection do
				(
					local hits_ex = #()
					hits_ex = intersectRayScene (ray [s.center.x, s.center.y, 1] [0,0,-1])
					print #(hits_ex)
					if hits_ex != undefined then
					(
						local good = false
						for hit in hits_ex where hit[1].name == "bounds_MSK" do
						(
							--poi = point pos:hit[2].pos
							err += s.name + ": is in boundaries of Moscow\n"
							good = true
						)
						if not good then err += s.name + ": is not in boundaries of Moscow\n"
					)	
					else
					(
						err += s.name + ": is not in boundaries of Moscow\n"
					)
						
				)
				messagebox err
			)
		)	
		else messageBox "Scene Moscow_boundaries_MSK.max do not loaded"
	)
	
	on btn_load_moscow rightclick do
	(
		delete ($bounds_MSK*)
	)
	
	on btn_find_rot pressed do
	(
		if selection.count == 1 then
		(
			j = selection[1]
			local ang = rotate_to_min_Y_gab j 2.0 -360 360
			ang = rotate_to_min_Y_gab j 0.1 (ang - 1.0) (ang + 1.0)
			in coordsys world rotate j (eulerangles 0 0 ang)
			edt_pivot_rot_z.text = (selection[1].rotation as eulerAngles).z as string
		)
	)
	
	on btn_resetXForm pressed do
	(
		for i in selection do
		(
			ResetXForm i
			ConverttoPoly i
			edt_pivot_pos_x.text = i.pos.x as string
			edt_pivot_pos_y.text = i.pos.y as string
			edt_pivot_pos_z.text = i.pos.z as string	

			edt_pivot_rot_x.text = (i.rotation as eulerAngles).x as string
			edt_pivot_rot_y.text = (i.rotation as eulerAngles).y as string
			edt_pivot_rot_z.text = (i.rotation as eulerAngles).z as string	
		)
	)
	
	on btn_combine_two_models pressed do 
	(
		if selection.count == 2 then
		(
			local a = selection[1]
			local b = selection[2]
			
			local a1 = copy a
			local b1 = copy b
			converttopoly a1 
			converttopoly b1 
			
			if polyop.getnumfaces a1 > polyop.getnumfaces b1 then
			(
				a = selection[1]
				b = selection[2]
			)
			else
			(
				a = selection[2]
				b = selection[1]				
			)
			
			delete a1
			delete b1
			
			a.pos = [0,0,0]
			move b (a.center-b.center)
			
		)
		else messageBox "Select only two objects"
	)
	
	on btn_pivot_get pressed do
	(
		if selection.count == 1 then
		(
			edt_pivot_pos_x.text = selection[1].pos.x as string
			edt_pivot_pos_y.text = selection[1].pos.y as string
			edt_pivot_pos_z.text = selection[1].pos.z as string
			
			edt_pivot_rot_x.text = (selection[1].rotation as eulerAngles).x as string
			edt_pivot_rot_y.text = (selection[1].rotation as eulerAngles).y as string
			edt_pivot_rot_z.text = (selection[1].rotation as eulerAngles).z as string	
		)
		else messageBox "Select one single object"
	)
	
	on btn_pivot_set pressed do
	(
		if selection.count == 1 then
		(
			local a = selection[1]
			if classof a == Editable_Poly then 
			(
				case of 
				(
					((polyop.getFaceSelection a).isempty and (polyop.getVertSelection a).isempty):
					(
						a.pivot = [a.center.x, a.center.y, a.min.z]
					)
					
					((polyop.getFaceSelection a).numberset > 0): 
					(
						local sel = polyop.getFaceSelection a
						polyop.detachFaces a sel delete:false asNode:true name:a.name node:&b
						b = maxOps.getNodeByHandle (amax (for o in objects collect o.inode.handle))
						a.pivot = [a.center.x, a.center.y, b.center.z]
						delete b
					)
					
					((polyop.getVertSelection a).numberset > 0): 
					(
						local sel = polyop.getVertSelection a
						polyop.detachVerts a sel delete:false asNode:true name:a.name node:&b
						b = maxOps.getNodeByHandle (amax (for o in objects collect o.inode.handle))
						a.pivot = [a.center.x, a.center.y, b.center.z]
						delete b
					)
					
					((polyop.getFaceSelection a).numberset == polyop.getnumfaces a): 
					(
						a.pivot = [a.center.x, a.center.y, a.min.z]
					)
					
					((polyop.getVertSelection a).numberset == polyop.getnumVerts a): 
					(
						a.pivot = [a.center.x, a.center.y, a.min.z]
					)
					
					default: 
					(
						a.pivot = [a.center.x, a.center.y, a.min.z]
					)
					
				)
			)
			else a.pivot = [a.center.x, a.center.y, a.min.z]
		)
		else messageBox "Select one single object"
	)
	
	on btn_pivot_pos pressed do
	(
		if selection.count == 1 then
		(
			selection[1].pos.x = edt_pivot_pos_x.text as float
			selection[1].pos.y = edt_pivot_pos_y.text as float
			selection[1].pos.z = edt_pivot_pos_z.text as float
		)
		else messageBox "Select one single object"		
	)
	
	on btn_pic_open pressed do 
	(
		pic = selectBitMap()
		if pic != undefined then
		(			
			img_tag_pic.bitmap = pic
			edt_pic_dims.text = pic.width as string + "x" + pic.height as string
		)
	)
	
	on btn_convert_to_base pressed do 
	(	
		if img_tag_pic.bitmap != undefined or img_tag_pic.bitmap != (bitmap 50 50 color:(color 50 50 50)) then
		(
			if img_tag_pic.bitmap.width != 256 or img_tag_pic.bitmap.height != 256 then 
			(
				HiddenDOSCommand ("magick " + "\"" + img_tag_pic.bitmap.filename + "\""+ " -trim -resize 256x256^! " + "\""+ (getfilenamepath img_tag_pic.bitmap.filename + getFilenameFile img_tag_pic.bitmap.filename + "+" + getFilenameType img_tag_pic.bitmap.filename) + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
				img_tag_pic.bitmap = openbitmap (getfilenamepath img_tag_pic.bitmap.filename + getFilenameFile img_tag_pic.bitmap.filename + "+" + getFilenameType img_tag_pic.bitmap.filename)
				img_tag_pic.bitmap.filename = (getfilenamepath img_tag_pic.bitmap.filename + getFilenameFile img_tag_pic.bitmap.filename + "+" + getFilenameType img_tag_pic.bitmap.filename)
				edt_pic_dims.text = img_tag_pic.bitmap.width as string + "x" + img_tag_pic.bitmap.height as string
				--setclipboardText (ConvertImageToBase64String (img_tag_pic.bitmap.filename))
				close img_tag_pic.bitmap
			)
			if doesfileexist img_tag_pic.bitmap.filename then 
			(
				setclipboardText (ConvertImageToBase64String (img_tag_pic.bitmap.filename))
				messagebox "Image in Clipboard"
			)
			--close img_tag_pic.bitmap
		)
		else messageBox ("No image selected")
	)
)

rollout File "File operations" autoLayoutOnResize:true
(
	button btn_export_preview "Export Preview" width:80 across:3 align:#left tooltip:"Экспортировать модель для предварительного просмотра в формат FBX для 3D-просмотрщика Autodesk или Unreal Engine | Export preview model to FBX for 3D Viewers or Unreal Engine"
	button btn_omkte "Get OMK TE Code" width:90 offset:[0,0] tooltip:"LMB: Запустить диалоговое окно выбора кода OMK TE из списка улиц\nLMB+CTRL: Из списка населенных пунктов | LMB: Start the OMK TE code selection dialog from the list of streets\nLMB+CTRL: From the list of settlements" 
	edittext edt_omkte "" fieldWidth:90 width:90 text:"" offset:[0,0] align:#right tooltip:"Если кодов несколько надо выбрать один, остальные стереть | If there are several codes, select one and erase the others"

	button btn_export_lowpoly "Export LowPoly" across:3 align:#left tooltip:"На основе анализа выбранных объектов, экспортировать НПМ модель (Lowpoly) в формат FBX со встроенными текстурами | Export Lowpoly model to FBX with embedded textures"	
	button btn_export_highpoly "Export HighPoly" offset:[8,0] tooltip:"На основе анализа выбранных объектов, экспортировать ВПМ модель (Highpoly) в формат FBX | Export Highpoly model to FBX with checking of selected objects"
	button btn_archivate "Archivate All" align:#right tooltip:"Заархивировать модели в целевой папке согласно именам файлов, с проверкой  | Archivate Models in Target Folder with checking"

	edittext edt_project_current_name "Current Project" align:#right Width:260 text:(GetINI_Current_Project_Name maxFilePath)
	dropdownlist dpl_ini_names "" items:(GetINI_Projects_Names()) selection:(GetINI_Current_Project_Index maxFilePath) width:260 fieldWidth:260 align:#right
	edittext edt_project_path "Current File Path" align:#left width:260 text:maxFilePath
	edittext edt_project_lowpoly_name "Lowpoly Name" align:#left width:260 text:(GetINI_Current_Project_Lowpoly maxFilePath) 
	edittext edt_project_highpoly_name "Highpoly Name" align:#left width:260 text:(GetINI_Current_Project_Highpoly maxFilePath)	

	button btn_load_Names "Load Names" across:3 align:#left tooltip:"Do not work yet. Load previous saved names of paths and objects names"	
	button btn_save_Names "Save Names" offset:[-10,0] tooltip:"Do not work yet. Save names of paths and objects names"
	button btn_delete_Names "Delete Names" offset:[0,0] align:#right tooltip:"Do not work yet. Delete selected names from INI file" 

	on File open do
	(
		for i in File.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_files.ini") i.name "File" (syssetup.rdo_lang.state))
	)
		
	on btn_omkte pressed do
	(
		global dirs_select = #()
		local ctrl = keyboard.controlPressed
		excel_file = if ctrl then GetDir #maxroot +"\\GeoScripts\\OMK_TE2.csv" else GetDir #maxroot +"\\GeoScripts\\OMK_TE3.csv"
		global arr_excel = #()
		stri_pr = #()
		stri_pr = ReadAllLines excel_file	
		if stri_pr != "" then
			if stri_pr.count > 0 then
			(
				arr_excel = for i = 1 to stri_pr.count collect (filterstring stri_pr[i] "\t\n" splitEmptyTokens:true)
				if arr_excel.count > 0 then for i=1 to arr_excel.count do for j=1 to arr_excel[i].count do arr_excel[i][j] = substitutestring arr_excel[i][j] "\"" ""
			)	
			
			try(destroyDialog ::TableOMKTE)catch()
			rollout TableOMKTE "Table OMK TE Codes" 
			(
				fn qsort_csv arr1 arr2 = 
				(
					case of 
					(
						(arr1[2] < arr2[2]): -1
						(arr1[2] > arr2[2]): 1
						default:0
					)
				)

				fn autoResizeColumn lv columns: = 
				(
					vScrollWidth = 21 -- vertical scrollbar width
					for c = 0 to columns-1 do
					(
						lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
						vScrollWidth += lv.Columns.Item[c].Width
					) 
					vScrollWidth
				)
						
				fn PopulateList lv dirs_select =
				(
					try (qsort dirs_select qsort_csv)catch()
					
					lv.Items.Clear()
					lv.view = (dotNetClass "system.windows.forms.view").details --lv.view = (dotNetClass "View").details
					lv.HideSelection = true 
					lv.HeaderStyle = (dotNetClass "System.Windows.Forms.ColumnHeaderStyle").clickable
					--lv.Font = dotNetObject "System.Drawing.Font" "Tahoma" 18 (dotNetClass "System.Drawing.FontStyle").Regular (dotNetClass "System.Drawing.GraphicsUnit").Pixel
					--lv.backcolor = maxBC 
					--lv.forecolor = maxFC
					--lv.height = 390
					lv.FullRowSelect = true    
					lv.MultiSelect = false --true    
					lv.AllowColumnReorder = true
					lv.GridLines = true
					lv.checkBoxes = false 
					lv.Scrollable = true
					lv.ShowItemToolTips = true
					--for i = 0 to lv.Items.count-1 do lv.Items.Item[i].checked = true
					columnsAr = #(" ", "Place", "Code")
					lv.columns.Clear()
					for i = 1 to 3 do lv.columns.add columnsAr[i] 0	
					lv.width = autoResizeColumn lv columns:3
					lv.width = 440
					--lv.Update()
					rows = #()
					for t = 1 to dirs_select.count do --where dirs_select[t][2] != undefined and dirs_select[t][3] != undefined do
					(
						li = dotNetObject "System.Windows.Forms.ListViewItem" (if dirs_select[t][1] != undefined then dirs_select[t][1] else " ")
						li.UseItemStyleForSubItems = true
						--полосатость списка
						--colAdd = 240 + (if (mod t 2) == 0 then 10 else -10)
						--li.BackColor = li.backcolor.fromARGB colAdd colAdd colAdd
						li.subitems.add (if dirs_select[t][2] != undefined then dirs_select[t][2] else " ")
						li.subitems.add (if dirs_select[t][3] != undefined then dirs_select[t][3] else " ")
						append rows li
					)
					lv.items.addRange rows
					--lv.Update()
					lv.width = autoResizeColumn lv columns:3
					lv.width = 440
					lv.Update()
				)
				
				dotNetControl lv "ListView" pos:[5,5] width:400 height:700

				button btnClipboard "Copy to Clipboard" across:3 offset:[0,0] tooltip:""
				button btnPaste "Click to Paste and Close" offset:[0,0] tooltip:""
				button btnClose "Close" align: #right tooltip:"Закрыть это диалоговое окно | Close this dialog"

				on TableOMKTE open do
				(  
					PopulateList lv arr_excel 
					for i in TableOMKTE.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_TableOMKTE.ini") i.name "TableOMKTE" (syssetup.rdo_lang.state))
				)

				on btnClipboard pressed do
				(
					for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected do
					(
						if (arr_excel[val+1][3]).count < 4 then setclipboardText ("0" + arr_excel[val+1][3]) else setclipboardText (arr_excel[val+1][3])
					)
				)
				
				on btnPaste pressed do
				(
					for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected do
					(
						print #(arr_excel[val+1])
						if (arr_excel[val+1][3]).count < 4 then setclipboardText ("0" + arr_excel[val+1][3]) else setclipboardText (arr_excel[val+1][3]) --setclipboardText (arr_excel[val+1][3])
						if (arr_excel[val+1][3]).count < 4 then File.edt_omkte.text = ("0" + arr_excel[val+1][3]) else File.edt_omkte.text = (arr_excel[val+1][3])
						try(destroyDialog ::TableOMKTE)catch()
					)
					
				)
				
				on btnClose pressed do
				(
					try(destroyDialog ::TableOMKTE)catch()
				)	
			
			)
			createDialog TableOMKTE width:440 height:800 style:#(#style_titlebar, #style_border, #style_sysmenu, #style_resizing)	
	)	
	
/*	
	on btn_omkte rightclick do
	(
		fn cl = (setclipboardText (File.edt_omkte.text); try(closeRolloutFloater TableOMKTE_FL)catch())
		local ctrl = keyboard.controlPressed
		excel_file = if ctrl then GetDir #maxroot +"\\GeoScripts\\OMK_TE2.csv" else GetDir #maxroot +"\\GeoScripts\\OMK_TE3.csv"
		global arr_excel = #()
		stri_pr = #()
		stri_pr = ReadAllLines excel_file	
		if stri_pr != "" then
			if stri_pr.count > 0 then
			(
				arr_excel = for i = 1 to stri_pr.count collect (filterstring stri_pr[i] ";\t\n" splitEmptyTokens:true)
				if arr_excel.count > 0 then for i=1 to arr_excel.count do for j=1 to arr_excel[i].count do arr_excel[i][j] = substitutestring arr_excel[i][j] "\"" ""
			)	
			--print #(arr_excel)
			global sel = #()
			str = ""
			append str ("rollout TableOMKTE " + "\"" + "Table OMK TE Codes" + "\"" + " autoLayoutOnResize:true width:300 height:800\n" + "(\n")
						
			for i = 1 to arr_excel.count do
			(
				append str ("label lbla_" + i as string + " " + "\"" + arr_excel[i][1] + "\"" + " align:#left across:3 width:20 height:15 \n")
				append str ("label lblb_" + i as string + " " + "\"" + arr_excel[i][2] + "\"" + " align:#left style_sunkenedge:true width:200 height:15 offset:[-90,0] \n")
				append str ("button btn_" + i as string + " " + "\"" + arr_excel[i][3] + "\"" + " width:100 height:15 align:#right \n") 
			)
			for i = 1 to arr_excel.count do
			(
				append str ("on btn_" + i as string + " pressed do ( File.edt_omkte.text = btn_" + i as string + ".text; cl() )\n") --setclipboardText ("+ i as string + "); try(closeRolloutFloater TableOMKTE_FL)catch()
			)
			append str (")\n")
			append str ("addRollout TableOMKTE TableOMKTE_FL\n")
			
			try(destroyDialog ::TableOMKTE_FL)catch()
			try(closeRolloutFloater TableOMKTE_FL)catch()
			TableOMKTE_FL = newRolloutFloater "OMK TE Codes" 400 800
			execute (str)
	)
*/

	on btn_archivate pressed do
	(
		files = getFiles (UDIMs.edt_multimat_path.text + "*.*")
		print #(files)
		fbxs_hi = for f in files where (tolower (getFilenameType f) == ".fbx") and (findstring (getFilenameFile f) "SM_" != undefined) and ((findstring (getFilenameFile f) "_00" == undefined) or (findstring (getFilenameFile f) "_00" != undefined) or (findstring (getFilenameFile f) "_Ground" != undefined)) and (findstring (getFilenameFile f) "_Light" == undefined) collect f
		print #(fbxs_hi)
		fbxs_low = for f in files where (tolower (getFilenameType f) == ".fbx") and (findstring (getFilenameFile f) "SM_" == undefined) and (trimright ((filterstring (getFilenameFile f) "_")[1]) "0123456789" == "") collect f
		print #(fbxs_low)

		--archivate lowpoly *fbx
		stri = ""
		arch = ""
		for f in fbxs_low do stri += f + "\n"
		for f in fbxs_low where (findstring (getFilenameFile f) "_Ground" != undefined) do arch = (substitutestring (getFilenameFile f) "_Ground" "") + ".zip"
		if arch == "" then 
			for f in fbxs_low where (findstring (getFilenameFile f) "_Ground" == undefined) do arch = (substitutestring (getFilenameFile f + getFilenameType f) "_01.fbx" "") + ".zip"
		try 
		(
			dnSW = dotNetClass "System.IO.StreamWriter"
			dnFile = dotnetClass "System.IO.File"
			myTxt = dotNetObject dnSW (dnFile.create (UDIMs.edt_multimat_path.text + "zip.txt")) 
			myTxt.WriteLine stri 
			myTxt.Close() 
			myTxt.Dispose()
		)catch()				
		--ZIP = "\"C:\Program Files\7-Zip\7z.exe\"" + " a -tzip -y " + "\"" + arch + "\"" + " @zip.txt"
		ZIP = "\"" + GetDir #maxroot + "GeoScripts\\7z.exe" + "\"" + " a -tzip -y " + "\"" + arch + "\"" + " @zip.txt"
		print ZIP
		HiddenDOSCommand (ZIP) startpath:(UDIMs.edt_multimat_path.text)
		
		texes = #()
		geojson = #()
		dops = #()
		for f in fbxs_hi do
		(
			f_ = substitutestring (getFilenameFile f) "SM_" "T_"
			if findstring (getFilenameFile f) "_00" != undefined or findstring (getFilenameFile f) "_Ground" != undefined then
				texes = for t in files where findstring t f_ != undefined and findstring t "_d_" == undefined and findstring t "_o_" == undefined and findstring t "_m_" == undefined and findstring t "_n_" == undefined and findstring t "_r_" == undefined and tolower (getFilenameType t) == ".png" collect t 
			else
				texes = for t in files where findstring t f_ != undefined and findstring (getFilenameFile t) "_00" == undefined and findstring (getFilenameFile t) "_Ground" == undefined and findstring t "_d_" == undefined and findstring t "_o_" == undefined and findstring t "_m_" == undefined and findstring t "_n_" == undefined and findstring t "_r_" == undefined and tolower (getFilenameType t) == ".png" collect t 
			print #(texes)
			
			if findstring (getFilenameFile f) "_00" != undefined or findstring (getFilenameFile f) "_Ground" != undefined then
				geojson = for t in files where findstring t ((getFilenameFile f) + ".geojson") != undefined collect t
			else
				geojson = for t in files where findstring t ((getFilenameFile f) + ".geojson") != undefined and findstring (getFilenameFile t) "_00" == undefined and findstring (getFilenameFile t) "_Ground" == undefined collect t
			print #(geojson)
			
			if findstring (getFilenameFile f) "_00" != undefined or findstring (getFilenameFile f) "_Ground" != undefined then
				dops = for t in files where findstring t ".fbx" != undefined and findstring t (getFilenameFile f) != undefined and (getFilenameFile t) != (getFilenameFile f) collect t
			else
				dops = for t in files where findstring (getFilenameFile t) "_00" == undefined and findstring (getFilenameFile t) "_Ground" == undefined and findstring (getFilenameFile t) ".fbx" != undefined and findstring t (getFilenameFile f) != undefined /* and (getFilenameFile t) != (getFilenameFile f)*/ collect t
				
			print #(dops)
			
			arch = (getFilenameFile f) + ".zip"
			stri = f + "\n"
			for t in texes do stri += t + "\n"
			for t in geojson do stri += t + "\n"	
			for t in dops do stri += t + "\n"		
			
			try 
			(
				dnSW = dotNetClass "System.IO.StreamWriter"
				dnFile = dotnetClass "System.IO.File"
				myTxt = dotNetObject dnSW (dnFile.create (UDIMs.edt_multimat_path.text + "zip.txt")) 
				myTxt.WriteLine stri 
				myTxt.Close() 
				myTxt.Dispose()
			)catch()				
			--ZIP = "\"C:\Program Files\7-Zip\7z.exe\"" + " a -tzip -y " + "\"" + arch + "\"" + " @zip.txt"
			ZIP = "\"" + GetDir #maxroot + "GeoScripts\\7z.exe" + "\"" + " a -tzip -y " + "\"" + arch + "\"" + " @zip.txt"
			
			print ZIP
			HiddenDOSCommand (ZIP) startpath:(UDIMs.edt_multimat_path.text)
		)
		if doesFileExist (UDIMs.edt_multimat_path.text + "zip.txt") do deletefile (UDIMs.edt_multimat_path.text + "zip.txt")
	)
	
	on dpl_ini_names selected txt do edt_project_current_name.text = dpl_ini_names.items[txt] as string

	on btn_export_preview pressed do
	(
		--print UDIMs.edt_multimat_path.text
		allright = true
		/*
		ucx_obj = false
		for i in selection do
		(
			if findstring i.name "UCX" != undefined then ucx_obj = true
			if i.ishidden then i.ishidden = false
			j = copy i 
			converttopoly j
			ids = #()
			for p in #{1..polyop.getNumFaces j} do appendifunique ids (polyop.getFaceMatID j p)
			if classof j.material == multiSubMaterial then 
			(
				if j.material.materialList.count != ids.count then allright = false
			)
			else 
			(
				if findstring j.name "Glass" == undefined and findstring j.name "UCX" == undefined then allright = false
			)
			delete j
		)
		if ucx_obj then messagebox "Found UCX objects in export for preview"
		*/
		if allright then
		(
			pluginManager.loadClass FbxExporter
			FBXExporterSetParam "Cameras" false 
			FBXExporterSetParam "FileVersion" "FBX201400" 
			FBXExporterSetParam "SmoothingGroups" true
			FBXExporterSetParam "Triangulate" false
			FBXExporterSetParam "Animation" false
			FBXExporterSetParam "Lights" false
			FBXExporterSetParam "ASCII" false
			FBXExporterSetParam "EmbedTextures" true 
			FBXExporterSetParam "GeomAsBone" false
			FBXExporterSetParam "GenerateLog" false
			FBXExporterSetParam "UpAxis" "Y"
			FBXExporterSetParam "ScaleFactor" 1.0
			FBXExporterSetParam "AxisConversionMethod" "None"
			FBXExporterSetParam "Preserveinstances" false
			FBXExporterSetParam "Convert2Tiff" false
			FBXExporterSetParam "ConvertUnit" "m" 
			FBXExporterSetParam "FilterKeyReducer" false
			FBXExporterSetParam "NormalsPerPoly" false
			FBXExporterSetParam "PointCache"  false 
			FBXExporterSetParam "Shape"  false
			FBXExporterSetParam "Skin"  false 
			FBXExporterSetParam "SmoothMeshExport" true
			exportFile (UDIMs.edt_multimat_path.text + "preview.fbx") #noPrompt selectedOnly:true using:FBXEXP --theClasses[8] using:theClasses[(findItem theClasses FBXEXP)] 
		)
		--else messagebox "Wrong materials on models"
	)
	
	on btn_export_lowpoly pressed do
	(
		allright = true
		ucx_obj = false
		mats = false
		sel = false
		omkte = false
		dist = false
		objs = false
		if edt_omkte.text == "" then 
		(
			omkte = true
			allright = false
		)
		if selection.count == 0 then 
		(
			sel = true
			allright = false
		)
		if allright then
		for i in selection do
		(
			if findstring i.name "UCX" != undefined then 
			(
				ucx_obj = true
				allright = false
			)
			if classof i.material != Standard then 
			(
				allright = false
				mats = true
			)
			if distance i.pos [0,0,0] <= 100 then 
			(
				dist = true
				allright = false				
			)
			if superclassof i != GeometryClass then
			(
				objs = true
				allright = false					
			)
			if i.ishidden then i.ishidden = false
		)
		if allright then
		(
			pluginManager.loadClass FbxExporter
			FBXExporterSetParam "Cameras" false 
			FBXExporterSetParam "FileVersion" "FBX201400" 
			FBXExporterSetParam "SmoothingGroups" true
			FBXExporterSetParam "SmoothMeshExport" false
			FBXExporterSetParam "Triangulate" false
			FBXExporterSetParam "Animation" false
			FBXExporterSetParam "Lights" false
			FBXExporterSetParam "ASCII" false
			FBXExporterSetParam "EmbedTextures" true 
			FBXExporterSetParam "GeomAsBone" false
			FBXExporterSetParam "GenerateLog" false
			FBXExporterSetParam "UpAxis" "Y"
			FBXExporterSetParam "ScaleFactor" 1.0
			FBXExporterSetParam "AxisConversionMethod" "None"
			FBXExporterSetParam "Preserveinstances" false
			FBXExporterSetParam "Animation" false
			FBXExporterSetParam "Convert2Tiff" false
			FBXExporterSetParam "ConvertUnit" "m" 
			FBXExporterSetParam "FilterKeyReducer" false
			FBXExporterSetParam "GeomAsBone" false
			FBXExporterSetParam "GenerateLog" false
			FBXExporterSetParam "Lights" false
			FBXExporterSetParam "NormalsPerPoly" false --?
			FBXExporterSetParam "PointCache" false 
			FBXExporterSetParam "Shape" false
			FBXExporterSetParam "Skin" false 
			FBXExporterSetParam "SmoothMeshExport" true
			
			if not doesDirectoryExist UDIMs.edt_multimat_path.text then makeDir UDIMs.edt_multimat_path.text
			
			ground = #()
			oks = #()
			ground = for i in selection where findstring (tolower i.name) "ground" != undefined collect i
			oks = for i in selection where findstring (tolower i.name) "ground" == undefined collect i
			
			if ground.count > 0 then
			(
				nam = ""
				nam = substitutestring ground[1].name "SM_" ""
				nam = substitutestring nam "_GroundEl" ""
				nam = substitutestring nam "_Ground" ""
				
				select ground
				exportFile (UDIMs.edt_multimat_path.text + edt_omkte.text + "_" + nam + "_Ground.fbx") #noPrompt selectedOnly:true using:FBXEXP --theClasses[8] using:theClasses[(findItem theClasses FBXEXP)] 
			)
			if oks.count > 0 then
			(
				nam = ""
				nam = substitutestring oks[1].name "SM_" ""
				nam = substitutestring nam "_Main" ""
				nam = substitutestring nam "_001" ""
				nam = substitutestring nam "_002" ""
				nam = substitutestring nam "_003" ""
				nam = substitutestring nam "_004" ""
				nam = substitutestring nam "_005" ""				
				nam = substitutestring nam "_006" ""	
				nam = substitutestring nam "_007" ""	
				nam = substitutestring nam "_008" ""	
				nam = substitutestring nam "_009" ""					
				
				select oks
				exportFile (UDIMs.edt_multimat_path.text + edt_omkte.text + "_" + nam + "_01.fbx") #noPrompt selectedOnly:true using:FBXEXP --theClasses[8] using:theClasses[(findItem theClasses FBXEXP)] 
			)
		)
		else 
		(
			s = "Wrong: \n"
			if objs then s += "selected objects is not geometry\n"
			if dist then s += "one of selected object have wrong position near zero\n"
			if omkte then s += "OMK TE Code not selected\n"
			if ucx_obj then s += "selected UCX objects\n"
			if mats then s += "materials on models\n"
			if sel then s += "no objects selected\n"	
			messagebox s
		)
	)
	
	on btn_export_highpoly rightclick do
	(
		sel = selection[1]
		--objs = for i in objects where (findstring i.name "_Ground" != undefined or findstring i.name "_Main" != undefined) and findstring i.name "Glass" == undefined and findstring i.name "SM_" != undefined and findstring i.name "_SM_" == undefined and not i.isHidden and not i.isFrozen and abs(i.pos.x) <= 1.0 and abs(i.pos.y) <= 1.0 and abs(i.pos.z) <= 1.0 collect i 
		selectmore (for t in objects where findstring t.name "UCX_SM_" != undefined and findstring t.name sel.name != undefined collect t)
		selectmore (for t in objects where findstring t.name "Glass" != undefined and findstring t.name sel.name != undefined collect t)
	)
	
	on btn_export_highpoly pressed do
	(
		--print UDIMs.edt_multimat_path.text
		objs = for i in objects where (findstring i.name "_Ground" != undefined or findstring i.name "_Main" != undefined) and findstring i.name "Glass" == undefined and findstring i.name "SM_" != undefined and findstring i.name "_SM_" == undefined and not i.isHidden and not i.isFrozen and abs(i.pos.x) <= 1.0 and abs(i.pos.y) <= 1.0 and abs(i.pos.z) <= 1.0 collect i 
		print #(objs)
		for i in objs do
		(
			USXs = for t in objects where findstring t.name "UCX_SM_" != undefined and findstring t.name i.name != undefined collect t
			print #(USXs)
			Glasses = for t in objects where findstring t.name "Glass" != undefined and findstring t.name i.name != undefined collect t
			print #(Glasses)	
			Lightes = for t in objects where (findstring t.name "Spot" != undefined or findstring t.name "Root" != undefined) and findstring t.name (substitutestring i.name "SM_" "") != undefined collect t
			print #(Lightes)
			
			clearSelection()
			selectmore i
			selectmore Glasses
			selectmore USXs
			--selectmore Lightes
			if USXs != undefined then
			(
				if USXs.count > 0 then 
				(			
					pluginManager.loadClass FbxExporter
					FBXExporterSetParam "Cameras" false 
					FBXExporterSetParam "FileVersion" "FBX201400" 
					FBXExporterSetParam "SmoothingGroups" true
					FBXExporterSetParam "SmoothMeshExport" true
					FBXExporterSetParam "Triangulate" false
					FBXExporterSetParam "Animation" false
					FBXExporterSetParam "Lights" false
					FBXExporterSetParam "ASCII" false
					FBXExporterSetParam "EmbedTextures" false 
					FBXExporterSetParam "GeomAsBone" false
					FBXExporterSetParam "GenerateLog" false
					FBXExporterSetParam "UpAxis" "Y"
					FBXExporterSetParam "ScaleFactor" 1.0
					FBXExporterSetParam "AxisConversionMethod" "None"
					FBXExporterSetParam "Preserveinstances" false
					FBXExporterSetParam "Convert2Tiff" false
					FBXExporterSetParam "ConvertUnit" "m" 
					FBXExporterSetParam "FilterKeyReducer" false
					FBXExporterSetParam "NormalsPerPoly" true --?
					FBXExporterSetParam "PointCache"  false 
					FBXExporterSetParam "Shape"  false
					FBXExporterSetParam "Skin"  false 
					exportFile (UDIMs.edt_multimat_path.text + (substitutestring i.name "_Main" "") + ".fbx") #noPrompt selectedOnly:true using:FBXEXP --theClasses[8] using:theClasses[(findItem theClasses FBXEXP)] 
					if Lightes != undefined then 
						if Lightes.count > 0 then
						(
							select Lightes
							pluginManager.loadClass FbxExporter
							FBXExporterSetParam "Cameras" false 
							FBXExporterSetParam "FileVersion" "FBX201400" 
							FBXExporterSetParam "SmoothingGroups" true
							FBXExporterSetParam "SmoothMeshExport" true
							FBXExporterSetParam "Triangulate" false
							FBXExporterSetParam "Animation" false
							FBXExporterSetParam "Lights" true
							FBXExporterSetParam "ASCII" false
							FBXExporterSetParam "EmbedTextures" false 
							FBXExporterSetParam "GeomAsBone" false
							FBXExporterSetParam "GenerateLog" false
							FBXExporterSetParam "UpAxis" "Y"
							FBXExporterSetParam "ScaleFactor" 1.0
							FBXExporterSetParam "AxisConversionMethod" "None"
							FBXExporterSetParam "Preserveinstances" false
							FBXExporterSetParam "Convert2Tiff" false
							FBXExporterSetParam "ConvertUnit" "m" 
							FBXExporterSetParam "FilterKeyReducer" false
							FBXExporterSetParam "NormalsPerPoly" true --?
							FBXExporterSetParam "PointCache"  false 
							FBXExporterSetParam "Shape"  false
							exportFile (UDIMs.edt_multimat_path.text + i.name + "_Light" + ".fbx") #noPrompt selectedOnly:true using:FBXEXP --theClasses[8] using:theClasses[(findItem theClasses FBXEXP)] 
						)
				)
				else
				(
					messagebox ("No UCX models to export with model: " + i.name) 
				) 
				--clearSelection()
			)
		)
		/*
		ucx_obj = false
		glass_obj = false
		ground_obj = false
		for i in selection where findstring i.name "UCX" != undefined do ucx_obj = true
		for i in selection where findstring i.name "Glass" != undefined do glass_obj = true
		for i in selection where findstring i.name "Ground" != undefined do ground_obj = true			
		if ucx_obj and glass_obj and ground_obj then
		(
			pluginManager.loadClass FbxExporter
			FBXExporterSetParam "Cameras" false 
			FBXExporterSetParam "FileVersion" "FBX201400" 
			FBXExporterSetParam "SmoothingGroups" true
			FBXExporterSetParam "SmoothMeshExport" false
			FBXExporterSetParam "Triangulate" false
			FBXExporterSetParam "Animation" false
			FBXExporterSetParam "Lights" false
			FBXExporterSetParam "ASCII" false
			FBXExporterSetParam "EmbedTextures" false 
			FBXExporterSetParam "GeomAsBone" false
			FBXExporterSetParam "GenerateLog" false
			FBXExporterSetParam "UpAxis" "Y"
			FBXExporterSetParam "ScaleFactor" 1.0
			FBXExporterSetParam "AxisConversionMethod" "None"
			FBXExporterSetParam "Preserveinstances" false
			FBXExporterSetParam "Animation" false
			FBXExporterSetParam "Convert2Tiff" false
			FBXExporterSetParam "ConvertUnit" "m" 
			FBXExporterSetParam "FilterKeyReducer" false
			FBXExporterSetParam "GeomAsBone"  false
			FBXExporterSetParam "GenerateLog"  false
			FBXExporterSetParam "Lights"  false
			FBXExporterSetParam "NormalsPerPoly"  false --?
			FBXExporterSetParam "PointCache"  false 
			FBXExporterSetParam "Shape"  false
			FBXExporterSetParam "Skin"  false 
			FBXExporterSetParam "SmoothMeshExport"  true
			exportFile (edt_project_path.text + "Images\\" + "hipoly.fbx") #noPrompt selectedOnly:true using:FBXEXP --theClasses[8] using:theClasses[(findItem theClasses FBXEXP)] 
		)
		else 
		(
			mess = ""
			if not ucx_obj then mess += "UCX object not selected\n"
			if not glass_obj then mess += "Glass object not selected\n"
			if not ground_obj then mess += "Ground object not selected\n"
			messagebox ("Wrong selection\n" + mess)
		)
		*/
	)
)

rollout Docker "Dock and Update" autoLayoutOnResize:true
(
	button btn_update "Update script" offset:[0,0] across:4 align:#left toolTip:"Открыть облако с обновлениями в текущем интернет-браузере | Open cloud with updates in current internet browser"
	button lbl2 "\x2190 Dock" border:false offset:[10,0] toolTip:"LMB: Закрепить панель инструментов слева | LMB: Dock toolbar to left side"
	button lbl1 "Make Float" border:false offset:[10,0] toolTip:"LMB: Сделать панель инструментов плавающей\nRMB: Закрыть панель инструментов | LMB: Make toolbar float\nRMB: Close toolbar"	
	button lbl3 "Dock \x2192" border:false offset:[0,0] align:#right toolTip:"LMB: Закрепить панель инструментов справа | LMB: Dock toolbar to right side"
	hyperLink hyperLink1 " \x2709 geomobil@mail.ru" width:120 across:3 align:#left color:black hoverColor:red visitedColor:black address:"mailto:geomobil@mail.ru"
	hyperLink hyperLink2 "\x2709 3ddd.ru" width:70 offset:[30,0] color:black hoverColor:red visitedColor:black address:"https://3ddd.ru/users/georgiys"
	hyperLink hyperLink3 "\x2709 Telegram" width:70 align:#right color:black hoverColor:red visitedColor:black address:"https://t.me/AGR3D_MKA/566"

	on Docker open do
	(
		for i in Docker.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_Docker.ini") i.name "Docker" (syssetup.rdo_lang.state))
	)
	
	on lbl1 pressed do
	(
		cui.RegisterDialogBar GeoAGR minSize:[10,700] maxSize:[500,700] --style:#(#cui_dock_all, #cui_floatable, #cui_floatableDialogbar, #cui_dock_allDialog, #cui_dock_bottomCan, #cui_dock_rightCan, #cui_dock_topCan, #cui_dock_left, #cui_dock_vertCan , #cui_dock_horzCan, #cui_handles, #cui_handlesShow, #cui_max_sized)
		cui.FloatDialogBar GeoAGR
	)

	on lbl1 rightclick do
	(
		try(cui.RegisterDialogBar GeoAGR minSize:[10,700] maxSize:[500,700])catch()
		try(cui.UnRegisterDialogBar GeoAGR)catch()
		try(destroyDialog ::GeoAGR)catch() --destroyDialog GeoAGR
		try(closeRolloutFloater GeoAGR)catch()
		gc()
	)

	on lbl2 pressed do
	(
		cui.RegisterDialogBar GeoAGR minSize:[10,700] maxSize:[500,700] --style:#(#cui_dock_all, #cui_floatable, #cui_floatableDialogbar, #cui_dock_allDialog, #cui_dock_bottomCan, #cui_dock_rightCan, #cui_dock_topCan, #cui_dock_left, #cui_dock_vertCan , #cui_dock_horzCan, #cui_handles, #cui_handlesShow, #cui_max_sized)
		cui.DockDialogBar GeoAGR #cui_dock_left
		--cui.UnRegisterDialogBar geo	
	)

	on lbl3 pressed do
	(
		cui.RegisterDialogBar GeoAGR minSize:[10,700] maxSize:[500,700] --style:#(#cui_dock_all, #cui_floatable, #cui_floatableDialogbar, #cui_dock_allDialog, #cui_dock_bottomCan, #cui_dock_rightCan, #cui_dock_topCan, #cui_dock_left, #cui_dock_vertCan , #cui_dock_horzCan, #cui_handles, #cui_handlesShow, #cui_max_sized)
		cui.DockDialogBar GeoAGR #cui_dock_right 	
		--cui.UnRegisterDialogBar geo	
	)

	on btn_update pressed do
	(
		process = dotnetclass "System.Diagnostics.Process"
		process.start ("https://cloud.mail.ru/public/Zq1B/2FKsi1fDn")
	)		
)

--addRollout RulesCheck GeoAGR rolledup:true
addRollout syssetup GeoAGR rolledup:true
addRollout slicers GeoAGR rolledup:true
addRollout UDIMs GeoAGR rolledup:false
addRollout Obj_Spln GeoAGR rolledup:true
addRollout Obj_tools GeoAGR rolledup:true
addRollout UCX GeoAGR rolledup:true
addRollout Geojson GeoAGR rolledup:true
addRollout File GeoAGR rolledup:true
addRollout Docker GeoAGR rolledup:false


/*
createDialog GeoAGR lockwidth:true lockheight:false autoLayoutOnResize:true style:#(#style_resizing, #style_sunkenedge, #style_titlebar, #style_sysmenu, #style_minimizebox) 
try (SetDialogPos GeoAGR [500, 90])catch()
AddSubRollout GeoAGR.S_slicers slicers rolledup:false autoLayoutOnResize:true lockheight:false
AddSubRollout GeoAGR.S_UDIMs UDIMs rolledup:false autoLayoutOnResize:true lockheight:false
AddSubRollout GeoAGR.S_Obj_Spln Obj_Spln rolledup:false autoLayoutOnResize:true lockheight:false
AddSubRollout GeoAGR.S_UCX UCX rolledup:false autoLayoutOnResize:true lockheight:false
AddSubRollout GeoAGR.S_Geojson Geojson rolledup:false autoLayoutOnResize:true lockheight:false
AddSubRollout GeoAGR.S_File File rolledup:false autoLayoutOnResize:true lockheight:false
*/

)
