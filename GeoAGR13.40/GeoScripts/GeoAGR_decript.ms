========================================
GeoAGR CODE INTERCEPTOR (MaxScript)
========================================

[OK] Found: C:\Program Files\Autodesk\3ds Max 2025\GeoScripts\GeoAGR.ini
[RUN] Starting GeoAGR.exe...

[OK] GeoAGR.exe finished (exit code: 0)
[RUN] Reading clipboard...

[OK] Intercepted: 1142075 chars
-- Error occurred in anonymous codeblock; filename: C:\MaxManager\tools\GeoAGR_Interceptor.ms; position: 1546; line: 48
-- MAXScript FileIn Exception:
-- Runtime error: FileStream cannot create: C:\MaxManager\analysis\geoagr_intercepted_01.11.2025_95157.ms
-- MAXScript callstack:
--	thread data: threadID:90512
--	------------------------------------------------------
--	[stack level: 0]
--	In anonymous codeblock; filename: C:\MaxManager\tools\GeoAGR_Interceptor.ms; position: 1547; line: 48
--		Locals:
--			file_ini: "C:\Program Files\Autodesk\3ds Max 2025\GeoScripts\GeoAGR.ini"
--			Lines: undefined
--			output_file: "C:\MaxManager\analysis\geoagr_intercepted_01.11.2025_95157.ms"
--			exe: 0
--			output: undefined
--			clipboard_code: "--wishlist:
/*		
		??????????? ?????????, ????????? ????? ? ????? ???????????
		polyop.cutFace 

		???? ??? ???????: ????????? ??????????? ?????????? ???????? ? ???????, ????? ???????? ? ?????? ?????, ????? ??????? ???????? ??? ???????? ??????,
		???????? ??? ???????? ???? ????????? n-??? ??? ?????????? ?? ? 7.6 ????? ? 4096 ???????? ?? ??? ???? 2048 ?? ????????? ???? 4 ? ????? ?? ???????? 
		????? ?????????? ???????? ???? ?????? ??? 7.6 ????? ???? ????? ??? ??????????? ????? ????????? ?? ????? ???????,
		????? ???? ????????????? ????? ??? ? ??????????????? ?????? 
		? ???????? ?????????? ????????? ?? ????? ??? ?????
		
		???????????? ????? meshlib
		??????????? ?????????? python ? ?????, ????? ?????????? ?? ???? ? ??????????? meshlib meshlab, ??????????? C# ??????????
		
		?????? ???????? ?? ???? ????? ????????, ???????? ?? ???? ??????? ?????? ?? ??????? ? ??????, ? ???????????? ??????????? ???????, ?? ???????? ????????, ? ????????????, ? ????????? ? pdf

		??????????? ???????? ??? CAD ??????????????? ???? - ??? ?????????
		
		???????? ? ??????? ??????? ???????? ??????, ??? ????????????? ??????

		???? ???????, ?? ?????? ????? ?????? ????? ? ???????????? ?????, 
		?????????????? ????????????? ?????? ?????????, 
		??????? ????????? ????????, ????? ????????, ???? ???? ?????, ?? ?????? ?? ??????
		?????? polyop.slice ?? polyop.cutFace
		polyop.cutFace <Poly poly> <int face> <point3 start> <point3 destination> <point3 projdir> node:<node=unsupplied>
		polyop.slice <Poly poly> <facelist> <ray plane_and_dir> node:<node=unsupplied>
		<bool><EditablePoly>.slice <point3>slicePlaneNormal <point3>slicePlaneCenter [flaggedFacesOnly:<bool>] [faceFlags:<DWORD>] 
		flaggedFacesOnly default value: false
		faceFlags default value: 1
		<index><EditablePoly>.cutFaces <index>startFace <point3>startPosition <point3>endPosition <point3>viewDirectionCut 
		using a plane defined by the point specified by the two face positions and the view direction. 

		PCloudToMesh ?? ?????? ??????? ??????????? ????? (??? ??????? ????? meshlib converter)

		???????? ????? ??? ? ??????? ?? ??????, ????? ?????? ?????-?? ?????? ??????????, ?????-?? ????????

		???????? ????? UCX ?????? ????????, ??????? ?? 30?? ? 1?
		????????? convex-concave ?? ????????? ?????????
		???????? ??????? OMK-TE ?? ?????? ???????

		btn_UdimFit fit - ???????? ??? ?????????? ???? ?? ?????? ????????? ?? ? ??? ??????
		???????? ? ?????? ? ??????????? ????????? ?????? ????

		???????? UV ?? ?????? ?????????, ????????, ??????????? ??? ????? ?????? ???? ? ?????? ????

		transfer edges ?? ??????????? ????? ? ????????

		?????? ????????? IntersectRay ?????????: ?????? ?? ?????????? ?? ????????? ??????????????? ????? ?? ????????? ray (??????? ?????) ? ?? pos ??????????? ? ????????? ? ????????? ?? ??? ???????? ?????
		??????????? ??????????? ???????????? ?????, ??????????? ? ?????????????????? ???????
		btn_FlipFaces ????????????? ???????????? ????? ? ???????????? ????????, ???? ???????, ??????, ?????
		? ?????????????? ?????? ?????????? ????????? ?????????, ????????? ??? ??????????? ???????? ????????

		??????????? ?? ???????? PopulateTerrain, ??? ????? ???????? ?????? ??? ??????? ????????
		
		???? ???????? ???????? ??????? ????, ???????????? ?? ???????, ? ??????? ??????????? ????????? ??????????? ??????? ?? ?????
		
		???????? ???????? ?????????????????? ? ??????????, ??????????? ?? ????????? ?????????? ?? ???????? (???????????, ???????, ???????, ??????????? ???????, ??? ??? ??????????)
		
		???????? ?????? ??????? ? ??????? ??????? ?????? ? ???????? ?????
		
		?????????? ???????? - ?????????? ?????? ini ?? ???????? ? ?????, ? ?? ???????? ???????
		
		???????? ???????? ? ????????? ????????, ??? ???? ????? ?????????? ?????? ????? ? ????? ??????? ? ?? ??????? ???????, ?????? ?? ???? ????????? ??????

		???????? ????????????? ???????????? ???????????? ? ??????????????? ? ?????????? ?????? ????? ? ?????? ?????????
		???????? ????????? ?????? ?? ?????? ??????? ?????????
		???????? ??? ? ???? ????????? ???????? polyop.setMapFace <Poly poly> <int mapChannel> <int map face index> <map vertex array>Sets the map vertices for the specified map face. 
		
		???????? ?????? ?????? ? ????????? ???????? ???????
		????????? ?????? ?????? ? ????????? ???????? ?????? ?????? ? ???? ???????, ? ??????????? ?????????? ????????? ? ?????????

		?????????? UCX convex concave, ???? ???????? ?????? ???????????? ??? concave

		?????? ?????? ???????? ???? ? ?????????? ???????? ? ???????
		???????? ???????? ?????????? ????????, ??????????????

		????????? ??????? ??????? ?? ??????
		
		?????? ? ???????????????? ??????? <void><Unwrap_UVW>.selectInvertedFaces() 
		
		OSL ???????? UDIM ? Multitile
		
		?????????? ???????? ? ??????? ??? ?? ? ?????????? INI, ??????? ???? ? ???????
		
		?UDIM to IDs ?????????????? ??? ????????, ??????? ????? ?? ????? ????????? ? ?????, ? ?? ?????????? ?? ????????
		
		?????? ? ???? ??? ???????? ??????? ??? ??????? ?? ???????? ? ???????, ???????? ????
		
		???????? ??????????? ???????? ???????? ??? ???????
		????? ??????????? ????? ?? ?????? ??? ??????? ?????????? ????????
		
		?????????? ????? Geojson ? ???????????
		????? ???????????? ??? ????????? ??? ?????????? ?????, ?????, ?????, ???, ?????? ?? ???????????? ????

		???????? grid helper ???????????????? ????? ??????? ? ?????????? ??? ?? ????????? ???????
		activegrid = undefined 
		
		???? ???????? ?? ?????? ???????? ??????????
		???? ???? ??????? ?? ?????? ??????????
		
*/

--macroScript GeoAGR category:"Geoscript"
(
	setclipboardText " "
	--escapeEnable = false
	--main programm
	escapeEnable = true
	
	fn DisableProcessWindowsGhosting =
    (
		local source = StringStream ("using System.Runtime.InteropServices; public class DisableWindowsGhosting{ [DllImport(\"user32.dll\")]  public static extern bool DisableProcessWindowsGhosting();  }")

		compilerParams = dotnetobject "System.CodeDom.Compiler.CompilerParameters"
		compilerParams.ReferencedAssemblies.Add("System.dll");
		compilerParams.GenerateInMemory = on
		csharpProvider = dotnetobject "Microsoft.CSharp.CSharpCodeProvider"
		compilerResults = csharpProvider.CompileAssemblyFromSource compilerParams #(source as String)
		flush source
		close source
		if (compilerResults.Errors.Count > 0 ) then
		(
			local errs = stringstream ""
			for i = 0 to (compilerResults.Errors.Count-1) do
			(
				local err = compilerResults.Errors.Item[i]
				format "Error:% Line:% Column:% %\n" err.ErrorNumber err.Line err.Column err.ErrorText to:errs
			)
			format "%\n" errs
			undefined
		)
		else
		(
			compilerResults.CompiledAssembly.CreateInstance "DisableWindowsGhosting"
		)
    )
	
	fn gettime = 
	(
		local client = dotnetObject "System.Net.Sockets.TcpClient" "time.nist.gov" 13
		client.SendTimeout = 2000
		local streamReader = dotnetObject "System.IO.StreamReader" (client.GetStream())
		local response = streamReader.ReadToEnd asDotnetObject:true
 
		local utcDateTimeString = response.Substring 7 17 asDotNetObject:true
		local localDateTime = (dotnetClass "System.DateTime").ParseExact utcDateTimeString "yy-MM-dd HH:mm:ss" (dotnetClass "System.Globalization.CultureInfo").InvariantCulture (dotnetClass "System.Globalization.DateTimeStyles").AssumeUniversal
 
		streamReader.Dispose()
		--print (localDateTime.ToString())
		localDateTime.ToString()
	)
	
	fn translit t =
	(
		nm = ""
		if t != undefined then
			if t.count > 0 then 
			(
				for j in #{1..t.count} do
					case t[j] of
					(
						"?": nm+="A"
						"?": nm+="B"
						"?": nm+="V"
						"?": nm+="G"
						"?": nm+="D"
						"?": nm+="E"
						"?": nm+="Yo"
						"?": nm+="Zh"
						"?": nm+="Z"
						"?": nm+="I"
						"?": nm+="J"
						"?": nm+="K"
						"?": nm+="L"
						"?": nm+="M"
						"?": nm+="N"
						"?": nm+="O"
						"?": nm+="P"
						"?": nm+="R"
						"?": nm+="S"
						"?": nm+="T"
						"?": nm+="U"
						"?": nm+="F"
						"?": nm+="H"
						"?": nm+="Cz"
						"?": nm+="Ch"
						"?": nm+="Sh"
						"?": nm+="Shch"
						"?": nm+=""
						"?": nm+="Y"
						"?": nm+=""
						"?": nm+="E"
						"?": nm+="Yu"
						"?": nm+="Ya"
						"?": nm+="a"
						"?": nm+="b"
						"?": nm+="v"
						"?": nm+="g"
						"?": nm+="d"
						"?": nm+="e"
						"?": nm+="yo"
						"?": nm+="zh"
						"?": nm+="z"
						"?": nm+="i"
						"?": nm+="j"
						"?": nm+="k"
						"?": nm+="l"
						"?": nm+="m"
						"?": nm+="n"
						"?": nm+="o"
						"?": nm+="p"
						"?": nm+="r"
						"?": nm+="s"
						"?": nm+="t"
						"?": nm+="u"
						"?": nm+="f"
						"?": nm+="h"
						"?": nm+="cz"
						"?": nm+="ch"
						"?": nm+="sh"
						"?": nm+="shch"
						"?": nm+=""
						"?": nm+="y"
						"?": nm+=""
						"?": nm+="e"
						"?": nm+="yu"
						"?": nm+="ya"

						"0": nm+="0"
						"1": nm+="1"
						"2": nm+="2"
						"3": nm+="3"
						"4": nm+="4"
						"5": nm+="5"
						"6": nm+="6"
						"7": nm+="7"
						"8": nm+="8"
						"9": nm+="9"

						" ": nm+="_"
						"_": nm+="_"
						".": nm+="_"
						",": nm+=""
						"-": nm+=""
						"/": nm+=""
						"\\": nm+=""
						"'": nm+=""
						"`": nm+=""

						"A": nm+="A"
						"B": nm+="B"
						"C": nm+="C"
						"D": nm+="D"
						"E": nm+="E"
						"F": nm+="F"
						"G": nm+="G"
						"H": nm+="H"
						"I": nm+="I"
						"J": nm+="J"
						"K": nm+="K"
						"L": nm+="L"
						"M": nm+="M"
						"N": nm+="N"
						"O": nm+="O"
						"P": nm+="P"
						"Q": nm+="Q"
						"R": nm+="R"
						"S": nm+="S"
						"T": nm+="T"
						"U": nm+="U"
						"V": nm+="V"
						"W": nm+="W"
						"X": nm+="X"
						"Y": nm+="Y"
						"Z": nm+="Z"

						"a": nm+="a"
						"b": nm+="b"
						"c": nm+="c"
						"d": nm+="d"
						"e": nm+="e"
						"f": nm+="f"
						"g": nm+="g"
						"h": nm+="h"
						"i": nm+="i"
						"j": nm+="j"
						"k": nm+="k"
						"l": nm+="l"
						"m": nm+="m"
						"n": nm+="n"
						"o": nm+="o"
						"p": nm+="p"
						"q": nm+="q"
						"r": nm+="r"
						"s": nm+="s"
						"t": nm+="t"
						"u": nm+="u"
						"v": nm+="v"
						"w": nm+="w"
						"x": nm+="x"
						"y": nm+="y"
						"z": nm+="z"
						
						default: nm += t[j]
					)
			)
		nm	
	)
		
	fn check_file f = 
	(
		good = false
		if f != undefined then
		(
			f_name = getfilenamefile f + getfilenametype f
			--print f_name
			ff = filterstring f_name "."
			--print #(ff)
			if ff.count > 1 then
			(
				--print ff.count
				if ff.count == 2 then good = false --?????? ???? ?????, ??? ??????
				if ff.count > 2 then
				(
					--print (trimright (ff[ff.count - 1]) "0123456789")
					if (trimright (ff[ff.count - 1]) "0123456789") == "" then 
					(
						
						ss = filterstring (ff[ff.count - 2]) "_" --?????? ??? ????? ?????? ????????? ?????????????
						--print #(ss)
						--print ss.count
						if ss.count > 1 then
						(
							if ss[ss.count] == "1" then good = true --????? ??????? ????? ????? _1
						)
					)
				)
			)
		)
		--print good
		good
	)	
	
	fn check_file_uv f = 
	(
		good = false
		if f != undefined then
		(
			f_name = getfilenamefile f + getfilenametype f
			--print f_name
			ff = filterstring f_name "."
			--print #(ff)
			if ff.count > 1 then
			(
				--print ff.count
				if ff.count == 2 then good = false --?????? ???? ?????, ??? ??????
				if ff.count > 2 then
				(
					--print (trimright (ff[ff.count - 1]) "0123456789")
					if (trimright (ff[ff.count - 1]) "0123456789") == "" then 
					(
						good = true 
					)
				)
			)
		)
		--print good
		good
	)	
	
	fn uv_file_rename i =
	(
		local new = i
		if new != undefined and new != "" then
		(
			local s = getfilenamefile i
			local pat = getfilenamepath i
			local ext = getfilenametype i
								
			local ss = filterstring s "_"
			if ss.count > 1 then
			(
				local V = ss[ss.count]
				local U = ss[ss.count - 1]
				V = substitutestring V "V" "" --???????????? ?????
				U = substitutestring U "U" "" --?????????????? ?????
				if (U as integer) >= 1 and (U as integer) <= 10 and (V as integer) >= 1 and (V as integer) <= 10 then
				(
					local udim_num = 1000 + (U as integer) + (10 * (V as integer - 1))
					local str = ""
					for a = #{1..(ss.count - 2)} do str += ss[a] + "_"
					new = pat + str + "." + (udim_num as string) + ext
				)
			)
		)
		new
	)
	
	fn udim_to_uv_num i = 
	(
		local str = ""
		--udim_num = 1000 + (U as integer) + (10 * (V as integer - 1))
		if i != undefined and i >= 1001 then
		(
			--local uv_num = i - 1000
			--local U = (mod uv_num 10) + 1
			--local V = ((uv_num - (U - 1)) / 10) as integer + 1
			
			local uv_num = i - 1000
			local U = mod uv_num 10
			local V = ((uv_num - U) / 10) as integer + 1
			
			str = "U" + U as string + "V" + V as string
			--print str
		)
		str
	)
								
	fn get_hits s selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular =
	(
		err = #()
		if s != undefined and classof s == Editable_Poly then
		(
			for i in selfaces where not keyboard.escPressed do
			(
				
				local vec = polyop.getFaceNormal s i
				if invert_face then vec *= -1.0
				local points = #()
				--append points (polyop.getFaceCenter s i)
				append points (polyop.getSafeFaceCenter s i)
				if do_verts then
				(
					local verts = polyop.getVertsUsingFace s #{i}
					join points (for v in verts collect	(polyop.getvert s v))
				)
				
				if points.count > 0 then 
				(
					for poi in points where poi != undefined do
					(
						/*
						addModifier s (Edit_Mesh())
							
						hits_ex = intersectRayEx s (ray poi vec)
						--print #(hits_ex)
						if hits_ex != undefined then
						(
							if (distance poi hits_ex[1].pos >= minimum_range) and (distance poi hits_ex[1].pos <= maximum_range) and (abs(dot vec hits_ex[1].dir) >= near_perpendicular or abs(dot vec hits_ex[1].dir) <= (1.0 - near_perpendicular)) do 
							(
								appendIfUnique err #(i, direction * (distance poi hits_ex[1].pos), vec, hits_ex[1].pos, hits_ex[1].dir, hits_ex[2])
							)
						)	
						deleteModifier s 1
						*/						
						--	/*
						if do_verts then
						(
							hits = intersectRayScene (ray poi vec)
							--print #(hits_new)
							if hits.count > 0 then
							(
								for h in hits where (h[1] == s) and (distance poi h[2].pos >= minimum_range) and (distance poi h[2].pos <= maximum_range) and (abs(dot vec h[2].dir) >= near_perpendicular or abs(dot vec h[2].dir) <= (1 - near_perpendicular)) do 
								(
									appendIfUnique err #(i, direction * (distance poi h[2].pos), vec, h[2].pos, h[2].dir)
								)
							)
						)
						else
						(
							hits_new = intersectRay s (ray poi vec)
							if hits_new != undefined then
							(
								if (distance poi hits_new.pos >= minimum_range) and (distance poi hits_new.pos <= maximum_range) and (abs(dot vec hits_new.dir) >= near_perpendicular or abs(dot vec hits_new.dir) <= (1.0 - near_perpendicular)) do 
								(
									appendIfUnique err #(i, direction * (distance poi hits_new.pos), vec, hits_new.pos, hits_new.dir)
								)
							)
						)
						--*/
					)
				)
			)
		)
		err
	)
	
	fn getConvexEdges node show threshold ignoreHardEdges ignoreOpenEdges = 
		if iskindof node Editable_Poly then
		(
			local edgeFaces = polyop.getedgefaces 
			local faceNormal = polyop.getfacenormal 
			local faceCenter = polyop.getfacecenter 
			local faceSmooth = polyop.getfacesmoothgroup
			edges = #{}
			for e in (node.edges as bitarray) do
			(
				ff = edgeFaces node e
				if (not ignoreOpenEdges and ff.count != 2) or ((ff.count == 2) and (n1 = faceNormal node ff[1]; n2 = faceNormal node ff[2]; vc = faceCenter node ff[2] - faceCenter node ff[1]; (dot n1 vc <= 0) and (acos (dot n1 n2) > threshold) and (not ignoreHardEdges or (bit.and (faceSmooth node ff[1]) (faceSmooth node ff[2]) > 0)))) then append edges e
			)
			if show then node.selectededges = edges
			edges
		)	
	
	fn faces_to_elements s faces =
	(
		elems = #()
		part_of_faces = faces
		while not part_of_faces.isempty do with redraw off
		(
			if keyboard.escPressed then exit
			for i in part_of_faces where not keyboard.escPressed do 
			(
				elem = polyOp.getElementsUsingFace s #{i}
				--vv = polyop.getVertsUsingFace s elem
				--pp = for v in vv collect polyop.getVert s v
				--append elems #(elem, vv, pp) 
				append elems elem
				part_of_faces -= elem
				exit
			)
		)
		elems
	)	

	fn rotate_to_min_Y s step mini maxi =  			
	(
		gc()
		angles = 0.0 
		if s != undefined then
		(
			max create mode
			ss = copy s
			ResetXForm ss
			converttopoly ss
			mY = ss.min.y
			delete ss
			for ang = mini to maxi by step where not keyboard.escPressed do
			(
				ss = copy s
				ResetXForm ss
				converttopoly ss
				in coordsys world rotate ss (eulerangles 0 0 ang)
				ResetXForm ss
				converttopoly ss
				mmY = ss.min.y 
				if mmY < mY then
				(
					mY = mmY 
					angles = ang
				)
				delete ss
			)
			print angles
			--rotate s (eulerangles 0 0 angles)
		)
		angles
	)
	
	fn rotate_to_min_Y_gab s step mini maxi =  			
	(
		gc()
		angles = 0.0 
		if s != undefined then
		(
			max create mode
			local ss = copy s
			ResetXForm ss
			CenterPivot ss
			converttopoly ss
			local pos = ss.pivot
			local mY = abs (ss.max.y - ss.min.y)
			delete ss
			for ang = mini to maxi by step where not keyboard.escPressed do
			(
				local ss = copy s
				ResetXForm ss
				CenterPivot ss
				converttopoly ss
				in coordsys world rotate ss (eulerangles 0 0 ang)
				ResetXForm ss
				CenterPivot ss
				converttopoly ss
				mmY = abs (ss.max.y - ss.min.y)
				if mmY < mY then
				(
					mY = mmY 
					angles = ang
					local pos = ss.pivot
				)
				delete ss
			)
			format "angle=% pivot_ini=% pivot_fin=% \n" angles s.pivot pos
			--rotate s (eulerangles 0 0 angles)
		)
		angles
	)
	
	fn rotate_to_max_Y s step mini maxi =  			
	(
		gc()
		angles = 0.0 
		if s != undefined then
		(
			max create mode
			ss = copy s
			ResetXForm ss
			converttopoly ss
			mY = ss.max.y
			delete ss
			for ang = mini to maxi by step where not keyboard.escPressed do
			(
				ss = copy s
				ResetXForm ss
				converttopoly ss
				in coordsys world rotate ss (eulerangles 0 0 ang)
				ResetXForm ss
				converttopoly ss
				mmY = ss.max.y 
				if mmY > mY then
				(
					mY = mmY 
					angles = ang
				)
				delete ss
			)
			print angles
			--rotate s (eulerangles 0 0 angles)
		)
		angles
	)
	
	fn dist s elem1 elem2 d =
	(
		if not elem1.isempty and not elem2.isempty then 
		(
			local vv1 = polyop.getVertsUsingFace s elem1
			local vv2 = polyop.getVertsUsingFace s elem2
			local pp1 = for v1 in vv1 collect polyop.getVert s v1
			local pp2 = for v2 in vv2 collect polyop.getVert s v2	
			for p1 in pp1 do
				for p2 in pp2 where distance p1 p2 <= d do return true
		)
		return false 
	)		
	
	fn getNormals poly faces =
	(
		local normal = [0, 0, 0]
		for f in faces do normal += in coordsys poly (polyop.getFaceNormal poly f)
		return normalize (normal / faces.numberSet)
	)
	
	fn alignUVGizmo theObj theMap =
	(
		local a = copy theObj 
		converttopoly a  
		local faces = #{1..a.numFaces}
		delete a
		faceNormal = getNormals theObj faces
		worldUpVector = [0,0,1]
		rightVector = normalize (cross worldUpVector faceNormal)
		upVector = normalize (cross rightVector faceNormal)
		theMatrix = matrix3 rightVector upVector faceNormal [0,0,0]
		theMap.gizmo.transform = theMatrix
		theMatrix
	)

	fn addBBoxVertex bbpMax bbpMin p = 
	(
		if bbpMax == undefined then 
		(
			bbpMin = copy p
			bbpMax = copy p
		)
		if p.x > bbpMax.x then bbpMax.x = p.x
		if p.y > bbpMax.y then bbpMax.y = p.y
		if p.z > bbpMax.z then bbpMax.z = p.z

		if p.x < bbpMin.x then bbpMin.x = p.x
		if p.y < bbpMin.y then bbpMin.y = p.y
		if p.z < bbpMin.z then bbpMin.z = p.z
	)

	fn getcenters obj faces = 
	(
		centre = [0,0,0]
		if obj != undefined and classof obj == Editable_Poly then
		(
			if not faces.isempty then
			(
				for theFace in faces do center += polyOp.getSafeFaceCenter obj theFace
				centre /= faces.numberset
			)
		)
		centre
	)

	fn FitUVWMapToFace obj theMap =
	(
		local a = copy obj 
		converttopoly a  
		local faces = #{1..a.numFaces}
		delete a
		objTM = obj.objecttransform
		modTM = getModContextTM obj m --??? ??????
		cfp = getcenters obj faces 
		fTM = theMap.gizmo.transform
		facePointList = #{}
		for theFace in faces do join facePointList (polyOp.getFaceVerts obj.baseobject theFace)
		bbpMax = undefined
		bbpMin = undefined
		for f in facePointList do
		(
			local fp = polyOp.getVert obj f
			addBBoxVertex bbpMax bbpMin ((fp * (inverse objTM) * (inverse fTM)))
		)
		avp = bbpMax - bbpMin
		bbpMiddle = bbpMin + avp / 2
		theMap.gizmo.pos = bbpMiddle * fTM * modTM
		theMap.length = avp.y
		theMap.width = avp.x
		theMap.height = avp.z
	)

	fn get_gabarites s = 
	(
		gab = 0
		if s != undefined then
		(
			if classof s == editable_poly then
			(
				local d = #()
				local pp = for v in #{1..polyop.getNumVerts s} collect polyop.getvert s v
				for p1 in pp do
					for p2 in pp where p1 != p2 do 
					(
						append d (distance [p1.x, p1.y, 0] [p2.x, p2.y, 0])
					)
				gab = amax d
				gab = amax (#((s.max.z - s.min.z), gab))
			)
		)
		gab
	)
	
	fn getVertNormal poly vert =
	(
		local normal = [0, 0, 0]
		local vertFaces = polyop.getFacesUsingVert poly vert
		if vertFaces.numberSet > 0 then
		(
			for f in vertFaces do normal += polyop.getFaceNormal poly f
			return normalize (normal / vertFaces.numberSet)
		)
		else return normal
	)

	fn convex_concave poly faces = 
	(
		arr = #{}
		if poly != undefined then
		(
			if faces.isempty then
			(
				return arr
			)
			else 
			(
				for f in faces do
				(	
					a = polyop.getSafeFaceCenter poly f
					b = polyop.getFaceCenter poly f
					if a != undefined and b != undefined then
					(
						if distance a b > 0 then arr += #{f}
					)
					else arr += #{f}
				)
				return arr
			)
		) 
		else return arr
	)

	fn getmaps filename = for i in #{1..AssetManager.GetNumAssets()} where ((AssetManager.GetAssetByIndex i).getType()) == #Bitmap and getfilenamefile ((AssetManager.GetAssetByIndex i).getfilename()) == getfilenamefile filename collect ((AssetManager.GetAssetByIndex i).getfilename())

	fn fit_map sourcepath finalpath pos sc rez start = 
	(
		if doesfileexist sourcepath then
		(
			--finalpath = (getfilenamepath sourcepath) + (getfilenamefile sourcepath) + "_fit.png"
			local bm = openbitmap sourcepath gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if bm != undefined then
			(
				local wid = bm.width
				local hei = bm.height
				close bm
				free bm
				if wid != rez or hei != rez then 
				(
					--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^!" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^! " + "\"" + finalpath + "\"") startpath:start
				)
				
				--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
				HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "%% " + "\"" + finalpath + "\"") startpath:start
				
				wid = rez
				hei = rez
				local x_ = -(pos.x - 0.5)
				local y_ = -(pos.y - 0.5)
				local x = ((x_ * wid) as integer) 
				local y = ((y_ * hei) as integer) 
				x = if x >= 0 then "+" + (x as string) else (x as string)
				y = if y >= 0 then "+" + (y as string) else (y as string)
				format "fit_map scale=% x=% % y=% %\n" sc x_ x y_ y
				cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
				HiddenDOSCommand cmd startpath:start
				HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:start
			)	
		)
	)		

	fn fit_map_new sourcepath finalpath pos sc rez start = 
	(
		if doesfileexist sourcepath then
		(
			local bm = openbitmap sourcepath gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if bm != undefined then
			(
				local wid = bm.width
				local hei = bm.height
				close bm
				free bm
				if wid != rez or hei != rez then 
				(
					--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^!" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^! " + "\"" + finalpath + "\"") startpath:start
				)
				
				--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
				HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "%% " + "\"" + finalpath + "\"") startpath:start
				
				wid = rez
				hei = rez
				local x_ = (pos.x * wid) as integer -- -(pos.x - 0.5)
				local y_ = (pos.y * hei) as integer -- -(pos.y - 0.5)
				--local x = ((x_ * wid) as integer) 
				--local y = ((y_ * hei) as integer) 
				local x = if x_ >= 0 then "+" + (x_ as string) else (x_ as string)
				local y = if y_ >= 0 then "+" + (y_ as string) else (y_ as string)
				format "fit_map scale=% x=% % y=% %\n" sc x_ x y_ y
				cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
				HiddenDOSCommand cmd startpath:start
				--HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:start
			)	
		)
	)		
	
	fn fit_map_edge sourcepath finalpath pos sc mX mY mWidth mHeight start = 
	(
		if doesfileexist sourcepath then
		(
			--finalpath = (getfilenamepath sourcepath) + (getfilenamefile sourcepath) + "_fit.png"
			local bm = openbitmap sourcepath gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if bm != undefined then
			(
				local wid = bm.width
				local hei = bm.height
				local alpha = bm.hasalpha
				close bm
				free bm
				
				--if wid != rez or hei != rez then 
				--(
				--	HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^! " + "\"" + finalpath + "\"") startpath:start
					--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez as string + "x" + rez as string + "^!" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
				--)
				--else
				--(
					if doesFileExist finalpath then deleteFile finalpath
					if doesFileExist sourcepath then copyfile sourcepath finalpath
					--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
				--)

				--local x_ = ( (mX+mWidth/2) * wid ) as integer
				--local y_ = ( (1-mY-mHeight/2) * hei ) as integer

				local x_ = ( -(mX-(mX as integer)) * wid ) as integer
				local y_ = ( -(1-(mY - (mY as integer))-mHeight) * hei ) as integer
					
				--local x = ( pos.x * wid ) as integer
				--local y = ( pos.y * hei ) as integer
					
				local x = if x_ >= 0 then "+" + (abs(x_) as string) else "-" + (abs(x_) as string)
				local y = if y_ >= 0 then "+" + (abs(y_) as string) else "-" + (abs(y_) as string)
				
				--x = "+0"
				--y = "+0"
					
				format "scale=% x=% y=% pos=% wid=% hei=% mX=% mY=% mWidth=% mHeight=%\n " sc x y pos wid hei mX mY mWidth mHeight

				--HiddenDOSCommand ("magick " + "\"" + finalpath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:start
				HiddenDOSCommand ("magick " + "\"" + finalpath + "\"" + " -resize " + (sc*100) as string + "%% " + "\"" + finalpath + "\"") startpath:start
				local cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
				--local cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + "+0+0" + " -virtual-pixel Background -filter point -distort SRT 0 +repage -roll " + x as string + "x" + y as string + " " + "\"" + finalpath + "\""
				--local cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + ((wid * sc) as integer) as string + "x" + ((hei * sc) as integer) as string + "+0+0 -virtual-pixel Background -filter point -distort SRT 0 +repage -resize " + wid as string + "x" + hei as string + "^! -roll " + x as string + "x" + y as string + " " + "\"" + finalpath + "\""
				--local cmd = if alpha then "magick " + "\"" + finalpath + "\"" + " -filter point -resize " + (100/sc) as string + "^% +repage -background none -alpha Background -gravity southeast -extent " + wid as string + "x" + hei as string + " -roll " + x as string + "x" + y as string + " -define png:color-type=6 " + "\"" + finalpath + "\"" 
				--	else "magick " + "\"" + finalpath + "\"" + " -filter point -resize " + (100/sc) as string + "^% +repage -background black -alpha remove -alpha off -gravity southeast -geometry " + x + y + " -extent " + wid as string + "x" + hei as string + " -define png:color-type=6 " + "\"" + finalpath + "\"" 
				print cmd
				HiddenDOSCommand cmd startpath:start
				HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:start
			)	
		)
	)	

	fn copy_mat tex_ini tex_fin start =
	(
		--format "from=% to=%\n" tex_ini tex_fin
		if doesfileexist tex_ini then
		(
			if not doesfileexist tex_fin then HiddenDOSCommand ("magick " + "\"" + tex_ini + "\""+ " PNG24:" + "\""+ tex_fin + "\"") startpath:start
			--if doesfileexist tex_fin then deletefile tex_fin
			--copyfile tex_ini tex_fin
		)
		true
	)
	
	fn render_map tex size filename =
	(
		if tex != undefined then
		(
			local rm = renderMap tex size:[size, size] fileName:filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			save rm quiet:true gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if doesFileExist rm.filename then print ("saved rendered map " + (filename as string)) else print ("did not save rendered map " + (filename as string) ) 
			close rm	
			free rm			
		)		
	)
	
	fn valid_bump c = 
	(
		local r = false
		r = case of
		(
			--(c.r >= 254 and c.g >= 254 and c.b >= 254): true
			(c.r <= 1 and c.g <= 1 and c.b >= 254): true
			(c.r >= 254 and c.g <= 1 and c.b >= 254): true
			(c.r <= 1 and c.g >= 254 and c.b >= 254): true
			( abs(c.r - 128) <= 1 and abs(c.g - 128) <= 1 and c.b >= 254): true
			default: false
		)			
		r
	)
	
	fn valid_opacity c = 
	(
		local r = false
		r = case of
		(
			(c.r >= 254 and c.g >= 254 and c.b >= 254): true
			(c.r <= 1 and c.g <= 1 and c.b <= 1): true
			(c.r == c.g and c.r == c.b and c.b == c.g): true
			default: false
		)			
		r
	)
	
	fn valid_reflect c = 
	(
		local r = false
		r = case of
		(
			(c.r >= 254 and c.g >= 254 and c.b >= 254): true
			(c.r <= 1 and c.g <= 1 and c.b <= 1): true
			(c.r == c.g and c.r == c.b and c.b == c.g): true
			default: false
		)			
		r
	)
	
	fn render_map_rect tex size size_thumb filename not_make_thumb start type =
	(
		if tex != undefined then
		(
			print tex
			
			local size1 = size
			local size2 = size
			
			local _copy_ = false
			local filename_temp = filename + ".png" --??? ???????? ????? ?????????? ??????, ?????? = ?????????? ?????
			
			--???? ???????? ???????? ? ?????? ???????, ?? ?? ????????, ???? ???	?? ????????, ????? ?????????, ???? ?? ? ???????? ???????? filename, ????? ??? ?????? ?????
			if isproperty tex #filename then --if hasProperty tex "filename" then 
			(
				local tex_filename = ""
				for m in (getmaps (tex.filename as string)) where doesFileExist m do (tex_filename = m; exit) --???? ???????? ?? ?????? ?? ????, ? ?? assettracker
				
				local b = openBitMap (tex_filename as string) gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
				if b != undefined then
				(
					format "% % %\n" b b.width b.height

					if b.width != b.height then
					(
						if b.width > b.height then 
						(
							size1 = size
							size2 = size * b.height / b.width
						)
						else
						(
							size2 = size
							size1 = size * b.height / b.width					
						)
					)	
					
					if b.width == size and b.height == size then _copy_ = true
						
					if not not_make_thumb and b.width == size_thumb and b.height == size_thumb then 
					(
						size1 = size_thumb
						size2 = size_thumb
					)
					
					close b
					free b	
					
					if doesFileExist filename then deleteFile filename
					if _copy_ then 
					(
						if type != "Opacity" then 
						(
							/*
							if (getFilenameType (tex.filename as string)) == ".png" then 
							(
								copyFile (tex.filename as string) filename
								--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -background black -alpha remove -alpha off " + "\"" + filename + "\"") startpath:start --(getINISetting (GetDir #maxroot + "\\GeoScripts\\GeoAGR.ini") "Directories" "ImageMagick")
								--print ("copied " + (tex.filename as string) + " to " + (filename as string))
							)
							else 
							(
								HiddenDOSCommand ("magick " + "\"" + (tex.filename as string) + "\"" + " -define png:color-type=6 " + "\"" + filename + "\"") startpath:start --(getINISetting (GetDir #maxroot + "\\GeoScripts\\GeoAGR.ini") "Directories" "ImageMagick")
								--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off " + "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())
								--print ("magick " + "\"" + (tex.filename as string) + "\"" + " " + "\"" + filename + "\"")
							)
							*/
							HiddenDOSCommand ("magick " + "\"" + (tex_filename as string) + "\"" + " -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						)
						else
						(
							local alpha = false
							local b = openBitMap (tex_filename as string) gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
							if b != undefined then
							(
								if b.hasalpha then alpha = true else alpha = false
								close b
								free b		
									
								if alpha then
								(
									HiddenDOSCommand ("magick " + "\"" + (tex_filename as string) + "\"" + " -background black -alpha extract -unique-colors " + "\"" + filename_temp + "\"") startpath:start
									local bt = openBitMap filename_temp gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
									if bt != undefined then
									(
										if bt.width == 1 then 
										(
											--messageBox ("has alpha, width 1")
											HiddenDOSCommand ("magick " + "\"" + (tex_filename as string) + "\"" + " -threshold 50%% -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
										)
										else
										(
											--messageBox ("has alpha, width >1")
											HiddenDOSCommand ("magick " + "\"" + (tex_filename as string) + "\"" + " -transparent black -background black -alpha extract -threshold 50%% -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
										)
										close bt
										free bt	
										--if doesFileExist filename then deleteFile filename
										--HiddenDOSCommand ("magick " + "\"" + filename + ".jpg" + "\"" + " " + "\"" + filename + "\"") startpath:start	
										--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -alpha extract -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
									)
								)
								else
								(
									--messageBox ("no alpha")
									HiddenDOSCommand ("magick " + "\"" + (tex_filename as string) + "\"" + " -threshold 50%% -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
								)
							)
							--HiddenDOSCommand ("magick " + "\"" + (tex.filename as string) + "\"" + " " + "\"" + filename + "\"") startpath:start --(getINISetting (GetDir #maxroot + "\\GeoScripts\\GeoAGR.ini") "Directories" "ImageMagick")
						)
					)
				)
			)
			--print (classof tex)
			--print filename
			format "copy=%\n" _copy_
			if not _copy_ then
			(
				if doesFileExist filename then deleteFile filename
				local rm = renderMap tex size:[size1, size2] fileName:filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
				save rm quiet:true gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
				if doesFileExist rm.filename then print ("saved rendered map " + (filename as string)) else print ("did not save rendered map " + (filename as string)) 
				close rm	
				free rm		
			)

			case type of
			(
				"Diffuse":
				(
					HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -background black -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start --(getINISetting (GetDir #maxroot + "\\GeoScripts\\GeoAGR.ini") "Directories" "ImageMagick")
				)
				
				"Bump":
				(
					--????????? ????? ?? ??????? normal, ???? ?? ???, ?????? ????? ??????
					--HiddenDOSCommand ("normalmap.exe " + "\"" + filename + "\"" + " " + "\"" + filename + "\"" ) startpath:start
					HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -separate -threshold 50%% -combine -colors 32 -unique-colors " + "\"" + filename_temp + "\"") startpath:start
					local bt = openBitMap filename_temp gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
					if bt != undefined then
					(
						bt.gamma = 1.0
						local colors_quantity = #()
						if bt.width <= 32 then 
						(
							local line_bitmap = getPixels bt [0, 0] bt.width linear:true
							for pixel in line_bitmap where valid_bump pixel do append colors_quantity pixel							
							if (colors_quantity.count == 1 and bt.width == 1) or (colors_quantity.count == 4 and bt.width == 4) then ()
							else HiddenDOSCommand ("normalmap.exe " + "\"" + filename + "\"" + " " + "\"" + filename + "\"" ) startpath:start
						)
						else HiddenDOSCommand ("normalmap.exe " + "\"" + filename + "\"" + " " + "\"" + filename + "\"" ) startpath:start
						close bt
						free bt
					)
				)
				
				"Reflect":
				(
					--????????? ?????, ???? ?? ??, ?????? ?? ? ???????? ??? erm ?????
					--?????????, ???? erm ????? ?? ?????, ?? ?????? ?? ??????, ???? ? ????? ?????????
					if findstring (getfilenamefile filename) "_ERM_" == undefined then 
					(
						HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -separate -threshold 50%% -combine -colors 32 -unique-colors " + "\"" + filename_temp + "\"") startpath:start
						local bt = openBitMap filename_temp gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
						if bt != undefined then
						(
							bt.gamma = 1.0
							local colors_quantity = #()
							if bt.width <= 32 then 
							(
								local line_bitmap = getPixels bt [0, 0] bt.width linear:true
								for pixel in line_bitmap where valid_reflect pixel do append colors_quantity pixel							
								if colors_quantity.count != bt.width then 
								--?????? ?? ????????, ???????? ? ????? ERM
								HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -monochrome -channel G -separate -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
							)
							close bt
							free bt
						)						
					)
					
				)
				
				"Opacity":
				(

					--???????? ?????, ????????? ???? ?? ????? ????????, ???? ??, ?? ????????? ??? ????
					--print ("magick " + "\"" + filename + "\"" + " -background black -alpha extract -monochrome -alpha remove -alpha off png:color-type=6 " + "\"" + filename+ "\"")
					--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -background black -alpha extract -threshold 50%% -alpha remove -alpha off -monochrome " + "\"" + filename + ".jpg" + "\"") startpath:start
					--HiddenDOSCommand ("magick " + "\"" + filename + ".jpg" + "\"" + " " + "\"" + filename + "\"") startpath:start
					--if doesFileExist (filename + ".jpg") then deleteFile (filename + ".jpg")
					--if doesFileExist (filename + ".jpg") then copyFile (filename + ".jpg") filename

					local alpha = false
					local b = openBitMap filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
					if b != undefined then
					(
						if b.hasalpha then alpha = true else alpha = false
						close b
						free b		
									
						if alpha then
						(
							HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -background black -alpha extract -unique-colors " + "\"" + filename_temp + "\"") startpath:start
							local bt = openBitMap filename_temp gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
							if bt != undefined then
							(
								if bt.width == 1 then --?????????? ? ???? ????????? ?????
								(
									--messageBox ("has alpha, width 1")
									HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off -threshold 50%% -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
								)
								else
								(
									--messageBox ("has alpha, width >1")
									HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -background black -alpha extract -threshold 50%% -alpha remove -alpha off -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
								)
								close bt
								free bt	
								--if doesFileExist filename then deleteFile filename
								--HiddenDOSCommand ("magick " + "\"" + filename + ".jpg" + "\"" + " " + "\"" + filename + "\"") startpath:start	
								--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -alpha extract -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
							)
						)
						else
						(
							--messageBox ("no alpha")
							HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off -threshold 50%% -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						)
					)
						

						/*
						if b.hasalpha then 
						(
							HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -background black -alpha extract -threshold 50%% -alpha remove -alpha off " + "\"" + filename + "\"") startpath:start
							--if doesFileExist filename then deleteFile filename
							--HiddenDOSCommand ("magick " + "\"" + filename + ".jpg" + "\"" + " " + "\"" + filename + "\"") startpath:start	
							--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -alpha extract -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						)
						else 
						(
							HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -threshold 50%% -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
						)
						close b
						free b								
					*/
					
					/*			
					HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -separate -threshold 50%% -combine -colors 32 -unique-colors " + "\"" + filename_temp + "\"") startpath:start
					local bt = openBitMap filename_temp gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
					if bt != undefined then
					(
						bt.gamma = 1.0
						local colors_quantity = #()
						if bt.width <= 32 then 
						(
							local line_bitmap = getPixels bt [0, 0] bt.width linear:true
							for pixel in line_bitmap where valid_opacity pixel do append colors_quantity pixel							
							if colors_quantity.count != bt.width then 
							(
								--???????? ?????, ???? ????, ???? ??? - ?????? ?? ????????
								local b = openBitMap filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
								if b != undefined then
								(
									if b.hasalpha then HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -transparent black -alpha extract -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
									else HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -monochrome -define png:color-type=6 " + "\"" + filename + "\"") startpath:start
									close b
									free b								
								)
							)
							else
						)
						close bt
						free bt
					)
					*/
				)
			)
			
			local b = openBitMap filename gamma:1.0 inputGammaValue:1.0 inputGamma:1.0 
			if b != undefined then
			(
				local b_width = b.width
				local b_height = b.height
				close b
				free b	
				--if not not_make_thumb and b_width == size_thumb and b_height == size_thumb then 
				if (b_height != size or b_width != size) and (b_width != size_thumb and b_height != size_thumb) then
				(
					HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -interpolate Integer -filter point -resize " + size as string + "x" + size as string + "^! -define png:color-type=6 " + "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())
				)
			)
			--HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -alpha remove -alpha off " + "\"" + filename + "\"") startpath:start --(GetINI_ImageMagick())
			if doesFileExist filename_temp then deleteFile filename_temp
		)		
	)
	
	fn ClearSpline tol =
	(
		for spl in selection do 
			(
				if classof spl==SplineShape or classof spl==line do
				(
					numLine=numSplines spl
					subSplinesArr=for i in 1 to numLine collect i
					for iLine in subSplinesArr do
					(
						bl = isClosed spl iLine
						--p1, p2, p3, v1, v2, Angle, comAng
						iKnots = numKnots spl iLine
						if iKnots < 3 do continue
						i=1
						while (i+2) <= iKnots do
						(
							p1=getKnotpoint spl iLine i
							p2=getKnotpoint spl iLine (i+1)
							p3=getKnotpoint spl iLine (i+2)
							v1=p1-p2
							v2=p3-p2
							Angle = acos (dot (normalize v1) (normalize v2))
							comAng=int(Angle*100)/100.0							
							if comAng>=180.0-tol then (deleteKnot spl iLine (i+1)) else i+=1
							iKnots = numKnots spl iLine
						)
						if bl do
						(
							p1 = getKnotPoint spl iLine (iKnots-1)
							p2 = getKnotPoint spl iLine iKnots
							p3 = getKnotPoint spl iLine 1
							v1=p1-p2
							v2=p3-p2
							Angle = acos (dot (normalize v1) (normalize v2))
							comAng=int(angle*100)/100.0
							if comAng>=180.0-tol then deleteKnot spl iLine iKnots
						)
					)
					updateShape spl
					--redrawviews()
				)--endif
			)--end s
	)
	
	fn resize_texture sourcepath filename res1 res2 =
	(		
		bm_source = openbitmap sourcepath
		bm_final = bitmap res1 res2 filename:filename hdr:false hasalpha:(bm_source.hasalpha)
		copy bm_source bm_final
		close bm_source
		free bm_source
		save bm_final
		close bm_final
		free bm_final
	)
	
	fn edge_lenght poly e =
	(	
		local vv = polyop.getVertsUsingEdge poly #{e}
		local pp = for v in vv collect polyop.getVert poly v
		distance pp[1] pp[2]
	)
	
	fn union a b =
	(	
		for i in a do appendifunique b i
		b
	)
	
	fn detriangulate poly edges faces uv sm ang an disputed del inv =
	(
		case of 
		(
			(sm and not uv and ang):
				for i in edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 --returns 0 as there is no second face 
					f2 = poly.GetEdgeFace i 2 --returns 0 as there is no second face 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 or acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then edges -= #{i}
					--p.GetVertexEdgeCount 1 --returns 2 for a corner vertex			
				)
			(not sm and not uv and ang): 
				for i in edges where not keyboard.escPressed do --for i in edges where not keyboard.escPressed and ((poly.GetEdgeFace i 1) == 0 or (poly.GetEdgeFace i 2) == 0) do edges -= #{i}
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then edges -= #{i}
				)
			(sm and uv and ang):
				for i in edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 or (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 or acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then edges -= #{i}						
				)
			(not sm and uv and ang):
				for i in edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 or acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then edges -= #{i}						
				)		
			(sm and not uv and not ang):
				for i in edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 then edges -= #{i}
				)
			(not sm and not uv and not ang): 
				for i in edges where not keyboard.escPressed and ((poly.GetEdgeFace i 1) == 0 or (poly.GetEdgeFace i 2) == 0) do edges -= #{i}
			(sm and uv and not ang):
				for i in edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 or (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 then edges -= #{i}						
				)
			(not sm and uv and not ang):
				for i in edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then edges -= #{i}
					else if (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 then edges -= #{i}						
				)			
		)
		--edges ??????? ??? ????????? ?????, ??? ?????? ????? ???????????, ??? ?????? ?????????, ??? ?????????? ?????

		edges_ = #{}
		for f in faces where (polyop.getFaceDeg poly f) < 4 and not keyboard.escPressed do --????????? ?????? ? ?????? ?????? ????? 3, ??? ??? ?????????????????
		(
			ee = polyop.getEdgesUsingFace poly #{f}
			ee = ee - (-edges) --?? ???? ????? ???????? ???????? ???????? ?????????? ?????? ?????
			m = amax (for e in ee collect (edge_lenght poly e))
			for e in ee where m == edge_lenght poly e do edges_ += #{e} --???? ????? ???????, ???????? ???
		)
		
		--edges ??????? ? ?????? ???????? ???????
		
		--????????? ?????, ? ??????? ?? ????????? ????? ???????? ? ??????, ????????
		--????????????? ? ????????? ? ?????????
		if disputed then for f in faces where not keyboard.escPressed do
		(
			ee = polyop.getEdgesUsingFace poly #{f}
			if (ee * edges_).numberset > 1 then
			(			
				ee = ee - (-edges) --?? ???? ????? ???????? ???????? ???????? ?????????? ?????? ?????
				m = amax (for e in ee collect (edge_lenght poly e))
				for e in ee where m > edge_lenght poly e do edges_ -= #{e} --???? ????????, ????????? ???
			)
		)		
		
		if not inv then
		(
			polyOp.setEdgeSelection poly edges_
			if del then undo "Detriangulate" on poly.remove selLevel:#edge
		)
		else
		(
			polyOp.setEdgeSelection poly ((polyop.getEdgesUsingFace poly faces) - edges_)
		)
	)

	fn select_edges poly edges faces uv sm ang an spn = --?? ???????? ????????? ?????? ? ?????? ??? ???? ?? ?????
	(
		--?? ?????? ???? ? ???????????????, ?? ????? ???????? ????, ??????????? ? ????? ?????? ? ??????? ??????????? ????? ?????????? ?? ?????????
		
		all_edges = #{1..polyop.getNumEdges poly} --polyop.getEdgesUsingFace poly faces
		sel_edges = #{}
		sel_edges = polyop.getOpenEdges poly --??????? ???????, ???? ??????? ???? ?? ?????????????? ??????
		
		sel_edges = edges * sel_edges --?????? ??????? ?????????? ????????? 
		
		--??????? ????? ????? ?? ??????? ???, ???????? ???????, ???????
		case of 
		(
			(sm and not uv and ang):
				for i in edges - sel_edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 --returns 0 as there is no second face 
					f2 = poly.GetEdgeFace i 2 --returns 0 as there is no second face 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 or acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then sel_edges += #{i}
					--p.GetVertexEdgeCount 1 --returns 2 for a corner vertex			
				)
			(not sm and not uv and ang): 
				for i in edges - sel_edges where not keyboard.escPressed do --for i in edges where not keyboard.escPressed and ((poly.GetEdgeFace i 1) == 0 or (poly.GetEdgeFace i 2) == 0) do edges -= #{i}
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then sel_edges += #{i}
				)
			(sm and uv and ang):
				for i in edges - sel_edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 or (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 or acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then edges -= #{i}						
				)
			(not sm and uv and ang):
				for i in edges - sel_edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 or acos(dot (polyOp.getFaceNormal poly f1) (polyOp.getFaceNormal poly f2)) >= an then sel_edges += #{i}						
				)		
			(sm and not uv and not ang):
				for i in edges - sel_edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 then sel_edges += #{i}
				)
			(not sm and not uv and not ang): () --?????? ????????? ???? ??? ??????? ????
				--for i in edges - sel_edges where not keyboard.escPressed and ((poly.GetEdgeFace i 1) == 0 or (poly.GetEdgeFace i 2) == 0) do sel_edges += #{i}
			(sm and uv and not ang):
				for i in edges - sel_edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if (bit.and (poly.getFaceSmoothingGroups f1) (poly.getFaceSmoothingGroups f2)) == 0 or (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 then sel_edges += #{i}						
				)
			(not sm and uv and not ang):
				for i in edges - sel_edges where not keyboard.escPressed do
				(
					f1 = poly.GetEdgeFace i 1 
					f2 = poly.GetEdgeFace i 2 
					if f1 == 0 or f2 == 0 then sel_edges += #{i}
					else if (union (polyOp.getMapFace poly 1 f1) (polyOp.getMapFace poly 1 f2)).count > 4 then sel_edges += #{i}						
				)			
		)
		--print #(sel_edges)
		
		-- edges ??????? ??? ????????? ?????, ??? ?????? ????? ???????????, ??? ?????? ?????????, ??? ?????????? ?????
		-- sel_edges ?????-?? ?????, ??????? ????? ???? ???????, ?? ??? ??? ?? ???
		
		--polyop.getOpenEdges <Poly poly>
		--polyop.getBorderFromEdge <Poly poly> <int edge>
		
		--edges -= sel_edges 

		bad = #{}
		good = #{} --sel_edges
		last = #{}
		last += sel_edges
		--current = #{} 
		angle = 45.0
		--while edges.numberset > 0 do
		--(
			print (edges.numberset)
			--if keyboard.escPressed then exit --with good
			--current = last
			for e in sel_edges where not keyboard.escPressed do
			(
				last = #{}
				vv1 = polyop.getVertsUsingEdge poly #{e} -- ????? ?? ???? ?????? ?? ?????????? ?????
				--ee = polyop.getEdgesUsingVert poly vv1 --????? ????? ?? ???? ??????
				--ee -= #{e} --????????? ???????? ?????
				--pp1 = for v in vv1 collect polyop.getVert poly v --??????? ????? ? ????? ?????		
				--vv2 = polyop.getVertsUsingEdge poly ee --????? ?????? ?????? ?????
				--pp2 = for v in vv2 collect polyop.getVert poly v --??????? ????? ? ?????? ??????	
				--vv2 -= vv1 --????????? ????? ????? ????? (? ???? ?????? ????? ?? ?????)
				
				pp1 = for v in vv1 collect polyop.getVert poly v
				for v in vv1 do
				(
					p1 = polyop.getVert poly v --????? ?? ????????? ???????
					ee = polyop.getEdgesUsingVert poly #{v} --????? ????? ?? ??????? ???????  
					--ee -= #{e} --????????? ???????? ?????
					edges -= ee
					--ee ??????? 3 ??, ?????? ?? 7 ?? ? ?????, ???? ??????? ???? ?? ???? 
					for ed in ee where d != e do
					(
						vv2 = polyop.getVertsUsingEdge poly #{ed} --????? ?????? ?????? ?? ??????? ?????
						vv2 -= #{v} --????????? ????? ???????
						pp2 = for w in vv2 collect polyop.getVert poly w --??????? ????? ? ?????? ????????
		
						for p2 in pp2 do
						(
							if p1 == pp1[1] then 
								angle = acos (dot (normalize (pp1[1] - pp1[2])) (normalize (pp1[1] - p2))) 
							else 
								angle = acos (dot (normalize (pp1[2] - pp1[1])) (normalize (pp1[2] - p2))) 	
							--print angle
							case of
							(				
								(angle >= abs(90 - spn) and angle <= (90 + spn)): last += #{ed}
								(angle >= abs(180 - spn) and angle <= (180 + spn)): last += #{ed}
								(angle <= spn): last += #{ed}
								default: bad += #{ed}
							)
							print last.numberset
						)
					)
				)
			)
			good += last
			--edges -= good
			--edges -= bad
			
		--)
		good += sel_edges
		
		polyOp.setEdgeSelection poly good
		/*
				for v in Verts where (nEdges = thePoly.GetVertexEdgeCount v) == 2 do 
				--for v in Verts where (nEdges = polyop.getEdgesUsingVert thePoly v).numberset == 2 do
				(
					if keyboard.escPressed then exit
					--if getProgressCancel() then exit
					--progressUpdate (100*v/cou)
					vv = #{} --????? ?????? ?? ?????? ?????
					for e in nEdges do vv += polyop.getVertsUsingEdge thePoly #{e} --???????? ?? ?????? ?????? ? ????? ????? ??????
					vv -= #{v} --????????? ?? ?????? ????? ???????
					p1 = polyop.getVert thePoly v --??????? ????? ? ????? ???????
					pp = for w in vv collect polyop.getVert thePoly w --??????? ??? ??? ????? ?? ?????? ??????
					angle = acos (dot (normalize (p1 - pp[1])) (normalize (p1 - pp[2]))) 				
					if angle >= abs(180 - spn) or angle <= abs(spn) then Verts_Err += #{v} --???? ???? ????? ?????????, ?????????? ?? ????? ?????, ??????????? ? == 180 ????????, ?? ??? ? ???? ?????? - ??????? ???????; ?????, ???? ??????? ?????????? ???? ? ????? ?? ?????? ?????; ?????, ???? ?????????? ? ???? ??????? ?? ?????? ?????, ????? ???? ????? 0 --if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
				)
		*/
		--for f in faces where not keyboard.escPressed do 
		--(
		--	ee = polyop.getEdgesUsingFace poly #{f}
			
			--ee = ee - (-edges) --?? ???? ????? ???????? ???????? ???????? ?????????? ?????? ?????
			--m = amax (for e in ee collect (edge_lenght poly e))
			--for e in ee where m == edge_lenght poly e do edges_ += #{e} --???? ????? ???????, ???????? ???
		--)

		--polyOp.setEdgeSelection poly sel_edges
	)	
	
	fn transfer_edges_new =
	(	
		if selection.count == 1 then if selection[1].modifiers.count > 0 then undo "Collapse All" on convertToPoly selection[1]
		if selection.count == 1 and classof selection[1].baseobject == Editable_Poly then
		(
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			sel = selection[1].baseobject
					
			edges = #{}
			verts_ALL = #()
			edges_ = #{}
			--verts_ = #{}
			edges_good = #{}
				
			edges = polyop.getEdgeSelection sel
			--print #(edges)
			if not edges.isempty then 
				for i in edges do
				(
					verts = #()
					verts = polyop.getEdgeVerts sel i
					--print #(verts)
					append verts_ALL #{verts[1], verts[2]} 
					--join verts_ (verts as bitarray)
				)
			--polyop.setVertSelection sel verts_
			--subObjectLevel = 1							
		)
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			print #(verts_ALL)
			unwrapmod.setPolygonMode false
			unwrapmod.setTVElementMode false
			unwrapmod.unhide()
			unwrapmod.setTVSubObjectMode 2
			--verts_ = unwrapmod.getSelectedGeomVerts() 			
			--print #(verts_)
			--unwrapmod.selectVertices verts_
			--unwrapmod.vertToEdgeSelect()
			--unwrapmod.setTVSubObjectMode 2
			--unwrapmod.syncTVSelection()
			
			--<bitArray><Unwrap_UVW>.getSelectedGeomVertsByNode <node>node 
			--<void><Unwrap_UVW>.setSelectedGeomVertsByNode <bitArray>selection <node>node 
			
			faces_all_ = #{1..unwrapmod.numberPolygons()}
			unwrapmod.selectFaces faces_all_
			--<integer><Unwrap_UVW>.NumberVertices() 
			unwrapmod.faceToEdgeSelect() 
			--<void><Unwrap_UVW>.edgeToVertSelect() 
			edges_all_ = unwrapmod.getSelectedEdges()
			print #(edges_all_)
			
			for e_ in edges_all_ do
			(
				unwrapmod.selectEdges #{e_}
				unwrapmod.edgeToVertSelect() 
				unwrapmod.setTVSubObjectMode 1
				vv_ = unwrapmod.getSelectedVertices()
				unwrapmod.setSelectedGeomVertsByNode vv_ selection[1]
				polyop.setVertSelection sel vv_
				vv = polyop.getVertSelection sel 
				--vv = unwrapmod.getSelectedGeomVertsByNode selection[1]
				--print #(vv_)
				--print #(vv)
				if finditem verts_ALL vv != 0 then edges_good += #{e_}
					
				--exit
			)
			
			/*
			for v in verts_ALL do
					(
						edges_ = #{}
						unwrapmod.selectVertices v
						unwrapmod.vertToEdgeSelect()
						edges_ = unwrapmod.getSelectedEdges() --join edges_ (unwrapmod.getSelectedEdges())
						
						for e in edges_ do 
						(
							unwrapmod.selectEdges #{e}
							ve = #{}
							unwrapmod.edgeToVertSelect() 
							ve = unwrapmod.getSelectedVertices()
							format "ve=% v=%\n" ve v
							if (ve as array)[1] == (v as array)[1] and (ve as array)[2] == (v as array)[2] then append edges_good e
						)
					)	*/
			print edges_good
			unwrapmod.setTVSubObjectMode 2 
			if not edges_good.isempty then 
			(
				unwrapmod.selectEdges edges_good
			)

			
		)
		redrawViews()		
	)

		fn transfer_edges =
		(	
			if selection.count == 1 then if selection[1].modifiers.count > 0 then undo "Collapse All" on convertToPoly selection[1]
			if selection.count == 1 and classof selection[1].baseobject == Editable_Poly then
			(
				max modify mode
				unwrapmod = modpanel.getcurrentobject()
				sel = selection[1] --.baseobject
					
				edges = #{}
				verts_ALL = #()
				edges_ = #{}
				verts_ = #{}
				edges_good = #{}
					
				edges = polyop.getEdgeSelection sel
				print #(edges)
				if not edges.isempty then 
					for i in edges do
					(
						verts = #()
						verts = polyop.getEdgeVerts sel i
						--print #(verts)
						append verts_ALL #{verts[1],verts[2]} 
						join verts_ (verts as bitarray)
					)
				polyop.setVertSelection sel verts_
				--subObjectLevel = 1				
				
				if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
				(
					addmodifier selection[1] (Unwrap_UVW())
					unwrapmod = modpanel.getcurrentobject()
				)
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					print #(verts_ALL)
					unwrapmod.setPolygonMode false
					unwrapmod.setTVElementMode false
					unwrapmod.unhide()
					unwrapmod.setTVSubObjectMode 1
					verts_ = unwrapmod.getSelectedGeomVerts() 
					--unwrapmod.vertToEdgeSelect()
					--unwrapmod.setTVSubObjectMode 2
					unwrapmod.selectVertices verts_
					
					--<point3><Unwrap_UVW>.GetVertexPositionByNode <time>time <integer>index <node>node 
					--<void><Unwrap_UVW>.setSelectedGeomVerts <bitArray>selection 
					--<bitArray><Unwrap_UVW>.getSelectedGeomVertsByNode <node>node 
					--<void><Unwrap_UVW>.selectEdges <bitArray>selection 
					--<point3><Unwrap_UVW>.getVertexPosition <time>time <integer>index 
					--<void><Unwrap_UVW>.setSyncSelectionMode <boolean>sync --Sets the Sync. to Viewport mode. 
					--<void><Unwrap_UVW>.syncTVSelection() --Synchronizes the selection in the Editor to reflect the viewport selection
					
					for v in verts_ALL do
					(
						edges_ = #{}
						unwrapmod.selectVertices v
						unwrapmod.vertToEdgeSelect()
						edges_ = unwrapmod.getSelectedEdges() --join edges_ (unwrapmod.getSelectedEdges())
						
						for e in edges_ do 
						(
							unwrapmod.selectEdges #{e}
							ve = #{}
							unwrapmod.edgeToVertSelect() 
							ve = unwrapmod.getSelectedVertices()
							format "ve=% v=%\n" ve v
							if (ve as array)[1] == (v as array)[1] and (ve as array)[2] == (v as array)[2] then append edges_good e
						)
					)
					print edges_good
					unwrapmod.setTVSubObjectMode 2 
					if not edges_good.isempty then 
					(
						unwrapmod.selectEdges edges_good
					)
				)
			)
			redrawViews()
		)

	
	fn getFirstElBitarray a =
    (
        for i = 1 to a.count where a[i] do return i --?????? ????????, ????? ? ????? ????? ?????? ??-? ? ???????? ?? ????
        0
    )

	fn ReadAllLines excel_file = 
	(
		if doesfileexist excel_file then 
		(
			try
			(
				local stri = (dotNetClass "System.IO.File").ReadAllLines excel_file ((dotNetClass "System.Text.Encoding").UTF8)
				stri
			)
			catch
			(
				messagebox ("???? ????? ?????? ??????????\n" + excel_file)
				local stri = ""
				stri
			)
		)
		else
		(
			local stri = ""
			stri	
		)
	)

	fn WriteAllLines excel_file excel = 
	(
		try
		(
			--Writer = dotNetObject"System.IO.StreamWriter" excel_file false ((dotNetClass "System.Text.Encoding").GetEncoding("Windows-1251")) --ANSI
			--local Writer = dotNetObject"System.IO.StreamWriter" excel_file false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-16LE"))
			local Writer = dotNetObject"System.IO.StreamWriter" excel_file false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-8"))
			Writer.Write(excel)
			Writer.Close()
			free Writer
			free excel_file
			free excel
		)
		catch(print ("???? ?? ???????: " + excel_file))
	)
	
	fn redrawscr_laca = gw.updatescreen()

	fn VertexShow = 
	(
		try 
		(
			if viewport.activeViewport != lastviewport do 
			(
				completeredraw()
				lastViewport = viewport.activeViewport 
			)
			if (selection.count == 1) and ((classof $.baseobject == Editable_Mesh) or (classof $.baseobject == Editable_Poly)) then
			(
				gw.setTransform (matrix3 1)
				if (classof $ == Editable_Mesh) then
					for gw_i in (getvertselection $) do gw.wtext ((gw.wTransPoint (getvert $ gw_i)) + [5,-5,0]) (gw_i as string) color:[231,217,55]
				else
					for gw_i in (polyop.getvertselection $.baseobject) do gw.wtext ((gw.wTransPoint (polyop.getvert $ gw_i)) + [5,-5,0]) (gw_i as string) color:[231,217,55]
				gw.enlargeupdaterect #whole
			)
		)
		catch()
	)

	fn FaceShow = 
	(
		try 
		(
			if viewport.activeViewport != lastviewport do 
			(
				completeredraw()
				lastViewport = viewport.activeViewport 
			)
			if (selection.count == 1) and ((classof $.baseobject == Editable_Mesh) or (classof $.baseobject == Editable_Poly)) then
			(
				gw.setTransform (matrix3 1)
				if (classof $ == Editable_Mesh) then
					for gw_i in (getfaceselection $) do 
					(
						local posss = [0,0,0]
						local face_i = meshop.getfacecenter $ gw_i
						gw.wtext ((gw.wtransPoint face_i)+[0,0,100]) (gw_i as string) color:[255,255,255]
					)
				else 
				(
					for gw_i in (polyop.getfaceselection $.baseobject) do 
					(
						local face_i = polyop.getfacecenter $ gw_i
						gw.wtext ((gw.wtransPoint face_i)+[0,0,100]) (gw_i as string) color:[255,255,255]
					)
				)				
				gw.enlargeupdaterect #whole
			)
		)
		catch()
	)
	
	fn GetBitmapTextures_Paths theObjects name_from name_to =
	(
		texMaps = #()
		for obj in theObjects do join texMaps (getClassInstances bitmapTexture target:obj asTrackViewPick:off) --for obj in theObjects do join texMaps (usedMaps obj) 
		--makeUniqueArray texMaps
		for i in texMaps where hasproperty i "filename" do i.filename = substitutestring i.filename name_from name_to
		texMaps
	)

	fn GetBitmapTextures theObjects name_from name_to =
	(
		subMapContainers = #()
		for obj in theObjects where obj.material != undefined do
		(
			for i in 1 to getNumSubMtls obj.material do append subMapContainers (getSubMtl obj.material i)
			append subMapContainers (obj.material)
		)
		for subMapContainer in subMapContainers do
		(
			for i in 1 to getNumSubTexmaps subMapContainer do
			(
				theSubTexMap = getSubTexMap subMapContainer i
				if theSubTexMap != undefined then
				(
					if (getNumSubTexmaps theSubTexMap) > 0 then append subMapContainers theSubTexMap
				)
			)
		)
		for i in subMapContainers do i.name = substitutestring i.name name_from name_to
		subMapContainers
	)

	fn GetINI_ImageMagick =
	(
		setIniForceUTF16Default true
		local filenameIni = GetDir #maxroot + "GeoScripts\\GeoAGR.ini" --getFilenamePath(getSourceFileName()) + "GeoAGR.ini"
		--print filenameIni
		local ImageMagickUseScriptDir = "true"
		local DirPath = GetDir #maxroot + "GeoScripts\\"
		
		ImageMagickUseScriptDir = getINISetting filenameIni "Directories" "ImageMagickUseScriptDir"
		if ImageMagickUseScriptDir != undefined then 
			if ImageMagickUseScriptDir != "true" then DirPath = (getINISetting filenameIni "Directories" "ImageMagick")
		print DirPath
		DirPath
	)
	
	fn GetINI_Projects_Names =
	(
		setIniForceUTF16Default true
		local filenameIni = getFilenamePath(getSourceFileName()) + "GeoAGR.ini"
		local NumIni = (getINISetting filenameIni "Projects" "Number") as integer
		local NamesIni = for i in #{1..NumIni} where hasINISetting filenameIni "Projects" ("Name" + (i as string)) collect getINISetting filenameIni "Projects" ("Name" + (i as string))
		NamesIni
	)

	fn GetINI_Current_Project_Name dir =
	(
		setIniForceUTF16Default true
		local filenameIni = getFilenamePath(getSourceFileName()) + "GeoAGR.ini"
		local NumIni = (getINISetting filenameIni "Projects" "Number") as integer
		NamesIni = ""
		for i in #{1..NumIni} where hasINISetting filenameIni "Projects" ("Name" + (i as string)) do 
		(
			NameIni = getINISetting filenameIni "Projects" ("Name" + (i as string))
			Folder = if hasINISetting filenameIni NameIni "Folder" then getINISetting filenameIni NameIni "Folder" else ""
			if Folder == dir then NamesIni = NameIni
		)
		NamesIni
	)

	fn GetINI_Current_Project_Index dir =
	(
		setIniForceUTF16Default true
		local filenameIni = getFilenamePath(getSourceFileName()) + "GeoAGR.ini"
		local NumIni = (getINISetting filenameIni "Projects" "Number") as integer
		index = 0
		for i in #{1..NumIni} where hasINISetting filenameIni "Projects" ("Name" + (i as string)) do 
		(
			NameIni = getINISetting filenameIni "Projects" ("Name" + (i as string))
			Folder = if hasINISetting filenameIni NameIni "Folder" then getINISetting filenameIni NameIni "Folder" else ""
			if Folder == dir then index = i
		)
		index
	)

	fn GetINI_Current_Project_Lowpoly dir =
	(
		setIniForceUTF16Default true
		local filenameIni = getFilenamePath(getSourceFileName()) + "GeoAGR.ini"
		local NumIni = (getINISetting filenameIni "Projects" "Number") as integer
		LowpolyIni = ""
		for i in #{1..NumIni} where hasINISetting filenameIni "Projects" ("Name" + (i as string)) do 
		(
			NameIni = getINISetting filenameIni "Projects" ("Name" + (i as string))
			Folder = if hasINISetting filenameIni NameIni "Folder" then getINISetting filenameIni NameIni "Folder" else ""
			Lowpoly_obj = if hasINISetting filenameIni NameIni "Lowpoly_obj" then getINISetting filenameIni NameIni "Lowpoly_obj" else ""
			if Folder == dir then LowpolyIni = Lowpoly_obj
		)
		LowpolyIni
	)

	fn GetINI_Current_Project_Highpoly dir =
	(
		setIniForceUTF16Default true
		local filenameIni = getFilenamePath(getSourceFileName()) + "GeoAGR.ini"
		local NumIni = (getINISetting filenameIni "Projects" "Number") as integer
		HighpolyIni = ""
		for i in #{1..NumIni} where hasINISetting filenameIni "Projects" ("Name" + (i as string)) do 
		(
			NameIni = getINISetting filenameIni "Projects" ("Name" + (i as string))
			Folder = if hasINISetting filenameIni NameIni "Folder" then getINISetting filenameIni NameIni "Folder" else ""
			Highpoly_objs = if hasINISetting filenameIni NameIni "Highpoly_objs" then getINISetting filenameIni NameIni "Highpoly_objs" else ""
			if Folder == dir then HighpolyIni = Highpoly_objs
		)
		HighpolyIni
	)

	fn GetINI_Folder n =
	(
		setIniForceUTF16Default true
		local Folder = getINISetting (getFilenamePath(getSourceFileName()) + "GeoAGR.ini") n "Folder"
		Folder
	)

	fn GetTexelDensity theMapSize =
	(
		if classof (unwrapmod = modpanel.getcurrentobject()) == unwrap_uvw do --Check the Modifier Class whether it is unwrap_uvw or not
		(
			if (faces = unwrapmod.getselectedfaces()).count > 0 do
			(
				unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom -- Get some information about the selection
				textureArea = theMapSize^2 -- Calculate the total texture area
				usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
				texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
			)
		)
		texelDensity --return value
	) 

	fn GetMetersFromGU = --Function to calculate how many "meters" in system units
	(
		local meters = case units.systemType of
		(
			#Inches: 0.0254
			#Feet: 0.3048
			#Miles: 1609.0
			#Millimeters: 0.001
			#Centimeters: 0.01
			#Meters: 1.0
			#Kilometers: 1000.0
		)
		return meters * units.SystemScale 
	)
	
	fn ConvertImageToBase64String filename =
	(
		if (doesfileexist filename) do
		(
			ConvertClass = dotNetClass "System.Convert"
			ImageClass = dotNetClass "System.Drawing.Image"
			memstream = dotnetobject "System.IO.MemoryStream"
			ImgLoaded = ImageClass.fromfile filename
			ImgLoaded.save memstream ImgLoaded.rawformat
			Base64string = ConvertClass.ToBase64String (memstream.ToArray())
			memstream.close()
			Base64String --return Base64String
		)
	)

	fn ConvertBase64StringToImage string =
	(
		ConvertClass = dotNetClass "System.Convert"
		ImageClass = dotNetClass "System.Drawing.Image"
		bytearr = ConvertClass.FromBase64String string
		memstream = dotnetobject "System.IO.MemoryStream" bytearr
		DecodedImg = ImageClass.fromstream memstream
		memstream.close()
		DecodedImg	--return DecodedImg
	)

	fn getNameFromPath path =
	(
		s = filterString path "\\"
		res = s[s.count]
		res
	)

	fn create_plane imgfilepath =
	(
		sn = getNameFromPath(imgfilepath)
		cmt = Standardmaterial() 
		cmt.name = sn
		cmt.diffuseMap = Bitmaptexture fileName:imgfilepath
		cmt.diffuseMap.coords.realWorldScale = off
		try (NitrousGraphicsManager.SetTextureSizeLimit 2048 true ) catch ()
		cmt.showInViewport = true
		img = cmt.diffuseMap.bitmap
		pp = Plane length:img.height width:img.width lengthsegs:1 widthsegs:1 name:sn --transform:(matrix3 [1,0,0] [0,0,1] [0,-1,0] [0,0,0]) isSelected:off 
		pp.realWorldMapSize = off
		pp.mat = cmt
	)

	fn doubleslash s =
	(
		s = substitutestring s "\\" "\\\\" 
		return s
	)

	fn getMaterialThumbnail mat picpath = 
	(
		local thumb = undefined
		local iGlobal = (dotnetClass "Autodesk.Max.GlobalInterface").Instance
		if iGlobal != undefined then 
		(
			local IntPtr = dotnetClass "System.IntPtr"
			local pStampSize = (dotnetclass "Autodesk.Max.PostageStampSize").Large

			local backupMat = meditMaterials[24]
			meditMaterials[24] = mat
			local matRef = iGlobal.CoreInterface.GetMtlSlot 0

			local pStamp = matRef.CreatePStamp pStampSize true
			local bytes = pStamp.Image
			local size = pStamp.Width
			thumb = bitmap size size gamma:0.45 color:(color 0 0 0 255) filename:picpath hdr:false 
		
			local step = size * 3
			for y = 1 to bytes.count by step do 
			(
				local row = for x = y to (y + step - 1) by 3 collect [bytes[x + 2], bytes[x + 1], bytes[x]]
				setpixels thumb [0, size -= 1] row
			)
			pStamp.Dispose()
			matRef.Dispose()
			meditMaterials[24] = backupMat
			save thumb quiet:true
		)
		return thumb
	)
	--display (getMaterialThumbnail (meditMaterials[1]) "C:\\pic1.png")


	fn flatten =
	(
			for sp in selection do 
			(
					--sp.wireColor = black
					if ((classof sp == SplineShape or classof sp == Line) and sp.modifiers.count == 0) do 
					(
						new_z = sp.pos.z = 0 
						for s = 1 to (numSplines sp) do ( 
							for k = 1 to (numKnots sp s) do ( 
								knt = getKnotPoint sp s k 
								in_vec = getInVec sp s k 
								out_vec = getOutVec sp s k 
								knt.z = in_vec.z = out_vec.z = new_z 
								setInVec sp s k in_vec 
								setOutVec sp s k out_vec 
								setKnotPoint sp s k knt 
								)	--end k loop 
							)	--end s loop 
						updateshape sp
						ResetXForm sp
						converttosplineshape sp
					)
					--centerpivot sp
				sp.dir=[0,0,1]
			)
	)

	fn slicepl i cut pos eu =
	(
		with redraw off
		(
			addmodifier i (sliceModifier())
			modTM = getModContextTM i i.modifiers[1]
			objTM = i.objecttransform
			i.modifiers[1].Clean = true
			i.modifiers[1].SliceFormat = 0 --plane
			i.modifiers[1].Slice_Type = cut
			i.modifiers[1].Faces___Polygons_Toggle = 2 --automatic
			--if not ctrl then 
			i.modifiers[1].slice_plane.rotation = eu 
			--else i.modifiers[1].slice_plane.rotation = rot
			i.modifiers[1].slice_plane.position = (pos * modTM * (inverse objTM)) 

		)
		/*
		--converttopoly i
		--i.deleteIsoVerts()
		--polyop.CollapseDeadStructs i
		mod_slice=sliceModifier()
		mod_slice.Slice_Type=cut
		mod_slice.slice_plane.rotation=quat 0 0 0 1
		mod_slice.slice_plane.position=[0,0,0]
		mod_slice.Faces___Polygons_Toggle=0
		pl=plane()
		pl.typeinPos=[0,0,0] 
		pl.rotation = rot --eulerangles 0 0 0
		pl.length=100
		pl.width=100
		pl.pos=pos
		addmodifier i mod_slice
		a = pl.rotation
		b = i.rotation
		c = pl.pos
		d = i.pos
		i.modifiers[1].slice_plane.controller[2].controller.value = b-a
		i.modifiers[1].slice_plane.controller[1].controller.value = c-d
		delete pl
		converttopoly i
		polyop.CollapseDeadStructs i
		--return i
		*/
	)
	
	fn slicepoly i pos eu =
	(
		with redraw off
		(
			if classof i != Editable_Poly then converttopoly i
			local faces = polyop.getFaceSelection i
			if faces.isempty then faces = #{1..polyop.getNumFaces i} 
			local plane = ray pos [eu.x, eu.y, eu.z]
			polyop.slice i faces plane
		)
	)
	
	fn getFilesRecursive root pattern =
	(
		local dir_array = GetDirectories (root + "/*")
		for d in dir_array do join dir_array (GetDirectories (d + "/*"))
		local my_files = #()
		for f in dir_array do join my_files (getFiles (f + pattern))
		my_files
	)

	fn getDirsRecursive root =
	(
		local dir_array = GetDirectories (root + "/*")
		for d in dir_array do join dir_array (GetDirectories (d + "/*"))
		dir_array
	)

	fn getDirsRecursive_pattern root pattern =
	(
		local dir_array = #()
		dir_arrays = GetDirectories (root + "/*")
		for d in dir_arrays do join dir_array (GetDirectories (d + "/*" + pattern))
		dir_array
	)
	
	fn import_objects_file arch = 
	(
		arr = #()
		myfiles = #()

		filesFBX = #()
		filesTEX = #()
		filesAll = #()
		objAll = #()
		filesFBX_CURRENT = #()
		
		myfiles = #(arch)
		--max reset file						
		resetMaxFile #noPrompt
		units.DisplayType = #metric
		units.MetricType = #meters
		units.SystemType = #meters	
		for f in myfiles where not keyboard.escPressed do 
		(
			ext = getFilenameType f
			nam = getFilenameFile f
			path = getFilenamePath f

			nam2 = nam
			dirname = path + nam + "\\"
			--print dirname
			
			makedir dirname
			filename = dirname + nam + ext
			--print filename
			
			if not doesFileExist filename then copyFile f filename
				
			--cmd = "\"C:\Program Files\7-Zip\7z.exe\"" + " x *.zip -o* -y " --" x *.* -y"
			cmd = "\"" + GetDir #maxroot + "GeoScripts\\7z.exe" + "\"" + " x *.zip -o* -y " --" x *.* -y"
			--print cmd
			HiddenDOSCommand (cmd) startpath:(dirname)
			
			filesFBX_CURRENT = getFiles (dirname + "\\" + nam + "\\" + "*.fbx")

			if filesFBX_CURRENT != undefined then
				if filesFBX_CURRENT != #() then
					for fbx in filesFBX_CURRENT where fbx != undefined do 
					(
						importFile fbx #noPrompt
						append objAll (objects as array)
					)
						
			filesFBX = (getFiles (dirname + nam + "\\" + "*.fbx"))
			filesAll = (getFiles (dirname + nam + "\\" + "*.*"))
				
			for f in filesFBX do 
			(
				ff = getFilenameFile f
				print (dirname + nam + "\\" + ff + ".fbm\\" + "*.*")
				append filesTEX (getFiles (dirname + nam + "\\" + ff + ".fbm\\" + "*.*")) --????? ??????? ?????????? ????? ??????? ? ??????????, ??????? ???
			)
			arr = #(myfiles, filesFBX, filesTEX, filesAll, objAll)
		)
		arr --#(myfiles, filesFBX, filesTEX, filesAll, objAll)
	)
	
	fn import_objects path_arc = 
	(
		myfiles = #()
		myDirs = #()	

		filesFBX = #()
		filesGeoJSON = #()
		filesPNG = #()
		filesAll = #()
		objAll = #()
		filesFBX_CURRENT = #()
		
		--myDirs = getDirsRecursive path_arc 
		myDirs = path_arc 
		print myDirs
		myfiles = getFiles (myDirs + "*.zip")

		sort myfiles
		print #(myfiles)
		max reset file
		for f in myfiles where not keyboard.escPressed do 
		(
			ext = getFilenameType f
			nam = getFilenameFile f
			path = getFilenamePath f

			nam2 = nam
			dirname = path + nam + "\\"
			print dirname
			
			makedir dirname
			filename = dirname + nam + ext
			print filename
			
			if not doesFileExist filename then copyFile f filename
				
			--cmd = "\"C:\Program Files\7-Zip\7z.exe\"" + " x *.zip -o* -y " --" x *.* -y"
			cmd = "\"" + GetDir #maxroot + "GeoScripts\\7z.exe" + "\"" + " x *.zip -o* -y " --" x *.* -y"
			print cmd
			HiddenDOSCommand (cmd) startpath:(dirname)
			
			filesFBX_CURRENT = getFiles (dirname + "\\" + nam + "\\" + "*.fbx")
			
	
			if filesFBX_CURRENT != undefined then
				if filesFBX_CURRENT != #() then
					for fbx in filesFBX_CURRENT where fbx != undefined do 
					(
						importFile fbx #noPrompt
						append objAll (objects as array)
					)
						
			append filesFBX (getFiles (dirname + "\\" + nam + "\\" + "*.fbx"))
			append filesGeoJSON (getFiles (dirname + "\\" + nam + "\\"+ "*.geojson"))
			append filesPNG (getFiles (dirname + "\\" + nam + "\\"+ "*.PNG"))
			append filesAll (getFiles (dirname + "\\" + nam + "\\"+ "*.*"))
		)
		#(myfiles, filesFBX, filesGeoJSON, filesPNG, filesAll, objAll)
	)

	fn FBX_Statictics =
	(
		stri = ""
		WindowHandle = DialogMonitorOPS.GetWindowHandle()
		controls = windows.getChildrenHWND WindowHandle --parent:#max
		--"	File Directory:	File Version:	7.4.0 File Creator:	FBX SDK/FBX Plugins version 2020.3.4 File Custom Writer:	No File Creation Time:	2025/4/30  23:31:24 File Axis Direction:	Z-up File Units:	Meters System Axis Direction:	Z-up System Units:	Meters System frame rate:	30,0 File frame rate:	30,0 File content:	5 Elements,   5 Materials,   17 Textures"
		for child in controls where findstring child[5] "File Directory:" != undefined or findstring child[5] "File Version:" != undefined do stri = (child)[5] 
		UIAccessor.PressButtonByName WindowHandle "Cancel"
		if stri != undefined then WriteAllLines (GetINI_ImageMagick() + "!.txt") stri
		--stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!!.txt") ((dotNetClass "System.Text.Encoding").UTF8)		
		true
	)
	
	fn GetFBXFileVersion theFBXFile = 
	(
		r = 0
		if theFBXFile != undefined then
		(
			theBinStream = fopen theFBXFile "r"
			--keyWord = "FBXVersion"
			--notFind = true
			--textFromBin = ""
			--fseek theBinStream 0 #seek_end
			--binEnd = ftell theBinStream 
			fseek theBinStream 116 #seek_set
			r = (ReadLong theBinStream #signed)
			FClose theBinStream
		)
		r
	)
		
/*	
	fn GetFBXFileVersion_ theFBXFile = 
	(
		local versionFloat, theBinStream, keyWord, notFind, textFromBin, binEnd
		versionFloat = 0
		if theFBXFile != undefined then
		(
			theBinStream = fopen theFBXFile "r"
			keyWord = "FBXVersion"
			notFind = true
			textFromBin = ""
			fseek theBinStream 0 #seek_end
			binEnd = ftell theBinStream 
			fseek theBinStream 0 #seek_set
			
			while (ftell theBinStream < binEnd) and notFind do
			(
				textFromBin = ReadString theBinStream -- ReadString theBinStream 
				if textFromBin == keyWord[1] then
				(
					for i = 1 to keyWord.Count - 1 do textFromBin += ReadString theBinStream as string
				)
				if keyWord == textFromBin then
				(
					versionString = ""
					for i = 1 to 4 do versionString += ReadByte theBinStream --as string
					versionFloat = versionString --as float
					notFind = false
					exit
				)
			)
			FClose theBinStream
		)
		versionFloat
	)
*/
	
	fn parse_error_symbols t = 
	(
		local p = trimleft t "_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
		p = trimright p "_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
		p
	)
	
	fn delete_only_digits t = 
	(
		local p = substitutestring t "0" ""
		p = substitutestring p "1" ""
		p = substitutestring p "2" ""
		p = substitutestring p "3" ""
		p = substitutestring p "4" ""
		p = substitutestring p "5" ""
		p = substitutestring p "6" ""
		p = substitutestring p "7" ""
		p = substitutestring p "8" ""
		p = substitutestring p "9" ""
		p
	)
	
	fn delete_only_ground t = 
	(
		local t = substitutestring t "Ground" ""
		t
	)
	
	fn delete_few_symbols t = 	
	(		
		local p = substitutestring t "'" ""
		p = substitutestring p "`" ""
		p = substitutestring p "ulicza" ""
		p = substitutestring p "Ulicza" ""	
		p = substitutestring p "ploshhad" ""
		p = substitutestring p "Ploshhad" ""	
		p = substitutestring p "bulvar" ""	
		p = substitutestring p "Bulvar" ""	
		p = substitutestring p "most" ""	
		p = substitutestring p "Most" ""	
		p = substitutestring p "?" "N"		
		p = substitutestring p "." ""
		p = substitutestring p "-" ""		
		p = substitutestring p "(" ""	
		p = substitutestring p ")" ""	
		
		p = trimleft p
		p = trimright p
		p = substitutestring p " " ""
		p
	)
	
	fn sortexcel_len arr1 arr2 = 
	(
		if arr1 != undefined and arr2 != undefined then
		(
			case of 
			(
				(arr1.count < arr2.count): 1
				(arr1.count > arr2.count): -1
				default: 0
			)
		)
		else 0
	)
	
	fn tag_getEdgeVerts obj face_index edge_index =
	(
		if classOf obj == Editable_Poly then
		(
			local verts = polyop.getFaceVerts obj face_index
			local edges = polyop.getFaceEdges obj face_index
	 
			edge_index = findItem edges edge_index
			if edge_index == edges.count then #(verts[edge_index], verts[1])
			else #(verts[edge_index], verts[edge_index+1])
		)
		else #() --"ERROR"
	)

	fn tag_getMapVert obj map_channel face_indices index =
	(
		if classOf obj == Editable_Poly then
		(
			if classof face_indices == integer then face_indices = #(face_indices)
			else face_indices = face_indices as Array
			local mesh_verts = #()
			local text_verts = #()
			for i in face_indices do
			(
				join mesh_verts (polyop.getFaceVerts obj i)
				join text_verts (polyop.getMapFace obj map_channel i)
			)
			index = findItem mesh_verts index
			polyop.getMapVert obj map_channel text_verts[index]
		)
		else undefined --"ERROR"
	)

	fn tag_setMapVert obj map_channel face_indices index vert =
	(
		if classOf obj == Editable_Poly then
		(
			if classof face_indices == integer then face_indices = #(face_indices)
			else face_indices = face_indices as Array
			local mesh_verts = #()
			local text_verts = #()
			for i in face_indices do
			(
				join mesh_verts (polyop.getFaceVerts obj i)
				join text_verts (polyop.getMapFace obj map_channel i)
			)
			index = findItem mesh_verts index
			polyop.setMapVert obj map_channel text_verts[index] vert
		)
		else undefined --"ERROR"
	)
	 
	fn tag_getVertex obj index =
	(
		if classOf obj == Editable_Poly then in coordsys world polyop.getVert obj index
		else undefined --"ERROR"
	)
	 
	fn tag_slice obj faces normal center =
	(
		if classOf obj == Editable_Poly then
		(
			local plane = ray center normal
			--for i in faces do polyop.slice obj #{i} plane
			polyop.slice obj faces plane
		)
		else undefined --"ERROR"
	)
	 
	fn tag_equal_int a b =
	(
		if a-b > 0.001 or a-b < -0.001 then false else true
	)

	fn checkMirror obj map_channel face_index =
	(
		local sum = 0
		
		if classOf obj == Editable_Poly then
		(
			local verts = polyop.getFaceVerts obj face_index
			local edges = polyop.getFaceEdges obj face_index --polyop.getFaceVerts obj face_index --polyop.getFaceEdges obj face_index
			
			for i = 1 to edges.count do
			(
				local edge_verts
				local tv1, tv2, tv3
	 
				if i == edges.count-1 then
				(
					tv1 = (tag_getMapVert obj map_channel face_index verts[i])
					tv2 = (tag_getMapVert obj map_channel face_index verts[i+1])
					tv3 = (tag_getMapVert obj map_channel face_index verts[1])
				)
				else 
				(
					if i == edges.count then
					(
						tv1 = (tag_getMapVert obj map_channel face_index verts[i])
						tv2 = (tag_getMapVert obj map_channel face_index verts[1])
						tv3 = (tag_getMapVert obj map_channel face_index verts[2])
					)
					else
					(
						tv1 = (tag_getMapVert obj map_channel face_index verts[i+0])
						tv2 = (tag_getMapVert obj map_channel face_index verts[i+1])
						tv3 = (tag_getMapVert obj map_channel face_index verts[i+2])
					)
				)
				
				local edge1_vect = normalize (tv2 - tv1)
				local edge2_vect = normalize (tv3 - tv1)
		
				-- (cross edge1_vect edge2_vect)
				sum += (cross edge1_vect edge2_vect).z
			)
		)
		
		(sum <= 0)
	)

	fn TAG objs	question =						
	(
		local alt = keyboard.altPressed 
		local map_channel = 1
		if objs.count == 0 do return -1
		
		local tag_objs = #()
		tag_objs = for o in objs where classOf o == Editable_Poly or classOf o == PolyMeshObject collect o

		if tag_objs.count == 0 do return -1
		
		local instances
		for i = 1 to tag_objs.count do
			if tag_objs[i] != #empty do
				if (InstanceMgr.GetInstances tag_objs[i] &instances) > 1 do
					for i2 = i+1 to tag_objs.count do
						for j in instances do
							if tag_objs[i2] == j do
								tag_objs[i2] = #empty
		local is_too_much = -1
		do
		(
			is_too_much = findItem tag_objs #empty
			if is_too_much != 0 do deleteItem tag_objs is_too_much
		) while is_too_much != 0

	
		-- begin loop		
		local o = 0
		for obj in tag_objs where not keyboard.escPressed do 
		(
			o += 1
			--local obj = real_obj
			-- this is a workaround for max 9, because collapseNodeTo is buggy
			--obj = editable_mesh()
			--obj.baseobject = copy real_obj.baseobject
			--local save_obj = real_obj.baseobject
			--hide real_obj
			
			--if classof obj != PolyMeshObject then convertTo obj PolyMeshObject
			converttopoly obj

			select obj
			setCommandPanelTaskMode #modify

			local facecount = obj.faces.count
			
			local FaceSel = #{}
			local FaceSel = polyop.getFaceSelection obj
			if FaceSel.isempty then FaceSel = #{1..facecount}
			
			local query = true
			if subObjectLevel != undefined then 
				if subObjectLevel == 4 or subObjectLevel == 5 then query = false
			
			if query and question then
			(
				if FaceSel.numberset < facecount then
				(
					if querybox "There are selected faces.\nUse them (YES) or ignore (NO)?" then FaceSel = polyop.getFaceSelection obj else FaceSel = #{1..facecount}
				)
			)
			
			local error_cut_faces = #{}
	 		local is_UVmapped = false
			local faces_cutplanes = #()
			faces_cutplanes[facecount] = #()

			local uvwmod = Unwrap_UVW()
			addModifier obj uvwmod
			uvwmod.setMapChannel map_channel
			uvwmod.setConstantUpdate false
			uvwmod.setShowSelectedVertices false
			--uvwmod.updateView()
			uvwmod.setTVSubObjectMode 3

			-- first test: is the object uv mapped?
			local x, y, width, height, areaUVW, areaGeom
			uvwmod.getArea #{1..facecount} &x &y &width &height &areaUVW &areaGeom
			is_UVmapped = ((x >= 0.001) and (x+width <= 0.999) and (y >= 0.001) and (y+height <= 0.999))

			local error_faces = #{}
			if not is_UVmapped do
			(
				error_faces = #{}
				for f in #{1..uvwmod.numberPolygons()} where not keyboard.escPressed do
				(
					uvwmod.getArea #{f} &x &y &width &height &areaUVW &areaGeom
					if (width < 0.00001 or height < 0.00001 or areaUVW < 0.000001) and areaGeom > 0.000001 do error_faces += #{f}
					--if (width < 0.00001 or height < 0.00001 or areaUVW < 0.00001) and areaGeom > 0.001 do error_faces += #{f}
				)
			)
			
			deleteModifier obj uvwmod

			-- First step: analyze the model and save the slice planes in an array
			setCommandPanelTaskMode #create
			
			if not is_UVmapped then
			(
				local faces_cutplanes_count = 0
				--local textures_used = 0
				
				for f = FaceSel - error_faces where not keyboard.escPressed do --#{1..facecount} - error_faces do --for f = 1 to facecount do 
				(
					-- it's likely that we need some sliceplanes for some faces
					faces_cutplanes[f] = #()

					local act_edges = polyop.getFaceEdges obj f					
					if act_edges != undefined do
					(
						local edgecount = act_edges.count
						
						edge_cutpoints_x = #() -- count is same as edgecount at the end
						edge_cutpoints_y = #()
						
						local is_mirrored = checkMirror obj map_channel f
						
						-- build two tables: one with so called x-points, the other one with y-points
						-- e.g. x-points are all at texture uv with y = ...,-1.0,0.0,1.0,2.0,...
						-- so I have to save the min value (e.g. -1.0), in min_y
						--
						-- it has to be guaranteed that the table with the x-points
						-- will be filled correctly (no gaps), so find the right pos (e.g. [3] for 1.0)
						
						-- find the minimum texture coords	
						
						local absminx = 1000000
						local absminy = 1000000
						local minx = 1000000
						local miny = 1000000
						local maxx
						local maxy
						local dir
						local tempx = (ceil(minx)) as integer
						local tempy = (ceil(miny)) as integer	
						
						for i in act_edges where not keyboard.escPressed do 
						(
							local vertices = tag_getEdgeVerts obj f i
							if vertices.count == 0 then continue 
								
							local tv1 = tag_getMapVert obj map_channel f vertices[1]
							local tv2 = tag_getMapVert obj map_channel f vertices[2]
							
							if tv1 != undefined and tv2 != undefined then
							(
								minx = if tv1.x < tv2.x then tv1.x else tv2.x
								miny = if tv1.y < tv2.y then tv1.y else tv2.y
							)
							
							absminx = if absminx < minx then absminx else minx
							absminy = if absminy < miny then absminy else miny
						)
						
						absminx = (ceil(absminx)) as integer
						absminy = (ceil(absminy)) as integer
						
						-- save cutting points for every edge
						-- those cutting points are found at every x/y-axis of texture uvs
						for i in act_edges where not keyboard.escPressed do 
						(
							local vertices = tag_getEdgeVerts obj f i
							
							local tv1 = tag_getMapVert obj map_channel f vertices[1]
							local tv2 = tag_getMapVert obj map_channel f vertices[2]
							
							if tv1 != undefined and tv2 != undefined then
							(
								tv1 = [tv1.x, tv1.y] -- convert to Point2
								tv2 = [tv2.x, tv2.y]
								dir = tv2 - tv1
								
								minx = if tv1.x < tv2.x then tv1.x else tv2.x
								maxx = if tv1.x >= tv2.x then tv1.x else tv2.x
								miny = if tv1.y < tv2.y then tv1.y else tv2.y
								maxy = if tv1.y >= tv2.y then tv1.y else tv2.y
							)
							-- the x-axes ( ... -2, -1, 0, 1, ...)
							tempx = (ceil(minx)) as integer
							while tempx < ceil(maxx) do
							(
								local new_percent = (tempx - tv1.x) / dir.x
								local new_vect = dir * new_percent
								
								-- get the cutpoint in 3d space
								local new_dir = (tag_getVertex obj vertices[2]) - (tag_getVertex obj vertices[1])
								local new_point = (tag_getVertex obj vertices[1]) + (new_dir*new_percent)
								if edge_cutpoints_x[tempx-absminx+1] == undefined do edge_cutpoints_x[tempx-absminx+1] = #()
								append edge_cutpoints_x[tempx-absminx+1] #(i, new_point, tv1.y + new_vect.y, tempx) -- edgenumber, point, texcoords
								tempx += 1
							)
							
							-- the y-axes ( ... -2, -1, 0, 1, ...)			
							tempy = (ceil(miny)) as integer
							while tempy < ceil(maxy) do 
							(
								if keyboard.escPressed then exit
								local new_percent = (tempy-tv1.y)/dir.y
								local new_vect = dir*new_percent
								
								-- get the cutpoint in 3d space
								local new_dir = (tag_getVertex obj vertices[2]) - (tag_getVertex obj vertices[1])
								local new_point = (tag_getVertex obj vertices[1]) + (new_dir*new_percent)
								
								if edge_cutpoints_y[tempy-absminy+1] == undefined do edge_cutpoints_y[tempy-absminy+1] = #()
				
								append edge_cutpoints_y[tempy-absminy+1] #(i, new_point, tv1.x + new_vect.x, tempy) -- edgenumber, coord, texcoords
								tempy += 1
							)				
						)
						
						-- get the points, get their position in 3d-space, build a sliceplane
						-- we have to check if edges cross (they shouldn't)
						-- first: for y
						for i = 1 to edge_cutpoints_y.count where not keyboard.escPressed do 
						(
							local allpoints = deepCopy edge_cutpoints_y[i]
							local points = edge_cutpoints_y[i]
							local act_point_i = 0
							
							while points.count > 1 do
							(
								if keyboard.escPressed then exit
								act_point_i += 1
								local act_edge = copy points[1][1]
								local act_point = copy points[1][2]
								local act_TC = copy points[1][3]
								local act_TC2 = copy points[1][4]
								
								-- get the first point (the active one) out of the list
								deleteItem points 1
										
								-- and test it against every other point on the same "line"
								for other_points_i = 1 to points.count where not keyboard.escPressed do 
								(
									local other_edge = points[other_points_i][1]
									local other_point = points[other_points_i][2]
									local other_TC = copy points[other_points_i][3]
									
									-- find out if other edges are crossing
									local is_near = true
									for test_points_i = 1 to allpoints.count while is_near do
									(
										if test_points_i != act_point_i and test_points_i != (act_point_i+other_points_i) do
										(
											local test_TC = allpoints[test_points_i][3]
											if act_TC < other_TC then
												if test_TC >= act_TC and test_TC <= other_TC do is_near = false
											else
												if test_TC <= act_TC and test_TC >= other_TC do is_near = false
										)
									)
									if is_near do
									(				
										-- angle between edges ...
										local verta = tag_getEdgeVerts obj f act_edge
										local verto = tag_getEdgeVerts obj f other_edge
										
										if verta.count > 0 and verto.count > 0 then
										(
											local tva1 = tag_getMapVert obj map_channel f verta[1]
											local tva2 = tag_getMapVert obj map_channel f verta[2]
											local tvo1 = tag_getMapVert obj map_channel f verto[1]
											local tvo2 = tag_getMapVert obj map_channel f verto[2]
											
											if tva1 != undefined and tva2 != undefined and tvo1 != undefined and tvo2 != undefined then
											(
												-- which one is on the left?
												local going_on = true
												if not is_mirrored then
												(
													if act_TC < other_TC then
														if (tva1.y <= tva2.y) do going_on = false
													else
														if (tvo1.y <= tvo2.y) do going_on = false
												)
												else
												(
													if act_TC < other_TC then
														if (tva1.y >= tva2.y) do going_on = false
													else
														if (tvo1.y >= tvo2.y) do going_on = false
												)
												
												if going_on do
												(
													local plane_normal = cross (polyop.getFaceNormal obj f) (other_point-act_point)
													plane_normal = normalize plane_normal
																		
													append faces_cutplanes[f] #(act_point, plane_normal, false, act_TC2) -- center, normal, is-x-axis, which axis
													faces_cutplanes_count += 1
												)
											)
										)
									)
								)
							)
						)
						
						-- the same for x
						for i = 1 to edge_cutpoints_x.count where not keyboard.escPressed do
						(
							local allpoints = deepCopy edge_cutpoints_x[i]
							local points = edge_cutpoints_x[i]
							local act_point_i = 0
							
							while points.count > 1 do
							(
								if keyboard.escPressed then exit
								act_point_i += 1
								local act_edge = copy points[1][1]
								local act_point = copy points[1][2]
								local act_TC = copy points[1][3]
								local act_TC2 = copy points[1][4]
								
								-- get the first point (the active one) out of the list
								deleteItem points 1
										
								-- and test it against every other point on the same "line"
								for other_points_i = 1 to points.count where not keyboard.escPressed do 
								(
									local other_edge = points[other_points_i][1]
									local other_point = points[other_points_i][2]
									local other_TC = points[other_points_i][3]
									
									-- find out if other edges are crossing
									local is_near = true
									for test_points_i = 1 to allpoints.count while is_near do
									(
										if test_points_i != act_point_i and test_points_i != (act_point_i+other_points_i) do
										(
											local test_TC = allpoints[test_points_i][3]
											if act_TC < other_TC then
												if test_TC >= act_TC and test_TC <= other_TC do is_near = false
											else
												if test_TC <= act_TC and test_TC >= other_TC do is_near = false
										)
									)
									
									if is_near do
									(
										-- angle between edges ...
										local verta = tag_getEdgeVerts obj f act_edge
										local verto = tag_getEdgeVerts obj f other_edge
								
										if verta.count > 0 and verto.count > 0 then
										(
											local tva1 = tag_getMapVert obj map_channel f verta[1]
											local tva2 = tag_getMapVert obj map_channel f verta[2]
											local tvo1 = tag_getMapVert obj map_channel f verto[1]
											local tvo2 = tag_getMapVert obj map_channel f verto[2]
											
											if tva1 != undefined and tva2 != undefined and tvo1 != undefined and tvo2 != undefined then
											(
												-- which one is on the left?
												local going_on = true
												if not is_mirrored then
												(
													if act_TC < other_TC then
														if (tva1.x >= tva2.x) do going_on = false
													else
														if (tvo1.x >= tvo2.x) do going_on = false
												)
												else
												(
													if act_TC < other_TC then
														if (tva1.x <= tva2.x) do going_on = false
													else
														if (tvo1.x <= tvo2.x) do going_on = false
												)
									
												if going_on do
												(
													local plane_normal = cross (polyop.getFaceNormal obj f) (other_point-act_point)
													plane_normal = normalize plane_normal
													
													append faces_cutplanes[f] #(act_point, plane_normal, true, act_TC2) -- center, normal, is-x-axis, which axis
													faces_cutplanes_count += 1
												)
											)
										)
									)
								)
							)
						)
					)
				)
				--obj.preserveUVs = true
			)
			
			obj.preserveUVs = true
			
			--slice the geometry
			local newfaces = #{}
			if not is_UVmapped do
			(
				for f = FaceSel - error_faces where not keyboard.escPressed do --for f = #{1..facecount} - error_faces do --for f = 1 to facecount do 
				(
					if faces_cutplanes[f].count > 0 then
					(
						local old_edgecount = obj.edges.count
						
						--setFaceSelection obj #(f)
						polyop.setfaceselection obj #{f}
						
						local act_verts = obj.numVerts
						
						for i = 1 to faces_cutplanes[f].count where not keyboard.escPressed do
						(
							local active_faces = polyop.getFaceSelection obj 
							
							if alt then 
							(
								for ff in active_faces do 
								(
									active_faces = polyop.getFaceSelection obj 
									local success = tag_slice obj #{ff} faces_cutplanes[f][i][2] faces_cutplanes[f][i][1]
									newfaces += polyop.getfaceselection obj
									if not success then error_cut_faces += active_faces
								)
							)
							else
							(
								local success = tag_slice obj active_faces faces_cutplanes[f][i][2] faces_cutplanes[f][i][1]
								newfaces += polyop.getfaceselection obj
								if not success then error_cut_faces += active_faces
							)
							
							local xaxis = faces_cutplanes[f][i][3]
							local tc_val = faces_cutplanes[f][i][4]
							
							for j = act_verts+1 to obj.numVerts where not keyboard.escPressed do
							(
								local tv = tag_getMapVert obj map_channel (polyop.getfaceselection obj) j
								if xaxis then tv.x = tc_val else tv.y = tc_val
								tag_setMapVert obj map_channel (polyop.getfaceselection obj) j tv
								
								--local tv = tag_getMapVert obj map_channel (getFaceSelection obj) j
								--if xaxis then tv.x = tc_val else tv.y = tc_val
								--tag_setMapVert obj map_channel (getFaceSelection obj) j tv
							)		
							act_verts = obj.numVerts
						)
					)
				)
				
			)

			setCommandPanelTaskMode #modify
			polyop.setFaceSelection obj (FaceSel + newfaces)
			
			if not error_cut_faces.isempty then messagebox "Some faces do not cut"
			
/*
			if real_obj != obj do
			(
				real_obj.baseobject = obj.baseobject
				for geo in geometry where geo.baseobject == save_obj do geo.baseobject = obj.baseobject
				delete obj
				unhide real_obj
			)
*/			
		)
		select objs
		return 1
	)

	fn RGBtoHEX clrRGB = ("#" + ((bit.intAsHex clrRGB.r) + (bit.intAsHex clrRGB.g) + (bit.intAsHex clrRGB.b)) as string)
	
	fn round x = 
	(
		local x5 = x as integer
		local x6 = if x >= 0 then (x + 0.5) as integer else (x - 0.5) as integer
		local x7 = if x >= 0 then (x + 1) as integer else (x - 1) as integer	
		local x3 = if x5 == x6 then x5 else x7
		x3
	)
	
	fn dr i =
	(
		local j = i as integer
		(i - j)
	)
	
	fn trim t = 
	(
		if t != undefined then
		(
			format "% --> " t
			if t != "" then
			(
				local a = trimright t "0123456789" 
				a = trimleft a "0123456789"
				
				a = substitutestring a "0" ""
				a = substitutestring a "1" ""
				a = substitutestring a "2" ""
				a = substitutestring a "3" ""
				a = substitutestring a "4" ""
				a = substitutestring a "5" ""
				a = substitutestring a "6" ""
				a = substitutestring a "7" ""
				a = substitutestring a "8" ""
				a = substitutestring a "9" ""
				
				format "% --> " a
				if a != undefined then 
					if a != "" then 
						for i = 1 to a.count do t = substitutestring t a[i] "" 
				format "% --> " t
			)
			local s = case of
			(
				((t as integer) >= 1001 and (t as integer) <= 1100): ((t as integer) - 1000) 
				((t as integer) > 0 and (t as integer) <= 100): (t as integer)
				default: 0
			)		
			format "%\n" s			
			return (s as integer)
		)
		0
	)
	
		
	fn par pp p spn = 
	(
		--local angle = acos(dot (normalize vec_A) (normalize vec_B))
		--local paral = if angle >= abs(180 - spn) or angle <= abs(spn) then true else false  
		--local paral = if abs(dot (normalize vec_A) (normalize vec_B)) >= (1-spn) or abs(dot (normalize vec_A) (normalize vec_B)) <= spn then true else false
		--local paral = if abs(dot(normalize vec_A) (normalize vec_B)) <= 0.1 then true else false
		--local paral = if abs(dot (normalize vec_A) (normalize vec_B)) >= (1-spn) or abs(dot (normalize vec_A) (normalize vec_B)) <= spn then true else false
		local vec_A = pp[1] - p
		local vec_B = pp[2] - p
		local paral = if abs(dot (normalize vec_A) (normalize vec_B)) >= (1 - spn) then true else false
		paral	
	)
	
	fn getsize a =
	(
		local str = ""
		
		if a != undefined then
		try
		(
			local b = openBitMap a.filename 
			if b != undefined then
			(
				str += b.width as string + "x" + b.height as string
				str += if b.hasalpha then " Alpha " else " "
				close b
				free b
			)
		)
		catch(str += " ")
		str
	
	)		
	
	fn WriteFile filename stri =
	(
		local Writer = dotNetObject"System.IO.StreamWriter" filename false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-8"))
		--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("Windows-1251")) --ANSI
		--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-16LE"))
		Writer.Write(stri)
		Writer.Close()
		free Writer
		--free filename
		--free stri
	)
	
	fn TooltipWriter filenameIni controls str =
	(
		--local filenameIni = GetDir #maxroot + "\\GeoScripts\\tooltips_syssetup.ini"
		if not doesFileExist filenameIni then
		(
			local stri = str
			for i in controls.controls where isProperty i "tooltip" do 
			(
				--if findstring i.tooltip "|" != undefined then i.tooltip = (filterstring i.tooltip "|")[1]
				--if findstring i.tooltip "|" != undefined then 
				stri += i.name + "=" + (substitutestring (substitutestring (i.tooltip as string) "\n" "::" ) "\r" "") + "\n"
				--print stri
				--messageBox stri
				WriteFile filenameIni stri 
			)
			free stri
		)
	)
	
	fn TooltipReader filenameIni controls_name str state =
	(
		try
		(
			if doesFileExist filenameIni then
			(
				local tooltip = getINISetting filenameIni str controls_name
				if tooltip != undefined then
				(
					if tooltip != "" then
					(
						if findstring tooltip "|" != undefined then 
						(
							tooltip = substitutestring tooltip " | " "|"
							tooltip = substitutestring tooltip "\r" ""
							tooltip = substitutestring tooltip "::" "\n"
							tooltip = (filterstring tooltip "|")[state]
							if state == 1 then 
							(
								tooltip = substitutestring tooltip "LMB" "???"
								tooltip = substitutestring tooltip "RMB" "???"
							)
							return tooltip
						)
					)
					else return ""
				)
				else return ""
			)
			else return ""
		)catch(return "")
		return ""
	)
	
	fn ValidTypeControl c = 
	(
		local a = false 
		
		a =	case (classof c) of
			(
				default: false
				CheckBoxControl: true
				EditTextControl: true
				ComboBoxControl: true
				ButtonControl: true
				RadioControl: true	
				LabelControl: true
				SpinnerControl: true
				ColorPickerControl: true
			)
		return a
	)

	
/*
--try(destroyDialog ::GeoAGR)catch()
--menu
rollout GeoAGR "GeoAGR v1.0" width:500 --height:500 
(
	subrollout S_slicers "Slicers operations" width:450 height:335 --across: 2 
	subrollout S_UDIMs "UDIMs operations" width:450 height:390
	subrollout S_Obj_Spln "Objects operations" width:450  height:120
	subrollout S_UCX "UCX operations" width:450 height:80
	subrollout S_Geojson "Geojson operations" width:450 height:100
	subrollout S_File "File operations" width:450 height:30
)
*/
	
DisableWindowsGhosting = DisableProcessWindowsGhosting()
DisableWindowsGhosting.DisableProcessWindowsGhosting()	
	
try(destroyDialog ::GeoAGR)catch()
try(closeRolloutFloater GeoAGR)catch()

global GeoAGR -- = newRolloutFloater "GeoAGR v1.13.18" 300 700 
global RulesCheck_lowpoly
global RulesCheck_highpoly
global syssetup
global UDIMs
global slicers
global Obj_Spln
global Obj_tools
global UCX
global Geojson
global File
global Docker

GeoAGR = newRolloutFloater "GeoAGR v1.13.32" 300 700 

rollout RulesCheck_lowpoly "Rules Check for Lowpoly Models" autoLayoutOnResize:true height:300
(	
	--button ui_btn_test "\x2714" 
	--label  ui_lbl_test "\x2716"

	radiobuttons rdo_check_lowpoly labels: #("Check Archive", "Check All Scene", "Check Selection in Scene") columns:1 rows:3 default:1 align:#left across:2 offset:[0,0] enabled:false tooltip:""
	button btn_get_path_lowpoly_rules_check "Open Archive with Models" align:#left tooltip:"Open Archive with LowPoly Models to Check Rules"
	edittext edt_lowpoly_rules_check_path "" text:"" labelOnTop:false bold:true width:260 fieldWidth:260 readonly:false offset:[0,0] tooltip:"Path to Folder with LowPoly Models"
	button btn_lowpoly_rules_check "Start Check Rules" align:#left across:3 tooltip:"???? ?? ??? ??????? ??????? ..."
	button btn_lowpoly_checkers_on "Check All" offset:[25,0] tooltip:""
	button btn_lowpoly_checkers_off "UnCheck All" align:#right tooltip:""
	progressBar pb_lowpoly "" width:260 height:10 tooltip:"Checking progress"
	label lbl_lowpoly_progress "" align:#left style_sunkenedge:false width:260 tooltip:"Press ESC to CANCEL check"

		checkbox chk_rules_lowpoly_table_1_All "??????? 1. ????? ?????????? ? ???????" checked:true offset:[0,0] align:#left tooltip:"??????? 1. ????? ??????????? ?????????? ? ?????? ?????? ?? ?????????? ??????"
		checkbox chk_rules_lowpoly_table_1_1 "1.?????????? ? ???????? ??????????????" checked:true offset:[0,0] align:#left tooltip:"1.?????????? ? ???????? ?????????????? ???????" 
		
		checkbox chk_rules_lowpoly_table_1_1_1 "1.1. FBX 7.4 (FBX 2014) binary" checked:true offset:[20,0] align:#left tooltip:"1.1. ?????????? ???????? ?????? ?????? ??????????????? ?????????? ? ????????????? ???????? ??????? FBX ?????? 7.4 (FBX 2014) ????????? ????." 
		checkbox chk_rules_lowpoly_table_1_1_2 "1.2. ??????????? ?????????" checked:true offset:[20,0] tooltip:"1.2. ??????????????? ?????? ?? ?????? ????????? ??????????? ???????? ??? ?????? ????." 
		checkbox chk_rules_lowpoly_table_1_1_3 "1.3. ???????????? ?????? 3ds max" checked:true offset:[20,0] tooltip:"1.3. ??????????????? ?????? ?????? ??????????? ? ??????????? ???????????? ?????? ???????????? ???????????." 
		checkbox chk_rules_lowpoly_table_1_1_4 "1.4. ???????????? ????????????" checked:true offset:[20,0] tooltip:"1.4. ??????????????? ?????????? ?????? ?????? ??????????????? ???????????? ? ??????????? ??????????, ?????????????? ? ?????? ?????????????? ?????????????? ??????? (???????, ????????? ???????) ? ????????? ????????????." 

		checkbox chk_rules_lowpoly_table_1_2 "2. ?????????? ? ???????? ?????????" checked:true offset:[0,10] align:#left tooltip:"2. ?????????? ? ???????? ?????????"
		checkbox chk_rules_lowpoly_table_1_2_1 "2.1. ??????? ????????? - ?????" checked:true offset:[20,0] tooltip:"2.1. ??????? ??????????? ????????? ?????? ???? ???????????: ???? ???????? ??????? ????????? ????????????? ?????? ?????." 
		
		checkbox chk_rules_lowpoly_table_1_3 "3. ?????????? ? ?????????? Address" checked:true offset:[0,10] align:#left tooltip:"3. ?????????? ? ?????????? ?????????? Address"
		checkbox chk_rules_lowpoly_table_1_3_1 "3.1. ?????????? ??????, ??? ?????" checked:true offset:[20,0] tooltip:"3.1. ????????????? ????????????? ?????????? ???????????????? ?????????, ?????? ??????? ???????? ???????? ??????? ???????????? ???????? ?????????? ????????? ?? 5 ?????? 2015 ?. ? 171? ?? ??????????? ??????? ????????? ????????????? ?????????, ????????? ??????-???????? ????, ????????? ???????? ?????????, ????? ?????? (??????????), ?????????, ???????????? ? ???????? ?????????? ??????, ? ?????? ???????????? ???????????? ???????????????? ?????????. ????? ? ????? ??????????? ???? ?? ????????.\n?????????: ???????? ???????? ???????? ???? ?? ?????? ??????????? ?????? ??????????????, ? ?????? ???? ???????? ??????, ??? ???? ?????? ????? ????? ??????? ? ??????? ?????."
		checkbox chk_rules_lowpoly_table_1_3_2 "3.2. ????? ????????? ????? _" checked:true offset:[20,0] tooltip:"3.2. ???????????????? ???????? ?????? ?????????? ????????????? ????????? (?????????? ?????????), ??????? ? ???????? ??????? ????????????? (_). ?????? ???????????, ??????? ??????, ??????????? ? ?????????? ???????? ??????? ????????????? (_)."
		checkbox chk_rules_lowpoly_table_1_3_3 "3.3. ?????????? _ ???? ? ????" checked:true offset:[20,0] tooltip:"3.3. ???????????????? ???????? ??????????? ?????? ??????????????. ???????? ? ????????? ????? ?????????? ?????? ?????????????? ???? ?? ?????." 
		checkbox chk_rules_lowpoly_table_1_3_4 "3.4. ????????? ????? ? ??????" checked:true offset:[20,0] tooltip:"3.4. ?????? ????? ????? ?????????? ? ????????? ?????." 
		checkbox chk_rules_lowpoly_table_1_3_5 "3.5. ????? ????? ??????????" checked:true offset:[20,0] tooltip:"3.5. ? ????????? ????????? ??????-???????? ???? ?????????? ?????? ????? ?????." 
		checkbox chk_rules_lowpoly_table_1_3_6 "3.6. ??????????? ????? - ??? :" checked:true offset:[20,0] tooltip:"3.6. ???? ?????? ?? ????? ??????? ?????????????/????????? ??????,..., ?? ? ?????????? Address ??????????? ??????????? ????? ???????, ?????? : ?????????? ?? _.\n????????: 77:02:0015007:4157   77_02_0015007_4157   77:02:0015007:4157, ?????? 7   77_02_0015007_4157_?_7\n????????? ... ??????????? ??????? ..., ... ?967-?? ?? 15.03.2017\n3.1. ??????????? ????? ????? ????????????? ????????? ..\n?-?-?1?2-?-?-?, ???:\n? -  ????? ???????? ?????????? ????????? ?? ??????? ?????, ???????????? ???????? ?????????? ?? 19.09.96 N 102 - 77 - ??????????? ?????, ???????? ????? (???) ?.??????\n? - ????? ??????????? ???? ?????? - ??????????? ????? (?? ?????? ????? ????????????? ???????? ???????????????? ??????? : \n01-???, 02-????, 03-???, 04-????, 05-???, 06-????, 07-???, 08-????, 09-???, 10-?.??????????)\n?1?2 - ????????????? ????????? ????? ???????????? ????????, ??????? ???????? ? ???? : \n?1 - ??????????? ?????, ???????? ????? ???????????? ??????? ?????? ??????????? ????\n?2 - ??????????? ?????, ???????? ????? ???????????? ???????? ?????? ???????...\n? - ??????????? ?????, ???????? ????? ?????????? ??????? ? ???????? ???????????? ????????...\n? - n-????????? ?????, ???????? ????? ?????? ??? ??????????...\n? - ?????????????? ?????, ???????? ????? ?????? ??? ???????? ????????? ? ??????...\n- - ??????????? ????????? ?????? ???????????? ??????."

		checkbox chk_rules_lowpoly_table_2_All "??????? 2. ?????????? ? ??? ???????" checked:true offset:[0,10] align:#left tooltip:"??????? 2 ??????????? ?????????? ? ???????? ?????????? ??????? ????????????????????????????? ??????? ???????? ???????????? ?????????????"
		checkbox chk_rules_lowpoly_table_2_1 "1. ?????????? ? ??????, ???????, ?????????" checked:true offset:[0,0] tooltip:"?????????? ? ????? ??????, ? ??????, ? ????????? ??????"
		checkbox chk_rules_lowpoly_table_2_1_1 "1.1. ????? ZIP < 1 Gb" checked:true offset:[20,0] tooltip:"1.1. ???????????? ?????? ????? ?????? - 1 ??" 
		checkbox chk_rules_lowpoly_table_2_1_2 "1.2. ????? ?????? ? ??????: 2..21 FBX" checked:true offset:[20,0] tooltip:"1.2. ? ?????? ????? ?????? ?????? ?? 2 ?? 21 ?????? ??????? FBX (??????? 2): ???? ???? ??????????????? ? ?? 20 ?????? ??????? FBX ?????????? ??????? ??????? ???." 
		checkbox chk_rules_lowpoly_table_2_1_3 "1.3. ????? ? ??????? ??????" checked:true offset:[20,0] tooltip:"1.3. ? ?????? ?????? ??????? FBX ?? ?????? ??????? ?????? ????????, ?? ?????????? ? ???? ?????, ????????? ??? ??????, ????????, ???????????, ?????, ??????, ??????, ??????????????	?????,	??????	????????,??????????????? ????????, ?? ??????????? ? ?????????? ???????, ????????? ?????????? ???????????, ????????? ? ?????????? ????????????, ?????, ?????????? ? ??." 
		checkbox chk_rules_lowpoly_table_2_1_4 "1.4. ?????? FBX ??-?? ?????????, ?????? ?-?" checked:true offset:[20,0] tooltip:"1.4. ? ?????? ????? ??????? FBX ???????????????, ?????? ?? ?????????? ??????? (?? 22 ??.), ?????? 5 ????????? ???????? ?????????:" 
		checkbox chk_rules_lowpoly_table_2_1_4_1 "1.4.1 ????????? ??-??: <20 ???. ???????" checked:true offset:[20,0] tooltip:" ????????? ??????????????? (???????? 20 ?????????? ???????);"
		checkbox chk_rules_lowpoly_table_2_1_4_2 "1.4.2 ?????????????? ?????? ??-??: ???" checked:true offset:[20,0] tooltip:" ????????? ?????????????? ??????? ??????????????? (??? ???????) (??? ?????????? ???????);"
		checkbox chk_rules_lowpoly_table_2_1_4_3 "1.4.3 ????????? ????????? ??-??: 1 ?????" checked:true offset:[20,0] tooltip:" ????????? ????????? ????????? ??????????????? (???, ????? ????????? ? ??.) (1 ?????????? ?????);"
		checkbox chk_rules_lowpoly_table_2_1_4_4 "1.4.4 ?????????????? ?????? ??-? ??-??: ???" checked:true offset:[20,0] tooltip:"  ????????? ?????????????? ??????? ????????? ??????????????? (??? ???????) (??? ?????????? ???????);"
		checkbox chk_rules_lowpoly_table_2_1_4_5 "1.4.5 ????????? ??????????????: 1 ?????" checked:true offset:[20,0] tooltip:" ????????? ??????????????, ??????? ???????? ? ???? ??? ?????????????? ?? ????? (1 ?????????? ?????)."
		checkbox chk_rules_lowpoly_table_2_1_5 "1.5. ??????? ???????????????" checked:true offset:[20,0] tooltip:"1.5. ????? ??????????????? - ???????????? ????? ??? ? ???????? ????????????? ? ??????????" 
		checkbox chk_rules_lowpoly_table_2_1_6 "1.6. ??? ??? ? ??-?? ??-?? ???? ? ??? ? ???" checked:true offset:[20,0] tooltip:"1.6. ????? ???????????????, ? ????? ??? ??? ??????? ??? ?????? ???? ??????????? ? ?????? ???? ? ????????? ??? ??? ??????????????????? ??????, ??? ? ??? ??????????????????. ??? ????????, ? ??? ?????, ? ???, ??????????, ??????? ????????? ? ??." 

		checkbox chk_rules_lowpoly_table_2_2 "2. ?????????? ? ?????????? ??? ?? ?????" checked:true offset:[0,10] align:#left tooltip:"2. ?????????? ? ?????????? ?????? ??? ?? ????????? ????? ??????? FBX"
		checkbox chk_rules_lowpoly_table_2_2_1 "2.1. ?????????? ??????, ?????" checked:true offset:[20,0] tooltip:"2.1. ?????????? ?????? ?? ????????? (?? ????? 20) ?????? ??????? FBX ????????? ?????? ??? ?????????? ?????????? ??????????? ????????? ? ??????? ?????? ????? ??????? FBX (??.?.3.7)." 
		checkbox chk_rules_lowpoly_table_2_2_2 "2.2. ?????????? ?? ???????" checked:true offset:[20,0] tooltip:"2.2. ?????????? ????? ?????????????? ????????????? ?? ??????? ??? ????????? ????????? ????????: ??????????????? ???????, ???????, ????????, ?????????, ??????????." 
		checkbox chk_rules_lowpoly_table_2_2_3 "2.3. ?????????? ?? ??????. ??????" checked:true offset:[20,0] tooltip:"2.3. ??? ?????????? ??? ?? ????????? ?????? ??????? FBX ?????????????? ??????????? ? ?????????????? ??????. " 
		checkbox chk_rules_lowpoly_table_2_2_4 "2.4. ????????? ? ?????????????" checked:true offset:[20,0] tooltip:"2.4. ??? ?????????? ??? ?? ????????? ?????? ??????? FBX ????????? ? ????????????? ?? ?????????? ? ?????? ????? ??????? FBX, ? ???????? ???????? ? ?????? ????? ???." 

		checkbox chk_rules_lowpoly_table_2_3 "3. ?????????? ? ???????? ?????????" checked:true offset:[0,10] align:#left tooltip:"3. ?????????? ? ???????? ?????????"
		checkbox chk_rules_lowpoly_table_2_3_1 "3.1. ??????????? ?????????? ??-???" checked:true offset:[20,0] tooltip:"3.1. ??? ???????? ??????? (?????) ??????? ???????????? ?????????? ????????? ?????????? ??????????? ????????? (??????? 4), ????? ???????, ??????????? ??? ??????????? UV-?????????." 
		checkbox chk_rules_lowpoly_table_2_3_2 "3.2. ????? ???? ??? ?????? ???????" checked:true offset:[20,0] tooltip:"3.2. ??????? ????????? ? ?????????????? ??????, ????????????? ?????? ??????, ?????? ????????????? ? ????? ????? ??????? FBX." 
		checkbox chk_rules_lowpoly_table_2_3_3 "3.3. ????????? ???? ??? ??-??" checked:true offset:[20,0] tooltip:"3.3. ???????????????, ??? ???????? ? ???????? ?????????????? ?????? ???? ???????????? ? ????????? ???? ??????? FBX (??????? 2)." 
		checkbox chk_rules_lowpoly_table_2_3_4 "3.4. ???? ????????? ???? > 1?" checked:true offset:[20,0] tooltip:"3.4. ???????? ?? ????????? ??????? ????????? ??????????????? ?????? ???? ????????? ???? ?? ?????????? ?? ????? 1 ?????." 
		checkbox chk_rules_lowpoly_table_2_3_5 "3.5. ????????????? ????? ? ??????" checked:true offset:[20,0] tooltip:"3.5. ??????? ????????? ?? ?????? ????? ????????????? ?????? ????? ?????, ????? ? ?.?." 
		checkbox chk_rules_lowpoly_table_2_3_6 "3.6. ?????????? ????? ??-???" checked:true offset:[20,0] tooltip:"3.6. ?????????? ?????????? ?????????? ??????????? ????????? ?????? ??? ? ?????? ?????? ????? ??????? FBX - 150 000, ??? ???????????????, ??? ????????? ? ????????? ?????????????? ? ????? - 180 000." 
		checkbox chk_rules_lowpoly_table_2_3_7 "3.7. ????????, ???????????, ??????" checked:true offset:[20,0] tooltip:"3.7. ??????? ????????? ?? ?????? ?????????:\n ?????????? ? ??????????????? ??????, ????? ? ????????? (??????????? ?????????? 0,002 ?);\n ????????????? ??????, ????? ? ?????????;\n ???????? ??????? ?????;" 
		checkbox chk_rules_lowpoly_table_2_3_8 "3.8. ??????? ???????? ??????" checked:true offset:[20,0] tooltip:"3.8. ??????? ????????, ??????? ? ???????? ????? ??????????, ?????? ???? ?????????? ? ??????? ???????????." 
		checkbox chk_rules_lowpoly_table_2_3_9 "3.9. ?????? ? ???????????? ??-??" checked:true offset:[20,0] tooltip:"3.9. ?????????????? ?????????????? ? ???????????? ????????, ?? ???????? ?? ????? ????? ??????? ?????????????, ???????????? ? ??????? ??????????? ?? ?????????? ??????." 
		checkbox chk_rules_lowpoly_table_2_3_10 "3.10. ?????? ?????????????? ?????????" checked:true offset:[20,0] tooltip:"3.10. ??? ??????????? ???????? ??????????? ?????????????? ?????????, ????????????? ???? ?????, ?????????? ????? ???? ?????? ?????????? ?? ????? 5 ?? ? ?? ????? 2 ??." 
		checkbox chk_rules_lowpoly_table_2_3_11 "3.11. ??????? ?????????????? ???." checked:true offset:[20,0] tooltip:"3.11. ?????????????? ?????? ???????? ????, ????? ??????????, ?? ?????? ????? ???????." 
		checkbox chk_rules_lowpoly_table_2_3_12 "3.12. ???????????? ????????" checked:true offset:[20,0] tooltip:"3.12. ??????? ????????? ?????? ???? ??????????????? ????? ????????? ? ???? ??????? FBX." 
		checkbox chk_rules_lowpoly_table_2_3_13 "3.13. ????????? ?? ??????????? ??????" checked:true offset:[20,0] tooltip:"3.13. ???????? ?????????? ??????????? ?????? (?????, ???????, ???) ?????? ?????????????? ? ?????????? ???? ?????? ? ??? ????? ??????, ??? ??? ????? ??????????????? ?????? ?????????????? ?????? (??????? 1?)." 
		checkbox chk_rules_lowpoly_table_2_3_14 "3.14. ????????????? ???????? ? ?????." checked:true offset:[20,0] tooltip:"3.14. ????????, ??? ??????? ???????????? ????? ????????????, ?????? ?????????? ??????????????." 
		checkbox chk_rules_lowpoly_table_2_3_15 "3.15. ?????????? ???????" checked:true offset:[20,0] tooltip:"3.15. ? ??????? ?? ?????? ???? ?????????? ????????: ??? ??????? ??????? ? ??????? ???????????, ?????????? ??????? ??? ?????-???? ?????? ????????, ? ???? ?????? ??????????? ?? ?????? ???? ????????? ????????????? ?????????, ??? ?? ???????? ???, ??????? ?? ??????????????? ?? ??? ????? ?????." 
		checkbox chk_rules_lowpoly_table_2_3_16 "3.16. ????????????? ?????? ????????" checked:true offset:[20,0] tooltip:"3.16. ??? ????????????? ?????? ?????? ???? ???????? (?????????)." 
		checkbox chk_rules_lowpoly_table_2_3_17 "3.17. ?????? ???????????" checked:true offset:[20,0] tooltip:"3.17. ?????? ??????????? ?????????? ????????????? ???????? ??????? ? ??????????? ?? ?????? ?? ?????????." 

		checkbox chk_rules_lowpoly_table_2_4 "4. ?????????? ? ??????????" checked:true offset:[0,10] align:#left tooltip:"4. ?????????? ? ??????????"
		checkbox chk_rules_lowpoly_table_2_4_1 "4.1. ??????????? ?????????" checked:true offset:[20,0] tooltip:"4.1. ????????? ?? ?????? ???? ??????? ??? ?????? ????????? ??????? ??????? (VRay, Octane, Corona, Arnold ? ??????? ?? ??? ???????????? ??????????? ???????? ????????, ? ????? Physical Material, Blend)."
		checkbox chk_rules_lowpoly_table_2_4_2 "4.2. ???????? ?????????????? ???????" checked:true offset:[20,0] tooltip:"4.2. ???????? ?????????????? ??????? ?? ?????? ????????? ? ???? ?????????? ????."
		checkbox chk_rules_lowpoly_table_2_4_3 "4.3. ???? ?????????????? ???????" checked:true offset:[20,0] tooltip:"4.3. ???? ????????? ?????????????? ??????? ???????? ???????????? ????? ????????? ?????????? ????????? (??????? 16)." 
		checkbox chk_rules_lowpoly_table_2_4_4 "4.4. ???????? ? ??????? ???-??" checked:true offset:[20,0] tooltip:"4.4. ???????? ? ??????? ??????????, ??? ?????????????, ?????????? ??????????????? ??????????? ???????." 
		checkbox chk_rules_lowpoly_table_2_4_5 "4.5. ???-?? ?????????? ? ???????" checked:true offset:[20,0] tooltip:"4.5. ?????????? ?????????? (????? ?????????? ?????????????? ???????) ????????????? ?????????? ?????????? ???????." 
		checkbox chk_rules_lowpoly_table_2_4_6 "4.6. ???-?? ?????????????? ???-??" checked:true offset:[20,0] tooltip:"4.6. ?????????? ?????????? ??? ?????????????? ??????? ?? ?????? ????????? 7." 

		checkbox chk_rules_lowpoly_table_2_5 "5. ?????????? ? ?????????? ??????" checked:true offset:[0,10] align:#left tooltip:"5. ?????????? ? ?????????? ?????? (???? ???????)"
		checkbox chk_rules_lowpoly_table_2_5_1 "5.1. ?????????? ????? PNG" checked:true offset:[20,0] tooltip:"5.1. ?????????? ????? ?????? ??????????????? ? ???? ?????????? ??????? ? ??????? PNG ? ???? ???????? ? ???? ??????? FBX (??????? 5)."
		checkbox chk_rules_lowpoly_table_2_5_2 "5.2. ?????????? ??????? ????" checked:true offset:[20,0] tooltip:"5.2. ????????? ????????? ??????? ?????????? ????: 128x128, 256x256, 512x512, 1024x1024, 2048x2048 ????????, ???????????? ?????? ?????????? ?????, ?????? ??????? ????????? (??.?.5.11), 2048x2048 ????????"
		checkbox chk_rules_lowpoly_table_2_5_3 "5.3. ?????? ? 8 ????????" checked:true offset:[20,0] tooltip:"5.3. ????????????? ??????????? ?????????? ?????? ? 8 ????????."
		checkbox chk_rules_lowpoly_table_2_5_4 "5.4. ??????????? ?????? 1:1" checked:true offset:[20,0] tooltip:"5.4. ??????????? ?????? ?????????? ????? ?????? ???? ?????? 1:1."
		checkbox chk_rules_lowpoly_table_2_5_5 "5.5. ?????-????? ????????" checked:true offset:[20,0] tooltip:"5.5. ?????-????? ???????? ? ?????????????."
		checkbox chk_rules_lowpoly_table_2_5_6 "5.6. ?????? ???? 5 ?????" checked:true offset:[20,0] tooltip:"5.6. ?????????? ????? ??????????? ????????? ??????????????, ?????? ?? ????? ???????????? ? ? ???????????? ? ???????????? ??????? ?????????. ??????????? ????????? ????? ??????? ??? ??????? ????????? ??????? ?? ????: ?????????? ?????, ????????, ????????????, ????? ????????????? ? ?????????????. ????????? ??? ???????????? ??????????? ? ???? (??????? 6)."
		checkbox chk_rules_lowpoly_table_2_5_7 "5.7. ?????????? ?????? ? ??????" checked:true offset:[20,0] tooltip:"5.7. ??? ?????????? ????? ? ?????? ?????? ??????????? ?????? ?????? ????? ?????????? ??????."
		checkbox chk_rules_lowpoly_table_2_5_8 "5.8. ????? ????????????? ??????" checked:true offset:[20,0] tooltip:"5.8. ????????? ?????? ?????????? ???? ????????????? ??????: ?????????????????? ?????? ??????????? ?? ?????? ?????????? ????? ? ?????? ????????????? ????? ??????, ?? ????? ????????????? - ??????, ????? ???????????? ???????????, ???? ?????????? ??????????, ??????????????? ????????? ???????? ??????? ??????, ??????????? ????????????? ????? ??????."
		checkbox chk_rules_lowpoly_table_2_5_9 "5.9. ?? ?????? ??? ?? 1 ?????? ????" checked:true offset:[20,0] tooltip:"5.9. ?? ?????? ??? ? ??????? ?????? ??? ?????????? ???????????? ?? ?????? ??????????? ??????."
		checkbox chk_rules_lowpoly_table_2_5_10 "5.10. ???? ???-?? ??????? ??-??" checked:true offset:[20,0] tooltip:"5.10. ???????????? ?????????? ??????? ??? ?????? ??????????????? - 20, ?? ?????????? ????? ???????????? ??????????? ? ????????? ????????."
		checkbox chk_rules_lowpoly_table_2_5_11 "5.11. ????? ??????? ??-??? ??-??" checked:true offset:[20,0] tooltip:"5.11. ??? ??????????????? ????????? ???????????????, ??????????? ? ???? ????????????? ???????? (? ??????????? ????????? ? ?????? ?????????? ? ????????????? ?????????? ?????????) ?????????? ???????????? ???? ?????????? ????? ?? ??? ????????, ???????? ?? ????? 512x512 ????????."
		checkbox chk_rules_lowpoly_table_2_5_12 "5.12. ????? ??????? ????-??" checked:true offset:[20,0] tooltip:"5.12. ??? ??????????????? ????????? ?????????????? ?????????? ???????????? ???? ?????????? ????? ???? ?? ??? ????????, ???????? ?? ????? 2048x2048 ????????. ? ?????????? ????? ?????? ??????? ? ???????????? ??????? ????? ?????????? ????? ?, ??? ?????????????, ????? ????????????."

		checkbox chk_rules_lowpoly_table_2_6 "6. ?????????? ? ????????? ????????" checked:true offset:[0,10] align:#left tooltip:"6.?????????? ? ????????? ????????"
		checkbox chk_rules_lowpoly_table_2_6_1 "6.1. ????????? ???? Ground" checked:true offset:[20,0] tooltip:"6.1. ?????????? ? ????????? ?????????? ???? ???????????????? ?????? ?? ??????????? ??????? ? ???????? ??????? ??????????: ????????? ??????? ?????? ???? ?? ?????? 10 ???????? ?? ??. ?????, ??? ??? ???????? 2048x2048 ????????????? ???????? ?? ????????? 204 ?? 204 ??????, ?? ?? ????? 40 ???????? ?? ???. ???? (??????? 7, ??????? 8)."
		checkbox chk_rules_lowpoly_table_2_6_2 "6.2. ????????? ???? ???????????" checked:true offset:[20,0] tooltip:"6.2. ?????????? ? ????????? ?????????? ???? ?? ???????????????? ?? ????????, ????????? ???? ??? ????? ?? ????????? ?????? ??????????????? ???????? ?????? 3.4 ????????? ??????????, ? ????? ?? ????????? ??????????????, ??? ? ????????? ???????????????."

		checkbox chk_rules_lowpoly_table_2_7 "7. ?????????? ? ???????? ????????? ??????" checked:true offset:[0,10] align:#left tooltip:"7. ?????????? ? ??????????? ???????? ????????? ??????/??????????????? ???????????\n??????????? ?????? ??????????? ???????????? ??? ??? ??????? ? ????? ???? ????????? ????? ????????? ? ????? ??????, ??? ??????? ??????????? ?????? ????? ????????? ? ????? ???????:"
		checkbox chk_rules_lowpoly_table_2_7_1 "7.1. ?????????? ????? ??????" checked:true offset:[20,0] tooltip:"7.1. ? ?????? ????????????? ?????????? ???? ?????? ?? ???????? ? ????????? ?????? ????????? ? ? ???????????? ??????? ?????????? ?????????? ????? ?????????????? ? ?????????????, ???????? ??????? 5.6, 5.8;"
		checkbox chk_rules_lowpoly_table_2_7_2 "7.2. ?????????????? ??????" checked:true offset:[20,0] tooltip:"7.2. ? ?????? ???????????????? ?????? ???????? ? ????????? ?????? ????????? ? ????????? ??????????? ???????? ???????? ??????? 4.2, 4.3 ????????? ??????????."		
		
		checkbox chk_rules_lowpoly_table_2_8 "8. ?????????? ? ????? ??????? ? ????? ????????" checked:true offset:[0,10] align:#left tooltip:"8. ?????????? ? ????? ??????? ? ????? ???????? ??????? ?????????"
		checkbox chk_rules_lowpoly_table_2_8_1 "8.1. ???? ???????? ???? ????????" checked:true offset:[20,0] tooltip:"8.1. ???? ???????? ???? ???????? ????????? ????? ?????????? (??????) ???????????????? ?????? ??????????????? ????? ???????? ??? ? ????? ?????????? ???????."
		checkbox chk_rules_lowpoly_table_2_8_2 "8.2. ??????? ????????? ???" checked:true offset:[20,0] tooltip:"8.2. ??? ??????? ????????? ?????? ????? ???????????? ???????? ? ?????????? ??????? ????????? ? ????? ???????? ?????????? ????????."
		checkbox chk_rules_lowpoly_table_2_8_3 "8.3. ???????????? ??????? ?????????" checked:true offset:[20,0] tooltip:"8.3. ?? ??????????? ????????????? ???????????? (????????) ??????? ????????? ??? ????????? ????????????? ???????? (?????????? ???????? ?????)."		

		checkbox chk_rules_lowpoly_table_2_9 "9. ?????????? ? ????????? ? ?????????????" checked:true offset:[0,10] align:#left tooltip:"9. ?????????? ? ????????? ????????? ? ?????????????"
		checkbox chk_rules_lowpoly_table_2_9_1 "9.1. ???????? ???? ????????, ???-??" checked:true offset:[20,0] tooltip:"9.1. ???????? ??????????? ? ????????????? ??????, ???????? ?????????, ?????????? ? ??????? ? ????? ???????????/?????????? ???????? ? ???????????? ???????:\n1. ? ???????????? ???????? ????????? ?????????? ?????????????? ?:\n_Main ??? (????? ?????????????? ???????)\n_MainGlass ?????????????? ??????? ???\n_Ground ???????????????	(????? ?????????????? ???????)\n_GroundGlass ??????????????	??????? ???????????????\n_GroundEl ????????? ???????????????: ???, ?????? ????????? ? ??. (????? ?????????????? ?????????)"		
		checkbox chk_rules_lowpoly_table_2_9_2 "9.2. ???????? ???? ????" checked:true offset:[20,0] tooltip:"9.2. ? ???????????? ?????????? ???? ?????????? ?????????????? ? ??????:\n_d ?????????? ?????\n_n ????????\n_o ????????????\n_m ?????????????\n_r ?????????????"	

		checkbox chk_rules_lowpoly_table_2_10 "10. ?????????? ? ??????" checked:true offset:[0,10] align:#left tooltip:"10. ?????????? ? ????????????? ??????, ?????????, ??????? ? ??????????"
		checkbox chk_rules_lowpoly_table_2_10_1 "10.1. ????? ???? ????? < 254 ???????" checked:true offset:[20,0] tooltip:"10.1. ????? ????????????, ??????? ????? ? ??? ????????, ????????? ? ????????, ?? ?????? ????????? ???????? ? 254 ???????."
		checkbox chk_rules_lowpoly_table_2_10_2 "10.2. ??????? ? ??????????? ? ??????" checked:true offset:[20,0] tooltip:"10.2. ???????????? ?????? ?????????? ????????????? ????????? (?????????? ?????????), ??????? ? ???????? ??????? ????????????? (_), ????????????? ?????? ????????????, ??????? ??????, ???????????."
		checkbox chk_rules_lowpoly_table_2_10_3 "10.3. ??????? ?????????? ??? FBX" checked:true offset:[20,0] tooltip:"10.3. ??????? ????????????."
		checkbox chk_rules_lowpoly_table_2_10_3_1 "10.3.1 ???? ??? ??? ?? ?????? ? FBX" checked:true offset:[20,0] tooltip:"10.3.1. ???? ?????? ????????? ???????? ????? ?pe???c_Address: 0313_ProezdNansena_ZU_8.zip 0313_77_02_0015007_4157_Vld_15.zip - ??? ??????? - ?????????????? ???, ???????????? ???????? ??????????????? ?????????????? ??????????????? ?????? ??????"
		checkbox chk_rules_lowpoly_table_2_10_3_2 "10.3.2 ???????? ???? ????? FBX" checked:true offset:[20,0] tooltip:"10.3.2. ???? ??????? FBX ????????? ???????? ??????, ??? ??????????? ?? ?????????? ?? ????????? ????? ??????? FBX: - ??? ??? ?pe???c_Address_?o?ep, ??? ????? - ??? ?????????? ????? fbx, ??? ????? ??? ? ?????? ???????, ??????????? ????? ?? 01 ?? 20, ??????????? ? ????? ? ???????, ?????? ??????????????? ? ??? ?????????, ? ??????? ???????????. ???? FBX ????, ?? ??? ?????????? ????? 01 0313_ProezdNansena_ZU_8_01.fbx 0313_ProezdNansena_ZU_8_02.fbx 0313_77_02_0015007_4157_Vld_l5_01.fbx - ??? ??????????????? ???????_Address_Ground 0313_ProezdNansena_ZU_8_Ground.fbx 0313_77_02_0015007_4157_Vld_15_Ground.fbx"
		checkbox chk_rules_lowpoly_table_2_10_3_3 "10.3.3 ???????? ???? ???????? ? FBX" checked:true offset:[20,0] tooltip:"10.3.3. ??????? ????????? ????????? ???????? ??????, ??? ??????????? ?? ?????????? ?? ????????? ????? ??????? FBX: - ??? ??? SM_Address_HOMep_Main, ??? ????? - ??? ?????????? ????? ??? ?? ???? ???????, ? ?? ? ?????????? FBX-?????, ??? ?????????? ??? ?? ?????, ??????????? ????? ?? 001 ?? 020, ??????????? ? ????? ? ???????, ?????? ??????????????? ? ??? ?????????, ? ??????? ???????????, ????????:SM_ProezdNansena_ZU_8_001_Main\nSM_Address ????? MainGlass - ??? ?????????????? ??????? ???, ????????: SM_ProezdNansena_ZU_8_001_MainGlass\n ??? ??????????????? SM_Address_Ground: SM_ProezdNansena_ZU_8_Ground\n ??? ?????????????? ??????? ??????????????? SM ????? GroundGlass, SM_ProezdNansena_ZU_8_GroundGlass\n- ??? ????????? ??????????????? SM_Address_GroundEl, SM_ProezdNansena_ZU_8_GroundEl\n- ??? ?????????????? ??????? ????????? ??????????????? SM_Address_GroundElGlass, SM_ProezdNansena_ZU_8_GroundElGlass\n- ??? ?????????????? SM_Address_Flora, SM_ProezdNansena_ZU_8_Flora"		
		checkbox chk_rules_lowpoly_table_2_10_3_4 "10.3.4 ???????? ???? ??????? ? FBX" checked:true offset:[20,0] tooltip:"10.3.4. ???????? ????????? ???????? ??????:\n	? ????????? ???????, ????? ?????? ?????????????, ? ??????????? ?????????? ??????? ???????: ??????? ?, ????? (??? ???????????????, ??? ????????? ? ??????????????) ??? ????? ????? (??? ???), ??????????????? ???????? ????????? ???????, ??????????????? ?????????? ?????? ???????, ???????? SlotNumber  ?????????? ????? ?????????, ? ???????? ??????????? ?????????? ????? (???????? ????????????, ???????????????, ??????? ? ???????). ???? ???????? ???????????? ? ?????? ?????? ?????, ?? ??? ?????????? ????? ????? 1, - ??? ???????, ??? ??????????? ?? ?????????? ?? ????????? ????? ??????? FBX\nT_Address_?o?ep_Cy????c?eo?e?p??_Cy???????????????????_SlotNumber\nT_ProezdNansena_ZU_8_001_Main_d_1\nT_ProezdNansena_ZU_8_002_Main_d_1\n- ??? ???????????????, ??? ????????? ? ??????????????\nT_Address_Cy????c?????????_?????????????????????_SlotNumber\nT_ProezdNansena_ZU_8_Ground_d_1.png\nT_ProezdNansena_ZU_8_GroundEl_d_1.png\nT_ProezdNansena_ZU_8_GroundEl_m_1.png\nT_ProezdNansena_ZU_8_GroundEl_r_1.png\n?_ProezdNansena_ZU_8_Flora_d_1.png\n?_ProezdNansena_ZU_8_Flora_o_1.png"
		checkbox chk_rules_lowpoly_table_2_10_3_5 "10.3.5 ???????? ???? ???-??? ? FBX" checked:true offset:[20,0] tooltip:"10.3.5. ????????? ????????? ???????? ??????: ????????? ?? ??????????? ?????????? ?????????????? ???????, ??????? ???????? ??? ?? ??????, ??? ? ??????????????? ??? ????????, ??? ???? ??? ??????? ???????????? ??????? ?, ? ??? ??????????  ??????? ?. ??????? ?????????? ???? ? ???????? ?????????? ??????????\n?_ProezdNansena_ZU_8_001_Main_1\n?_ProezdNansena_ZU_8_002_Main_1\n?_ProezdNansena_ZU_8_Main_1\n?_ProezdNansena_ZU_8_Main_2\n?_ProezdNansena_ZU_8_Ground_1\n?_ProezdNansena_ZU_8_GroundEl_1\n?_ProezdNansena_ZU_8_Flora_1\n??? ?????????????? ??????? M_Glass_HOMep, ??? ????? - ??? ?????????? ????? ????????? ?? 01 ?? 07 ??? ?????????????? ?????? ? ?????? ???????, ????????? ?????????????? ??????? ????? ?????????? ????????\nM_Glass_01\nM_Glass_02"
	
	mapped fn check_on e = e.checked = true
	mapped fn check_off e = e.checked = false
	
	on btn_lowpoly_checkers_on pressed do
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "_table_" != undefined collect i
		check_on arr
	)
		
	on btn_lowpoly_checkers_off pressed do
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "_table_" != undefined collect i
		check_off arr		
	)
	
	on chk_rules_lowpoly_table_1_All changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_1_" != undefined collect i
		if arg then check_on arr else check_off arr
	)
	
	on chk_rules_lowpoly_table_2_All changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_" != undefined collect i
		if arg then check_on arr else check_off arr
	) 
	
	on chk_rules_lowpoly_table_1_1 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_1_1" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_1_2 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_1_2" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_1_3 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_1_3" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_2_1 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_1" != undefined collect i
		if arg then check_on arr else check_off arr
	)	

	on chk_rules_lowpoly_table_2_2 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_2" != undefined collect i
		if arg then check_on arr else check_off arr
	)		
	
	on chk_rules_lowpoly_table_2_3 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_3" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_2_4 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_4" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_2_5 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_5" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_2_6 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_6" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_2_7 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_7" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on chk_rules_lowpoly_table_2_8 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_8" != undefined collect i
		if arg then check_on arr else check_off arr
	)	

	on chk_rules_lowpoly_table_2_9 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_9" != undefined collect i
		if arg then check_on arr else check_off arr
	)	

	on chk_rules_lowpoly_table_2_10 changed arg do 
	(
		arr = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "chk_rules_lowpoly_table_2_10" != undefined collect i
		if arg then check_on arr else check_off arr
	)	
	
	on btn_get_path_lowpoly_rules_check pressed do
	(
		--source = (getSavePath caption:"Select Folder with ZIP archive(es)" initialDir: maxFilePath)
		source = getOpenFileName "Select Archive ZIP File archive" types: "ZIP|*.zip|ALL|*.*" 
		print source
		if source != undefined then
		(
			if doesFileExist source then edt_lowpoly_rules_check_path.text = source --+ "\\"
			else edt_lowpoly_rules_check_path.text = ""
		)
		else edt_lowpoly_rules_check_path.text = ""
	)
	
	on btn_lowpoly_rules_check pressed do
	(
		pb_lowpoly.value = 0
		
		case rdo_check_lowpoly.state of
		(
			1:
			(
				if edt_lowpoly_rules_check_path.text != "" then
				(					
					err = ""					
					
					chks = #()
					chks = for i in RulesCheck_lowpoly.Controls where classof i == CheckBoxControl and findstring i.name "_table_" != undefined and i.checked collect i
					arr = #()
					if chks.count > 0 then arr = if edt_lowpoly_rules_check_path.text != "" then import_objects_file edt_lowpoly_rules_check_path.text else #()
					print #(arr)
					
					--print #(chks)
					if chks.count > 0 and arr.count > 0 then
					for i in #{1..chks.count} do
					(
						pb_lowpoly.value = (i as float) / (chks.count as float) * 100
						lbl_lowpoly_progress.text = chks[i].text
						--RulesCheck_lowpoly.scrollPos = 0
						case chks[i].name of
						(
							"chk_rules_lowpoly_table_1_All": (err += "\x2714 ;??????? 1. ????? ?????????? ? ???????;\n")
							"chk_rules_lowpoly_table_1_1": (err += "\x2714 ;1.?????????? ? ???????? ??????????????;\n")
							
							"chk_rules_lowpoly_table_1_1_1": --"1.1. FBX 7.4 (FBX 2014) binary" 
							(
								for f in arr[2] do --#(myfiles, filesFBX, filesTEX, filesAll, objAll)
								(
									--print f
									k = false
									v = 0
									
									in_file = openFile f mode:"rt" 
									if in_file != undefined then
									(
										k = if skipToString in_file "Kaydara FBX Binary" != undefined then true else false
									)
									close in_file
									free in_file
									
									if k then
									(
										if (v = GetFBXFileVersion f) as string == "7400" then () --err += "\x2714 ;1.1.1.; " + (getfilenamefile f) + ": FBX binary ???? ?????????? ?????? FBX 7.4 2014-2015\n"
										else err += "\x2716 ;1.1.1.;" + (getfilenamefile f) + ": FBX binary ???? ?? ?????????? ?????? " + v as string + " \n"
									)
									else err += "\x2716 ;1.1.1.;" + (getfilenamefile f) + ": ?? FBX binary ????\n"
								)
								--The first 27 bytes contain the header.
								--Bytes 0 - 20: Kaydara FBX Binary  \x00 (file-magic, with 2 spaces at the end, then a NULL terminator).
								--Bytes 21 - 22: [0x1A, 0x00] (unknown but all observed files show these bytes).
								--Bytes 23 - 26: unsigned int, the version number. 7300 for version 7.3 for example.
							)

							"chk_rules_lowpoly_table_1_1_2": () --(err += "\x2714 ;1.1.2.; ????? ??????????? ???????? ? ???? FBX ?? ??????????\n" ) --"1.2. ??????????? ?????????" 
							"chk_rules_lowpoly_table_1_1_3": () --(err += "\x2714 ;1.1.3.; ???????? ???????????? ?????? ?? ?? ???????????\n" ) --"1.3. ???????????? ?????? 3ds max" 
							"chk_rules_lowpoly_table_1_1_4": () --(err += "\x2714 ;1.1.4.; ???????????? ???????????? ?? ???????????????\n") --"1.4. ???????????? ????????????" 

							"chk_rules_lowpoly_table_1_2": (err += "\x2714 ;2.?????????? ? ???????? ?????????;\n") 
							"chk_rules_lowpoly_table_1_2_1": --"2.1. ??????? ????????? - ?????" 
							(
								--FbxImporter 
								stri = ""
								sys = ""
								for f in arr[2] do
								(
									DialogMonitorOPS.unRegisterNotification id:#eye
									dialogMonitorOps.enabled = true
									DialogMonitorOPS.RegisterNotification FBX_Statictics id:#eye
									importFile f using:FbxImporter --importFile "C:\\Temporary Files\\Elghansa\\Untitled2.fbx" using:FbxImporter
									dialogMonitorOPS.UnRegisterNotification id:#eye
									dialogMonitorOps.enabled = false	
									
									stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!.txt") ((dotNetClass "System.Text.Encoding").UTF8)	
									if stri != undefined then 
									(
										for str in stri where findstring str "File Units:" != undefined do sys = trimleft (trimright (filterstring str ":")[2])
									)
									if sys == "Meters" then () --err += "\x2714 ;1.2.1.; " + (getfilenamefile f) + ": ????????? ??????? ?????\n"
									else  err += "\x2716 ;1.2.1.; " + (getfilenamefile f) + ": ????????? ??????? ?? ?????\n"
								)
							)
							
							"chk_rules_lowpoly_table_1_3": (err += "\x2714 ;3.?????????? ? ?????????? Address;\n") 
							"chk_rules_lowpoly_table_1_3_1": --"3.1. ????? ???????????? ?????????? ??????, ??? ?????" 
							(
								--???????? ???????????? ????????
								t = parse_error_symbols (getfilenamefile edt_lowpoly_rules_check_path.text)
								if t != "" then 
								(
									if findstring t "." != undefined then err += "\x2716 ;1.3.1.; " + (getfilenamefile edt_lowpoly_rules_check_path.text) + ": ??? ????? ?????? ZIP ???????? ???????????? ??????? ????? .\n"
									--??????? ? 1_3_2 else err += "\x2716 ;1.3.1.; " + (getfilenamefile edt_lowpoly_rules_check_path.text) + ": ??? ????? ?????? ZIP ???????? ???????????? ???????\n"
								)
								--??????? ? 1_3_2 else err += "\x2714 ;1.3.1.; " + (getfilenamefile edt_lowpoly_rules_check_path.text) + ": ??? ????? ?????? ZIP ?? ???????? ???????????? ???????\n"

								for f in arr[2] do 
								(
									t = parse_error_symbols (getfilenamefile f)
									if t != "" then 
									(
										if findstring t "." != undefined then err += "\x2716 ;1.3.1.; " + (getfilenamefile f) + ": ??? ????? FBX ???????? ???????????? ??????? ????? .\n"
										--??????? ? 1_3_2 else err += "\x2716 ;1.3.1.; " + (getfilenamefile f) + ": ??? ????? FBX ???????? ???????????? ???????\n"
									)
									--??????? ? 1_3_2 else err += "\x2714 ;1.3.1.; " + (getfilenamefile f) + ": ??? ????? FBX ?? ???????? ???????????? ???????\n"					
								)

								excel_file1 = GetDir #maxroot + "GeoScripts\\abbr3.csv" --??? ???????? ?????????? ? ????? ?????? ? ???? ??????
								excel_file2 = GetDir #maxroot + "GeoScripts\\abbr4.csv" --??? ???????? ?????????? ? ????? ?????? ? ???? ????????
								stri_arr1 = #()
								stri1 = #()
								stri_long1 = #()
								stri_arr2 = #()
								stri2 = #()
								stri_long2 = #()
								stri_arr1 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file1 ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "???? abbr3.csv ?? ?????? ??? ?? ???????????")
								stri_arr2 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file2 ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "???? abbr4.csv ?? ?????? ??? ?? ???????????")

								--print #(stri_arr)
	
								if stri_arr1.count > 0 do 
								(
									for i in #{1..stri_arr1.count} do append stri1 (filterstring stri_arr1[i] ";")[2] 
									for i in #{1..stri_arr1.count} do append stri_long1 (translit (filterstring stri_arr1[i] ";")[1])
									qsort stri1 sortexcel_len --?????????? ?? ?????? ?????, ??????? ? ??????, ????? ????? ????????
									qsort stri_long1 sortexcel_len --?????????? ?? ?????? ?????, ??????? ? ??????, ????? ????? ????????										
								)
								
								if stri_arr2.count > 0 do 
								(
									for i in #{1..stri_arr2.count} do append stri2 (filterstring stri_arr2[i] ";")[2] 
									for i in #{1..stri_arr2.count} do append stri_long2 (translit (filterstring stri_arr2[i] ";")[1])
									qsort stri2 sortexcel_len --?????????? ?? ?????? ?????, ??????? ? ??????, ????? ????? ????????
									qsort stri_long2 sortexcel_len --?????????? ?? ?????? ?????, ??????? ? ??????, ????? ????? ????????										
								)

								--print #(stri)	
								--print (stri_long)									
				
								excel_file_ul = GetDir #maxroot + "GeoScripts\\ul5.csv" --??? ???????? ???????????? ???????? ????
								excel_file_pos = GetDir #maxroot + "GeoScripts\\ul4.csv" --??? ???????? ???????????? ???????? ?????????
								stri_arr3 = #()
								stri_arr4 = #()
								stri_arr3 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file_ul ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "???? ul5.csv ?? ?????? ??? ?? ???????????")
								stri_arr4 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file_pos ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "???? ul4.csv ?? ?????? ??? ?? ???????????")

								stri_ul = #()
								stri_ul_full = #()
								stri_pos = #()
								stri_pos_pre = #()
								--print #(stri_arr)
								if stri_arr3.count > 0 do 
								(
									for i in #{1..stri_arr3.count} do append stri_ul_full (filterstring stri_arr3[i] ";")[3] 
									for i in #{1..stri_arr3.count} do append stri_ul (filterstring stri_arr3[i] ";")[4] 
									--print (stri_ul)	
									--for s1 in #{1..stri_ul.count} where stri_ul[s1] != undefined do
									--(
									--	for s2 in #{1..stri_long.count} where stri_long[s2] != undefined do 
									--	(
									--		stri_ul[s1] = substitutestring stri_ul[s1] stri_long[s2] ""
									--		stri_ul[s1] = substitutestring stri_ul[s1] (tolower stri_long[s2]) ""
									--	)
									--	stri_ul[s1] = delete_few_symbols stri_ul[s1]
									--)
									--qsort stri_ul sortexcel_len --?????????? ?? ?????? ?????, ??????? ? ??????, ????? ????? ????????
									--print (stri_ul)		
								)
								if stri_arr4.count > 0 do 
								(
									for i in #{1..stri_arr4.count} do append stri_pos_pre (filterstring stri_arr4[i] ";")[2] 
									for i in #{1..stri_arr4.count} do append stri_pos (filterstring stri_arr4[i] ";")[3] 
								)
								
								--???????? ? ????? ??????
								t = getfilenamefile edt_lowpoly_rules_check_path.text
								--if t != translit t then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? ?????? ZIP ???????? ???????????? ??????? ?? ? ?????????\n"

								if findstring t "_" != undefined then --err += "\x2716 ;1.3.1.; " + t + ": ??? ????? ?????? ZIP ?? ???????? ??????? ?????????? _\n"
								(
									tt = #()
									tt_ini = #()
									tt = filterstring t "_"
									tt_ini = filterstring t "_"
									if tt.count > 1 then
									(
										for t1 in #{1..tt.count} do
										(		
											tt[t1][1] = toupper tt[t1][1]  
											--if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ??????????, ?????? ????? ?????? ?????????? ? ????????? ?????: " + tt_ini[t1] + "\n"
										)
										--print #(tt)	
				
										--???????? ?????? ????, ?? ?????? ???? 4 ? ??? ?????
										if delete_only_digits tt[1] != "" and tt[1].count != 4 then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ??????????, ?????? ??????? ?????? ???? ? ???? ??????? ???? ?????? ?? ??? ??: " + tt[1] + "\n"
										
										--???????? ???? ????? ?????????? ? ???????
										for t1 in #{1..tt.count} do
										(		
											tt[t1] = delete_only_digits tt[t1] 
											--if tt[t1] != "" and tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ????? ?????????? ?? ?????? ????????? ?????? ??????????????: " + tt_ini[t1] + "\n"
										)
										--print #(tt)
										
										--???????? ???? ???? ????????????? ???????? ????????? ??????
										for t1 in #{1..tt.count} where tt[t1] != "" do
										(		
											for t2 in #{1..stri_long1.count} do tt[t1] = substitutestring tt[t1] stri_long1[t2] "" --??????????? ?????? ?????? ??-??? ??????
											if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ?? ????????? ???????? ??????: " + tt_ini[t1] + "\n"
										)
										--print #(tt)	
										
										--???????? ???????????? ???????? ???? ? ????????
										for t1 in #{1..tt.count} where tt[t1] != "" and t1 <= 2 do
										(		
											for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul_full[t2] "" --??????????? ?????? ?????? ????
											for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] ("Pos" + stri_pos[t2]) "" --??????????? ?????? ?????? ????????
											for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] (stri_pos_pre[t2] + stri_pos[t2]) "" --??????????? ?????? ?????? ????????

											for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul[t2] "" --??????????? ?????? ?????? ????
											for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] stri_pos[t2] "" --??????????? ?????? ?????? ????????
		
											if tt[t1] == tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ???????? ?? ?????? ? ??????????? ?????????????? ????????????? ???? ?????? (??? 0012013): " + tt_ini[t1] + "\n"
										)
										--print #(tt)

										-- ???????? ????? ?? ?????? ??????????? ?????? ??????????????, ? ?????? ???? ???????? ??????, ??? ???? ?????? ????? ????? ??????? ? ??????? ?????.
										for t1 in #{1..tt.count} where tt[t1] != "" do
										(		
											for t2 in #{1..stri1.count} do tt[t1] = substitutestring tt[t1] stri1[t2] "" --??????????? ?????? ?????????? ??-??? ??????
											if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ?? ?????? ???? ?????????? ????????? ?????? ?: " + tt_ini[t1] + " ???, ????????, ??????????? ????????? ???????? ??????, ???????? ???????? ?????? ?? ?????? ??????????? ?????? ??????????????, ? ?????? ???? ???????? ??????, ??? ???? ?????? ????? ????? ??????? ? ??????? ????? \n"											
										)
										--print #(tt)

										-- ??????????? ????
										for t1 in #{1..tt.count} where tt[t1] != "" do
										(		
											for t2 in #{1..stri2.count} do tt[t1] = substitutestring tt[t1] stri2[t2] "" --??????????? ?????? ?????????? ??-??? ??????
											if tt[t1] == "D" or tolower tt[t1] == "dom" then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ?????????? D ??? ??? ??????????: " + tt_ini[t1] + " \n"											
											if tt[t1] == "Uch" then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, Uch ?????????? ???????? ?? ZU: " + tt_ini[t1] + " \n"											
											if tt[t1] == tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ?????????? ???????? ?????? ?? ?????? ? ??????: " + tt_ini[t1] + " \n"											
										)
										--print #(tt)										
									)
								)
								
								for f in arr[2] do 
								(
									t = getfilenamefile f
									--if t != translit t then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ???????? ???????????? ??????? ?? ? ?????????\n"
									if findstring t "_" != undefined then --err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ?? ???????? ??????? ?????????? _\n"
									(
										tt = #()
										ttt = #()
										tt_ini = #()
										tt = filterstring t "_"
										tt_ini = filterstring t "_"
										if tt.count > 1 then
										(
											for t1 in #{1..tt.count} do
											(		
												tt[t1][1] = toupper tt[t1][1]  
												--if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ??????????, ?????? ????? ?????? ?????????? ? ????????? ?????: " + tt_ini[t1] + "\n"
											)
											--print #(tt)												
											
											--???????? ?????? ????, ?? ?????? ???? 4 ? ??? ?????
											if delete_only_digits tt[1] != "" and tt[1].count != 4 then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ??????????, ?????? ??????? ?????? ???? ? ???? ??????? ???? ?????? ?? ??? ??: " + tt[1] + "\n"
	
											for t1 in #{1..tt.count} do --?????????????? ??????? ?? ???? ?? ???? ?????????
											(
												tt[t1] = delete_only_ground tt[t1] 
												tt_ini[t1] = delete_only_ground tt_ini[t1] 
											)
											--print #(tt)
										
											--???????? ???? ????? ?????????? ? ???????
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(	
												tt[t1] = delete_only_digits tt[t1] 
												if tt[t1] != "" and tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ????? ?????????? ?? ?????? ????????? ?????? ??????????????: " + tt_ini[t1] + "\n"
											)
											--print #(tt)
											
											/*
											--???????? ???????????? ???????? ????
											for t1 in #{1..tt.count} where tt[t1] != "" and t1 <= 2 do
											(		
												for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul[t2] "" --??????????? ?????? ?????? ????
												if tt[t1] == tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ???????? ?? ?????? ? ??????????? ?????????????? ????????????? ???? ?????? (??? 0012013): " + tt_ini[t1] + "\n"
											)
											--print #(tt)
											
											--???????? ???? ???? ????????????? ???????? ????????? ??????
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(		
												for t2 in #{1..stri_long.count} do tt[t1] = substitutestring tt[t1] stri_long[t2] "" --??????????? ?????? ?????? ??-??? ??????
												if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ?? ????????? ???????? ??????: " + tt_ini[t1] + "\n"
											)
											--print #(tt)

											-- ???????? ????? ?? ?????? ??????????? ?????? ??????????????, ? ?????? ???? ???????? ??????, ??? ???? ?????? ????? ????? ??????? ? ??????? ?????.
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(		
												for t2 in #{1..stri.count} do tt[t1] = substitutestring tt[t1] stri[t2] "" --??????????? ?????? ?????????? ??-??? ??????
												if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ?? ?????? ???? ?????????? ????????? ?????? ?: " + tt_ini[t1] + " ???, ????????, ??????????? ????????? ???????? ??????, ???????? ???????? ?????? ?? ?????? ??????????? ?????? ??????????????, ? ?????? ???? ???????? ??????, ??? ???? ?????? ????? ????? ??????? ? ??????? ????? \n"											
											)
											--print #(tt)
											*/

											--???????? ???? ???? ????????????? ???????? ????????? ??????
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(		
												for t2 in #{1..stri_long1.count} do tt[t1] = substitutestring tt[t1] stri_long1[t2] "" --??????????? ?????? ?????? ??-??? ??????
												if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ":??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ?? ????????? ???????? ??????: " + tt_ini[t1] + "\n"
											)
											--print #(tt)	
										
											--???????? ???????????? ???????? ???? ? ????????
											for t1 in #{1..tt.count} where tt[t1] != "" and t1 <= 2 do
											(		
												for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul_full[t2] "" --??????????? ?????? ?????? ????
												for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] ("Pos" + stri_pos[t2]) "" --??????????? ?????? ?????? ????????
												for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] (stri_pos_pre[t2] + stri_pos[t2]) "" --??????????? ?????? ?????? ????????

												for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul[t2] "" --??????????? ?????? ?????? ????
												for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] stri_pos[t2] "" --??????????? ?????? ?????? ????????
			
												if tt[t1] == tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ???????? ?? ?????? ? ??????????? ?????????????? ????????????? ???? ?????? (??? 0012013): " + tt_ini[t1] + "\n"
											)
											--print #(tt)

											-- ???????? ????? ?? ?????? ??????????? ?????? ??????????????, ? ?????? ???? ???????? ??????, ??? ???? ?????? ????? ????? ??????? ? ??????? ?????.
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(		
												for t2 in #{1..stri1.count} do tt[t1] = substitutestring tt[t1] stri1[t2] "" --??????????? ?????? ?????????? ??-??? ??????
												if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ?? ?????? ???? ?????????? ????????? ?????? ?: " + tt_ini[t1] + " ???, ????????, ??????????? ????????? ???????? ??????, ???????? ???????? ?????? ?? ?????? ??????????? ?????? ??????????????, ? ?????? ???? ???????? ??????, ??? ???? ?????? ????? ????? ??????? ? ??????? ????? \n"											
											)
											--print #(tt)		

											-- ??????????? ????
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(		
												for t2 in #{1..stri2.count} do tt[t1] = substitutestring tt[t1] stri2[t2] "" --??????????? ?????? ?????????? ??-??? ??????
												if tt[t1] == "D" or tolower tt[t1] == "dom" then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ?????????? D ??? ??? ??????????: " + tt_ini[t1] + " \n"											
												if tt[t1] == "Uch" then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, Uch ?????????? ???????? ?? ZU: " + tt_ini[t1] + " \n"											
												if tt[t1] == tt_ini[t1] then err += "\x2716 ;1.3.1.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ?????????? ???????? ?????? ?? ?????? ? ??????: " + tt_ini[t1] + " \n"											
											)
											--print #(tt)												
										)
									)
								)
							) 

							"chk_rules_lowpoly_table_1_3_2": --"3.2. ????? ????????? ????? _, ??????????? ?????????? ? ??????????? " 
							(
								--???????? ???????????? ????????
								t = parse_error_symbols (getfilenamefile edt_lowpoly_rules_check_path.text)
								if t != "" then err += "\x2716 ;1.3.2.; " + (getfilenamefile edt_lowpoly_rules_check_path.text) + ": ??? ????? ?????? ZIP ???????? ???????????? ???????\n"
								--else err += "\x2714 ;1.3.2.; " + (getfilenamefile edt_lowpoly_rules_check_path.text) + ": ??? ????? ?????? ZIP ?? ???????? ???????????? ???????\n"

								for f in arr[2] do 
								(
									t = parse_error_symbols (getfilenamefile f)
									if t != "" then err += "\x2716 ;1.3.2.; " + (getfilenamefile f) + ": ??? ????? FBX ???????? ???????????? ???????\n"
									--else err += "\x2714 ;1.3.2.; " + (getfilenamefile f) + ": ??? ????? FBX ?? ???????? ???????????? ???????\n"					
								)
								
								--???????? ?????????????
								t = getfilenamefile edt_lowpoly_rules_check_path.text
								if t != translit t then err += "\x2716 ;1.3.2.; " + t + ": ??? ????? ?????? ZIP ???????? ???????????? ??????? ?? ? ?????????\n"
								if findstring t "_" == undefined then err += "\x2716 ;1.3.2.; " + t + ": ??? ????? ?????? ZIP ?? ???????? ??????? ?????????? _\n"
								if findstring t " " != undefined then err += "\x2716 ;1.3.2.; " + t + ": ??? ????? ?????? ZIP ???????? ???????  \n"

								
								for f in arr[2] do 
								(
									t = getfilenamefile f
									if t != translit t then err += "\x2716 ;1.3.2.; " + t + ": ??? ????? FBX ???????? ???????????? ??????? ?? ? ?????????\n"
									if findstring t "_" == undefined then err += "\x2716 ;1.3.2.; " + t + ": ??? ????? FBX ?? ???????? ??????? ?????????? _\n"
									if findstring t " " != undefined then err += "\x2716 ;1.3.2.; " + t + ": ??? ????? FBX ???????? ???????  \n"										
								)	
							)
							
							"chk_rules_lowpoly_table_1_3_3": --"3.3. ?????????? ??????????????, ????? ? ????? ????????"
							(
								--???????? ? ????? ??????
								t = getfilenamefile edt_lowpoly_rules_check_path.text

								if findstring t "_" != undefined then 
								(
									tt = #()
									ttt = #()
									tt_ini = #()
									tt = filterstring t "_"
									tt_ini = filterstring t "_"
									if tt.count > 1 then
									(
										--???????? ???? ????? ?????????? ? ???????
										for t1 in #{1..tt.count} do
										(		
											tt[t1] = delete_only_digits tt[t1] 
											if tt[t1] != "" and tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.3.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ????? ?????????? ?? ?????? ????????? ?????? ??????????????: " + tt_ini[t1] + "\n"
										)
										--print #(tt)		
									)
								)	
								
								--???????? ? ????? fbx
								for f in arr[2] do 
								(
									t = getfilenamefile f
									if findstring t "_" != undefined then 
									(
										tt = #()
										ttt = #()
										tt_ini = #()
										tt = filterstring t "_"
										tt_ini = filterstring t "_"
										if tt.count > 1 then
										(
											--???????? ???? ????? ?????????? ? ???????
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(	
												tt[t1] = delete_only_digits tt[t1] 
												if tt[t1] != "" and tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.3.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ????? ?????????? ?? ?????? ????????? ?????? ??????????????: " + tt_ini[t1] + "\n"
											)
											--print #(tt)
										)
									)
								)
							)
							
							"chk_rules_lowpoly_table_1_3_4": --"3.4. ????????? ????? ? ??????" 
							(
								--???????? ? ????? ??????
								t = getfilenamefile edt_lowpoly_rules_check_path.text

								if findstring t "_" != undefined then 
								(
									tt = #()
									tt_ini = #()
									tt = filterstring t "_"
									tt_ini = filterstring t "_"
									if tt.count > 1 then
									(
										for t1 in #{1..tt.count} do
										(		
											tt[t1][1] = toupper tt[t1][1]  
											if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.4.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ?????? ????? ?????? ?????????? ? ????????? ?????: " + tt_ini[t1] + "\n"
										)
										--print #(tt)		
									)
								)	
								
								--???????? ? ????? fbx
								for f in arr[2] do 
								(
									t = getfilenamefile f
									if findstring t "_" != undefined then 
									(
										tt = #()
										tt_ini = #()
										tt = filterstring t "_"
										tt_ini = filterstring t "_"
										if tt.count > 1 then
										(
											for t1 in #{1..tt.count} where tt[t1] != "" do
											(	
												tt[t1][1] = toupper tt[t1][1] 
												if tt[t1] != tt_ini[t1] then err += "\x2716 ;1.3.4.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ?????? ????? ?????? ?????????? ? ????????? ?????: " + tt_ini[t1] + "\n"
											)
											--print #(tt)
										)
									)
								)								
							)
							
							"chk_rules_lowpoly_table_1_3_5": --"3.5. ????? ????? ??????????"
							(
								--???????? ? ????? ??????
								t = getfilenamefile edt_lowpoly_rules_check_path.text
								
								if t != substitutestring t "Ul" "" then err += "\x2716 ;1.3.5.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ????? Ul ?????????? ? ????????\n"
								if t != substitutestring t "Ulitsa" "" or t != substitutestring t "ulitsa" "" or t != substitutestring t "Ulicza" "" or t != substitutestring t "ulicza" "" or t != substitutestring t "Ulitza" "" or t != substitutestring t "ulitza" "" then err += "\x2716 ;1.3.5.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ????? ????? ? ????????? ?????????? ? ????????\n"
								
								--???????? ? ????? fbx
								for f in arr[2] do 
								(
									t = getfilenamefile f
									if t != substitutestring t "Ul" "" then err += "\x2716 ;1.3.5.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ????? Ul ?????????? ? ????????\n"
									if t != substitutestring t "Ulitsa" "" or t != substitutestring t "ulitsa" "" or t != substitutestring t "Ulicza" "" or t != substitutestring t "ulicza" "" or t != substitutestring t "Ulitza" "" or t != substitutestring t "ulitza" "" then err += "\x2716 ;1.3.5.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ????? ????? ? ????????? ?????????? ? ????????\n"
								)																
							)
							
							"chk_rules_lowpoly_table_1_3_6": --"3.6. ??????????? ????? - ??? :" 
							(
								--?-?-?1?2-?-?-?, 
								--?=77 - ??????????? ?????, 
								--? - ??????????? ????? 
								--?1 - ??????????? ?????
								--?2 - ??????????? ?????
								--? - ??????????? ?????
								--? - n-????????? ?????, ???????? ????? ?????? ??? ??????????
								--? - ?????????????? ?????, ???????? ????? ?????? ??? ???????? ????????? ? ??????...
								
								--???????? ? ????? ??????
								t = getfilenamefile edt_lowpoly_rules_check_path.text	
								if findstring t ":" != undefined then err += "\x2716 ;1.3.6.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ??? ???????? ???????????? ?????? ????? ?????????? ?? ?????? ????????? ?????? ??????????????\n"
									
								if findstring t "_" != undefined then 
								(
									tt = #()
									tt = filterstring t "_"
									if tt.count >= 5 then
									(
										--???????? ?? ??????????? ?????
										for t1 in #{2..5} where (for t2 in #{2..5} where delete_only_digits tt[t2] == "" collect tt[t2]).count == 4 do
										(
											if t1 == 2 and tt[t1].count != 2 and tt[t1] != "77" then err += "\x2716 ;1.3.6.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ? ??????????? ?????? ??????: " + tt[t1] + "\n"
											if t1 == 3 and tt[t1].count != 2 then err += "\x2716 ;1.3.6.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ? ??????????? ?????? ??????: " + tt[t1] + "\n"
											if t1 == 4 and tt[t1].count != 5 then err += "\x2716 ;1.3.6.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ? ??????????? ?????? ??????: " + tt[t1] + "\n"
											if t1 == 5 and tt[t1].count != 3 then err += "\x2716 ;1.3.6.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ? ??????????? ?????? ??????: " + tt[t1] + "\n"
										)
										--print #(tt)		
									)
								)	

								--???????? ? ????? fbx
								for f in arr[2] do 
								(
									t = getfilenamefile f
									if findstring t ":" != undefined then err += "\x2716 ;1.3.6.; " + t + ": ??? ????? FBX ???????? ???????? ?????? ?????????? ? ??????, ??? ???????? ???????????? ?????? ????? ?????????? ?? ?????? ????????? ?????? ??????????????\n"
									--???????? ?? ??????????? ?????
									if findstring t "_" != undefined then 
									(
										tt = #()
										tt = filterstring t "_"
										if tt.count >= 5 then
										(
											for t1 in #{2..5} where (for t2 in #{2..5} where delete_only_digits tt[t2] == "" collect tt[t2]).count == 4 do
											(
												if t1 == 2 and tt[t1].count != 2 and tt[t1] != "77" then err += "\x2716 ;1.3.6.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ? ??????????? ?????? ??????: " + tt[t1] + "\n"
												if t1 == 3 and tt[t1].count != 2 then err += "\x2716 ;1.3.6.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ? ??????????? ?????? ??????: " + tt[t1] + "\n"
												if t1 == 4 and tt[t1].count != 5 then err += "\x2716 ;1.3.6.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ? ??????????? ?????? ??????: " + tt[t1] + "\n"
												if t1 == 5 and tt[t1].count != 3 then err += "\x2716 ;1.3.6.; " + t + ": ??? ????? ?????? ZIP ???????? ???????? ?????? ?????????? ? ??????, ? ??????????? ?????? ??????: " + tt[t1] + "\n"
											)
										)
									)	
								)								
							)
							
							"chk_rules_lowpoly_table_2_All": (err += "\x2714 ;??????? 2. ?????????? ? ??? ???????;\n")
							"chk_rules_lowpoly_table_2_1": (err += "\x2714 ;1. ?????????? ? ??????, ???????, ?????????;\n")						

							"chk_rules_lowpoly_table_2_1_1": 
							(
								if (local p = ((GetFileSize edt_lowpoly_rules_check_path.text)/1024/1024/1024)) > 1.0 then err += "\x2716 ;2.1.1.; ?????? ?????? ZIP : " + p as string + "Gb > 1Gb \n" 
							) --else err += "\x2714 ;2.1.1.; ?????? ?????? ZIP : " + p as string + "Gb < 1Gb \n") --"1.1. ????? ZIP < 1 Gb" 
							
							"chk_rules_lowpoly_table_2_1_2": --#(myfiles, filesFBX, filesTEX, filesAll, objAll) "1.2. ????? ?????? ? ??????: 2..21 FBX"
							(
								if arr[2].count > 21 and arr[2].count < 2 then err += "\x2716 ;2.1.2.; ????? ?????? FBX ? ?????? ?? ? ????????? [2..21]: " + arr[2].count as string + "\n"
								local gr = 0
								local oks = 0
								for f in arr[2] do 
								(
									if findstring (getfilenamefile f) "_Ground" != undefined then gr += 1
									if findstring (getfilenamefile f) "_Ground" == undefined then oks += 1
								)
								if gr > 1 or oks == 0 then err += "\x2716 ;2.1.2.; ?????? ?????? FBX ? ?????? ?? ??????????, ?????? ???? ???? ???? ??????????????? FBX ? ?? 20 ?????? ??????? FBX ?????????? ??????? ??????? ???\n"
							)
							
							"chk_rules_lowpoly_table_2_1_3": --"1.3. ????? ? ??????? ??????" 
							(
								 --#(myfiles, filesFBX, filesTEX, filesAll, objAll)
								--print arr[5]
								if LayerManager.count > 1 then err += "\x2716 ;2.1.3.; ? ??????? ?????? ??????? FBX ?? ?????? ???? ?????????????? ?????\n"
							
								for o in (arr[5][arr[5].count]) do
								(
									print o.name
									if superClassOf o != GeometryClass then err += "\x2716 ;2.1.3.; ? ?????? ?????? ??????? FBX ?? ?????? ??????? ??????? ??????: " + o.name + " " + (superClassOf o) as string + " \n"
									else
									(
										converttopoly o
										if polyop.getNumVerts o == 0 or polyop.getNumEdges o == 0 or polyop.getNumFaces o == 0 then err += "\x2716 ;2.1.3.; ? ?????? ?????? ??????? FBX ?? ?????? ??????? ?????? ???????, ?? ?????????? ? ???? ?????, ????????? ??? ??????\n"
										if (o.position.x_position.controller.keys.count >= 1) or (o.position.y_position.controller.keys.count >= 1) or (o.position.z_position.controller.keys.count >= 1) or (o.rotation.x_rotation.controller.keys.count >= 1) or (o.rotation.y_rotation.controller.keys.count >= 1) or (o.rotation.z_rotation.controller.keys.count >= 1) or (o.scale.keys.count >= 1) then err += "\x2716 ;2.1.3.; ? ?????? ?????? ??????? FBX ?? ?????? ??????? ???????, ?????????? ? ???? ??????? ?????????? ? ???? ????????, ????? ????????\n"
										
										local aa = #("Circle", "Box", "Shape", "Line", "Sphere", "Plane")
										if (for a in aa where findstring o.name a != undefined collect o.name).count > 0 then err += "\x2716 ;2.1.3.; ? ?????? ?????? ??????? FBX ?? ?????? ??????? ??????????????? ???????, ?? ??????????? ? ?????????? ???????: " + o.name + "\n"
										
										local bb = #("Stacy", "People", "Humano", "_posed_", "RP_", "rp_", "Man", "Girl", "Women", "DAZ")
										if (for a in bb where findstring o.name a != undefined collect o.name).count > 0 then err += "\x2716 ;2.1.3.; ? ?????? ?????? ??????? FBX ?? ?????? ??????? ?????? ?????: " + o.name + "\n"

										local cc = #("Car", "Audi", "Mersedes", "Toyota", "Haval", "Avto")
										if (for a in cc where findstring o.name a != undefined collect o.name).count > 0 then err += "\x2716 ;2.1.3.; ? ?????? ?????? ??????? FBX ?? ?????? ??????? ?????? ??????????: " + o.name + "\n"

										local dd = #("UCX_", "USX_")
										if (for a in dd where findstring o.name a != undefined collect o.name).count > 0 then err += "\x2716 ;2.1.3.; ? ?????? ?????? ??????? FBX ??? ??? ?? ?????? ??????? ?????? UCX: " + o.name + "\n"

										local ee = #("_Glass") 
										if (for a in ee where findstring o.name a != undefined collect o.name).count > 0 then err += "\x2716 ;2.1.3.; ? ?????? ?????? ??????? FBX ??? ??? ?? ?????? ??????? ?????? _Glass, ???? ????????? _MainGlass, _GroundGlass, _GroundElGlass, ?????????? _Glass ??????????? ??? ???: " + o.name + "\n"

										--??? ?????????? ??????
										--?????????? ?????????? ??????????? 
										--?????????? ? ?????????? ????????????
										
										--????????
										--deleteKeys objects #allKeys
										--if LayerManager.count >1 then
										--(
										--	DelLayer = LayerManager.getLayerFromName "0"
										--	for obj in objects do DelLayer.addnode obj
										--	for id = LayerManager.count - 1 to 1 by -1 do
										--	(
										--		layer = LayerManager.getLayer id
										--		contains_nodes = LayerManager.doesLayerHierarchyContainNodes layer.name
										--		if not contains_nodes then deleted = LayerManager.deleteLayerByName layer.name
										--	)
										--)		
									)
								)
							)
							
							"chk_rules_lowpoly_table_2_1_4": --"1.4. ?????? FBX ??-?? ?????????, ?????? ?-?" "1.4. ? ?????? ????? ??????? FBX ???????????????, ?????? ?? ?????????? ??????? (?? 22 ??.), ?????? 5 ????????? ???????? ?????????:" 
							(	
								local gr = #()
								local gr_gl = #()
								local gr_el = #()
								local gr_el_gl = #()
								local gr_flora = #()
								local oks = #()
								local oks_gl = #()
								
								local all_texes = #()
								if arr[3].count > 0 then
								(
									for a in arr[3] do 
										for b in a do append all_texes b
								)
								else err += "\x2716 ;2.1.4.; ? ????? ?????? FBX ??? ???????, ????? ????????????? ???? FBX ? ??????????, ???????????? ? ??????????, ??? Embed Media\n"
								if all_texes.count == 0 then err += "\x2716 ;2.1.4.; ? ????? ?????? FBX ??? ???????, ????? ????????????? ???? FBX ? ??????????, ???????????? ? ??????????, ??? Embed Media\n"

								for o in (arr[5][arr[5].count]) do
								(
									--print o.name
									case of
									(
										(findstring o.name "_GroundElGlass" != undefined): append gr_el_gl o
										(findstring o.name "_GroundEl" != undefined): append gr_el o	
										(findstring o.name "_GroundGlass" != undefined): append gr_gl o
										(findstring o.name "_Ground" != undefined): append gr o
										(findstring o.name "_Flora" != undefined): append gr_flora o
										(findstring o.name "_MainGlass" != undefined): append oks_gl o
										(findstring o.name "_Main" != undefined): append oks o
									)
								)
								
								if chk_rules_lowpoly_table_2_1_4_1.checked then -- "1.4.1 ????????? ??????????????? (???????? 20 ?????????? ???????);"
								if gr.count != 0 then 
								(
									--print #(gr)
									for g in gr do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined and findstring (getfilenamefile t) "GroundEl" == undefined and findstring (getfilenamefile t) "GroundGlass" == undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4.1.; ? ????? ?????? FBX ??? ????????? ? ??????? Ground\n"
										if maps.count != tex.count then 
										(
											err += "\x2716 ;2.1.4.1; ? ????? ?????? FBX ????? ???? ? ????????? Ground ?? ???????????? ????? ??????????? ???????\n"
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count >= 20 then err += "\x2716 ;2.1.4.1.; ? ????? ?????? FBX ????????? ??????????????? ?????? ????? ???????? 20 ?????????? ???????\n"
										if maps.count == 0 then err += "\x2716 ;2.1.4.1.; ? ????? ?????? FBX ?? ????????? ????? ? ????? ????????? Ground\n"
										if tex.count == 0 then err += "\x2716 ;2.1.4.1.; ? ????? ?????? FBX ?? ????????? ????? Ground\n"
									)
								)
								
								if chk_rules_lowpoly_table_2_1_4_3.checked then -- "1.4.3 ????????? ????????? ????????? ??????????????? (???, ????? ????????? ? ??.) (1 ?????????? ?????);"
								if gr_el.count != 0 then 
								(
									--print #(gr_el)
									for g in gr_el do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined and findstring (getfilenamefile t) "GroundElGlass" == undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4.3.; ? ????? ?????? FBX ??? ????????? ? ??????? GroundEl\n"
										if maps.count != tex.count then 
										(
											err += "\x2716 ;2.1.4.3; ? ????? ?????? FBX ????? ???? ? ????????? GroundEl ?? ???????????? ????? ??????????? ???????\n"
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count > 1 then err += "\x2716 ;2.1.4.3.; ? ????? ?????? FBX ????????? ??????????????? GroundEl ?????? ????? ???????? 1 ?????????? ?????\n"
										if maps.count == 0 then err += "\x2716 ;2.1.4.3.; ? ????? ?????? FBX ?? ????????? ????? ? ????? ????????? GroundEl\n"
										if tex.count == 0 then err += "\x2716 ;2.1.4.3.; ? ????? ?????? FBX ?? ????????? ????? GroundEl\n"

									)									
								)

								if chk_rules_lowpoly_table_2_1_4_5.checked then --"1.4.5 ????????? ??????????????, ??????? ???????? ? ???? ??? ?????????????? ?? ????? (1 ?????????? ?????)."
								if gr_flora.count != 0 then 
								(
									--print #(gr_flora)
									for g in gr_flora do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4.5.; ? ????? ?????? FBX ??? ????????? ? ??????? Flora\n"
										if maps.count != tex.count then 
										(
											err += "\x2716 ;2.1.4.5; ? ????? ?????? FBX ????? ???? ? ????????? Flora ?? ???????????? ????? ??????????? ???????\n"
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count > 1 then err += "\x2716 ;2.1.4.5.; ? ????? ?????? FBX ????????? ??????????????? Flora ?????? ????? ???????? 1 ?????????? ?????\n"
										if maps.count == 0 then err += "\x2716 ;2.1.4.5.; ? ????? ?????? FBX ?? ????????? ????? ? ????? ????????? Flora\n"
										if tex.count == 0 then err += "\x2716 ;2.1.4.5.; ? ????? ?????? FBX ?? ????????? ????? Flora\n"
									)
								)
								
								if oks.count != 0 then 
								(
									--print #(oks)
									for g in oks do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined and findstring (getfilenamefile t) "Ground" == undefined and findstring (getfilenamefile t) "Glass" == undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4; ?????????????. ? ????? ?????? FBX ??? ????????? ? ??????? Main\n"
										if maps.count != tex.count then 
										(
											err += "\x2716 ;2.1.4.; ?????????????. ? ????? ?????? FBX ????? ???? ? ????????? Main: " + g.name + " ?? ???????????? ????? ??????????? ???????\n"
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count > 1 then err += "\x2716 ;2.1.4.; ?????????????. ? ????? ?????? FBX ????????? Main: " + g.name + "?????? ??? ?????? ????? ???????? 1 ?????????? ?????\n"
										if maps.count == 0 then err += "\x2716 ;2.1.4.; ?????????????. ? ????? ?????? FBX ?? ????????? ????? ? ????? ????????? Main: " + g.name + "\n"
										if tex.count == 0 then err += "\x2716 ;2.1.4.; ?????????????. ? ????? ?????? FBX ?? ????????? ????? Main: " + g.name + "\n"
									)									
								)
								
								if oks_gl.count != 0 then 
								(
									--print #(oks_gl)
									for g in oks_gl do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4.; ?????????????. ? ????? ?????? FBX ??? ????????? ? ??????? MainGlass\n"
										if maps.count != tex.count then 
										(
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count > 0 then err += "\x2716 ;2.1.4.; ?????????????. ? ????? ?????? FBX ????????? MainGlass ?? ?????? ????? ?????????? ???????\n"
										if maps.count != 0 then err += "\x2716 ;2.1.4.; ?????????????. ? ????? ?????? FBX ?? ?????? ???? ????? ? ?????? ????????? MainGlass\n"
										if tex.count != 0 then err += "\x2716 ;2.1.4.; ?????????????. ? ????? ?????? FBX ?? ?????? ???? ???? ? MainGlass\n"
									)
								)
								
								if chk_rules_lowpoly_table_2_1_4_4.checked then --"1.4.4 ????????? ?????????????? ??????? ????????? ??????????????? (??? ???????) (??? ?????????? ???????);"
								if gr_el_gl.count != 0 then 
								(
									--print #(gr_el_gl)
									for g in gr_el_gl do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4.4.; ? ????? ?????? FBX ??? ????????? ? ??????? GroundElGlass\n"
										if maps.count != tex.count then 
										(
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count > 0 then err += "\x2716 ;2.1.4.4.; ? ????? ?????? FBX ????????? ??????????????? GroundElGlass ?? ?????? ????? ?????????? ???????\n"
										if maps.count != 0 then err += "\x2716 ;2.1.4.4.; ? ????? ?????? FBX ?? ?????? ???? ????? ? ?????? ????????? GroundElGlass\n"
										if tex.count != 0 then err += "\x2716 ;2.1.4.4.; ? ????? ?????? FBX ?? ?????? ???? ???? ? GroundElGlass\n"
									)
								)
								
								if chk_rules_lowpoly_table_2_1_4_2.checked then -- "1.4.2 ????????? ?????????????? ??????? ??????????????? (??? ???????) (??? ?????????? ???????);"
								if gr_gl.count != 0 then 	
								(
									--print #(gr_gl)
									for g in gr_gl do 
									(
										tex = #()
										maps = #()
										nabor = #()
										nabor_count = 0
										tex = for t in all_texes where findstring (getfilenamefile t) (substitutestring g.name "SM_" "T_") != undefined collect (getfilenamefile t)
										if g.material != undefined then maps = usedMaps g.material else err += "\x2716 ;2.1.4.2.; ? ????? ?????? FBX ??? ????????? ? ??????? GroundGlass\n"
										if maps.count != tex.count then 
										(
											if maps.count > tex.count then 
											(
												for t in maps do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
											)
											else
											(
												for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
												nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 									
											)
										)
										else
										(
											for t in tex do appendIfUnique nabor ((filterstring t "_")[(filterstring t "_").count])
											nabor_count = (for n in nabor where delete_only_digits n == "" collect n).count 
										)
										--print #(tex)
										--print #(maps)
										--print #(nabor)
										--print nabor_count
										if nabor_count > 0 then err += "\x2716 ;2.1.4.2.; ? ????? ?????? FBX ????????? ??????????????? GroundGlass ?? ?????? ????? ?????????? ???????\n"
										if maps.count != 0 then err += "\x2716 ;2.1.4.2.; ? ????? ?????? FBX ?? ?????? ???? ????? ? ?????? ????????? GroundGlass\n"
										if tex.count != 0 then err += "\x2716 ;2.1.4.2.; ? ????? ?????? FBX ?? ?????? ???? ???? ? GroundGlass\n"
									)
								)
							)								
							
							"chk_rules_lowpoly_table_2_1_5": --"1.5. ??????? ???????????????" 
							(
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" != undefined collect (getfilenamefile f)).count != 1 then err += "\x2716 ;2.1.5.; ????? ??????????????? - ???????????? ????? ??? ? ???????? ????????????? ? ??????????\n"
							)
							
							"chk_rules_lowpoly_table_2_1_6": --"1.6. ??? ??? ? ??-?? ??-?? ???? ? ??? ? ???" 
							(
								--_Main ??? (????? ?????????????? ???????)
								--_MainGlass ?????????????? ??????? ???
								--_Ground ???????????????	(????? ?????????????? ???????)
								--_GroundGlass ??????????????	??????? ???????????????
								--_GroundEl ????????? ???????????????: ???, ?????? ????????? ? ??. (????? ?????????????? ?????????)
								--_GroundElGlass ??????????????	????????? ???????????????
								--_Flora ??????????????

								local gr = 0
								local gr_gl = 0
								local gr_el = 0
								local gr_el_gl = 0
								local gr_flora = 0
								local oks = 0
								local oks_gl = 0
								
								for o in (arr[5][arr[5].count]) do
								(
									--print o.name
									case of
									(
										(findstring o.name "_GroundElGlass" != undefined): gr_el_gl += 1
										(findstring o.name "_GroundEl" != undefined): gr_el += 1	
										(findstring o.name "_GroundGlass" != undefined): gr_gl += 1
										(findstring o.name "_Ground" != undefined): gr += 1
										(findstring o.name "_Flora" != undefined): gr_flora += 1
										(findstring o.name "_MainGlass" != undefined): oks_gl += 1
										(findstring o.name "_Main" != undefined): oks += 1
									)
								)
								if gr == 0 then err += "\x2716 ;2.1.6.; ??? ?????? Ground, ?????? ??????????????? ??????? ??? ?????? ???? ???????????\n"
								if gr_el == 0 then err += "\x2716 ;2.1.6.; ??? ?????? GroundEl, ?????? ??????????????? ??????? ??? ?????? ???? ??????????? ? ?????? ????. ??? ????????, ? ??? ?????, ???, ??????? ????????? ? ??.\n"
								if gr_flora == 0 then err += "\x2716 ;2.1.6.; ??? ?????? Flora, ?????? ??????????????? ??????? ??? ?????? ???? ??????????? ? ?????? ????. ??? ????????, ? ??? ?????, ??????????\n"
								if oks == 0 then err += "\x2716 ;2.1.6.; ??? ??????? Main, ??? ??? ??????? ??? ?????? ???? ??????????? ? ?????? ????\n"
								if oks_gl == 0 then err += "\x2716 ;2.1.6.; ??? ?????? MainGlass\n"
								if gr_el_gl == 0 then err += "\x2716 ;2.1.6.; ??? ?????? GroundElGlass\n"
								if gr_gl == 0 then err += "\x2716 ;2.1.6.; ??? ?????? GroundGlass\n"	
							)
							
							"chk_rules_lowpoly_table_2_2": (err += "\x2714 ;2. ?????????? ? ?????????? ??? ?? ?????;\n") -- "2. ?????????? ? ?????????? ??? ?? ?????" 
							"chk_rules_lowpoly_table_2_2_1":  -- "2.1. ?????????? ??????, ?????" "2.1. ?????????? ?????? ?? ????????? (?? ????? 20) ?????? ??????? FBX ????????? ?????? ??? ?????????? ?????????? ??????????? ????????? ? ??????? ?????? ????? ??????? FBX (??.?.3.7)." 
							(
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" == undefined collect (getfilenamefile f)).count > 1 then err += "\x2716 ;2.2.1.; ?????????? ?????? ?? ????????? ?????? ??????? FBX ????????? ?????? ??? ?????????? ?????????? ??????????? ????????? ? ??????? ?????? ????? ??????? FBX.\n"
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" == undefined collect (getfilenamefile f)).count > 20 then err += "\x2716 ;2.2.1.; ?????????? ?????? ?? ????? ?????? ??????? FBX ?????? 20?? ???????????.\n"
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" != undefined collect (getfilenamefile f)).count > 1 then err += "\x2716 ;2.2.1.; ?????????? ?????? ??????????????? ?? ????????? ?????? ??????? FBX ???????????.\n"
							)
							
							"chk_rules_lowpoly_table_2_2_2": -- "2.2. ?????????? ?? ???????" "2.2. ?????????? ????? ?????????????? ????????????? ?? ??????? ??? ????????? ????????? ????????: ??????????????? ???????, ???????, ????????, ?????????, ??????????." 
							(
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" == undefined collect (getfilenamefile f)).count > 1 then err += "\x2716 ;2.2.2.; ?????????? ?????? ?? ????????? ?????? ??????? FBX ????? ?????????????? ????????????? ?? ??????? ??? ????????? ????????? ????????: ??????????????? ???????, ???????, ????????, ?????????, ??????????.\n"
							)
							
							"chk_rules_lowpoly_table_2_2_3": -- "2.3. ?????????? ?? ??????. ??????" "2.3. ??? ?????????? ??? ?? ????????? ?????? ??????? FBX ?????????????? ??????????? ? ?????????????? ??????. " 
							(
								local q_main = #()
								local q_main_glass = #()
								
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" == undefined collect (getfilenamefile f)).count > 1 then 
								(
									for oo in arr[5] do
									(
										q_main = #()
										q_main_glass = #()
										for o in oo where findstring (tolower o.name) "_ground" == undefined do 
										(
											if findstring (tolower o.name) "_mainglass" != undefined then append q_main_glass o.name
											if findstring (tolower o.name) "_main" != undefined and findstring (tolower o.name) "glass" == undefined then append q_main o.name	
										)
										if q_main_glass.count != q_main.count then err += "\x2716 ;2.2.3.; ??? ?????????? ??? ?? ????????? ?????? ??????? FBX ?????????????? ??????????? ? ?????????????? ??????.\n"
									)										
								)
							) 

							"chk_rules_lowpoly_table_2_2_4": -- "2.4. ????????? ? ?????????????" "2.4. ??? ?????????? ??? ?? ????????? ?????? ??????? FBX ????????? ? ????????????? ?? ?????????? ? ?????? ????? ??????? FBX, ? ???????? ???????? ? ?????? ????? ???." 
							(
								if (for f in arr[2] where findstring (getfilenamefile f) "_Ground" == undefined collect (getfilenamefile f)).count > 1 then 
								(
									local aa = #()
									local bb = #()
									for o in (arr[5][arr[5].count]) where findstring o.name "Main" != undefined do
									(
										local a = (filterstring o.name "_")[(filterstring o.name "_").count - 1]
										append aa a
										appendifunique bb a
									)		
									if aa.count != bb.count then err += "\x2716 ;2.2.4.; ??? ?????????? ??? ?? ????????? ?????? ??????? FBX ????????? ? ????????????? ?? ?????????? ? ?????? ????? ??????? FBX, ? ???????? ???????? ? ?????? ????? ???.\n"
								)
							)
							
							"chk_rules_lowpoly_table_2_3": (err += "\x2714 ;3. ?????????? ? ???????? ?????????;\n") --"3. ?????????? ? ???????? ?????????"
							"chk_rules_lowpoly_table_2_3_1": -- "3.1. ??????????? ?????????? ??-???" "3.1. ??? ???????? ??????? (?????) ??????? ???????????? ?????????? ????????? ?????????? ??????????? ????????? (??????? 4), ????? ???????, ??????????? ??? ??????????? UV-?????????." 
							(
								err += " ;2.3.1.; ??? ???????? ??????? (?????) ??????? ???????????? ?????????? ????????? ?????????? ??????????? ?????????, ????? ???????, ??????????? ??? ??????????? UV-?????????.\n"
								--????? ????????? ????? ????????? ?????, ????? ?? ?????????? ?? ???? ????? ?????? ? ?????, ???? ??????? ?????????? ????? ???? ?? ?????????
							)
							
							"chk_rules_lowpoly_table_2_3_2": -- "3.2. ????? ???? ??? ?????? ???????" "3.2. ??????? ????????? ? ?????????????? ??????, ????????????? ?????? ??????, ?????? ????????????? ? ????? ????? ??????? FBX." 
							(
								local q_main = #()
								local q_main_glass = #()
								
								for oo in arr[5] do
								(
									q_main = #()
									q_main_glass = #()
									for o in oo where findstring (tolower o.name) "_ground" == undefined do 
									(
										if findstring (tolower o.name) "_mainglass" != undefined then append q_main_glass (substitutestring o.name "_MainGlass" "")
										if findstring (tolower o.name) "_main" != undefined and findstring (tolower o.name) "glass" == undefined then append q_main (substitutestring o.name "_Main" "")		
									)
									if q_main_glass.count == q_main.count and q_main_glass.count > 0 and q_main.count > 0 then 
									(
										for q in #{1..q_main_glass.count} where q_main_glass[q] != q_main[q] do err += "\x2716 ;2.3.2.; ??????? ????????? ? ?????????????? ??????, ????????????? ?????? ??????, ?????? ????????????? ? ????? ????? ??????? FBX: " + q_main_glass[q] " - " q_main[q] + "\n"
									)											
									else err += "\x2716 ;2.3.2.; ??????? ????????? ? ?????????????? ??????, ????????????? ?????? ??????, ?????? ????????????? ? ????? ????? ??????? FBX.\n"
								)										
							)					

							"chk_rules_lowpoly_table_2_3_3": -- "3.3. ????????? ???? ??? ??-??" "3.3. ???????????????, ??? ???????? ? ???????? ?????????????? ?????? ???? ???????????? ? ????????? ???? ??????? FBX (??????? 2)." 
							(
								local qq = #()
								for oo in arr[5] do
								(
									q = 0
									for o in oo where findstring (tolower o.name) "_ground" != undefined do 
									(
										case of
										(
											(findstring o.name "_GroundElGlass" != undefined): q += 1
											(findstring o.name "_GroundEl" != undefined): q += 1	
											(findstring o.name "_GroundGlass" != undefined): q += 1
											(findstring o.name "_Ground" != undefined): q += 1
											(findstring o.name "_Flora" != undefined): q += 1
										)
									)
									append qq q
								)
								if qq.count > 0 then
								(
									if (for s in qq where s > 0 collect s).count > 1 then err += "\x2716 ;2.3.3.; ???????????????, ??? ???????? ? ???????? ?????????????? ?????? ???? ???????????? ? ????????? ???? ??????? FBX.\n"
								)
								else err += "\x2716 ;2.3.3.; ???????????????, ??? ???????? ? ???????? ?????????????? ?????? ???? ???????????? ? ????????? ???? ??????? FBX.\n"
							)
								
							"chk_rules_lowpoly_table_2_3_4": -- "3.4. ???? ????????? ???? > 1?" "3.4. ???????? ?? ????????? ??????? ????????? ??????????????? ?????? ???? ????????? ???? ?? ?????????? ?? ????? 1 ?????." 
							(
								--????????? ????? ?? ?????????, ?????? ???????? ???? - ??? ?????, ???????? ?????? ?? ??? ?? ?????? ?????? ?????
								local numedges = #{}
								local vv = #{}
								local pp = #()
								local zz = #()
								
								for o in (arr[5][arr[5].count]) where findstring (tolower o.name) "_ground" != undefined and findstring (tolower o.name) "glass" == undefined and findstring (tolower o.name) "_groundel" == undefined do
								(
									--print o.name
									converttopoly o
									numedges = getConvexEdges o true 30 false false
									if not numedges.isempty then
									(
										vv = polyop.getVertsUsingEdge o numedges
										pp = for v in vv collect (polyop.getVert o v)
										for p1 in pp do
											for p2 in pp where p1 != p2 and abs(p1.x - p2.x) < 0.1 and abs(p1.y - p2.y) < 0.1 do append zz (abs(p1.z - p2.z))
										--print #(vv)
										--print #(pp)		
										--print #(zz)
										--print #(numedges)			
										--print "here"
										if zz.count > 0 then 
										(
											--print (amax zz)
											if (amax zz) <= 1.0 then err += "\x2716 ;2.3.4.; ???????? ?? ????????? ??????? ????????? ??????????????? ?????? ???? ????????? ???? ?? ?????????? ?? ????? 1 ?????: " + o.name + ", ??????: " + (amax zz) as string + "\n"
										)
										else err += "\x2716 ;2.3.4.; ???????? ?? ????????? ??????? ????????? ??????????????? ?????? ???? ????????? ???? ?? ?????????? ?? ????? 1 ?????: " + o.name + "\n"
									)
									else err += "\x2716 ;2.3.4.; ???????? ?? ????????? ??????? ????????? ??????????????? ?????? ???? ????????? ???? ?? ?????????? ?? ????? 1 ?????: " + o.name + "\n"
								)
							) 

							"chk_rules_lowpoly_table_2_3_5": -- "3.5. ????????????? ????? ? ??????" "3.5. ??????? ????????? ?? ?????? ????? ????????????? ?????? ????? ?????, ????? ? ?.?." 
							(
								for o in (arr[5][arr[5].count]) where o.parent != undefined do err += "\x2716 ;2.3.5.; ??????? ????????? ?? ?????? ????? ????????????? ?????? ????? ?????, ????? ? ?.?." + o.name + "\n"
							) 
							
							"chk_rules_lowpoly_table_2_3_6": -- "3.6. ?????????? ????? ??-???" "3.6. ?????????? ?????????? ?????????? ??????????? ????????? ?????? ??? ? ?????? ?????? ????? ??????? FBX - 150 000, ??? ???????????????, ??? ????????? ? ????????? ?????????????? ? ????? - 180 000." 
							(
								local num = 0
								local used = #()
								for o in #{1..arr[2].count} where findstring (getfilenamefile arr[2][o]) "_Ground" == undefined do
								(					
									num = 0
									for a in arr[5][o] where findItem used a == 0 do 
									(
										append used a
										converttopoly a
										num += polyop.getNumFaces a
									)	
									if num > 150000 then err += "\x2716 ;2.3.6.; ?????????? ?????????? ?????????? ??????????? ????????? ?????? ??? ? ?????? ?????? ????? ??????? FBX - 150 000: " + getfilenamefile arr[2][o] + "\n"
								)
								for o in #{1..arr[2].count} where findstring (getfilenamefile arr[2][o]) "_Ground" != undefined do
								(					
									num = 0
									for a in arr[5][o] where findItem used a == 0 do 
									(
										append used a
										converttopoly a
										num += polyop.getNumFaces a
									)	
									if num > 180000 then err += "\x2716 ;2.3.6.; ?????????? ?????????? ?????????? ??????????? ????????? ?????? ??? ???????????????, ??? ????????? ? ????????? ?????????????? ? ????? - 180 000 " + getfilenamefile arr[2][o] + "\n"
								)
							) 
							
							"chk_rules_lowpoly_table_2_3_7": -- "3.7. ????????, ???????????, ??????" "3.7. ??????? ????????? ?? ?????? ?????????:\n ?????????? ? ??????????????? ??????, ????? ? ????????? (??????????? ?????????? 0,002 ?);\n ????????????? ??????, ????? ? ?????????;\n ???????? ??????? ?????;" 
							(			
								for o in (arr[5][arr[5].count])	where (polyOp.getNumVerts o) > 0 or not keyboard.escPressed do
								(
									convertToPoly o
									local selverts = #{1..(polyOp.getNumVerts o)}
									local maximum_range = 0.002
									local verts_near = #{}
									
									for v1 in selverts where not keyboard.escPressed do
									(
										local p1 = polyop.getvert o v1	
										for v2 in selverts where v1 < v2 do
										(
											local p2 = polyop.getvert o v2
											local d = distance p1 p2
											if d <= maximum_range then verts_near += #{v1,v2}
										)
									)
									--print #(verts_near)
									if not verts_near.isempty then err += "\x2716 ;2.3.7.; ??????? ????????? ?? ?????? ?????????: ?????????? ? ??????????????? ??????, ??????????? ?????????? 0,002?: " + o.name + ", ????? ?????????? ??????: " + verts_near.numberset as string + "\n"
								)
								
								/*
								for o in (arr[5][arr[5].count])	where (polyOp.getNumEdges o) > 0 do
								(
									convertToPoly o
									local seledges = #{1..(polyOp.getNumEdges o)}
									local edges_parallel = #{}
									local vv1 = #{}
									local vv2 = #{}
									local pp1 = #()
									local pp2 = #()									
									
									for e1 in seledges do
									(
										vv1 += polyop.getVertsUsingEdge o #{e1}
										pp1 = for v in vv1 collect (polyop.getVert o v)
										for e2 in seledges where e1 < e2 do
										(
											vv2 += polyop.getVertsUsingEdge o #{e2}
											pp2 = for v in vv2 collect (polyop.getVert o v)
											angle = acos (dot (normalize (pp1[1] - pp1[2])) (normalize (pp2[1] - pp2[2]))) 				
											if angle >= abs(180 - 0.001) or angle <= abs(0.001) then edges_parallel += #{e1, e2} 
										)
									)
								)
								*/
								
								for o in (arr[5][arr[5].count])	where (polyOp.getNumFaces o) > 0 or not keyboard.escPressed do
								(
									convertToPoly o
									local er1 = #()
									local er2 = #()
									local er3 = #()
									local selfaces = #{1..(polyOp.getNumFaces o)}
									local minimum_range = 0.0
									local maximum_range = 0.002

									local do_verts = false -- true
									local near_perpendicular = 0.01 
									
									local invert_face = false
									local direction = 1.0
									er1 = get_hits o selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular
				
									polyop.flipNormals o selfaces
									
									direction = -1.0
									invert_face = false
									er2 = get_hits o selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular
									
									polyop.flipNormals o selfaces
				
									invert_face = true
									direction = -1.0
									er3 = get_hits o selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular
					
									if er1.count > 0 then err += "\x2716 ;2.3.7.; ??????? ????????? ?? ?????? ????????? ?????????? ? ??????????????? ?????????, ??????????? ?????????? 0,002?: " + o.name + ", ????? ?????????? ????????? ? ?????????, ?????????? ???? ?? ?????: " + er1.count as string + "\n"
									if er2.count > 0 then err += "\x2716 ;2.3.7.; ??????? ????????? ?? ?????? ????????? ?????????? ? ??????????????? ?????????, ??????????? ?????????? 0,002?: " + o.name + ", ????? ?????????? ????????? ? ?????????????????? ?????????: " + er2.count as string + "\n"
									if er3.count > 0 then err += "\x2716 ;2.3.7.; ??????? ????????? ?? ?????? ????????? ?????????? ? ??????????????? ?????????, ??????????? ?????????? 0,002?: " + o.name + ", ????? ?????????? ????????? ? ??????????????? ?????????: " + er3.count as string + "\n"
								)
								
								for o in (arr[5][arr[5].count])	where (polyOp.getNumVerts o) == 0 or (polyOp.getNumFaces o) == 0 do err += "\x2716 ;2.3.7.; ??????? ????????? ??? ?????? ??? ?????????: " + o.name + "\n"
								
								for o in (arr[5][arr[5].count])	where ((polyOp.getNumVerts o) > 0 and (polyOp.getNumFaces o) > 0) or not keyboard.escPressed do 
								(
									convertToPoly o
									local numverts = polyOp.getNumVerts o
									local numfaces = polyOp.getNumFaces o
									polyop.deleteIsoVerts o
									polyop.CollapseDeadStructs o
									local numverts_after = polyOp.getNumVerts o
									local numfaces_after = polyOp.getNumFaces o
									if (numverts - numverts_after) != 0 or (numfaces - numfaces_after) != 0 then err += "\x2716 ;2.3.7.; ??????? ????????? ?? ?????? ????????? ????????????? ??????, ????? ? ?????????: " + o.name + ", ????? ????????????? ??????: " + (numverts - numverts_after) as string + ", ????? ????????????? ?????????: " + (numfaces - numfaces_after) as string + "\n"
								)
							) 
							
							"chk_rules_lowpoly_table_2_3_8": -- "3.8. ??????? ???????? ??????" "3.8. ??????? ????????, ??????? ? ???????? ????? ??????????, ?????? ???? ?????????? ? ??????? ???????????." 
							(
								err += " ;2.3.8.; ??????? ????????, ??????? ? ???????? ????? ??????????, ?????? ???? ?????????? ? ??????? ???????????.\n"
							) 
							
							"chk_rules_lowpoly_table_2_3_9": -- "3.9. ?????? ? ???????????? ??-??" "3.9. ?????????????? ?????????????? ? ???????????? ????????, ?? ???????? ?? ????? ????? ??????? ?????????????, ???????????? ? ??????? ??????????? ?? ?????????? ??????." 
							(
								err += " ;2.3.9.; ?????????????? ?????????????? ? ???????????? ????????, ?? ???????? ?? ????? ????? ??????? ?????????????, ???????????? ? ??????? ??????????? ?? ?????????? ??????.\n"
								--????? ??????? ?????, ???? ?? ???????, ?? ???????? ?????????
							) 
														
							"chk_rules_lowpoly_table_2_3_10": -- "3.10. ?????? ?????????????? ?????????" "3.10. ??? ??????????? ???????? ??????????? ?????????????? ?????????, ????????????? ???? ?????, ?????????? ????? ???? ?????? ?????????? ?? ????? 5 ?? ? ?? ????? 2 ??." 
							(
								for o in (arr[5][arr[5].count])	where (polyOp.getNumFaces o) > 0 or not keyboard.escPressed do
								(
									convertToPoly o
									local er1 = #()
									local er2 = #()

									local selfaces = #{1..(polyOp.getNumFaces o)}
									--local minimum_range = 0.005
									--local maximum_range = 0.02
									local minimum_range = 0.0
									local maximum_range = 0.005

									local do_verts = false -- true
									local near_perpendicular = 0.01 

									polyop.flipNormals o selfaces
									
									direction = -1.0
									invert_face = false
									er1 = get_hits o selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular
									
									minimum_range = 0.02
									maximum_range = 0.03
									er2 = get_hits o selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular
									
									polyop.flipNormals o selfaces

									if er1.count > 0 then err += "\x2716 ;2.3.10.; ??? ??????????? ???????? ??????????? ?????????????? ?????????, ????????????? ???? ?????, ?????????? ????? ???? ?????? ?????????? ?? ????? 5 ??: " + o.name + ", ????? ?????????: " + er1.count as string + "\n"
									if er2.count > 0 then err += "\x2716 ;2.3.10.; ??? ??????????? ???????? ??????????? ?????????????? ?????????, ????????????? ???? ?????, ?????????? ????? ???? ?????? ?????????? ?? ????? 2 ??: " + o.name + ", ????? ?????????: " + er2.count as string + "\n"
								)
							) 
							
							"chk_rules_lowpoly_table_2_3_11": -- "3.11. ??????? ?????????????? ???." "3.11. ?????????????? ?????? ???????? ????, ????? ??????????, ?? ?????? ????? ???????." 
							(
								--???? ?? ?????? ? ????????? ??????
								for o in (arr[5][arr[5].count]) where findstring (tolower o.name) "glass" != undefined do 
								(
									converttopoly o
									if (polyop.getOpenEdges o).isempty then err += "\x2716 ;2.3.11.; ?????????????? ?????? ???????? ????, ????? ??????????, ?? ?????? ????? ???????: " + o.name + "\n"
								)	
							) 
							
							"chk_rules_lowpoly_table_2_3_12": -- "3.12. ???????????? ????????" "3.12. ??????? ????????? ?????? ???? ??????????????? ????? ????????? ? ???? ??????? FBX." 
							(
								--??????????????? ??? ? ???????? ????? ?? ? ?????
								local num_copy = 0
								local num = 0
								local num_area_zero = 0
								for o in (arr[5][arr[5].count]) where not keyboard.escPressed do
								(
									num_copy = 0
									num = 0									
									converttopoly o
									num = polyop.getNumFaces o
									for s in #{1..num} where polyop.getFaceArea o s <= 0.00001 do num_area_zero += 1
									oo = copy o
									select oo
									max modify mode
									subObjectLevel = 1
									oo.unhideAll #Vertex
									oo.unhideAll #Face
									max select all 
									oo.ConnectVertices vertexFlag:1
									subObjectLevel = 0
									num_copy = polyop.getNumFaces oo
									delete oo
									if num_area_zero > 0 then err += "\x2716 ;2.3.12.; ??????? ????????? ???????? ???????? ??????? ???????: " + o.name + ", ????? ???????????????: " + num_area_zero as string + "\n"
									if num_copy != num then err += "\x2716 ;2.3.12.; ??????? ????????? ?????? ???? ??????????????? ????? ????????? ? ???? ??????? FBX: " + o.name + ", ????????????????????? ?????????: " + (num_copy - num) as string + " \n"
								)
							) 
							
							"chk_rules_lowpoly_table_2_3_13": -- "3.13. ????????? ?? ??????????? ??????" "3.13. ???????? ?????????? ??????????? ?????? (?????, ???????, ???) ?????? ?????????????? ? ?????????? ???? ?????? ? ??? ????? ??????, ??? ??? ????? ??????????????? ?????? ?????????????? ??????." 
							(
								err += " ;2.3.13.; ???????? ?????????? ??????????? ?????? (?????, ???????, ???) ?????? ?????????????? ? ?????????? ???? ?????? ? ??? ????? ??????, ??? ??? ????? ??????????????? ?????? ?????????????? ??????.\n"
							) 
							
							"chk_rules_lowpoly_table_2_3_14": -- "3.14. ????????????? ???????? ? ?????." "3.14. ????????, ??? ??????? ???????????? ????? ????????????, ?????? ?????????? ??????????????." 
							(
								--???? ?? ???????? ???????? ? ????????? ? ?????? ????????????, ?? ??????? ???? ??? ???????? ????? ????????
								--?????? ???? ?? ????? ???????????? ? ?????
								local maps = #()
								for o in (arr[5][arr[5].count]) where o.material != undefined do
								(
									local maps = usedMaps o.material
									if maps.count > 0 then 
										for m in maps where findstring m "_o_" != undefined do err += " ;2.3.14.; ????????, ??? ??????? ???????????? ????? ????????????, ?????? ?????????? ??????????????: " + o.name + "\n"
								)
							)
							
							"chk_rules_lowpoly_table_2_3_15": -- "3.15. ?????????? ???????" "3.15. ? ??????? ?? ?????? ???? ?????????? ????????: ??? ??????? ??????? ? ??????? ???????????, ?????????? ??????? ??? ?????-???? ?????? ????????, ? ???? ?????? ??????????? ?? ?????? ???? ????????? ????????????? ?????????, ??? ?? ???????? ???, ??????? ?? ??????????????? ?? ??? ????? ?????." 
							(
								--???? ?????????? ??? ??? ????????, ?????? ?????? ????????????? ?? ?????, ???? ????????, ?????? ????
								err += " ;2.3.15.; ? ??????? ?? ?????? ???? ?????????? ????????: ??? ??????? ??????? ? ??????? ???????????, ?????????? ??????? ??? ?????-???? ?????? ????????, ? ???? ?????? ??????????? ?? ?????? ???? ????????? ????????????? ?????????, ??? ?? ???????? ???, ??????? ?? ??????????????? ?? ??? ????? ?????.\n"
							) 
							
							"chk_rules_lowpoly_table_2_3_16": -- "3.16. ????????????? ?????? ????????" "3.16. ??? ????????????? ?????? ?????? ???? ???????? (?????????)." 
							(
								for o in (arr[5][arr[5].count]) where o.scale != [1,1,1] do err += "\x2716 ;2.3.16.; ??? ????????????? ?????? ?????? ???? ???????? (?????????): " + o.name + "\n"
								for o in (arr[5][arr[5].count]) where o.rotation.x_rotation != 0.0 or o.rotation.y_rotation != 0.0 or o.rotation.z_rotation != 0.0 do err += "\x2716 ;2.3.16.; ??? ????????????? ?????? ?????? ???? ???????? (?????????): " + o.name + "\n"
							) 
							
							"chk_rules_lowpoly_table_2_3_17": -- "3.17. ?????? ???????????" "3.17. ?????? ??????????? ?????????? ????????????? ???????? ??????? ? ??????????? ?? ?????? ?? ?????????." 
							(
								local facesSG = #()
								for o in (arr[5][arr[5].count]) do
								(
									facesSG = for face in #{1..(polyop.getnumfaces o)} collect polyop.getFaceSmoothGroup o face
									if facesSG.count > 0 then
									(
										if (for ff in facesSG where ff != 0 collect ff).count == 0 then err += "\x2716 ;2.3.17.; ?????? ??????????? ?????????? ????????????? ???????? ??????? ? ??????????? ?? ?????? ?? ?????????: " + o.name + "\n" 
									)
									else err += "\x2716 ;2.3.17.; ?????? ??????????? ?????????? ????????????? ???????? ??????? ? ??????????? ?? ?????? ?? ?????????.\n"
								)
							) 

							"chk_rules_lowpoly_table_2_4": (err += "\x2714 ;4. ?????????? ? ??????????;\n")  -- "4. ?????????? ? ??????????"
							"chk_rules_lowpoly_table_2_4_1": -- "4.1. ??????????? ?????????" "4.1. ????????? ?? ?????? ???? ??????? ??? ?????? ????????? ??????? ??????? (VRay, Octane, Corona, Arnold ? ??????? ?? ??? ???????????? ??????????? ???????? ????????, ? ????? Physical Material, Blend)."
							(
								for o in (arr[5][arr[5].count]) where o.material != undefined do
								(	
									local m = o.material
									case classof m of
									(
										--Blend: CoronaLegacyMtl: CoronaPhysicalMtl: Physical_Material: Multimaterial: 
										default: (err += "\x2716 ;2.4.1.; ? ???????: " + o.name + " ???????? ???? " + (classof m) as string + ", ? ????????? ?? ?????? ???? ??????? ??? ?????? ????????? ??????? ??????? (VRay, Octane, Corona, Arnold, ? ????? Physical Material, Blend).\n")
										Physical_Material: (err += " ;2.4.1.; ? ???????: " + o.name + " ???????? ???? " + (classof m) as string + ", ????? ??? ????????? ????????????? ???? ???????? ??? ??????? FBX ????? ?? ?????????, ? ???? ??? ??????, ???? ??????? ??????? ? ???????? ???? StandartMaterial\n")
										Standardmaterial: () --?????? ?? ????????, ??? ??? ??????
										Multimaterial: 
										(
											err += " ;2.4.1.; ? ???????: " + o.name + " ???????? ???? " + (classof m) as string + ", ????? ???????? ?????????? ?????? ????? ?? ??????? ?????? ????????? ? ?????? ????????? ??????? ??????????.\n"
											for id in #{1..m.numsubs} where m.materialList[id] != undefined do
											(
												sub_m = m.materialList[id]
												case classof sub_m of
												(
													Standardmaterial: () --?????? ?? ????????, ??? ??? ??????
													default: (err += "\x2716 ;2.4.1.; ? ???????: " + o.name + " ??????????? ???? " + (classof sub_m) as string + ", ? ????????? ?? ?????? ???? ??????? ??? ?????? ????????? ??????? ??????? (VRay, Octane, Corona, Arnold, ? ????? Physical Material, Blend).\n")
												)
											)
										)
									)
								)
							
								for o in (arr[5][arr[5].count]) do 
								(
									--for tmap in (getClassInstances BitmapTexture target:o asTrackViewPick:off) do 
									for tmap in (getClassInstances CoronaBitmap target:o asTrackViewPick:off) do err += "\x2716 ;2.4.1.; ? ???????: " + o.name + " ???????? ????? ???? CoronaBitmap, ? ????????? ?? ?????? ???? ??????? ??? ?????? ????????? ??????? ???????.\n"
									for tmap in (getClassInstances CoronaNormal target:o asTrackViewPick:off) do err += "\x2716 ;2.4.1.; ? ???????: " + o.name + " ???????? ????? ???? CoronaNormal, ? ????????? ?? ?????? ???? ??????? ??? ?????? ????????? ??????? ???????.\n"
								)

								for o in (arr[5][arr[5].count]) where o.material == undefined do err += "\x2716 ;2.4.1.; ? ???????: " + o.name + " ??????????? ????????.\n"

								/*
								(
									mats = #()
									for matClass in material.classes do
									(
										for m in (getclassinstances matClass processAllAnimatables:true processChildren:true) do append mats m
									)
									print mats
								)
								*/	
							)
							
							"chk_rules_lowpoly_table_2_4_2": -- "4.2. ???????? ?????????????? ???????" "4.2. ???????? ?????????????? ??????? ?? ?????? ????????? ? ???? ?????????? ????."
							(
								for o in (arr[5][arr[5].count]) where o.material != undefined and findstring (tolower o.name) "glass" != undefined do 
								(
									local maps = #()
									maps = usedMaps o.material
									if maps.count > 0 then err += "\x2716 ;2.4.2.; ? ???????: " + o.name + ", ???????? ?????????????? ??????? ?? ?????? ????????? ? ???? ?????????? ????.\n"
								)	
							)
							
							"chk_rules_lowpoly_table_2_4_3": -- "4.3. ???? ?????????????? ???????" "4.3. ???? ????????? ?????????????? ??????? ???????? ???????????? ????? ????????? ?????????? ????????? (??????? 16)." 
							(
								for o in (arr[5][arr[5].count]) where findstring (tolower o.name) "glass" != undefined do
								(
									if o.material == undefined then err += "\x2716 ;2.4.3.; ? ???????: " + o.name + ", ??? ?????????, ? ???? ????????? ?????????????? ??????? ???????? ???????????? ????? ????????? ?????????? ?????????.\n"
									if o.material != undefined then	
									(
										if classof o.material != Standardmaterial then err += "\x2716 ;2.4.3.; ? ???????: " + o.name + " ?? ??? ??? ?????????, ????? ??? Standardmaterial, ???? ????????? ?????????????? ??????? ???????? ???????????? ????? ????????? ?????????? ?????????.\n"
									)
								)	
							)
							
							"chk_rules_lowpoly_table_2_4_4": -- "4.4. ???????? ? ??????? ???-??" "4.4. ???????? ? ??????? ??????????, ??? ?????????????, ?????????? ??????????????? ??????????? ???????." 
							(
								for o in (arr[5][arr[5].count]) where o.material != undefined and findstring (tolower o.name) "glass" == undefined do 
								(
									local maps = #()
									maps = usedMaps o.material
									if maps.count == 0 then err += "\x2716 ;2.4.4.; ? ???????: " + o.name + ", ???????? ? ??????? ??????????, ?????????? ??????????????? ??????????? ???????.\n"
								)
							)

							"chk_rules_lowpoly_table_2_4_5": -- "4.5. ???-?? ?????????? ? ???????" "4.5. ?????????? ?????????? (????? ?????????? ?????????????? ???????) ????????????? ?????????? ?????????? ???????." 
							(
								local mats = undefined 
								local mats_maps = #()	
								local mats_count = 0
								local file_texes = #()								
								local all_file_texes = #()	
								local file_texes_nabor = #()
								local file_texes_nabor_count = 0
								local mats_maps_nabor = #()
								local mats_maps_nabor_count = 0
								
								if arr[3].count > 0 then
								(
									for a in arr[3] do 
										for b in a do append all_file_texes b
								)		
								
								for o in (arr[5][arr[5].count]) where findstring (tolower o.name) "glass" == undefined do --#(o.name, o.material)
								(
									mats = o.material
									if o.material != undefined then 
									(
										mats_maps = usedMaps o.material
										case classof mats of
										(
											default: mats_count = 1
											Multimaterial: 
											(
												for id in #{1..m.numsubs} where mats.materialList[id] != undefined do
												(
													case classof mats.materialList[id] of
													(
														default: mats_count += 1
													)
												)
											)
										)								
									)
									
									file_texes = for t in all_file_texes where findstring (getfilenamefile t) (substitutestring o.name "SM_" "T_") != undefined and findstring (getfilenamefile t) "Glass" == undefined collect (getfilenamefile t)

									for t in file_texes do appendIfUnique file_texes_nabor ((filterstring t "_")[(filterstring t "_").count])
									for t in mats_maps do appendIfUnique mats_maps_nabor ((filterstring (getfilenamefile t) "_")[(filterstring (getfilenamefile t) "_").count])

									file_texes_nabor_count = (for n in file_texes_nabor where delete_only_digits n == "" collect n).count 
									mats_maps_nabor_count = (for n in mats_maps_nabor where delete_only_digits n == "" collect n).count

									if file_texes_nabor_count != mats_maps_nabor_count or file_texes_nabor_count != mats_count then err += "\x2716 ;2.4.5.; ? ???????: " + o.name + ", ?????????? ?????????? (????? ?????????? ?????????????? ???????) ?? ????????????? ?????????? ?????????? ???????.\n"
									--print file_texes_nabor_count
									--print mats_maps_nabor_count
									--print mats_count
									--print #(file_texes)
									--print #(mats_maps)
									--print #(file_texes_nabor)
									--print #(mats_maps_nabor)
								)

							)
							
							"chk_rules_lowpoly_table_2_4_6": -- "4.6. ???-?? ?????????????? ???-??" "4.6. ?????????? ?????????? ??? ?????????????? ??????? ?? ?????? ????????? 7." 
							(
								for o in (arr[5][arr[5].count]) where o.material != undefined and findstring (tolower o.name) "glass" != undefined do
								(
									case classof o.material of
									(
										Multimaterial: 
										(
											if (for id in #{1..o.material.numsubs} collect id).count > 7 then err += "\x2716 ;2.4.6.; ? ???????: " + o.name + " ?????????? ?????????? ??? ?????????????? ??????? ?? ?????? ????????? 7.\n"
											if (for id in #{1..o.material.numsubs} collect id).count < 2 then err += "\x2716 ;2.4.6.; ? ???????: " + o.name + " ??? ?????????????? ??????? ???????????? " + (classof o.material) as string + " ?????????? ?????? ? ??? ????, ???? ???????????? ??????? Standardmaterial.\n"
										)
										
										Standardmaterial: () --??? ??????, ???? ????????
										default: (err += "\x2716 ;2.4.6.; ? ???????: " + o.name + " ????????? ?????????? ??? ?????????????? ??????? ???? ??????????? ????? Multimaterial ? Standardmaterial ? ??????, ?? ?? ?????? 7.\n")
									)
								)
							)
							
							"chk_rules_lowpoly_table_2_5": (err += "\x2714 ;5. ?????????? ? ?????????? ??????;\n") --"5. ?????????? ? ?????????? ??????" 
							"chk_rules_lowpoly_table_2_5_1": () -- "5.1. ?????????? ????? PNG" checked:true offset:[20,0] tooltip:"5.1. ?????????? ????? ?????? ??????????????? ? ???? ?????????? ??????? ? ??????? PNG ? ???? ???????? ? ???? ??????? FBX (??????? 5)."
							"chk_rules_lowpoly_table_2_5_2": () -- "5.2. ?????????? ??????? ????" checked:true offset:[20,0] tooltip:"5.2. ????????? ????????? ??????? ?????????? ????: 128x128, 256x256, 512x512, 1024x1024, 2048x2048 ????????, ???????????? ?????? ?????????? ?????, ?????? ??????? ????????? (??.?.5.11), 2048x2048 ????????"
							"chk_rules_lowpoly_table_2_5_3": () -- "5.3. ?????? ? 8 ????????" checked:true offset:[20,0] tooltip:"5.3. ????????????? ??????????? ?????????? ?????? ? 8 ????????."
							"chk_rules_lowpoly_table_2_5_4": () -- "5.4. ??????????? ?????? 1:1" checked:true offset:[20,0] tooltip:"5.4. ??????????? ?????? ?????????? ????? ?????? ???? ?????? 1:1."
							"chk_rules_lowpoly_table_2_5_5": () -- "5.5. ?????-????? ????????" checked:true offset:[20,0] tooltip:"5.5. ?????-????? ???????? ? ?????????????."
							"chk_rules_lowpoly_table_2_5_6": () -- "5.6. ?????? ???? 5 ?????" checked:true offset:[20,0] tooltip:"5.6. ?????????? ????? ??????????? ????????? ??????????????, ?????? ?? ????? ???????????? ? ? ???????????? ? ???????????? ??????? ?????????. ??????????? ????????? ????? ??????? ??? ??????? ????????? ??????? ?? ????: ??????????? ?????, ????????, ????????????, ????? ????????????? ? ?????????????. ????????? ??? ???????????? ??????????? ? ???? (??????? 6)."
							"chk_rules_lowpoly_table_2_5_7": () -- "5.7. ?????????? ??????? ? ??????" checked:true offset:[20,0] tooltip:"5.7. ??? ?????????? ????? ? ?????? ?????? ??????????? ?????? ?????? ????? ?????????? ??????."
							"chk_rules_lowpoly_table_2_5_8": () -- "5.8. ????? ????????????? ??????" checked:true offset:[20,0] tooltip:"5.8. ????????? ?????? ?????????? ???? ????????????? ??????: ????????????????? ?????? ??????????? ?? ?????? ?????????? ????? ? ?????? ????????????? ????? ??????, ?? ?????? ??????????????? - ??????, ????? ???????????? ???????????, ???? ?????????? ??????????, ??????????????? ????????? ???????? ??????? ??????, ??????????? ????????????? ????? ??????."
							"chk_rules_lowpoly_table_2_5_9": () -- "5.9. ?? ?????? ??? ?? 1 ?????? ????" checked:true offset:[20,0] tooltip:"5.9. ?? ?????? ??? ? ??????? ?????? ??? ?????????? ???????????? ?? ?????? ??????????? ??????."
							"chk_rules_lowpoly_table_2_5_10": () -- "5.10. ???? ???-?? ??????? ??-??" checked:true offset:[20,0] tooltip:"5.10. ???????????? ?????????? ??????? ??? ?????? ??????????????? - 20, ?? ?????????? ????? ???????????? ??????????? ? ????????? ????????."
							"chk_rules_lowpoly_table_2_5_11": () -- "5.11. ????? ???????? ??-??? ??-??" checked:true offset:[20,0] tooltip:"5.11. ??? ??????????????? ????????? ???????????????, ??????????? ? ???? ????????????? ???????? (? ??????????? ????????? ? ?????? ?????????? ? ????????????? ?????????? ?????????) ?????????? ???????????? ???? ?????????? ????? ?? ??? ????????, ???????? ?? ????? 512x512 ????????."
							"chk_rules_lowpoly_table_2_5_12": () -- "5.12. ????? ??????? ????-??" checked:true offset:[20,0] tooltip:"5.12. ??? ??????????????? ????????? ?????????????? ?????????? ???????????? ???? ?????????? ????? ???? ?? ??? ????????, ???????? ?? ????? 2048x2048 ????????. ? ?????????? ????? ?????? ??????? ? ???????????? ??????? ????? ?????????? ????? ?, ??? ?????????????, ????? ????????????."

							"chk_rules_lowpoly_table_2_6": (err += "\x2714 ;6. ?????????? ? ????????? ????????;\n") -- "6. ?????????? ? ????????? ????????"
							"chk_rules_lowpoly_table_2_6_1": () -- "6.1. ????????? ???? Ground" checked:true offset:[20,0] tooltip:"6.1. ?????????? ? ????????? ?????????? ???? ???????????????? ?????? ?? ??????????? ??????? ? ???????? ??????? ??????????: ????????? ??????? ?????? ???? ?? ?????? 10 ???????? ?? ??. ????, ??? ??? ???????? 2048x2048 ????????????? ???????? ?? ????????? 204 ?? 204 ??????, ?? ?? ????? 40 ???????? ?? ??. ???? (??????? 7, ??????? 8)."
							"chk_rules_lowpoly_table_2_6_2": () -- "6.2. ????????? ???? ??????????" checked:true offset:[20,0] tooltip:"6.2. ?????????? ? ????????? ?????????? ???? ?? ???????????????? ?? ????????, ????????? ???? ??? ????? ?? ????????? ?????? ??????????????? ???????? ?????? 3.4 ????????? ??????????, ? ????? ?? ????????? ??????????????, ??? ? ????????? ???????????????."

							"chk_rules_lowpoly_table_2_7": (err += "\x2714 ;7. ?????????? ? ???????? ????????? ??????;\n") -- "7. ?????????? ? ???????? ????????? ??????" 
							"chk_rules_lowpoly_table_2_7_1": () -- "7.1. ?????????? ????? ??????" checked:true offset:[20,0] tooltip:"7.1. ? ?????? ????????????? ?????????? ???? ?????? ?? ???????? ? ????????? ?????? ????????? ? ? ???????????? ??????? ?????????? ?????????? ????? ????????????? ? ?????????????, ???????? ??????? 5.6, 5.8;"
							"chk_rules_lowpoly_table_2_7_2": () -- "7.2. ?????????????? ??????" checked:true offset:[20,0] tooltip:"7.2. ? ?????? ???????????????? ?????? ???????? ? ????????? ?????? ????????? ? ????????? ??????????? ???????? ???????? ??????? 4.2, 4.3 ????????? ??????????."		
							
							"chk_rules_lowpoly_table_2_8": (err += "\x2714 ;8. ?????????? ? ????? ??????? ? ????? ????????;\n") -- "8. ?????????? ? ????? ??????? ? ????? ????????"  
							"chk_rules_lowpoly_table_2_8_1": () -- "8.1. ???? ???????? ???? ????????" "8.1. ???? ???????? ???? ???????? ????????? ????? ?????????? (??????) ????????????? ?????? ??????????????? ????? ???????? ??? ? ????? ?????????? ???????."
							"chk_rules_lowpoly_table_2_8_2": () -- "8.2. ??????? ????????? ???" "8.2. ??? ??????? ????????? ?????? ????? ???????????? ???????? ? ?????????? ??????? ????????? ? ????? ???????? ?????????? ???????."
							"chk_rules_lowpoly_table_2_8_3": () -- "8.3. ???????????? ??????? ?????????" "8.3. ?? ??????????? ????????????? ???????????? (????????) ??????? ????????? ??? ????????? ????????????? ???????? (?????????? ???????? ?????)."		

							"chk_rules_lowpoly_table_2_9": (err += "\x2714 ;9. ?????????? ? ????????? ? ?????????????;\n") -- "9. ?????????? ? ????????? ? ?????????????"
							"chk_rules_lowpoly_table_2_9_1": () -- "9.1. ???????? ???? ????????, ???-??" "9.1. ???????? ??????????? ? ????????????? ??????, ???????? ?????????, ?????????? ? ??????? ? ????? ???????????/?????????? ???????? ? ???????????? ???????:\n1. ? ???????????? ???????? ????????? ?????????? ?????????????? ?:\n_Main ??? (????? ?????????????? ???????)\n_MainGlass ??????????????????? ??????? ???\n_Ground ??????????????? (????? ?????????????? ???????)\n_GroundGlass ?????????????? ??????? ???????????????\n_GroundEl ????????? ???????????????: ???, ?????? ????????? ? ??. (????? ?????????????? ?????????)"		
							"chk_rules_lowpoly_table_2_9_2": () -- "9.2. ???????? ???? ????" "9.2. ? ???????????? ?????????? ???? ?????????? ?????????????? ? ??????:\n_d ?????????? ?????\n_n ????????\n_o ????????????\n_m ?????????????\n_r ?????????????"	

							"chk_rules_lowpoly_table_2_10": (err += "\x2714 ;10. ?????????? ? ??????;\n") -- "10. ?????????? ? ??????"
							"chk_rules_lowpoly_table_2_10_1": --#(myfiles, filesFBX, filesTEX, filesAll, objAll) "10.1. ????? ???? ????? < 254 ???????" "10.1. ????? ????????????, ??????? ????? ? ??? ????????, ????????? ? ????????, ?? ?????? ????????? ???????? ? 254 ???????."
							(
								cou = 0
								for f in arr[1] where (getfilenamefile f).count > 254 do err += "\x2716 ;2.10.1.; ????? ???????????? ?????? ZIP, ??????? ????? ? ??? ????????, ????????? ? ????????, ?? ?????? ????????? ???????? ? 254 ???????\n"
								for f in arr[2] where (getfilenamefile f).count > 254 do err += "\x2716 ;2.10.1.; ????? ???????????? ????? FBX, ??????? ????? ? ??? ????????, ????????? ? ????????, ?? ?????? ????????? ???????? ? 254 ???????: " + (getfilenamefile f) + "\n"
								for a = #{1..arr[3].count} do
								(
									str = getfilenamefile arr[2][a]
									if (cou = (for f in arr[3][a] where (getfilenamefile f).count > 254 collect (getfilenamefile f)).count) > 0 then err += "\x2716 ;2.10.1.; ????? ???????????? ?????? PNG, ??????? ????? ? ??? ????????, ????????? ? ????????, ?? ?????? ????????? ???????? ? 254 ???????, ????? ?????? ? ??????????: " + str + " " + cou as string + "\n"
								)	
								for f in arr[5][arr[5].count] where f.name.count > 254 do err += "\x2716 ;2.10.1.; ????? ???????????? ???????? ?????????, ??????? ????? ? ??? ????????, ????????? ? ????????, ?? ?????? ????????? ???????? ? 254 ???????: " + f.name + "\n"
							)
							
							"chk_rules_lowpoly_table_2_10_2": -- "10.2. ??????? ? ??????????? ? ??????" "10.2. ???????????? ?????? ?????????? ????????????? ????????? (?????????? ?????????), ??????? ? ???????? ??????? ????????????? (_), ????????????? ?????? ????????????, ??????? ??????, ???????????."
							(
								--???????? ???????????? ????????
								for f in arr[1] do
								(
									t = parse_error_symbols (getfilenamefile f)
									if t != "" then err += "\x2716 ;2.10.2.; " + (getfilenamefile f) + ": ??? ????? ?????? ZIP ???????? ???????????? ???????\n"
								)
								
								for f in arr[2] do 
								(
									t = parse_error_symbols (getfilenamefile f)
									if t != "" then err += "\x2716 ;2.10.2.; " + (getfilenamefile f) + ": ??? ????? FBX ???????? ???????????? ???????\n"
								)
								
								for f in arr[2] do 
								(
									t = parse_error_symbols (getfilenamefile f)
									if t != "" then err += "\x2716 ;2.10.2.; " + (getfilenamefile f) + ": ??? ????? FBX ???????? ???????????? ???????\n"
								)								
								
								for a = #{1..arr[3].count} do
								(
									str = getfilenamefile arr[2][a]
									for f in arr[3][a] where parse_error_symbols (getfilenamefile f) != "" do err += "\x2716 ;2.10.2.; ??? ????? PNG ???????? ???????????? ???????: " + str + " " + (getfilenamefile f) + "\n"
								)	
						
								for f in arr[5][arr[5].count] where parse_error_symbols f.name != "" do err += "\x2716 ;2.10.2.; ??? ??????? ????????? ???????? ???????????? ???????: " + f.name + "\n"
								
								--???????? ?????????????
								for f in arr[1] do
								(
									t = getfilenamefile f
									if t != translit t then err += "\x2716 ;2.10.2.; " + t + ": ??? ????? ?????? ZIP ???????? ???????????? ??????? ?? ? ?????????\n"
									if findstring t "_" == undefined then err += "\x2716 ;2.10.2.; " + t + ": ??? ????? ?????? ZIP ?? ???????? ??????? ?????????? _\n"
									if findstring t " " != undefined then err += "\x2716 ;2.10.2.; " + t + ": ??? ????? ?????? ZIP ???????? ???????  \n"
								)
								
								for f in arr[2] do 
								(
									t = getfilenamefile f
									if t != translit t then err += "\x2716 ;2.10.2.; " + t + ": ??? ????? FBX ???????? ???????????? ??????? ?? ? ?????????\n"
									if findstring t "_" == undefined then err += "\x2716 ;2.10.2.; " + t + ": ??? ????? FBX ?? ???????? ??????? ?????????? _\n"
									if findstring t " " != undefined then err += "\x2716 ;2.10.2.; " + t + ": ??? ????? FBX ???????? ???????  \n"										
								)	

								for a = #{1..arr[3].count} do
								(
									str = getfilenamefile arr[2][a]
									for f in arr[3][a] where (getfilenamefile f) != translit (getfilenamefile f) do err += "\x2716 ;2.10.2.; ??? ????? PNG ???????? ???????????? ??????? ?? ? ?????????: " + str + " " + (getfilenamefile f) + "\n"
									for f in arr[3][a] where findstring (getfilenamefile f) "_" == undefined do err += "\x2716 ;2.10.2.; ??? ????? PNG ?? ???????? ??????? ?????????? _: " + str + " " + (getfilenamefile f) + "\n"
									for f in arr[3][a] where findstring (getfilenamefile f) " " != undefined do err += "\x2716 ;2.10.2.; ??? ????? PNG ???????? ???????????? ???????  : " + str + " " + (getfilenamefile f) + "\n"
								)	
						
								for f in arr[5][arr[5].count] where f.name != translit f.name do err += "\x2716 ;2.10.2.; ??? ??????? ????????? ???????? ???????????? ???????: " + f.name + "\n"
								for f in arr[5][arr[5].count] where findstring f.name "_" == undefined do err += "\x2716 ;2.10.2.; ??? ??????? ????????? ?? ???????? ??????? ?????????? _: " + f.name + "\n"
								for f in arr[5][arr[5].count] where findstring f.name " " != undefined do err += "\x2716 ;2.10.2.; ??? ??????? ????????? ???????? ???????????? ???????  : " + f.name + "\n"
							)
							
							"chk_rules_lowpoly_table_2_10_3": -- "10.3. ??????? ?????????? ??? FBX" 
							(
								
							)
							
							"chk_rules_lowpoly_table_2_10_3_1": -- "10.3.1 ???? ??? ??? ?? ?????? ? FBX" "10.3.1. ???? ?????? ????????? ???????? ????? ?pe???c_Address: 0313_ProezdNansena_ZU_8.zip 0313_77_02_0015007_4157_Vld_15.zip - ??? ??????? - ?????????????? ???, ???????????? ???????? ??????????????? ?????????????? ??????????????? ?????? ??????"
							(
								
							)
							
							"chk_rules_lowpoly_table_2_10_3_2": -- "10.3.2 ???????? ???? ????? FBX" "10.3.2. ???? ??????? FBX ????????? ???????? ??????, ??? ??????????? ?? ?????????? ?? ????????? ????? ??????? FBX: - ??? ??? ?pe???c_Address_?o?ep, ??? ????? - ??? ?????????? ????? fbx, ??? ????? ??? ? ?????? ???????, ??????????? ????? ?? 01 ?? 20, ??????????? ? ????? ? ???????, ?????? ??????????????? ? ??? ?????????, ? ??????? ???????????. ???? FBX ????, ?? ??? ?????????? ????? 01 0313_ProezdNansena_ZU_8_01.fbx 0313_ProezdNansena_ZU_8_02.fbx 0313_77_02_0015007_4157_Vld_l5_01.fbx - ??? ??????????????? ???????_Address_Ground 0313_ProezdNansena_ZU_8_Ground.fbx 0313_77_02_0015007_4157_Vld_15_Ground.fbx"
							(
								
							)
							
							"chk_rules_lowpoly_table_2_10_3_3": -- "10.3.3 ???????? ???? ???????? ? FBX" "10.3.3. ??????? ????????? ????????? ???????? ??????, ??? ??????????? ?? ?????????? ?? ????????? ????? ??????? FBX: - ??? ??? SM_Address_HOMep_Main, ??? ????? - ??? ?????????? ????? ??? ?? ???? ???????, ? ?? ? ?????????? FBX-?????, ??? ?????????? ??? ?? ?????, ??????????? ????? ?? 001 ?? 020, ??????????? ? ????? ? ???????, ?????? ??????????????? ? ??? ?????????, ? ??????? ???????????, ????????:SM_ProezdNansena_ZU_8_001_Main\nSM_Address ????? MainGlass - ??? ?????????????? ??????? ???, ????????: SM_ProezdNansena_ZU_8_001_MainGlass\n ??? ??????????????? SM_Address_Ground: SM_ProezdNansena_ZU_8_Ground\n ??? ?????????????? ??????? ??????????????? SM ????? GroundGlass, SM_ProezdNansena_ZU_8_GroundGlass\n- ??? ????????? ??????????????? SM_Address_GroundEl, SM_ProezdNansena_ZU_8_GroundEl\n- ??? ?????????????? ??????? ????????? ??????????????? SM_Address_GroundElGlass, SM_ProezdNansena_ZU_8_GroundElGlass\n- ??? ?????????????? SM_Address_Flora, SM_ProezdNansena_ZU_8_Flora"		
							(
								
							)
							
							"chk_rules_lowpoly_table_2_10_3_4": -- "10.3.4 ???????? ???? ??????? ? FBX" "10.3.4. ???????? ????????? ???????? ??????:\n? ????????? ???????, ????? ?????? ?????????????, ? ??????????? ?????????? ??????? ???????: ??????? ?, ????? (??? ???????????????, ??? ????????? ? ??????????????) ??? ????? ????? (??? ???), ??????????????? ???????? ????????? ???????, ??????????????? ?????????? ?????? ???????, ???????? SlotNumber  ?????????? ????? ?????????, ? ???????? ??????????? ?????????? ????? (???????? ????????????, ???????????????, ??????? ? ???????). ???? ???????? ???????????? ? ?????? ?????? ?????, ?? ??? ?????????? ????? ????? 1, - ??? ???????, ??? ??????????? ?? ?????????? ?? ????????? ????? ??????? FBX\nT_Address_?o?ep_Cy????c?eo?e?p??_Cy???????????????????_SlotNumber\nT_ProezdNansena_ZU_8_001_Main_d_1\nT_ProezdNansena_ZU_8_002_Main_d_1\n- ??? ???????????????, ??? ????????? ? ??????????????\nT_Address_Cy????c?????????_?????????????????????_SlotNumber\nT_ProezdNansena_ZU_8_Ground_d_1.png\nT_ProezdNansena_ZU_8_GroundEl_d_1.png\nT_ProezdNansena_ZU_8_GroundEl_m_1.png\nT_ProezdNansena_ZU_8_GroundEl_r_1.png\n?_ProezdNansena_ZU_8_Flora_d_1.png\n?_ProezdNansena_ZU_8_Flora_o_1.png"
							(
								
							)
							
							"chk_rules_lowpoly_table_2_10_3_5": -- "10.3.5 ???????? ???? ???-??? ? FBX" "10.3.5. ????????? ????????? ???????? ??????: ????????? ?? ??????????? ?????????? ?????????????? ???????, ??????? ???????? ??? ?? ??????, ??? ? ??????????????? ??? ????????, ??? ???? ??? ??????? ???????????? ??????? ?, ? ??? ??????????  ??????? ?. ??????? ?????????? ???? ? ???????? ?????????? ??????????\n?_ProezdNansena_ZU_8_001_Main_1\n?_ ProezdNansena_ZU_8_002_Main_1\n?_ ProezdNansena_ZU_8_Main_1\n?_ ProezdNansena_ZU_8_Main_2\n?_ ProezdNansena_ZU_8_Ground_1\n?_ ProezdNansena_ZU_8_GroundEl_1\n?_ ProezdNansena_ZU_8_Flora_1\n??? ?????????????? ??????? M_Glass_H????, ??? ????? - ??? ?????????? ????? ????????? ?? 01 ?? 07 ??? ?????????????? ?????? ? ?????? ???????, ????????? ?????????????? ??????? ????? ?????????? ????????\nM_Glass_01\nM_Glass_02"
							(
								
							)
						)
					)
					err += "\n;???????? ????????;\n"	
					--excel_file = GetDir #maxroot +"\\GeoScripts\\Reports\\" + (getfilenamefile edt_lowpoly_rules_check_path.text) + "_report_lowpoly.csv" 
					--time_str = ""
					time_str = localTime --getLocalTime() 
					--for ti in tim do time_str += ti	as string + "_"
					time_str = substitutestring time_str "\\" "_"
					time_str = substitutestring time_str ":" "_"
					time_str = substitutestring time_str " " "_"
					time_str = substitutestring time_str "." "_"
					excel_file = getfilenamepath edt_lowpoly_rules_check_path.text + getfilenamefile edt_lowpoly_rules_check_path.text + "_report_lowpoly_" + time_str + ".csv" 
					lbl_lowpoly_progress.text = ""
					--ss = substitutestring err ";" ""
					--messagebox ss
					
					--print err
					global dirs_select = #()
					stroke = #()
					stroke = filterstring err "\n" splitEmptyTokens:true
					
					dirs_select = for i in stroke collect (if (filterstring i ";" splitEmptyTokens:true).count == 0 then #(" "," "," ") else (filterstring i ";" splitEmptyTokens:true))
					print dirs_select
					
					if err != undefined then WriteAllLines excel_file err 
						
					try(destroyDialog ::report_lowpoly)catch()
					rollout report_lowpoly "Lowpoly Models Errors Report" 
					(
						fn autoResizeColumn lv columns: = 
						(
							vScrollWidth = 21 -- vertical scrollbar width
							for c = 0 to columns-1 do
							(
								lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
								vScrollWidth += lv.Columns.Item[c].Width
							) 
							vScrollWidth
						)
						
						fn PopulateList lv dirs_select =
						(
							lv.Items.Clear()
							lv.view = (dotNetClass "system.windows.forms.view").details
							lv.HideSelection = true 
							lv.HeaderStyle = (dotNetClass "System.Windows.Forms.ColumnHeaderStyle").clickable
							--lv.height = 390
							lv.FullRowSelect = true    
							lv.MultiSelect = false --true    
							lv.AllowColumnReorder = true
							lv.GridLines = true
							lv.checkBoxes = false --true 
							lv.Scrollable = true
							lv.ShowItemToolTips = true
							columnsAr = #("   ", "Table rule number                                               ", "Error Comment                                                                                                                                  ")
							lv.columns.Clear()
							for i = 1 to 3 do lv.columns.add columnsAr[i] 0	
							lv.width = autoResizeColumn lv columns:3
							--lv.width = 800
							lv.Update()
							
							rows = #()
							for t = 1 to dirs_select.count do
							(
								li = dotNetObject "System.Windows.Forms.ListViewItem" (dirs_select[t][1])
								li.UseItemStyleForSubItems = true
								li.subitems.add dirs_select[t][2]
								li.subitems.add dirs_select[t][3]
								append rows li
							)
							lv.items.addRange rows
							--lv.Update()
							lv.width = 990
							--lv.width = autoResizeColumn lv columns:3
							lv.Update()
						)
						
						dotNetControl lv "ListView" pos:[5,5] width:990 height:400
						label lbl_message "This report already saved near ZIP archive as CSV file"
						button btnCopyClp "Copy to Clipboard" offset:[0,0] across:4 tooltip:""
						button btnPasteClp "Paste from Clipboard" offset:[0,0] tooltip:""
						button btnGetScreen "Make Screen" offset:[0,0] tooltip:""	
						button btnDelScreen "Delete Screen" offset:[0,0] tooltip:""	
						button btnExportPDF "Export to PDF" offset:[0,0] across:3 tooltip:""		
						button btnExportCSV "Export to CSV" offset:[0,0] tooltip:""							
						button btnClose "Close" align:#right tooltip:"Close dialog"

						on report_lowpoly open do
						(  
							PopulateList lv dirs_select
						)
						
						on lv MouseDown arg do
						(
						)

						on lv MouseHover arg do 
						(
							--print "MouseHover"
							--ScrollToBottom 
							--listView.setSelection (int position) --???? ?? ?????? ??????? ????? ? ?????? ??????? ? ??????, ??????? ???????????
							--listView.smoothScrollToPosition (int position) --? ???? ?? ?????? ?????? ??????? ? ?????? ??????? ? listView, ?????? ???????????
							--if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
							--(
							--	val = hitNode.index + 1
							--	dirs_select[val][3]
							--)                

						)
				
						on lv MouseLeave arg do 
						(
							--scroll_down = false
							--print "MouseLeave"
						)
				
						on btnClose pressed do
						(
							try(destroyDialog ::report_lowpoly)catch()
						)	
					)
					createDialog report_lowpoly width:1000 height:500 style:#(#style_titlebar, #style_border, #style_sysmenu, #style_resizing)		

				)
				else
				(
					messagebox "No file specified"
				)
			)
			
			2:
			(
				
			)
			
			3:
			(
				--print #(RulesCheck_lowpoly.Controls)
			)

		)			
	)
)
addRollout RulesCheck_lowpoly GeoAGR rolledup:true

rollout RulesCheck_highpoly "Rules Check for HighPoly Models" autoLayoutOnResize:true
(	
	radiobuttons rdo_check_highpoly labels: #("Check Folder", "Check Current Scene", "Check Selection in Scene") columns:1 rows:3 default:3 align:#left offset:[0,0] across:2 enabled:false tooltip:""
	button btn_get_path_highpoly_rules_check "Open Folder with Models" align:#left enabled:false tooltip:"Open Folder with HighPoly Models to Check Rules"
	button btn_highpoly_rules_check "Start Check Rules" align:#left across:3 enabled:false tooltip:"??????? ??? ????..."
	button btn_highpoly_checkers_on "Check All" offset:[25,0] tooltip:""
	button btn_highpoly_checkers_off "UnCheck All" align:#right tooltip:""	
	edittext edt_highpoly_rules_check_path "" text:"" labelOnTop:false bold:true width:260 fieldWidth:260 readonly:false offset:[0,0] tooltip:"Path to Folder with HighPoly Models"
	progressBar pb_highpoly "" width:260 height:10 tooltip:"Checking progress" 
	label lbl_highpoly_progress "" align:#left style_sunkenedge:false width:260 tooltip:"Press ESC to CANCEL check"
	
		checkbox chk_rules_highpoly_table_1_All "??????? 1. ?????????? ? ??? ??????? ?????" checked:true offset:[0,0] align:#left tooltip:"??????? 1 ????? ??????????? ?????????? ? ?????? ?????? ?? ?????????? ??????"
		checkbox chk_rules_highpoly_table_1_1 "?????????? ? ???????? ???????" checked:true offset:[0,0] align:#left tooltip:"1. ?????????? ? ???????? ?????????????? ???????"
		checkbox chk_rules_highpoly_table_1_1_1 "1.1. FBX 7.4 (FBX 2014) binary" checked:true offset:[20,0] tooltip:"1.1. ?????????? ???????? ?????? ?????? ??????????????? ?????????? ? ????????????? ???????? ??????? FBX ?????? 7.4 (FBX 2014) ????????? ????;"
		checkbox chk_rules_highpoly_table_1_1_2 "1.2. ??????????? ?????????" checked:true offset:[20,0] tooltip:"1.2. ??????????????? ?????? ?? ?????? ????????? ??????????? ???????? ??? ?????? ????;"
		checkbox chk_rules_highpoly_table_1_1_3 "1.3. ???????????? ?????? 3ds max" checked:true offset:[20,0] tooltip:"1.3. ??????????????? ?????? ?????? ??????????? ? ??????????? ???????????? ?????? ???????????? ???????????."
		checkbox chk_rules_highpoly_table_1_1_4 "1.4. ???????????? ????????????" checked:true offset:[20,0] tooltip:"1.4. ??????????????? ?????????? ?????? ?????? ??????????????? ???????????? ? ??????????? ??????????, ?????????????? ? ?????? ?????????????? ?????????????? ??????? (???????, ????????? ???????) ? ????????? ????????????."

		checkbox chk_rules_highpoly_table_1_2 "2. ?????????? ? ???????? ?????????" checked:true offset:[0,10] align:#left tooltip:"2. ?????????? ? ???????? ?????????"
		checkbox chk_rules_highpoly_table_1_2_1 "2.1. c?????? ????????? - ?????" checked:true offset:[20,0] tooltip:"2.1. ??????? ??????????? ????????? ?????? ???? ???????????: ???? ???????? ??????? ????????? ????????????? ?????? ?????."
	
		checkbox chk_rules_highpoly_table_1_3 "3. ?????????? ? ?????????? Address" checked:true offset:[0,10] align:#left tooltip:"3. ?????????? ? ?????????? ?????????? Address"
		checkbox chk_rules_highpoly_table_1_3_1 "3.1. ?????????? ??????, ??? ?????" checked:true offset:[20,0] tooltip:"3.1. ????????????? ????????????? ?????????? ???????????????? ????????? ?????? ??????? ????????, ????????, ???????? ??????? ???????????? ???????? ?????????? ????????? ?? 5 ?????? 2015 ?. ? 171? ?? ??????????? ??????? ????????? ????????????? ?????????, ????????? ??????-???????? ????, ????????? ???????? ?????????, ????? ?????? (??????????), ?????????, ???????????? ? ???????? ?????????? ??????, ? ?????? ???????????? ???????????? ???????????????? ?????????. ????? ? ????? ??????????? ???? ?? ????????."
		checkbox chk_rules_highpoly_table_1_3_2 "3.2. ????? ????????? ????? _" checked:true offset:[20,0] tooltip:"3.2. ???????????????? ???????? ?????? ?????????? ????????????? ????????? (?????????? ?????????), ??????? ? ???????? ??????? ????????????? (_). ?????? ???????????, ??????? ??????, ??????????? ? ?????????? ???????? ??????? ????????????? (_)."
		checkbox chk_rules_highpoly_table_1_3_3 "3.3. ?????????? ??????????????" checked:true offset:[20,0] tooltip:"3.3. ???????????????? ???????? ??????????? ?????? ??????????????. ???????? ? ????????? ????? ?????????? ?????? ?????????????? ???? ?? ?????."
		checkbox chk_rules_highpoly_table_1_3_4 "3.4. ????????? ????? ? ??????" checked:true offset:[20,0] tooltip:"3.4. ?????? ????? ????? ?????????? ? ????????? ?????."
		checkbox chk_rules_highpoly_table_1_3_5 "3.5. ????? ????? ??????????" checked:true offset:[20,0] tooltip:"3.5. ? ????????? ????????? ??????-???????? ???? ?????????? ?????? ????? ?????. ????????:\n??. ???????????, ??. 67/1\nDubininskaya_Vl_67_1\n?????? ???????, ??. 8 ProezdNansena_Uch_8"
		checkbox chk_rules_highpoly_table_1_3_6 "3.6. ??????????? ????? - ??? :" checked:true offset:[20,0] tooltip:"3.6. ???? ?????? ?? ????? ??????? ?????????????/????????? ??????, ?? ? ?????????? Address ??????????? ??????????? ????? ???????, ?????? : ?????????? ?? _. ????????: 77:02:0015007:4157 77_02_0015007_4157\n77:02:0015007:4157, ?????? 7 77_02_0015007_4157_K_7"
		checkbox chk_rules_highpoly_table_1_3_7 "3.7. ?????????? ?????? ????????? ???" checked:true offset:[20,0] tooltip:"3.7. ? ???????? ??????? ?????? ??? ???????? ????? ???????????? ??????/???????????? ?????? ?????????? ????????? ?????????? ?????? ? ??????? number, ??? number  ??? ??????????? ?????, ??????? ? 001 ? ????? ?????? ?? ??????? ?? ????????? ???? ?????? ???????. ????????:\n?????? ???????, ??. 8\nProezdNansena_Uch_8_001\n77:02:0015007:4157\n77_02_0015007_4157_001"

		checkbox chk_rules_highpoly_table_2_All "" checked:true offset:[0,10] across:2 align:#left tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2 "??????? 2. ??????????? ?????????? ? ??????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"??????? 2 ??????????? ?????????? ? ?????? ?????? ?? ?????????? ???????"
		checkbox chk_rules_highpoly_table_2_1 "" checked:true offset:[0,0] across:2 align:#left tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_1 "1. ?????????? ? ??????, ???????, ?????????" align:#right style_sunkenedge:false tooltip:"1. ?????????? ? ????? ??????, ???????? ? ?????????? ??????, ????????? ??????"
		checkbox chk_rules_highpoly_table_2_1_1 "1.1. ?????? ZIP < 500MB" checked:true offset:[20,0] tooltip:"1.1. ?????? ??????? ??? ?????? ???????????? ? ???? ?????? ??????? ZIP ???????? ?? 500 ????????."
		checkbox chk_rules_highpoly_table_2_1_2 "1.2. ?????????? ZIP ??????, ???????????" checked:true offset:[20,0] tooltip:"1.2. ???? ??????? ZIP ?????? ?????? ?????????:\n ???? ??????? FBX\n ???? ??????? FBX ?????? ????????? (??? ??????? ? ???????)\n ???? ??????? GEOJSON\n3-2100 ?????? ??????? PNG"
		checkbox chk_rules_highpoly_table_2_1_3 "1.3. ?????????? ??? - ????????? ??????" checked:true offset:[20,0] tooltip:"1.3. ?????? ???????? ??????? ????????? ? ????? ??????? - ????????? ??????."
		checkbox chk_rules_highpoly_table_2_1_4 "1.4. ?????? ?????? ??? - ????????? ??????" checked:true offset:[20,0] tooltip:"1.4. ?????? ???????? (???????, ?????????) ? ?????????? ??????? - ????????? ??????."
		checkbox chk_rules_highpoly_table_2_1_5 "1.5. ??????????????? - ????????? ??????" checked:true offset:[20,0] tooltip:"1.5. ????? ??????????????? ?????????? ??????? ?? ????? ??? ?????????? ? ??????????????? (Ground) - ????????? ??????."
		checkbox chk_rules_highpoly_table_2_1_6 "1.6. ??????? ???????????????" checked:true offset:[20,0] tooltip:"1.6. ????? ??????????????? ?????????? ??????? - ???????????? ????? ??? ? ???????? ???????????? ? ??????????."
		checkbox chk_rules_highpoly_table_2_1_7 "1.7. ??? ??? ? ??-?? ??-?? ???? ? ??? ? ???" checked:true offset:[20,0] tooltip:"1.7. ????? ??????????????? ?????????? ???????, ? ????? ??? ??? ??????? ?????? ???? ??????????? ? ?????? ???? ? ????????? ??? ??? ??????????????????? ??????, ??? ? ??? ??????????????????. ??? ????????, ? ??? ?????, ? ???, ??????????, ??????? ????????? ? ??."		

		checkbox chk_rules_highpoly_table_2_2 "" checked:true offset:[0,10] across:2 align:#left tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_2 "2. ?????????? ? ????? GEOJSON" offset:[0,10] align:#right style_sunkenedge:false tooltip:"2. ?????????? ? ????????????? ????? JSON"
		checkbox chk_rules_highpoly_table_2_2_1 "2.1. ???????????? ????????? GEOJSON" checked:true offset:[20,0] tooltip:"2.1. ???? GEOJSON ?????? ???? ???????? ?????? ? ???????????? ?? ??????????, ???????????, ??????? ? ?????????? ?????, ??????? ?????????? ??????? ??????? ? ?????????? 3 ? ?????????? ????????????."
		checkbox chk_rules_highpoly_table_2_2_2 "2.2. ?????????? ?????? ??????" checked:true offset:[20,0] tooltip:"2.2. ? ?????? ?????? ? GEOJSON ????????????? ????????????? ???????? ? ???????? (???????, ?????????) ?? ???????????? ??????? ??? ??????? ????????? ????????? ?????????? ??? ??????? ???????? ??????????? ???????, ??? ?????????? ???????, ???????? ? ??????????, ??????? ?????????????? ?????? ? ????? ?? ????????."
		checkbox chk_rules_highpoly_table_2_2_3 "2.3. ?????? ??????? ??????????" checked:true offset:[20,0] tooltip:"2.3. ??? ?????????? ???????? ?????, ??? ????????? ?????? ????????, ????????, ???????????, ? ????????, ?????? ??? ?????????? ???????????? ????????."
		checkbox chk_rules_highpoly_table_2_2_4 "2.4. ???????? ?????? ? ?????" checked:true offset:[20,0] tooltip:"2.4. ??? ????????????? ?????? ???????? ?????? ? ???? okrug, rajon, developer, designer, cadNum, ????????, ????????? ??????????? ??????? ???????, ??? ???????????? ????? ???????, ? ?????? ?????? ???? ? ????? ???? ???????: ?????????????? ??????? ?? ????????. ? ????????? ????? ????????????? ?????? ?? ?????????????."
		checkbox chk_rules_highpoly_table_2_2_5 "2.5. ????????? ? ???????????? ?????" checked:true offset:[20,0] tooltip:"2.5. ????????? ??????? ????????? ?????? ? ???????? ?????. ???? ???? ????????, ??????????? ? ??????????? ?????????? ?????????."
		checkbox chk_rules_highpoly_table_2_2_6 "2.6. ?????????? ???? ?????" checked:true offset:[20,0] tooltip:"2.6. ??? ????, ????? ???? other, ?????? ???? ?????????."
		checkbox chk_rules_highpoly_table_2_2_7 "2.7. ???? ? ????????? UTF-8" checked:true offset:[20,0] tooltip:"2.7. ???? ??????????? ? ??????????????? ? ????????? UTF-8."		
		checkbox chk_rules_highpoly_table_2_2_8 "2.8. ???? ? ?????? features" checked:true offset:[20,0] tooltip:"2.8. ?????? ????????? ???? ? ?????? features ??????? ?? ???? ??????: ????? ???? ? ??? ????????. ?????? ????? ???? ?????????? ? ??????? ? ?????????? ???? ?? ????? ??????????, (??. ?????????? 7, ???. 7.1)"		
		
		checkbox chk_rules_highpoly_table_2_3 "" checked:true offset:[0,10] across:2 align:#left tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_3 "3. ?????????? ? ????? ? ???????? ?????????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"3. ?????????? ? ????? ? ???????? ?????????"
		checkbox chk_rules_highpoly_table_2_3_1 "3.1. ????? ?????? FBX" checked:true offset:[20,0] tooltip:"3.1. ?? ????? ?????? FBX ? ?????????? ??? ??? ??????????????? ?? ?????? ???? ?????? ????????, ?? ??????????? ? ????????? ?????? (????, ??????, ?????? ???????, ?????? ?????????, ????????? ? ?????????? ????????????, ??????? ?????????, ?? ??????????? ? ??????? ???, ????? ???, ????????, ?????????, ??????????, ???????? ? ?.?.)."
		checkbox chk_rules_highpoly_table_2_3_2 "3.2. ??? ?????? ? ???? 0 (default)" checked:true offset:[20,0] tooltip:"3.2. ??? ??????? ? ????? ?????? ???? ??????????? ? ?????? ???? (?????????), ??????????? ?? ?????????."
		checkbox chk_rules_highpoly_table_2_3_3 "3.3. ??? ?????? ?????" checked:true offset:[20,0] tooltip:"3.3. ?? ????? ?? ?????? ???? ?????? ?????? ???? (?????????)"
		checkbox chk_rules_highpoly_table_2_3_4 "3.4. ??????????? ?????????? ?????????????" checked:true offset:[20,0] tooltip:"3.4. ??? ???????? ??????? (?????) ??????? ???????????? ??????????? ?????????? ??????????? ?????????, ????? ???????, ??????????? ??? ??????????? UV-?????????."
		checkbox chk_rules_highpoly_table_2_3_5 "3.5. ??????????????? ??????????? ????????" checked:true offset:[20,0] tooltip:"3.5. ??????????????? ??????????? ?????? ???? ????????? ????????? ?? ???, ???????? ???????????, ???????? ?????????."
		checkbox chk_rules_highpoly_table_2_3_6 "3.6. ??? ? ??? Glass ? ????? FBX" checked:true offset:[20,0] tooltip:"3.6. ??????? ????????? ? ??????? ????????? ?? ????????? ????????????, ????????????? ?????? ??????, ?????? ????????????? ? ????? ???? ??????? FBX."
		checkbox chk_rules_highpoly_table_2_3_7 "3.7. ??-??, ??-??, ????-?? ? 1 ?????? ? ? FBX" checked:true offset:[20,0] tooltip:"3.7. ???????????????, ???????? ??????????????? ? ???????? ?????????????? ?????? ???? ?????????? ? ???? ?????? ????????? ? ???????????? ? ????????? ???? ??????? FBX."
		checkbox chk_rules_highpoly_table_2_3_8 "3.8. ???????? ?? ????????? ??? ?????????" checked:true offset:[20,0] tooltip:"3.8. ???????? ?? ????????? ??????? ????????? ??? ?????? ???? ????????? ???? ?? ???????, ??????????? ??? ?????????? ???? ????????? ?????? ????????? ???????????????."		
		checkbox chk_rules_highpoly_table_2_3_9 "3.9. ???? ????????? ???? >1?, ????????-????" checked:true offset:[20,0] tooltip:"3.9. ?? ????????? ??????? ????????? ??????????????? ???????? ?????? ???? ????????? ???? ?? ?????????? ?? ????? 1 ????? ? ?????????????? ?????????? ???????? ??????????? ????? ?????????, ?? ??????? ??????????? ???????????? (??. ?????????? 5)."
		checkbox chk_rules_highpoly_table_2_3_10 "3.10. ????????????? ????? ? ??????" checked:true offset:[20,0] tooltip:"3.10. ??????? ????????? ?? ?????? ????? ????????????? ?????? ????? ?????, ????? ? ?.?."
		checkbox chk_rules_highpoly_table_2_3_11 "3.11. ?????? ????????? ??-?? ???? ? ???????" checked:true offset:[20,0] tooltip:"3.11. ????????????? ????????????? ?????? ????????? ??? ????????? ???? (?? ??????????? ???????? ?? ????????? ????????????) ? ???????."
		checkbox chk_rules_highpoly_table_2_3_12 "3.12. ?????????? ???-?? ??-??? 2000 000 FBX" checked:true offset:[20,0] tooltip:"3.12. ?????????? ?????????? ??????????? ????????? ???? ???????? ????????? ??????, ?? ??????? ??????? ????????? ????????, ? ?????? ?????? ????? ??????? FBX  2 000 000."
		checkbox chk_rules_highpoly_table_2_3_13 "3.13. ????????, ???????, ????????" checked:true offset:[20,0] tooltip:"3.13. ??????? ????????? ?? ?????? ?????????:\n ?????????? ? ??????????????? ????? ? ????????? (??????????? ?????????? 0,002 ?);\n ????????????? ??????, ????? ? ?????????;\n ???????? ??????? ?????;\n ?????? ????????;\n ?????????????? ?????????????."
		checkbox chk_rules_highpoly_table_2_3_14 "3.14. ????????? ?? ??????" checked:true offset:[20,0] tooltip:"3.14. ?????????, ???????? ????????? ????????????, ?????? ???? ???????? ????????? ??????? ? ????????????. ??????? ?? ?????, ? ?????, ????????? ??????? ??????? ?????? ?????????? ????? ?????? ???? ???????."
		checkbox chk_rules_highpoly_table_2_3_15 "3.15. ?????? ?????????????? ?????????" checked:true offset:[20,0] tooltip:"3.15. ??? ??????????? ???????? ??????????? ??-???????????? ?????????, ????????????? ???? ?????, ?????????? ????? ???? ?????? ?????????? ?? ????? 5 ?? ? ?? ????? 2 ??."
		checkbox chk_rules_highpoly_table_2_3_16 "3.16. ?????? ???????????" checked:true offset:[20,0] tooltip:"3.16. ?????? ??????????? ?????????? ????????????? ???????? ?????????? ??????? ? ??????????? ?? ?????? ?? ????????? (??. ?????????? 4)."
		checkbox chk_rules_highpoly_table_2_3_17 "3.17. ?????????? ???????" checked:true offset:[20,0] tooltip:"3.17. ? ??????? ?? ?????? ???? ?????????? ????????: ??? ??????? ???????, ? ??????? ???????????, ?????????? ?????????, ? ???? ?????? ??????????? ?? ?????? ???? ????????? ????????????? ?????????, ?? ??????????? ???, ??????????????????? ?? ??? ????? ????? (? ??? ????? ????? ??????? ?? ????????? ????????????)."
		checkbox chk_rules_highpoly_table_2_3_18 "3.18. ??????????????: ?????, ??-??? ? ??????" checked:true offset:[20,0] tooltip:"3.18. ?????????????? ?????? ???? ????????? ???????????, ?????????? ???????????. ?????????????, ??? ???????, ???????????? ?????, ???????? ??????? ?????, ? ?????? ??????? ? ???????? ???????????? ??????????? ? ?????????? ?????? ? ?????-???????."
		checkbox chk_rules_highpoly_table_2_3_19 "3.19. ???????????? ????????" checked:true offset:[20,0] tooltip:"3.19. ??????? ????????? ?????? ???? ??????????????? ????? ????????? ? ???? ??????? FBX."
		checkbox chk_rules_highpoly_table_2_3_20 "3.20. ??????? ???????? ??????" checked:true offset:[20,0] tooltip:"3.20. ??????? ????????, ??????? ? ???????? ????? ??????????, ?????? ???? ?????????? ? ??????? ???????????."
		checkbox chk_rules_highpoly_table_2_3_21 "3.21. ????????????? ?????? ????????" checked:true offset:[20,0] tooltip:"3.21. ??? ????????????? ?????? ?????? ???? ???????? (?????????)."
		checkbox chk_rules_highpoly_table_2_3_22 "3.22. ???????? ??????? ??? ???????? ?????" checked:true offset:[20,0] tooltip:"3.22. ???????? ??????? ??? ???????? ?????, ???? ? ?????? ??????????? ???????????? ???????? ?????? ???????????????, ? ????? ? ??? ??? ?? ???????? (????, ??????? ? ?????? ???????? ????, ?????? ? ??.), ??????????????? ????????, ???????????. (??. ?????????? 8)"

		checkbox chk_rules_highpoly_table_2_4 "" checked:true offset:[0,10] across:2 align:#left tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_4 "4. ?????????? ? ??????????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"4. ?????????? ? ??????????"
		checkbox chk_rules_highpoly_table_2_4_1 "4.1. ??????????? ?????????" checked:true offset:[20,0] tooltip:"4.1. ????????? ?? ?????? ???? ??????? ??? ?????? ????????? ??????? ??????? (VRay, Octane, Corona, Arnold ? ??????? ?? ??? ???????????? ??????????? ???????? ????????), ? ????? ?? ????????? ? ????????????? ???????, ?????????????, ?? ??????? ???????, ????? ??? Physical Material, Blend."
		checkbox chk_rules_highpoly_table_2_4_2 "4.2. ???????? ?????????????? ???????" checked:true offset:[20,0] tooltip:"4.2. ???????? ?????????????? ??????? ?? ?????? ????????? ? ???? ?????????? ????."
		checkbox chk_rules_highpoly_table_2_4_3 "4.3. ??? ????? ? ????? ? ?????????? ??????" checked:true offset:[20,0] tooltip:"4.3. ??? ???? ? ?????????? ?????? ? ?????????? ?????? ???? ???????."
		checkbox chk_rules_highpoly_table_2_4_4 "4.4. ??????? ????????? Main >100 UDIM-????" checked:true offset:[20,0] tooltip:"4.4. ???? ? ???????? ????????? Main ????????? ?????????? ????? 100 UDIM-????, ?? ??????????? ??????????????(-??) ????????(-?) (?? ???? ????). ?????? ???????? ?????? ????? ???? SlotNumber ??????? ? ??????? ? ????? ?????? ?? ??????? ? ????? ?????? ???????."
		checkbox chk_rules_highpoly_table_2_4_5 "4.5. ??????????? ???-?? Glass ? ?? ????????" checked:true offset:[20,0] tooltip:"4.5. ???????????:\n ???????????? ????????? *_MainGlass ? *_Main ??? *_GroundGlass ? *_Ground ? ?????? ?????? ????????????? ?????????;\n ????????? ????????? Main ?? ?????? ??? ?????????? ?????????? ???? ????? 100."
		checkbox chk_rules_highpoly_table_2_4_6 "4.6. ?????????? ? ??????????????? ????????" checked:true offset:[20,0] tooltip:"4.6. ?????????? ? ??????????????? ???????? ????????? ??????? ? ?.8 ?????? ???????."
		checkbox chk_rules_highpoly_table_2_4_7 "4.7. ???????????? ???-?? ???-?? ?? 1 ??????" checked:true offset:[20,0] tooltip:"4.7. ???????????? ?????????? ?????????? ?? ???? ?????? ????????? - 7 ??."

		checkbox chk_rules_highpoly_table_2_5 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_5 "5. ?????????? ? ?????????, UV-?????????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"5. ?????????? ? ?????????? ?????? (???? ???????), UV-?????????, ?????????? ?????????"
		checkbox chk_rules_highpoly_table_2_5_1 "5.1. ?????????? ? ?????????" checked:true offset:[20,0] tooltip:"5.1. ?????????? ? ?????????? ?????? (???? ???????)"
		checkbox chk_rules_highpoly_table_2_5_1_1 "5.1.1. PNG ???????? ?? FBX, ?? embedded" checked:true offset:[20,0] tooltip:"5.1.1. ?????????? ????? ?? ?????? ???? ????????????? ? ???? ??????? FBX ? ?????? ??????????????? ? ??????? PNG ???????? ?? ????? ??????? FBX."
		checkbox chk_rules_highpoly_table_2_5_1_2 "5.1.2. ?????????? ??????? ???????" checked:true offset:[20,0] tooltip:"5.1.2. ????????? ????????? ??????? ?????????? ????: 256x256 (????????????? ? ?????????? ?????????), 2048x2048, 4096x4096 ????????."
		checkbox chk_rules_highpoly_table_2_5_1_3 "5.1.3. ?????? ??????? ??????? ? ??????" checked:true offset:[20,0] tooltip:"5.1.3. ? ?????? ?????? ??????????? ?????? ?? ??????????? ????????????? ?????????? ???????? ?????????? ????, ?????????? - ?????????? ????????."
		checkbox chk_rules_highpoly_table_2_5_1_4 "5.1.4. ???? ?????????? ????" checked:true offset:[20,0] tooltip:"5.1.4. ???? ?????????? ????:"
		checkbox chk_rules_highpoly_table_2_5_1_4_1 "5.1.4.1. ???????????? ?????" checked:true offset:[20,0] tooltip:"5.1.4.1. ???????????? ?????: ????? ?????????? ?????, ????? ERM, ????? ????????."
		checkbox chk_rules_highpoly_table_2_5_1_4_2 "5.1.4.2. ?????????????? ?????" checked:true offset:[20,0] tooltip:"5.1.4.2. ?????????????: ????? ????????????, ?????????????? ? ?????-????? ?????????? ????? ?????????? ?????."
		checkbox chk_rules_highpoly_table_2_5_1_5 "5.1.5. ?????? ? UDIM >32 ????????" checked:true offset:[20,0] tooltip:"5.1.5. ???? ? ????????, ????????????? ? ????? ????? UDIM-??????, ?????? ???? ?????????? ????????, ?? ??? ?????? ????? ?????????? ??????, ?? ???? ???????? ?? ???? UV-???????, ??? ???????? ????????? ????????, ?? ????? ??? ?? 32 ???????? (???????????? ?????? ?? ?????????????). UV-?????? ?? ?????? ???????????? ? ??????? UV-????????? ? ?????????."
		checkbox chk_rules_highpoly_table_2_5_1_6 "5.1.6. ? ERM ??? ????? ??????" checked:true offset:[20,0] tooltip:"5.1.6. ?????????? ????? ERM ? ???????? ?????? ??????????????? ?????? ??? ?????-??????."
		checkbox chk_rules_highpoly_table_2_5_1_7 "5.1.7. ? Normal ?????????? ?????" checked:true offset:[20,0] tooltip:"5.1.7. ?????????? ????? Normal ?????? ???? ???????????? ? ???????????? ? API DirectX."
		checkbox chk_rules_highpoly_table_2_5_1_8 "5.1.8. ??? ?????????????? ???????" checked:true offset:[20,0] tooltip:"5.1.8. ?????? ?????????? ????? ?????? ?????? ?????????????? ???? ?? ?? ???? ??????? ????????? (?????????????? ?????????? ???? ???? ?? ??????)."
	
		checkbox chk_rules_highpoly_table_2_5_2 "5.2. ?????????? ? UV-?????????" checked:true offset:[20,0] tooltip:"5.2. ?????????? ? UV-?????????."
		checkbox chk_rules_highpoly_table_2_5_2_1 "5.2.1 ??? *_Main ? *_Ground:" checked:true offset:[20,0] tooltip:"5.2.1. ??? ???????? ????????? ??????? *_Main ? ??????????????? *_Ground:"
		checkbox chk_rules_highpoly_table_2_5_2_1_1 "5.2.1.1. UV-????????? ????????? ?? UDIM" checked:true offset:[20,0] tooltip:"5.2.1.1. UV-????????? ??????????? ????????????? ?? ?????????? UDIM."
		checkbox chk_rules_highpoly_table_2_5_2_1_2 "5.2.1.2. ?????????? ????????? ?? UDIM" checked:true offset:[20,0] tooltip:"5.2.1.2. ?????????, ????????? ?? ???????? ?? ??????? ????? UDIM-??????, ??? ??????? ???????????? ??????????? ? ????????? ????????, ?????????? ?????????, ? ????????????? ??? ???????? ??????? ????????? ?????????? ????????? ??????? ?????????."
		checkbox chk_rules_highpoly_table_2_5_2_1_3 "5.2.1.3. ?????????? UDIM-??????" checked:true offset:[20,0] tooltip:"5.2.1.3. UDIM-?????? ???????????, ??????? ? 1001, ?????? ???????????????, ??? ????????? ? ????????????? ???? UDIM ?? ????? 10 ?? 10 (??. ?????????? 1, ??????? 1.2)."
		checkbox chk_rules_highpoly_table_2_5_2_1_4 "5.2.1.4. ???????????? ????? UV-?????????" checked:true offset:[20,0] tooltip:"5.2.1.4. UV-????????? ????????? ?? ?????????? UDIM ??????????? ? ???????????? ?????????? ? ?????? ?? ???? ?????."
		checkbox chk_rules_highpoly_table_2_5_2_1_5 "5.2.1.5. ??????? UV-????????? ?? ??????????" checked:true offset:[20,0] tooltip:"5.2.1.5. ??????? UV-????????? ?? ?????????? UDIM ?? ?????? ???? ???????? ?????????."
		checkbox chk_rules_highpoly_table_2_5_2_1_6 "5.2.1.6. ??? ???????? ? UV-????????? ?? UDIM" checked:true offset:[20,0] tooltip:"5.2.1.6. ??? UV-????????? ?? ?????????? UDIM ??????????? ???????? UV-??????? ?? ??????? UDIM-?????? (UV-??????? ?? ?????? ???????????? ????? ?????????? UDIM-???????)."
		checkbox chk_rules_highpoly_table_2_5_2_1_7 "5.2.1.7. ??????? UV-????????? ?????? UDIM" checked:true offset:[20,0] tooltip:"5.2.1.7. ??????? UV-????????? ?????? UDIM-?????? ?????????? ????????? ? ??????????? ??????? ?? ?????? UDIM-??????;"
		checkbox chk_rules_highpoly_table_2_5_2_1_8 "5.2.1.8. ??????????? ??????? ????????????" checked:true offset:[20,0] tooltip:"5.2.1.8. ??? ?????????? UV-????????? ?? ?????????? UDIM, ???????? ??????????? ??????? ????, ??????? ? ???????????? ??????? ????? ??????????? ??????? ?? ???????? ????????????."
		checkbox chk_rules_highpoly_table_2_5_2_2 "5.2.2. ??? *_MainGlass ? *_GroundGlass:" checked:true offset:[20,0] tooltip:"5.2.2. ??? ???????? ????????? ?? ????????? ???????????? *_MainGlass, *_GroundGlass:"
		checkbox chk_rules_highpoly_table_2_5_2_2_1 "5.2.2.1. ??? UV-????????? ?????? 1001 UDIM" checked:true offset:[20,0] tooltip:"5.2.2.1. UV-????????? ???? ????????? ????????? ?? ????????? ???????????? ?????????? ??????????? ? ???????? 1001 UDIM-?????? ? ???????????? ??????????? ? ??????????? ??????? ?? ?????? UDIM-??????. ??????????? ????????? UV-???????? ???? ?? ????? (??. ?????????? 6, ???. 6.1);"
		checkbox chk_rules_highpoly_table_2_5_2_2_2 "5.2.2.2. ???????????? ???????? UV-????????" checked:true offset:[20,0] tooltip:"5.2.2.2. ?????????? ??????????? ??????? UV-???????? ????????? ????????? ?? ????????? ????????????;"
		checkbox chk_rules_highpoly_table_2_5_2_2_3 "5.2.2.3. ?????????? ?????????? UV-????????" checked:true offset:[20,0] tooltip:"5.2.2.3. ?????????? ????????? ?????????? UV-???????? ????? ????????? ?? ????????? ???????????? ?????? ?? ????, ??? ???? ??????? ?????? ?????? ???? ???????? ? ??????? ????????? U:0 V:1;"
		checkbox chk_rules_highpoly_table_2_5_2_2_4 "5.2.2.4. ??? ?????????? UV-????????" checked:true offset:[20,0] tooltip:"5.2.2.4. ?????????? UV-???????? ???????????;"
		checkbox chk_rules_highpoly_table_2_5_2_2_5 "5.2.2.5. ?????????? ????????? ?????? ????" checked:true offset:[20,0] tooltip:"5.2.2.5. ???? ???? ????????? ? ?????? ?????????? ??????????? (????, ?????) ??? ??????????? ????????? ?????? ???? ? ?????, ??? ????????????? ?????? ??????? ?????????? ?????????? ???????, ?? ?? ????????????? ????????????? ?????????, ? ??????????? ????????????????? ?????????? ????? ???? (??. ?????????? 6, ???. 6.2);"
		checkbox chk_rules_highpoly_table_2_5_2_2_6 "5.2.2.6. ??? UV-????????? ? UCX ????????" checked:true offset:[20,0] tooltip:"5.2.2.6. UV-????????? ?? ??????????? ? ???????? ????????? ????????."

		checkbox chk_rules_highpoly_table_2_5_3 "5.3. ?????????? ? ?????????? ?????????" checked:true offset:[20,0] tooltip:"5.3. ?????????? ? ?????????? ?????????."
		checkbox chk_rules_highpoly_table_2_5_3_1 "5.3.1. ?????????? 256x256 ????????" checked:true offset:[20,0] tooltip:"5.3.1. ?????????? ?????????? ???????? ?????? ???? ????? 256x256 ????????."
		checkbox chk_rules_highpoly_table_2_5_3_2 "5.3.2. ????????????? ????????? ? ??????" checked:true offset:[20,0] tooltip:"5.3.2. ? ?????? ????? UDIM-????????? ??????????? ???????????? ? ?????????? ?????? ???????? ????????? ? ?????????? ???????? ???????."
		checkbox chk_rules_highpoly_table_2_5_3_3 "5.3.3. ???????? ??? ???????????" checked:true offset:[20,0] tooltip:"5.3.3. ?????????? ???????? ?????? ???? ?????? ??? ???????????."
		checkbox chk_rules_highpoly_table_2_5_3_4 "5.3.4. ???????? ????????? ????? ??????" checked:true offset:[20,0] tooltip:"5.3.4. ?????????? ???????? ?????? ???? ????????? ???????????? ??????, ?????????? ??????? ????????? ?????? ?????????? ????????."
		checkbox chk_rules_highpoly_table_2_5_3_5 "5.3.5. ????????????? ????????" checked:true offset:[20,0] tooltip:"5.3.5. ?????????? ???????? ????????? ???????????? ?????? ?? ????????????, ?? ??????? ????? ?????????? ?????? ??? ? ??????, ???? ??????? ?????????? ??????????, ????????, ?? ??????? ????????????, ????????????? ???????, ? ????? ?????????? ???????? ????????? ???????????? ?? ?????????, ?????????, ????????? ? ??. ?????????."

		checkbox chk_rules_highpoly_table_2_6 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_6 "6. ?????????? ? ????????? ????????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"6. ?????????? ? ????????? ???????? (????????? ????????)"
		checkbox chk_rules_highpoly_table_2_6_1 "6.1. ??????? ????????? ????????: 512..1706" checked:true offset:[20,0] tooltip:"6.1. ?????? ? ??????? ??????? ????????? ??????? ?? ???? 5121706 ????????????? ?? ???????: ????????? ???????? = ????? ??????? ???????? ? ???????? (4096 ??? 2048) / ????? ??? ?????? ???????? ? ?????? ? ??????? ???????????? ???????. ????????:"
		checkbox chk_rules_highpoly_table_2_6_1_1 "6.1.1 ??????? ??? ???????? 4096" checked:true offset:[20,0] tooltip:"6.1.1. ??? ???????? 4096 ????????? ????????? ?? ????????? ?? 7,8 ? ?? 2,5 ? ????? ??????????? ? ???????? ????????? ?? 525 ??/? ?? 1638 ??/? ??????????????."
		checkbox chk_rules_highpoly_table_2_6_1_2 "6.1.2 ??????? ??? ???????? 2048" checked:true offset:[20,0] tooltip:"6.1.2. ??? ???????? 2048 ????????? ????????? ?? ????????? ?? 3,9 ? ?? 1,3 ? ????? ??????????? ? ???????? ????????? ?? 525 ??/? ?? 1575 ??/? ??????????????."
		checkbox chk_rules_highpoly_table_2_6_2 "6.2. ????????? ? ????? ???????" checked:true offset:[20,0] tooltip:"6.2. ??? ?????????? ????, ???????????? ?????-?????, ????????????? ??????? ????????? ?? ??????????????? ?????????."
		checkbox chk_rules_highpoly_table_2_6_3 "6.3. ?????????? ? ????????? ??? ????????" checked:true offset:[20,0] tooltip:"6.3. ? ??????, ????? ???? (??? ?????) ?????????? ????? ?????????? UDIM-?????? ???????? ??????????? ?????????? 256*256 ?? ?????????? ????????? ??????? ? ???? UDIM-?????? ?? ?????????????, ? ???????? ?????? (??? ?????????? ????????????? ???????? ? ??????? ???????) ????????? ??????? ?????????? ????????."
		
		checkbox chk_rules_highpoly_table_2_7 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_7 "7. ?????????? ? ????????? ????????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"7. ?????????? ? ????????? ???????? ????????? ? ????????"
		checkbox chk_rules_highpoly_table_2_7_1 "7.1. ????????? ?????? ?????????" checked:true offset:[20,0] tooltip:"7.1. ???????????? ????????, ?????? ??????, ?????????? ??? ??????????? ?? ???????? ????????? ?????? ?? 5 ??, ?????????? ? ????????. ??????????: ????????? ???????."

		checkbox chk_rules_highpoly_table_2_8 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_8 "8. ?????????? ? ??????????? ??????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"8. ?????????? ? ??????????? ???????? ????????? ??????/??????????????? ???????????. ??????????? ?????? ???????? ???????????? ??? ??? ??????? ? ?????? ??????????????? ???????????:"
		checkbox chk_rules_highpoly_table_2_8_1 "8.1. ?????? ?????? ?? ????. ??????????" checked:true offset:[20,0] tooltip:"8.1. ??? ???????? ?? ????????? ???????????? ????? ?????? ?????? ???? ?????????? ? ?????? ?????? ????????? ? ??????????? ???????????? ????????? ???????? ??????? (??. ?.3.6) ? ?????????, ?? ?? ?????????? ?????."
		checkbox chk_rules_highpoly_table_2_8_2 "8.2. ? ??????? ?????????? - ?????? ????" checked:true offset:[20,0] tooltip:"8.2. ??????????????? ??????????? ? ??????? ?????????? ?????? ????? ?????? ?????????, ?? ?? ????? 7 ????."
		checkbox chk_rules_highpoly_table_2_8_3 "8.3. ??? ?????????? ? ???? ????????? ????" checked:true offset:[20,0] tooltip:"8.3. ?? ???????? ?? ????????? ???????????? ????, ????????? ?????? ? ?????? ?????????? ????????? ????????? ????????, ???? ???? ?? ????????? ?? ?????????? ?? ????????? ???????? ????????? ??????, ????????, ??????????;"
		checkbox chk_rules_highpoly_table_2_8_4 "8.4. ?????????? ????????? - ???? ??? ??????" checked:true offset:[20,0] tooltip:"8.4. ??????????????? ??????????? ????, ??????? ? ????????? ? ????????? ?????????????, ?? ?????? ????? ???????."	

		checkbox chk_rules_highpoly_table_2_9 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_9 "9. ?????????? ? ????? ??????? ? ????????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"9. ?????????? ? ????? ??????? ? ????????? ????????"
		checkbox chk_rules_highpoly_table_2_9_1 "9.1. ???? ???????? ????????????? ??????" checked:true offset:[20,0] tooltip:"9.1. ???? ???????? ???? ???????? ????????? ?????? ??????????????? ????? ???????? ? ????? ?????????? ???????."
		checkbox chk_rules_highpoly_table_2_9_2 "9.2. ???? ????? ????? ? GEOJSON" checked:true offset:[20,0] tooltip:"9.2. ????? ?????????? ?????????? ????? ? ??????? FBX ????? ???? ????? ??????? ? ??????????? ???????? ? ??????????????? ??? ????? ??????? GEOJSON."
		checkbox chk_rules_highpoly_table_2_9_3 "9.3. pivot ? ???? ????????? ? ???? ????????" checked:true offset:[20,0] tooltip:"9.3. ????? ??????? ??????? ???????????? ??????? ????????? ????????? ?????? ???? ??????????? ?????? ? ???? ?? ???? ????."
		checkbox chk_rules_highpoly_table_2_9_4 "9.4. pivot ????? ? ??-?? ? ????.??????" checked:true offset:[20,0] tooltip:"9.4. ????? ??????? ??? ??? ??????????????? ?????? ???? ??????????? ? ????????? ?????????????? ?????? ?????? ?? ???? X ? ?, ? ?? ??? Z ?????? ??????????????? ??????? ??????? ???????."
		checkbox chk_rules_highpoly_table_2_9_5 "9.5. ?????????? pivot ??? ???? ?????? FBX" checked:true offset:[20,0] tooltip:"9.5. ????? ??????? (pivot), ???? ??????? ?????? ????? ??????? FBX, ?????? ????? ?????????? ??????????, ?.?. ???????????? ?????? ?????? ??? ??? ??????????????? ????? ??????? ??????????? ? ??? ?? ???????????, ??? ? ??? ??? ??? ??????????????? ??????????????."
		checkbox chk_rules_highpoly_table_2_9_6 "9.6. pivot ??? ?????????? ?? ???????" checked:true offset:[20,0] tooltip:"9.6. ? ?????? ?????????? ???????? ?? ????????, ????? ??????? ?? ??? Z ????????????? ??????? ??????? ???????, ???? ????? ???????? ???????????? ? ???? ?????????? ????????, ? ???????? ?????? ????? ??????????? ??????????? ?????? ????????."
		checkbox chk_rules_highpoly_table_2_9_7 "9.7. ???????????? ????? ??????? ????????" checked:true offset:[20,0] tooltip:"9.7. ???????????? ????? ??????? ???????? ?? ????? ????????."
		
		checkbox chk_rules_highpoly_table_2_10"" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_10 "10. ?????????? ? ?????????????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"10. ?????????? ? ????????????? ??????, ?????????, ??????? ? ??????????"
		checkbox chk_rules_highpoly_table_2_10_1 "10.1. ????? ???????????? < 254 ???????" checked:true offset:[20,0] tooltip:"10.1. ????? ????????????, ??????? ????? ? ??? ????????, ????????? ? ????????, ?? ?????? ????????? ???????? ? 254 ???????."
		checkbox chk_rules_highpoly_table_2_10_2 "10.2. ???????? ? ????? ? ??????" checked:true offset:[20,0] tooltip:"10.2. ???????????? ?????? ?????????? ????????????? ????????? (?????????? ?????????), ??????? ? ???????? ??????? ????????????? (_). ?????? ???????????, ??????? ??????, ??????????? ? ?????????? ???????? ??????? ????????????? (_). ?????? ????? ????? ? ????????????, ? ??? ????? ? ???????? ????????????????? ????????, ?????????? ? ????????? ?????."
		checkbox chk_rules_highpoly_table_2_10_3 "10.3. ?????????? ????????? _" checked:true offset:[20,0] tooltip:"10.3. ?????? ???????????????? ???????, ???????\???????, ? ????? ???????? ? ????????? ????? ?????????? ???? ?? ????? ???????? ??????? ????????????? (_)."
		checkbox chk_rules_highpoly_table_2_10_4 "10.4. ??????? ????????????" checked:true offset:[20,0] tooltip:"10.4. ??????? ????????????."		
		checkbox chk_rules_highpoly_table_2_10_4_1 "10.4.1. ?????????? ?????? FBX" checked:true offset:[20,0] tooltip:"10.4.1. ???? ??????? FBX ????????? ???????? ?????? (????? GEOJSON ? ZIP ?????? ????????? ????????? ????? ???????????? FBX ??? ??? ? ???????????????):\n- ??? ??? SM_Address SM_ProezdNansena_Uch_8.fbx\n- ??? ??????????????? SM_Address_Ground SM_ProezdNansena_Uch_8_Ground.geojson\n- ??? ?????????? ????????? ??????? ?????? SM_Address_Light SM_ProezdNansena_Uch_8_Light.fbx\n- ??? ?????????? ????????? ??????????????? SM_Address_Ground_Light SM_ProezdNansena_Uch_8_Ground_Light.fbx"
		checkbox chk_rules_highpoly_table_2_10_4_2 "10.4.2. ?????????? ???????? ?????????" checked:true offset:[20,0] tooltip:"10.4.2. ??????? ????????? ????????? ???????? ??????:\n- ??? ??????????????? SM_Address_Ground SM_ProezdNansena_Uch_8_Ground\n- ??? ??????????????? ??????????? ??????????????? SM_Address_GroundGlass SM_ProezdNansena_Uch_8_GroundGlass\n- ??? ???????? SM_Address_Main SM_ProezdNansena_Uch_8_Main\n- ??? ??????????????? ??????????? ???????? (???? ??????? ????????????) SM_Address_MainGlass SM_ProezdNansena_Uch_8_MainGlass\n- ??? ???????? ???????? UCX_SM_Address_Main_Number, Number - ?????????? ????? ???????? ????????, ????? ?? 001 ?? 999. UCX_SM_ProezdNansena_Uch_8_Main_001\n- ??? ???????? ??????????????? UCX_SM_Address_Ground_Number, Number - ?????????? ????? ???????? ????????, ????? ?? 001 ?? 999. UCX_SM_ProezdNansena_Uch_8_Ground_001"
		checkbox chk_rules_highpoly_table_2_10_4_3 "10.4.3. ?????????? ??????? " checked:true offset:[20,0] tooltip:"10.4.3. ???????? ????????? ???????? ??????:\n???????????? ????? PNG ?????? ??????????????? (??. ?????????? 2)\n- ??? ???????? T_Address_TypeTexture_SlotNumber.NomerUDIM T_ProezdNansena_Uch_8_Diffuse_1.1001.png\n- ??? ??????????????? T_Address_Ground_TypeTexture_SlotNumber.NomerUDIM T_ProezdNansena_Uch_8_Ground_Diffuse_1.1001.png"
		checkbox chk_rules_highpoly_table_2_10_4_4 "10.4.4. ?????????? ?????????? ????? FBX" checked:true offset:[20,0] tooltip:"10.4.4. ????????? ? ?????? ????? ??????? FBX ????????? ?????? ??????:\n- ??? ?????????? ??????????????? M_Address_Ground_SlotNumber M_ProezdNansena_Uch_8_Ground_1\n- ??? ??????????????? ?????????? ??????????????? M_Address_GroundGlass_SlotNumber M_ProezdNansena_Uch_8_GroundGlass_1\n- ??? ???????????? ?????????? ???????? M_Address_Main_SlotNumber M_ProezdNansena_Uch_8_Main_1\n- ??? ??????????????? ?????????? ???????? M_Address_MainGlass_SlotNumber M_ProezdNansena_Uch_8_MainGlass_1"
		checkbox chk_rules_highpoly_table_2_10_4_5 "10.4.5. ?????????? ?????????? ????? ???" checked:true offset:[20,0] tooltip:"10.4.5. ???????????? ?????????? ????????? ??????? ??? ?????? ??????????????? ??????:\n- ??? ??????????????? ???????? ?????????? Address_Omni_Number, Number - ?????????? ????? ????????? ????????? ??????? ????, ????? ?? 001 ?? 050, ProezdNansena_Uch_8_Omni_001\n- ??? ???????????? ??????????? ? ?????????? ??????? ????? Address_Spot_Number, Number - ?????????? ????? ????????? ????????? ??????? ????, ????? ?? 001 ?? 050, ProezdNansena_Uch_8_Spot_001\n- ??? ????????? ???????? ?????????? ????????? Address_Root ProezdN ansena_Uch_8_Root"
		checkbox chk_rules_highpoly_table_2_10_4_6 "10.4.6. ?????????? ?????????? ????? ??-??" checked:true offset:[20,0] tooltip:"10.4.6. ???????????? ?????????? ????????? ??????????????? ?????? ??????????????? ??????:\n- ??? ??????????????? ???????? ?????????? Address_Ground_Omni_Number, ??? Number - ?????????? ????? ????????? ????????? ??????? ????, ????? ?? 001 ?? 050, ProezdNansena_Uch_8_Ground_Omni_001\n- ??? ???????????? ??????????? ? ?????????? ??????? ????? Address_Ground_Spot_Number, Number - ?????????? ????? ????????? ????????? ??????? ????, ????? ?? 001 ?? 050, ProezdNansena_Uch_8_Ground_Spot_001\n- ??? ????????? ???????? ?????????? ????????? Address_Ground_Root ProezdNansena_Uch_8_Ground_Root"		

		checkbox chk_rules_highpoly_table_2_11 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_11 "11. ?????????? ? ????????? ?????????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"11. ?????????? ? ????????? ?????????	? ?????????????"
		checkbox chk_rules_highpoly_table_2_11_1 "11.1. ?????????? ????????? ? ???????????" checked:true offset:[20,0] tooltip:"11.1. ???????? ??????????? ? ????????????? ??????, ???????? ?????????, ?????????? ? ??????? ? ????? ???????????/?????????? ???????? ? ???????????? ??????? ? ???????????? ?????????? ?????????????? ?:\nSM_ ??????? ????????? ??? ??????, ?????? ??????? FBX, ZIP, GEOJSON.\nT_ ?????????\nM_ ?????????\n_SlotNumber ????? ???????? ??? ?? 1 ?? 7 ? ?????????? ?????????? ? ?????????? ?????? ?????????, ??????? ????? ????????????, ??????????? ? ?????????? ? ?????????, ?????? ??? ??????????????? ?????? ???: ???????? ? ?????????? ?????\n_Main ??????? ????????? ??? ????????? ???, ????? ??????????????? ???????????\n_MainGlass ??????? ????????? ??? ????????? ??????????????? ??????????? ??? ????????? ???\n_Ground ??????? ????????? ??? ????????? ????????? ???????????????\n_GroundGlass ??????? ????????? ??? ????????? ??????????????? ??????????? ??? ????????? ???????????????\nNumberUDIM ?????????, ????? ????????? ??? ? ?????????? ?????????? ? ?????? UV-??????, ??? ??????? ????????? ????????\nUCX_ ??????? ????????? ????????, ??????????? ???????? ???? Mesh (????? ????????????? ??????)\n_Omni ??????????????? ???????? ?????????? ?????????\n_Spot ????????????	?????????? ????????? ???? ?????????\n_Root ?????????	???????? ???? ?????????? ?????????\n_Light ????? ??????? FBX ?????????? ?????????\n_TypeTexture_ ???????, ?????? ?????????? ? ???? ????????, ?????? ????? ? ??? ?????????? ? ?????????? ??????? ? ???????????? ?????????, ????? ???????????, ??????????? ?????? ? ?????????\n?????????? ???????? ? ?? ?????????:\nDiffuse ???????? ?????\nERM ? - ????? ??????????, R - ????? ?????????????, ? - ????? ?????????????\nNormal ????? ????????"

		checkbox chk_rules_highpoly_table_2_12 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_12 "12. ?????????? ? ???????? ??????????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"12. ?????????? ? ?????????, ?????????? ???????? ????????? ??? ??????? ??????"
		checkbox chk_rules_highpoly_table_2_12_1 "12.1. ????????? ??????????? ?\? ??????" checked:true offset:[20,0] tooltip:"12.1. ????????? ??? ?????? ?????????? ??????????? ?????????? ?????????? ?????? ? ????????????? ????????? 0-255, ??? ????????? ?? 0 ?? 127 - ???????/????????? ?????, ? ?? 128 ?? 255 - ???????????/??????? ????????????."
		checkbox chk_rules_highpoly_table_2_12_2 "12.2. ????? ????????? ? ?????-??????" checked:true offset:[20,0] tooltip:"12.2. ?????????? ????? ????????? ??? ??????? ?????????? ???????? ? ?????-????? ?????????? ????? ?????????? ?????."
		checkbox chk_rules_highpoly_table_2_12_3 "12.3. ???????? ?????????????? ?? 0,002?" checked:true offset:[20,0] tooltip:"12.3. ????????, ?? ??????? ????????? ?????????? ????? ? ?????????????, ? ??? ??????, ???? ??? ??????????????? ? ????? ??????, ?????? ???? ?????????????? ? ??????????? ??? ???? ????? ????????? ? ????????? ??????????? ???????? ?? 0,002 ????? ? ????????? ??????? ? ??????????????? ???????."
		
		checkbox chk_rules_highpoly_table_2_13 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_13 "13. ?????????? ? ????????? ????????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"13. ?????????? ? ????????? ????????"
		checkbox chk_rules_highpoly_table_2_13_1 "13.1. ?????? ???????? convex, ?? concave" checked:true offset:[20,0] tooltip:"13.1. ????????? ???????? - ??? ?????? ???????? (??. ?????????? 7, ???.7.1), ?????? ?? ??????? ?????? ???? ????????, ?????????, ?? ????????? ? ???? ????????? (??. ?????????? 7, ???.7.2) ? ?????? ???????? ????????????? ????? (??. ?/? 4 ?.?. ??, ??)."
		checkbox chk_rules_highpoly_table_2_13_2 "13.2. ??? ??????? ??? ? ??????????? ??-??" checked:true offset:[20,0] tooltip:"13.2. ????????? ???????? ???????? ????????????? ??? ???????? ????????? ??????????????? (???????? ?????: ???, ???????? ????????? ? ?????????????? ? ??? ?? ???????????) ? ????????????? ??? ??????? ???."
		checkbox chk_rules_highpoly_table_2_13_3 "13.3. ?????? ???? FBX ? ??????????" checked:true offset:[20,0] tooltip:"13.3. ?????? ???? ??????? FBX ?????? ????? ???? ????????? ????????, ????? ?????? FBX ? ??????????."
		checkbox chk_rules_highpoly_table_2_13_4 "13.4. ??? ???????????, ????? 0,01..0,02?" checked:true offset:[20,0] tooltip:"13.4. ??????????? ??????? ????????? ???????? ???, ????? ??? ?? ???????????? ????? ?????. ????? ????? ???????? ??????????? ???????? ????????????? ?????? 0,02 - 1 ??."
		checkbox chk_rules_highpoly_table_2_13_5 "13.5. ?????? ????????? ????????? ?????????" checked:true offset:[20,0] tooltip:"13.5. ?????? ???????? ???????? ?????? ????????? ????????? ??????????? ????????? ? ?? ??????????????? ??????????? (????? ???????), ? ?????? ???????? ????????? ??????????????? ????? ????????????? ????????? ??????????????? ? ?? ???????????????? ?????????????, ? ??????????? ???? ?????????? ??????? ??."
		checkbox chk_rules_highpoly_table_2_13_6 "13.6. ?????? ? ???????? ?? ????? ???????" checked:true offset:[20,0] tooltip:"13.6. ????????? ???????? ?????? ????? ????????? ????? ??????? ?????????, ???????? ??? ???????????, ?????? ? ???????? ?? ????? ??????? ????????? ??? ????????? ????????:"		
		checkbox chk_rules_highpoly_table_2_13_6_1 "13.6.1. ??? ??-??, ?? ????????? <0,1?" checked:true offset:[20,0] tooltip:"13.6.1. ???????????????, ???????? ?? ????????? - 10 ??;"
		checkbox chk_rules_highpoly_table_2_13_6_2 "13.6.2. ??? ?? ?????? ?????? <0,3?" checked:true offset:[20,0] tooltip:"13.6.2. ??? ?? ?????? ??????, ????, ??? ?????????? ???????????, ????? ??????? ?????????????? ??????? - 30 ??. ???? ????? ??? ?????? ?????, ????????? ??? ?????? ?????, ? ??????? ????????? ????? ? ????????;"
		checkbox chk_rules_highpoly_table_2_13_6_3 "13.6.3. ????????? ????????? ??? <1?" checked:true offset:[20,0] tooltip:"13.6.3. ????????? ????????? ??? - 1?."
		checkbox chk_rules_highpoly_table_2_13_7 "13.7. ???????? ??? ??????????" checked:true offset:[20,0] tooltip:"13.7. ????????? ???????? ?? ?????? ????????? ????? ??????????."
		checkbox chk_rules_highpoly_table_2_13_8 "13.8. ??????????? ????? ????????" checked:true offset:[20,0] tooltip:"13.8. ????, ?????????? ????? (???????), ??????? ??????? ?? ??????, ???????? ????????????? ???????? ?????? ???? ?????? ? ????? ??????? ? ????? ????????? ????????."
		checkbox chk_rules_highpoly_table_2_13_9 "13.9. ???????? ????? ????????? ????????" checked:true offset:[20,0] tooltip:"13.9. ???????? ? ??????? ????? ?????? ????? ????? ????????? ????????."
		checkbox chk_rules_highpoly_table_2_13_10 "13.10. ?????????? ???-?? ????????????? 5%" checked:true offset:[20,0] tooltip:"13.10. ?????????? ?????????????, ???????? ? ?????? ????????? ????????, ?????????????? ?? ???????: ?????????? ????????????? ?????? ? 0,05 = ?????????? ???????????? ????? ????????????? ????????? ????????, ?? ??????????? ???????	????? 50000	?????????????. ????????: ?????????? ????????????? ??????, ????????? ??????? ????????? ????????? ???????? ????? 1 243 374. ?? ???? 1 243 374 ? 0,05 = 62 168,7, ?????????? ???????????? ????? ????????????? ??? ????????? ???????? 62 169 (????? ??????? ????? ????? ????????? ?? ????? ?????? ? ?????? ?????????? ?????)."
		checkbox chk_rules_highpoly_table_2_13_11 "13.11. ??? ??????? c <50000, ???-?? <15000" checked:true offset:[20,0] tooltip:"13.11. ??? ???????, ????????? ?? ?????, ??? 50000 ??????????? ?????????, ??????????? ???????: ?????????? ???????????? ????? ??????????? ????????? ????????? ???????? = 15000 ??????????? ?????????."
		checkbox chk_rules_highpoly_table_2_13_12 "13.12. ??????????? ????? 2??? ????????? " checked:true offset:[20,0] tooltip:"13.12. ??????????? ?????????? ??????????? ????????? ?? ?????? ?? ???????????????? ?? ????????? ????????. ?? ????, ???? ?????????? ??????????? ????????? ?????? ?????????? ???????????? 2 ??? ??????????? ?????????, ?? ?????????? ??????????? ????????? ????????? ???????? ????? ????????????? ?????????? ?? 100000 ??????????? ?????????."				
		checkbox chk_rules_highpoly_table_2_13_13 "13.13. ??????????????? ????????? ????????" checked:true offset:[20,0] tooltip:"13.13. ??????????????? ????????? ???????? ?????? ???? ????????? ??????????????? ??????, ????????? ??????? ?? ?????????."				
		
		checkbox chk_rules_highpoly_table_2_14 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_14 "14. ?????????? ? ????????? ????????? (???)" offset:[0,10] align:#right style_sunkenedge:false tooltip:"14. ?????????? ? ???????????? ????????? ????????? (???)"
		checkbox chk_rules_highpoly_table_2_14_1 "14.1. ERM ??? ???????? ??????? ????????" checked:true offset:[20,0] tooltip:"14.1. ?????????? ????? ERM ???????????? ??? ???????? ??????? ???????? ??????????? (???????? ???????, ???????????? ?????, ???????? ???????, ??????????? ?????????? ?????????)"
		checkbox chk_rules_highpoly_table_2_14_2 "14.2. ERM ?? ??????????????? ????????" checked:true offset:[20,0] tooltip:"14.2. ?????????? ????? ERM ?? ????? ???? ???????????? ? ???????? ???????????????? ????????? ?????????."
		checkbox chk_rules_highpoly_table_2_14_3 "14.3. Emissive ???? ???????? ? ERM" checked:true offset:[20,0] tooltip:"14.3. ????? Emissive ?????? ?????? ???? ????????, ??? ??? ??? ??????????? ? ??????? ????? ????? ERM ? ??????? ?????????? ? ????????? ??????."
		checkbox chk_rules_highpoly_table_2_14_4 "14.4. ????? ???, Emissive ??????" checked:true offset:[20,0] tooltip:"14.4. ? ?????? ?????????? ?????????? ????????????, ????? Emissive ???????? ?????? ??????."
		checkbox chk_rules_highpoly_table_2_14_5 "14.5. ???? ???  ? ???????" checked:true offset:[20,0] tooltip:"14.5. ???? ??? ???????? ? ??? ?? ?????????? ???????????, ? ?????????? ????? ?????????? ?????"		

		checkbox chk_rules_highpoly_table_2_15 "" checked:true offset:[0,10] across:2 tooltip:"Check to check" 
		label lbl_rules_highpoly_table_2_15 "15.  ?????????? ? ?????????????? ?????????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"15. ?????????? ? ?????????????? ????????? ??????? ??????	? ??????????????? (???????? ??????)"
		checkbox chk_rules_highpoly_table_2_15_1 "15.1. ????? ????????? ???????" checked:true offset:[20,0] tooltip:"1. ????? ??? ???????? ????????? ??????? ??????????? ?????? ? ??? ??????, ???? ?????? ????????????? ??? ???????. ??????????? ?????????? ?????????? ????????? ? ??????, ????? ???? ????? ?????? ?? ?????????? ??????????? ?????? ???????? ? ?????, ????? ?? ????????? ??? ?????????:\n ???????????? ???????? ????????? ?????? ??????;\n ????????? ???????? ?????????;\n ???????????? ?????????? ?????."
		checkbox chk_rules_highpoly_table_2_15_2 "15.2. ?????????? ?????? ?????????? ?????" checked:true offset:[20,0] tooltip:"2. ??? ?????????? ?????? ?????????? ????????? ??????????? ????????????? ?????????? ????????? ?????? ?? ???????? ???????? ???????? ??????."
		checkbox chk_rules_highpoly_table_2_15_3 "15.3. ? FBX <50 ?????????? ?????????" checked:true offset:[20,0] tooltip:"3. ???? ??????? FBX ? ??????????? ????????? ?? ?????? ????????? ????? 50 ?????????? ?????????."
		checkbox chk_rules_highpoly_table_2_15_4 "15.4. ??????? ??????? ??? ??????????" checked:true offset:[20,0] tooltip:"4. ? ?????? ??????? ? ??????? ????????? ??????? ? ?????? ??????????? ?????????? ??????? ??? ??? ??????????????? ?????????? ?????????? ??????? ??? ?????????????? ????????????. ?????????? ???????? ?? ????? ???????? ????????? ?????????? ? ??????? ???? ERM, ? ???????? ????? ??? ?????? ?????????? ?????????, ?? ???????? ? ?????? ?????????????? ?????????? ???????."
		checkbox chk_rules_highpoly_table_2_15_5 "15.5. ??????? ????? FBX ? ??????????? ?????" checked:true offset:[20,0] tooltip:"5. ????????? ????????? ??????????????? ? ????????? ????? ??????? FBX ?????? 7.4 (FBX2014) ????????? ???? ??? ??????? ??????? ??? ? ??????? ??????? ??????????????? ???????? ? ??????? ???????????????? ZIP-??????."
		checkbox chk_rules_highpoly_table_2_15_6 "15.6. ?????????? ???? ?????????? ?????" checked:true offset:[20,0] tooltip:"6. ?????????? ????????? ????? ???? ?????? ???????? ??????????????? ??? ?????????? ?????????? ?????????."
		checkbox chk_rules_highpoly_table_2_15_7 "15.7. ?????????? ???? ?????????? ?????" checked:true offset:[20,0] tooltip:"7. ???????????? ?????? ??????? ????????? ?????????, ?? ??????????? ? ????????? ??? ??????????? ??????? ???????."
		checkbox chk_rules_highpoly_table_2_15_8 "15.8. ?????????? ????????? ?????????? ??." checked:true offset:[20,0] tooltip:"8. ? ?????????? ????????? ?????? ???? ????????? ?????? ???? ????? ? ??? ????. ????????? ??????????????? ?????????? ?????????."
		checkbox chk_rules_highpoly_table_2_15_9 "15.9. ???????? ???????? ?????????? ?????" checked:true offset:[20,0] tooltip:"9. ??? ??????? ?????????? ????????? ???????????? ????? ???????? ????????, ??? ??? ????????? ????????? ????????? ? ????????? ????????, ??????????? ??????????????? ?????? ????????."
		checkbox chk_rules_highpoly_table_2_15_10 "15.10. ????????? ???. ? ????????? ???????" checked:true offset:[20,0] tooltip:"10. ????????? ????????? ?????? ???? ??????????? ? ????????? ???????????? ??????????? ??????? ???, ????? ????? ???????? ????????? ????????? ???????, ? ?? ???????? ??????? ??????????? ?????? ????????????? ????? ?????? ??????? ?????? ? ????? ??????? ???? ????????????? ??????? (???????? ??????????? ?/? 14 ?.?. 3 ? ??????? ??????? ???????????, ??? ? ??? ??????)."
		checkbox chk_rules_highpoly_table_2_15_11 "15.11. ???????????? ?? ???-?? ???. <10??" checked:true offset:[20,0] tooltip:"11. ????????????? ???????????? ?? ????? 10 ?????????? ????????? ?? ???? ?????????? ?????? ??? ??? ???????????????."
	
		checkbox chk_rules_highpoly_table_3_All "" checked:true offset:[0,10] across:2 align:#left tooltip:"Check to check" 
		label lbl_rules_highpoly_table_3 "??????? 3. ???????? ?????????, ???????????" offset:[0,10] align:#right style_sunkenedge:false tooltip:"??????? 3. ???????? ????????? ? ??????????? ? ?????????? ???????"
		checkbox chk_rules_highpoly_table_3_1 "1. ?????? ?????? ? ?????????? <500Mb" checked:true offset:[20,0] tooltip:"1. ?????? ??????.\n?????????? ?? ??????? ?????? ?????? ??????/???????/??????????????? (Ground) ????????? ? ????????????? ?????????? 500 ??.\n??????????: ? ?????? ????????? 500 ?? ?????? ????????? ????? ??????, ????????? ??? ???????? ?????? ?????? ??????/???????/ ??????????????? (????????? ??????? + ??????? ????????? ??? ??????????????? ??????????? + ????????? ??? ????????), ? ????? ???? ?????????? ????."
		checkbox chk_rules_highpoly_table_3_2 "2. ?????????? ????????????? ? FBX <2???" checked:true offset:[20,0] tooltip:"2. ?????????? ??????????? ?????????. ?????????? ? ?????????? ????????? ?? ??? ????????? ? ?????? ?????? ????? FBX - ?? 2 ???. ??????????? ?????????."
		checkbox chk_rules_highpoly_table_3_3 "3. ?????????? ?????????? <7" checked:true offset:[20,0] tooltip:"3. ?????????? ??????????. ?????????? ? ?????????? ?????????? ?? ???? ????????? ??????, ?????? - ?? ????? 7 ??. ?? ??????."
		checkbox chk_rules_highpoly_table_3_4 "4. ??????????? ???????" checked:true offset:[20,0] tooltip:"4. ??????????? ???????. ??????? ??????? ?????? ???? ??????? ?? ??????? (????????????, ?????????? ????, ??????????????? ????? ? ?.?.). ???????, ??????? ?? ????????? ? ?????? ??? ???????????????, ??? ?? ?????? ???? ??????? ?? ??????? (??????????, ????, ??????? ?????? ? ?.?.)"
		checkbox chk_rules_highpoly_table_3_5 "5. ??????? ???? ?????? >0,1?" checked:true offset:[20,0] tooltip:"5. ????? ????????. ??????? ???? ?????? ??????? 10 ??."

	mapped fn check_on e = e.checked = true
	mapped fn check_off e = e.checked = false
	
	on btn_highpoly_checkers_on pressed do
	(
		arr = for i in RulesCheck_highpoly.Controls where classof i == CheckBoxControl and findstring i.name "_table_" != undefined collect i
		check_on arr
	)
		
	on btn_highpoly_checkers_off pressed do
	(
		arr = for i in RulesCheck_highpoly.Controls where classof i == CheckBoxControl and findstring i.name "_table_" != undefined collect i
		check_off arr		
	)
)
addRollout RulesCheck_highpoly GeoAGR rolledup:true


rollout syssetup "System Setup" autoLayoutOnResize:true
(
	button btn_set_meters "Set Meters" align:#left across:3 tooltip:"?????????? ????? ??? ????????? ??????? ? ?????????? ????? ??? ??????? ??????????? | Set Meters as system units and as system display units"
	button btn_set_alpha "Gamma 1.0" offset:[0,0] tooltip:"?????????? ????????? ????? ? 1.0 ??? ??????????? ??????? ? ??????, ?????? ?? ????? ??????????? ?????? ? ???????? ????????, ????? ??? ???????? ????????????? | Gamma to 1.0 of textures and colors, affects color selectors, better for modeling usability"
	button btn_set_alpha_two "Gamma 2.2" align:#right offset:[0,0] tooltip:"?????????? ????????? ????? ? 2.2 ??? ??????????? ??????? ? ??????, ?????? ?? ????? ??????????? ?????? ? ???????? ????????, ????? ??? ???????? ???????????? | Gamma to 2.2 of textures and colors, affects color selectors, better for VIZ rendering"
	button btn_set_standart_render_settings "Standart Render" across:3 align:#left offset:[0,0] tooltip:"?????????? ?????? ?????????? Standart, ????? ??? ???????? ????????????? | Set main render engine to Standart, better for modeling usability"
	button btn_set_corona_render_settings "Corona Render" offset:[20,0] tooltip:"?????????? ?????? ?????????? Corona Render, ????? ??? ???????? ???????????? | Set main render engine to Corona Render, better for VIZ rendering"
	button btn_set_mats "Mats" align:#right tooltip:"????????????? ????????? ????? ? ?????????? ?????? ? ??????? ???????? | Reload materials with right gamma and normal mapping"	
	radiobuttons rdo_lang labels: #("????????? ?? ??????-?????????? ????????", "English tooltips") columns:1 rows:2 default:1 align:#left offset:[0,0] tooltip:"????????? ?? ??????-?????????? ???????? | English tooltips"

	
	on rdo_lang changed state do
	(
		setIniForceUTF16Default true
		
		--TooltipWriter (GetDir #maxroot + "\\GeoScripts\\tooltips_syssetup.ini") syssetup "[syssetup]\n"
		--TooltipWriter (GetDir #maxroot + "\\GeoScripts\\tooltips_slicers.ini") slicers "[slicers]\n"
		--TooltipWriter (GetDir #maxroot + "\\GeoScripts\\tooltips_UDIMs.ini") UDIMs "[UDIMs]\n"
		
		for i in syssetup.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_syssetup.ini") i.name "syssetup" state)
		for i in slicers.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_slicers.ini") i.name "slicers" state)
		for i in UDIMs.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_UDIMs.ini") i.name "UDIMs" state)
		for i in Geojson.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_Geojson.ini") i.name "Geojson" state)
		for i in UCX.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_UCX.ini") i.name "UCX" state)
		for i in Obj_Spln.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_objs.ini") i.name "Obj_Spln" state)
		for i in Obj_tools.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_tools.ini") i.name "Obj_tools" state)
		for i in File.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_files.ini") i.name "File" state)
		for i in Docker.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_Docker.ini") i.name "Docker" state)

		/*
		local filenameIni = GetDir #maxroot + "\\GeoScripts\\tooltips_syssetup.ini"
		if not doesFileExist filenameIni then
		(
			local stri = "[syssetup]\n"
			for i in syssetup.controls where isProperty i "tooltip" do 
				--if findstring i.tooltip "|" != undefined then 
					stri += i.name + "=" + (substitutestring (substitutestring (i.tooltip) "\n" "::" ) "\r" "") + "\n"
			--print stri
			
			--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("Windows-1251")) --ANSI
			--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-16LE"))
			local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-8"))
			Writer.Write(stri)
			Writer.Close()
			free Writer
			free filenameIni
			free stri
		)
		
		local filenameIni = GetDir #maxroot + "\\GeoScripts\\tooltips_slicers.ini"
		if not doesFileExist filenameIni then
		(
			local stri = "[slicers]\n"
			for i in slicers.controls where isProperty i "tooltip" do 
				--if findstring i.tooltip "|" != undefined then 
					stri += i.name + "=" + (substitutestring (substitutestring (i.tooltip) "\n" "::" ) "\r" "") + "\n"
			--print stri
			
			--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("Windows-1251")) --ANSI
			--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-16LE"))
			local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-8"))
			Writer.Write(stri)
			Writer.Close()
			free Writer
			free filenameIni
			free stri
		)
*/		
/*
		try
		(
			for i in syssetup.controls where isProperty i "tooltip" do 
			(
				local tooltip = getINISetting (GetDir #maxroot + "\\GeoScripts\\tooltips_slicers.ini") "syssetup" i.name
				if tooltip != undefined then
					if tooltip != "" then
						if findstring tooltip "|" != undefined then 
						(
							tooltip = substitutestring tooltip " | " "|"
							i.tooltip = (filterstring (substitutestring tooltip "::" "\n") "|")[state]
						)
			)	
		)catch()
		
		try
		(
			for i in slicers.controls where isProperty i "tooltip" do 
			(
				local tooltip = getINISetting (GetDir #maxroot + "\\GeoScripts\\tooltips_slicers.ini") "slicers" i.name
				if tooltip != undefined then
					if tooltip != "" then
						if findstring tooltip "|" != undefined then 
						(
							substitutestring tooltip " | " "|"
							i.tooltip = (filterstring (substitutestring tooltip "::" "\n") "|")[state]
						)
			)	
		)catch()
*/		
	)

	on syssetup open do 
	(
		setIniForceUTF16Default true
		for i in syssetup.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_syssetup.ini") i.name "syssetup" 1)
	
		/*
		local filenameIni = GetDir #maxroot + "\\GeoScripts\\tooltips_syssetup.ini"
		if doesFileExist filenameIni then deleteFile filenameIni
		
		try
		(
			for i in syssetup.controls where isProperty i "tooltip" do (setINISetting filenameIni "syssetup" i.name (substitutestring (replace_LF_with_CRLF (replace_CRLF_with_LF i.tooltip)) "\n" "@" ))
		)catch()
			
		try
		(
			for i in syssetup.controls where isProperty i "tooltip" do 
			(
				local tooltip = getINISetting filenameIni "syssetup" i.name
				if tooltip != undefined then
					if tooltip != "" then
						if findstring tooltip "|" != undefined then 
							i.tooltip = (filterstring (substitutestring tooltip "@" "\n") "|")[1]
			)
		)catch()
		*/
	)

	on btn_set_mats pressed do 
	(
		for i in selection do 
		(
			for tmap in (getClassInstances BitmapTexture target:i asTrackViewPick:off) do 
			(
				--for r in (refs.dependents tmap immediateOnly:true) where try(classof r == CoronaNormal)catch(false) do appendIfUnique temp_arr r
				try(tmap.bitmap = openBitmap tmap.bitmap.filename gamma:2.2)catch()
			)
			for tmap in (getClassInstances CoronaBitmap target:i asTrackViewPick:off) do 
			(
				--for r in (refs.dependents tmap immediateOnly:true) where try(classof r == CoronaNormal)catch(false) do appendIfUnique temp_arr r
				try(tmap.gamma = 2.2)catch()
			)
			for tmap in (getClassInstances CoronaNormal target:i asTrackViewPick:off) do
			(
				try
				(
					tmap.addGamma = true
					if classof tmap.normalMap == BitmapTexture then tmap.normalMap.bitmap = openBitmap tmap.normalMap.bitmap.filename gamma:2.2
					if classof tmap.normalMap == CoronaBitmap then tmap.normalMap.gamma = 2.2
				)catch()
			)
		)
	)

	on btn_set_mats rightclick do 
	(
		for i in selection do 
		(
			for tmap in (getClassInstances BitmapTexture target:i asTrackViewPick:off) do 
			(
				--for r in (refs.dependents tmap immediateOnly:true) where try(classof r == CoronaNormal)catch(false) do appendIfUnique temp_arr r
				try(tmap.bitmap = openBitmap tmap.bitmap.filename gamma:1.0)catch()
			)
			for tmap in (getClassInstances CoronaBitmap target:i asTrackViewPick:off) do 
			(
				--for r in (refs.dependents tmap immediateOnly:true) where try(classof r == CoronaNormal)catch(false) do appendIfUnique temp_arr r
				try(tmap.gamma = 1.0)catch()
			)
			for tmap in (getClassInstances CoronaNormal target:i asTrackViewPick:off) do
			(
				try
				(
					tmap.addGamma = true
					if classof tmap.normalMap == BitmapTexture then tmap.normalMap.bitmap = openBitmap tmap.normalMap.bitmap.filename gamma:1.0
					if classof tmap.normalMap == CoronaBitmap then tmap.normalMap.gamma = 1.0
				)catch()
			)
		)
	)
	
	on btn_set_meters pressed do
	(
		units.DisplayType = #metric
		units.MetricType = #meters
		units.SystemType = #meters
	)
	
	on btn_set_alpha pressed do
	(
		if ((maxversion())[1] / 1000) - 2 + 2000 >= 2025 then ColorPipelineMgr.mode = #gamma 
		else 
		(
			IDisplayGamma.colorCorrectionMode = #gamma 	
			IDisplayGamma.colorCorrectionPrefMode = #gamma
		)		
		FileInGamma = 1.0
		FileOutGamma = 1.0
		displayGamma = 1.0
	)

	on btn_set_alpha_two pressed do
	(
		if ((maxversion())[1] / 1000) - 2 + 2000 >= 2025 then ColorPipelineMgr.mode = #gamma 
		else 
		(
			IDisplayGamma.colorCorrectionMode = #gamma 	
			IDisplayGamma.colorCorrectionPrefMode = #gamma
		)		
		FileInGamma = 2.2
		FileOutGamma = 2.2
		displayGamma = 2.2
	)
	
	on btn_set_standart_render_settings pressed do
	(
		renderSceneDialog.close()
		for rnd in 1 to (rendererClass.classes).count where matchPattern ((rendererClass.classes)[rnd] as string) pattern:"Default_Scanline_Renderer" do Renderers.Production = RendererClass.Classes[rnd]()
		for rnd in 1 to (rendererClass.classes).count where matchPattern ((rendererClass.classes)[rnd] as string) pattern:"Default_Scanline_Renderer" do renderers.activeShade = RendererClass.Classes[rnd]()
	)
	
	on btn_set_corona_render_settings pressed do
	(
		renderSceneDialog.close()
		if Renderers.Production != "Corona:Corona" then for rnd in 1 to (rendererClass.classes).count where matchPattern ((rendererClass.classes)[rnd] as string) pattern:"Corona" do Renderers.Production = RendererClass.Classes[rnd]()
		--for rnd in 1 to (rendererClass.classes).count where matchPattern ((rendererClass.classes)[rnd] as string) pattern:"CoronaRenderer" do Renderers.Production = RendererClass.Classes[rnd]()
	)
)

rollout slicers "Slicers" autoLayoutOnResize:true
(
	radiobuttons rdo_mods labels: #("Slice Modifiers", "Poly Slicers") columns:2 rows:1 default:1 align:#center offset:[0,0] tooltip:"???????????? ????? ???????: ????????? ???????????? slice ??? ???????????? ???????? ??????? ? editable poly | Use slicing method: add slice modifiers or use slice operations with editable poly"
	group "Slicer Distances Parameters"
	(
		spinner spn_gor_X "X interval" range:[0.001, 10000.0, 5.0] fieldWidth:35 align:#left across:3 tooltip:"?????????? ?????????? ????? ?????? ?? ??? X | Set distance between slices about X axis"
		checkbox chk_gor_side_x "From other side" checked:false offset:[5,0] width:100 tooltip:"???????? ??????? ???????????? ??? X ? ?????? ??????? ???????, ????????? ??????? ?????? | Begin slice about X axis from other side of object, using current offset" 
		spinner spn_gor_Xoffset "Offset" range:[0.0, 10000.0, 0.2] offset:[0,0] fieldWidth:30 align:#right tooltip:"?????????? ??? ??????? ?????? ??? ??????? ???? | Set the offset for the first slice for the object"
		checkbox chk_gor_Xfuses "Make fuses" checked:false across:2 align:#right offset:[50,0] tooltip:"?????? ?????? ?????? ??? ??????? ?????????, ????????? ????????????? ?????? ?????????? | Make two slices for each one interval by selected distance between of two slices" 
		spinner spn_gor_Xfuses "" range:[0.001, 10000.0, 0.01] enabled:chk_gor_Xfuses.checked align:#right fieldWidth:40 tooltip:"?????? ?????????? ??? ?????? ??????? | Distance between pair slices"
		
		spinner spn_gor_Y "Y interval" range:[0.001, 10000.0, 5.0] fieldWidth:35 align:#left across:3 tooltip:"?????????? ?????????? ????? ?????? ?? ??? Y | Set distance between slices about Y axis"
		checkbox chk_gor_side_y "From other side" checked:false offset:[5,0] tooltip:"???????? ??????? ???????????? ??? Y ? ?????? ??????? ???????, ????????? ??????? ?????? | Begin slice about Y axis from other side of object, using current offset" 
		spinner spn_gor_Yoffset "Offset" range:[0.0, 10000.0, 0.2] fieldWidth:30 offset:[0,0] tooltip:"?????????? ??? ??????? ?????? ??? ??????? ???? | Set the offset for the first slice for the object"
		checkbox chk_gor_Yfuses "Make fuses" checked:false across:2 align:#right offset:[50,0] tooltip:"?????? ?????? ?????? ??? ??????? ?????????, ????????? ????????????? ?????? ?????????? | Make two slices for each one interval by selected distance between of two slices" 
		spinner spn_gor_Yfuses "" range:[0.001, 10000.0, 0.01] enabled:chk_gor_Yfuses.checked align:#right fieldWidth:40 tooltip:"?????? ?????????? ??? ?????? ??????? | Distance between pair slices"		
		
		spinner spn_vert_Z "Z interval" range:[0.001, 10000.0, 1.1] fieldWidth:35 align:#left across:3 tooltip:"?????????? ?????????? ????? ?????? ?? ??? Z | Set distance between slices about Z axis"
		checkbox chk_vert_side_z "From other side" checked:false offset:[5,0] width:100 tooltip:"???????? ??????? ???????????? ??? Z ? ?????? ??????? ???????, ????????? ??????? ?????? | Begin slice about Z axis from other side of object, using current offset" 	
		spinner spn_vert_Zoffset "Offset" range:[0.0, 10000.0, 0.2] fieldWidth:30 offset:[0,0] tooltip:"?????????? ??? ??????? ?????? ??? ??????? ???? | Set the offset for the first slice for the object"
		checkbox chk_vert_Zfuses "Make fuses" checked:false across:2 align:#right offset:[50,0] tooltip:"?????? ?????? ?????? ??? ??????? ?????????, ????????? ????????????? ?????? ?????????? | Make two slices for each one interval by selected distance between of two slices" 
		spinner spn_vert_Zfuses "" range:[0.001, 10000.0, 0.01] enabled:chk_vert_Zfuses.checked align:#right fieldWidth:40 tooltip:"?????? ?????????? ??? ?????? ??????? | Distance between pair slices"
	)
	group "Slicer plane angles"
	(	
		radiobuttons rdo_angles labels: #("Ground(Top)/Reseted", "Walls(Front-Back)", "Walls(Left-Right)", "Custom") columns:2 rows:2 default:1 align:#left offset:[0,0] tooltip:"?????????????? ???????? ???? ??? ?????? ?? ??????????? ?????????, ??? ?????? ???-??????????? ??????? ?????? ???????????? ??? ???? ??? ?????????? ????????? ????? | Preseted angles for slices by view or viewport direction, for each axis-direction of slicing array uses three angles to orient slice plane"

		checkbox chk_x "For X axis slices" checked:true align:#left across:4 offset:[-5,0] tooltip:"???? ???? ?????? ??????????, ??????????? ??? ??? ??? ???????? ?????? ?? ??? X ? ?????????? ???? ??????????? | Use this axis when checked, make slices for X axis with selected options above" 
		spinner spn_eu_xx "X" range:[0.0, 360.0, 0.0] align:#right fieldWidth:35 offset:[20,0] tooltip:"??? ???? ??? ?????????? ????????? ???? | Three angles to orient slice plane"
		spinner spn_eu_yx "Y" range:[0.0, 360.0, 90.0] align:#right fieldWidth:35 offset:[10,0] tooltip:"??? ???? ??? ?????????? ????????? ???? | Three angles to orient slice plane"
		spinner spn_eu_zx "Z" range:[0.0, 360.0, 90.0] align:#right fieldWidth:35 tooltip:"??? ???? ??? ?????????? ????????? ???? | Three angles to orient slice plane"
		
		checkbox chk_y "For Y axis slices" checked:true align:#left across:4 offset:[-5,0] tooltip:"???? ???? ?????? ??????????, ??????????? ??? ??? ??? ???????? ?????? ?? ??? Y ? ?????????? ???? ??????????? | Use this axis when checked, make slices for Y axis with selected options above" 
		spinner spn_eu_xy "X" range:[0.0, 360.0, 90.0] align:#right fieldWidth:35 offset:[20,0] tooltip:"??? ???? ??? ?????????? ????????? ???? | Three angles to orient slice plane"
		spinner spn_eu_yy "Y" range:[0.0, 360.0, 0.0] align:#right fieldWidth:35 offset:[10,0] tooltip:"??? ???? ??? ?????????? ????????? ???? | Three angles to orient slice plane"
		spinner spn_eu_zy "Z" range:[0.0, 360.0, 90.0] align:#right fieldWidth:35 tooltip:"??? ???? ??? ?????????? ????????? ???? | Three angles to orient slice plane"
		
		checkbox chk_z "For Z axis slices" checked:false align:#left across:4 offset:[-5,0] tooltip:"???? ???? ?????? ??????????, ??????????? ??? ??? ??? ???????? ?????? ?? ??? Z ? ?????????? ???? ??????????? | Use this axis when checked, make slices for Z axis with selected options above"
		spinner spn_eu_xz "X" range:[0.0, 360.0, 0.0] align:#right fieldWidth:35 offset:[20,0] enabled:chk_z.checked tooltip:"??? ???? ??? ?????????? ????????? ???? | Three angles to orient slice plane"
		spinner spn_eu_yz "Y" range:[0.0, 360.0, 0.0] align:#right fieldWidth:35 offset:[10,0] enabled:chk_z.checked tooltip:"??? ???? ??? ?????????? ????????? ???? | Three angles to orient slice plane"
		spinner spn_eu_zz "Z" range:[0.0, 360.0, 0.0] align:#right fieldWidth:35 enabled:chk_z.checked tooltip:"??? ???? ??? ?????????? ????????? ???? | Three angles to orient slice plane"
	)
	group "Slicer Tools"
	(		
		button btn_slice "Slice to Axises" width:260 align:#left tooltip:"LMB: ???????? ??????? ????????????? Slice ??? ??????? ????? ??????? QuickSlice ? Editable_Poly | LMB: Add matrix of Slice Modifiers or QuickSlice as Editable_Poly"

		button btn_delete "Delete Slices" across:3 width:80 align:#left tooltip:"??????? ??? ???????????? ????? ?? ????? ?????????? ??????? | Remove all Slice modifiers from stack of selected object"
		button btn_slice_copy "Copy Slice Modifier" width:100 offset:[5,0] tooltip:"??????????? ????? ??????? ??????????? Slice ? ??????? ????????? ?? ????????? ???? ????? | Copy abovest Slice Modifier with current offset by selected above Axises"
		spinner spn_slice_copy_offset "Offset" range:[-100000.0, 100000.0, 1.09] fieldWidth:35 offset:[0,0] align:#right fieldWidth:40 tooltip:"???????? ????? ??????????? ?????????????? ????? | Offset between Slice Modifiers to be copied"

		button btn_conv "Convert to Poly" across:3 width:80 align:#left tooltip:"??????? ?????????????? ?????????? ???????? ? Editable poly | Simple convert selected objects to Editable poly"
		button btn_remove "Remove Verts" tooltip:"??????????? ????????? EDGE-BORDER, ??? ?????? ?????? ? ????!\nLMB: ??????? ?????? ??????? ????? ????????????? Slice\nRMB: ??????? ?????? ??????? ????? ShapeMerge\nRMB+CTRL: ??????? ?????? ???????????? ????? ????? ShapeMerge\nALT: ?????? ??????? ????????? ??????? | Use EDGE or BORDER selection for affect only for them!\nLMB: Try to Remove two-edged error vertices after Slice modifiers, using all object or only for EDGE-BORDER selection\nRMB: Try to Remove two-edged error vertices after ShapeMerge, EDGE-BORDER selection preffered\nRMB+CTRL: Try to Remove vertical error edges from BORDER selection, after ShapeMerge\nALT: Select errors only, do not remove anything"
		spinner spn_remove "Treshold" range:[0.0, 180.0, 0.01] scale:0.01 fieldWidth:30 type:#float align:#right tooltip:"????????? ???? ??? ???????? ?????? | Treshold angle to remove verts"
	)
	group "Slicer for texels density cut"
	(	
		button btn_guess_slice "Guess Slices" width:70 across:3 align:#left tooltip:"LMB: ??????????? ?????????? ????? ???????? ??? ????????? ????????, ??? ??????? ????? ??????? ????????? ????????? UDIM!\n\nRMB: ?????????? ????????? ??????????????? ??????? ?? ?????????? ????? ??????? ?? ??? Z, RMB+CTRL: ?? ??? Y, RMB:ALT: ?? ??? X | LMB: Set slices distances by target texel density. The UV Texel should be the same only if it completely fills the UDIM!\n\nRMB: Count result texel density from slicers distance by Z axis, RMB+CTRL: by Y axis, RMB:ALT: by X axis."
		dropdownlist ddl_texture_size "" items:#("256", "512", "1024", "2048", "4096") selection:5 width:52 fieldWidth:52 offset:[-10,0] tooltip:"??????? ????????:\n256*256 ????????,\n512*512 ????????,\n1024*1024 ????????,\n2048*2048 ????????,\n4096*4096 ???????? | Texture dimensions:\n256*256 pixels,\n512*512 pixels,\n1024*1024 pixels,\n2048*2048 pixels,\n4096*4096 pixels" 
		spinner spn_guess_slice "Target density" range:[0.001, 100000.0, 1380.0] scale:0.1 type:#float offset:[0,0] fieldWidth:45 width:70 align:#right tooltip:"???????? ????????? ???????? ?? ????????? [512..1706]\n???? ?????? ??????? ????? ????????? ????????? UDIM | Target texels density value [512..1706].\nIf each texel will fully fill UDIM"
	)
	group "Object unwrap UVW UDIM auto slicer"
	(	
		button btn_uv_cut_pressed "" width:1 height:1 across:2 align:#left tooltip:""
		button btn_uv_cut "Auto UDIM UV Grid Slicer" width:260 align:#right tooltip:"LMB: ??????????? ?? ????? = ?? ???????? UVWmap = ?? ???? UDIM = ?? ???????? ????????\n????? ???????? c ??????????? ???????\nLMB+CTRL: ?? ?????????? UVW ?? W\nRMB: ????? ?2\nRMB+CTRL: ?? ??????? ????????? ???????\nRMB+ALT: ?? ????????? VertexWeld | LMB: Auto Slice objects for every UDIM grid (by Friedrich Hanisch 3d-io), may work with face selection, be sure UVs larger than UDIM\nLMB+CTRL: Do not flatten W in UVW\nRMB: Use Method #2, alternative\nRMB+CTRL: Don't Remove bad Verts\nRMB+ALT: Don't Vertex Weld"
	)
	
	on slicers open do 
	(
		for i in slicers.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_slicers.ini") i.name "slicers" 1)

		/*
		--setIniForceUTF16Default true
		--local filenameIni = GetDir #maxroot + "\\GeoScripts\\tooltips_slicers.ini"
		--if doesFileExist filenameIni then deleteFile filenameIni
			
		--local stri = "[slicers]\n"
		--for i in slicers.controls where isProperty i "tooltip" do stri += i.name + "=" + (substitutestring (substitutestring (i.tooltip) "\n" "::" ) "\r" "") + "\n"
		--print stri
		
			--Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("Windows-1251")) --ANSI
			--local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-16LE"))
		--	local Writer = dotNetObject"System.IO.StreamWriter" filenameIni false ((dotNetClass "System.Text.Encoding").GetEncoding("UTF-8"))
		--	Writer.Write(stri)
		--	Writer.Close()
		--	free Writer
			--free filenameIni
			--free stri

		try
		(
			for i in slicers.controls where isProperty i "tooltip" do (setINISetting filenameIni "slicers" i.name (substitutestring (substitutestring (i.tooltip) "\n" "::" ) "\r" ""))
		)catch()
		
		
		try
		(
			for i in slicers.controls where isProperty i "tooltip" do 
			(
				local tooltip = getINISetting filenameIni "slicers" i.name
				if tooltip != undefined then
					if tooltip != "" then
						if findstring tooltip "|" != undefined then 
							i.tooltip = (filterstring (substitutestring tooltip "::" "\n") "|")[1]
			)
		)catch()
		*/
	)	
	
	on chk_gor_Xfuses changed arg do spn_gor_Xfuses.enabled = chk_gor_Xfuses.checked 
	on chk_gor_Yfuses changed arg do spn_gor_Yfuses.enabled = chk_gor_Yfuses.checked 	
	on chk_vert_Zfuses changed arg do spn_vert_Zfuses.enabled = chk_vert_Zfuses.checked 
		
	on chk_x changed arg do (spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked; rdo_angles.state = 4)
	on chk_y changed arg do (spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked; rdo_angles.state = 4)
	on chk_z changed arg do (spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked; rdo_angles.state = 4)
	
	on rdo_mods changed st do 
	(
		case st of
		(		
			1: case rdo_angles.state of
			(
				1: --top
				(
					spn_eu_xx.value = 0.0
					spn_eu_yx.value = 90.0
					spn_eu_zx.value = 90.0
					
					spn_eu_xy.value = 90.0
					spn_eu_yy.value = 0.0
					spn_eu_zy.value = 90.0
					
					spn_eu_xz.value = 0.0
					spn_eu_yz.value = 0.0
					spn_eu_zz.value = 0.0
					
					chk_x.checked = true
					chk_y.checked = true
					chk_z.checked = false
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
					
				)
				2: --front-back
				(
					spn_eu_xx.value = 0.0
					spn_eu_yx.value = 90.0
					spn_eu_zx.value = 90.0
					
					spn_eu_xy.value = 0.0
					spn_eu_yy.value = 0.0
					spn_eu_zy.value = 90.0
					
					spn_eu_xz.value = 0.0
					spn_eu_yz.value = 0.0
					spn_eu_zz.value = 0.0
					
					chk_x.checked = true
					chk_y.checked = false
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)	
				3: --left-right
				(
					spn_eu_xx.value = 0.0
					spn_eu_yx.value = 0.0
					spn_eu_zx.value = 90.0
					
					spn_eu_xy.value = 90.0
					spn_eu_yy.value = 0.0
					spn_eu_zy.value = 90.0
					
					spn_eu_xz.value = 0.0
					spn_eu_yz.value = 0.0
					spn_eu_zz.value = 0.0
					
					chk_x.checked = false
					chk_y.checked = true
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)
			)
			
			2: case rdo_angles.state of
			(
				1: --top
				(
					spn_eu_xx.value = (x_axis).x
					spn_eu_yx.value = (x_axis).y
					spn_eu_zx.value = (x_axis).z
					
					spn_eu_xy.value = (y_axis).x
					spn_eu_yy.value = (y_axis).y
					spn_eu_zy.value = (y_axis).z
					
					spn_eu_xz.value = (z_axis).x
					spn_eu_yz.value = (z_axis).y
					spn_eu_zz.value = (z_axis).z
					
					chk_x.checked = true
					chk_y.checked = true
					chk_z.checked = false
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
					
				)
				2: --front-back
				(
					spn_eu_xx.value = (x_axis).x
					spn_eu_yx.value = (x_axis).y
					spn_eu_zx.value = (x_axis).z
					
					spn_eu_xy.value = (y_axis).x
					spn_eu_yy.value = (y_axis).y
					spn_eu_zy.value = (y_axis).z
					
					spn_eu_xz.value = (z_axis).x
					spn_eu_yz.value = (z_axis).y
					spn_eu_zz.value = (z_axis).z
					
					chk_x.checked = true
					chk_y.checked = false
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)	
				3: --left-right
				(
					spn_eu_xx.value = (x_axis).x
					spn_eu_yx.value = (x_axis).y
					spn_eu_zx.value = (x_axis).z
					
					spn_eu_xy.value = (y_axis).x
					spn_eu_yy.value = (y_axis).y
					spn_eu_zy.value = (y_axis).z
					
					spn_eu_xz.value = (z_axis).x
					spn_eu_yz.value = (z_axis).y
					spn_eu_zz.value = (z_axis).z
					
					chk_x.checked = false
					chk_y.checked = true
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)
			)
		)		
	)
	
	on rdo_angles changed state do
	(
		case rdo_mods.state of
		(		
			1: case state of
			(
				1: --top
				(
					spn_eu_xx.value = 0.0
					spn_eu_yx.value = 90.0
					spn_eu_zx.value = 90.0
					
					spn_eu_xy.value = 90.0
					spn_eu_yy.value = 0.0
					spn_eu_zy.value = 90.0
					
					spn_eu_xz.value = 0.0
					spn_eu_yz.value = 0.0
					spn_eu_zz.value = 0.0
					
					chk_x.checked = true
					chk_y.checked = true
					chk_z.checked = false
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
					
				)
				2: --front-back
				(
					spn_eu_xx.value = 0.0
					spn_eu_yx.value = 90.0
					spn_eu_zx.value = 90.0
					
					spn_eu_xy.value = 0.0
					spn_eu_yy.value = 0.0
					spn_eu_zy.value = 90.0
					
					spn_eu_xz.value = 0.0
					spn_eu_yz.value = 0.0
					spn_eu_zz.value = 0.0
					
					chk_x.checked = true
					chk_y.checked = false
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)	
				3: --left-right
				(
					spn_eu_xx.value = 0.0
					spn_eu_yx.value = 0.0
					spn_eu_zx.value = 90.0
					
					spn_eu_xy.value = 90.0
					spn_eu_yy.value = 0.0
					spn_eu_zy.value = 90.0
					
					spn_eu_xz.value = 0.0
					spn_eu_yz.value = 0.0
					spn_eu_zz.value = 0.0
					
					chk_x.checked = false
					chk_y.checked = true
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)
			)
			
			2: case state of
			(
				1: --top
				(
					spn_eu_xx.value = (x_axis).x
					spn_eu_yx.value = (x_axis).y
					spn_eu_zx.value = (x_axis).z
					
					spn_eu_xy.value = (y_axis).x
					spn_eu_yy.value = (y_axis).y
					spn_eu_zy.value = (y_axis).z
					
					spn_eu_xz.value = (z_axis).x
					spn_eu_yz.value = (z_axis).y
					spn_eu_zz.value = (z_axis).z
					
					chk_x.checked = true
					chk_y.checked = true
					chk_z.checked = false
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
					
				)
				2: --front-back
				(
					spn_eu_xx.value = (x_axis).x
					spn_eu_yx.value = (x_axis).y
					spn_eu_zx.value = (x_axis).z
					
					spn_eu_xy.value = (y_axis).x
					spn_eu_yy.value = (y_axis).y
					spn_eu_zy.value = (y_axis).z
					
					spn_eu_xz.value = (z_axis).x
					spn_eu_yz.value = (z_axis).y
					spn_eu_zz.value = (z_axis).z
					
					chk_x.checked = true
					chk_y.checked = false
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)	
				3: --left-right
				(
					spn_eu_xx.value = (x_axis).x
					spn_eu_yx.value = (x_axis).y
					spn_eu_zx.value = (x_axis).z
					
					spn_eu_xy.value = (y_axis).x
					spn_eu_yy.value = (y_axis).y
					spn_eu_zy.value = (y_axis).z
					
					spn_eu_xz.value = (z_axis).x
					spn_eu_yz.value = (z_axis).y
					spn_eu_zz.value = (z_axis).z
					
					chk_x.checked = false
					chk_y.checked = true
					chk_z.checked = true
					
					spn_eu_xx.enabled = spn_eu_yx.enabled = spn_eu_zx.enabled = chk_x.checked 
					spn_eu_xy.enabled = spn_eu_yy.enabled = spn_eu_zy.enabled = chk_y.checked 
					spn_eu_xz.enabled = spn_eu_yz.enabled = spn_eu_zz.enabled = chk_z.checked 	
				)
			)
		)
	)	
	
	on btn_uv_cut rightclick do with redraw off with undo "UDIM Slicer" on 
	(
		if selection.count == 1 then
		(		
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			btn_uv_cut_pressed.pressed()
			
			i = selection[1]	
			max modify mode
			
			if not alt then 
			(
				converttopoly i
				addmodifier i (VertexWeld threshold: 0.001)	
				converttopoly i
			)
				
			if not ctrl then 
			(
				converttopoly i
				max modify mode
				--panel_mode = getCommandPanelTaskMode()
				--sub_level = subObjectLevel
				thePoly = i --selection[1] 
				--max create mode 
				numEdges = polyop.getNumEdges thePoly
				numVerts = polyop.getNumVerts thePoly
				Edges_sel = polyop.getEdgeSelection thePoly
				Verts_Err = #{}
				Verts = #{1..numVerts} 

				--for v in Verts where (nEdges = thePoly.GetVertexEdgeCount v) == 2 do 
				for v in Verts where (nEdges = polyop.getEdgesUsingVert thePoly v).numberset == 2 do
				(
					if keyboard.escPressed then exit
					vv = #{} --????? ?????? ?? ?????? ?????
					for e in nEdges do vv += polyop.getVertsUsingEdge thePoly #{e} --???????? ?? ?????? ?????? ? ????? ????? ??????
					vv -= #{v} --????????? ?? ?????? ????? ???????
					p1 = polyop.getVert thePoly v --??????? ????? ? ????? ???????
					pp = for w in vv collect polyop.getVert thePoly w --??????? ??? ??? ????? ?? ?????? ??????
					if p1 != undefined and pp[1] != undefined and pp[2] != undefined then
					(
						local v1 = p1 - pp[1]
						local v2 = p1 - pp[2]
						angle = acos (dot (normalize v1) (normalize v2) )
						if angle >= abs(180 - 0.1) or angle <= abs(0.1) then Verts_Err += #{v} --???? ???? ????? ?????????, ?????????? ?? ????? ?????, ??????????? ? == 180 ????????, ?? ??? ? ???? ?????? - ??????? ???????; ?????, ???? ??????? ?????????? ???? ? ????? ?? ?????? ?????; ?????, ???? ?????????? ? ???? ??????? ?? ?????? ?????, ????? ???? ????? 0 --if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
					)
				)

				if Verts_Err.numberset > 0 then
				(
					polyop.setVertSelection thePoly Verts_Err
					thePoly.Remove selLevel:#Vertex flag:1 --polyop.deleteEdges thePoly vert_edges delIsoVerts:true
				)
				--setCommandPanelTaskMode panel_mode
				--if sub_level != undefined then subObjectLevel = sub_level
			)	
			
			addmodifier i (Unwrap_UVW())	
		)				
	)
	
	on btn_uv_cut_pressed pressed do -- with redraw off with undo "UDIM Slicer" on 
	(
		if selection.count == 1 then
		(
			--ctrl = keyboard.controlPressed
			--alt = keyboard.altPressed
			
			max modify mode
			i = selection[1]
			converttopoly i
			subObjectLevel = 0
					
			local minUV_x
			local minUV_y
			local UV_width
			local UV_height
			local areaUVW
			local areaGeom
			local faces = #{}
			local do_part = false		
			
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(
				--unwrapmod.getArea #{1..unwrapmod.numberPolygons()} &minUV_x &minUV_y &UV_width &UV_height &areaUVW &areaGeom
				faces = unwrapmod.getselectedfaces()
				if faces.isempty then 
				(
					do_part = false
					faces = #{1..unwrapmod.numberPolygons()}
				)					
				else 
				(
					do_part = true
					--faces = #{1..unwrapmod.numberPolygons()}
				)
				unwrapmod.getArea faces &minUV_x &minUV_y &UV_width &UV_height &areaUVW &areaGeom
				converttopoly i
			)
			
			max create mode
		
			ChannelInfo.ClearChannel i 9 
			ChannelInfo.ClearChannel i 8 
			ChannelInfo.ClearChannel i 7
			ChannelInfo.ClearChannel i 6 
			ChannelInfo.ClearChannel i 5 
			ChannelInfo.ClearChannel i 4 
			ChannelInfo.ClearChannel i 3
			ChannelInfo.ClearChannel i 2
			
			converttopoly i
			
			ChannelInfo.AddChannel i --????????? ????? ????? 2
			ChannelInfo.CopyChannel i 1 0 -- ???????? ????????? ??????? ??????
			ChannelInfo.PasteChannel i 1 2 --????????? ????????? ??????? ?????? (?????????? ???? ??????????? ????? ????????? ? ????? ?????????, ????? ????? ?????? ?? ??????????? ??? ???????????)

			ChannelInfo.CopyChannel i 3 1 -- ???????? ????????? ??????? ?????? 
			ChannelInfo.PasteChannel i 1 0 --????????? ????????? ? ?????????  
			
			converttopoly i

			local c = i
			local faces_poly = #{}
			faces_poly = polyop.getFaceSelection i 
			local faces_del = #{}
			faces_del = #{1..polyop.getnumfaces c} - faces_poly
			
			if not faces_poly.isempty then 
			(
				--polyop.detachFaces i faces asNode:true delete:false --name:"Test" node:c 
				--c = maxOps.getNodeByHandle (amax (for o in objects collect i.inode.handle))
				c = snapshot i
				converttopoly c
				
				polyop.deleteFaces c faces_del delIsoVerts:true 
				resetxform c
				converttopoly c
			)
			else
			(
				c = snapshot i
				converttopoly c
				resetxform c
				converttopoly c
			)
				
			local xmin = c.min.x
			local xmax = c.max.x
			local ymin = c.min.y
			local ymax = c.max.y
			delete c
			free c
			
			local xt = minUV_x - ((minUV_x as integer) as float) 
			local yt = minUV_y - ((minUV_y as integer) as float) 	
			
			--format "xmin=% xmax=% minUV_x=% xt=%\n" xmin xmax minUV_x xt
			--format "minX=% maxX=%\n" (xmin - minUV_x - 1) (xmax - minUV_x + 1)
			--format "ymin=% ymax=% minUV_y=% yt=%\n" ymin ymax minUV_y yt
			--format "minY=% maxY=%\n" (ymin - minUV_y - 1) (ymax - minUV_y + 1)
			
			select i
			converttopoly i
			max modify mode
			if do_part then subObjectLevel = 4
				
			for xcut = (xmin - xt - 1) to (xmax - xt + 1) by 1 where not keyboard.escPressed do with redraw off --???????? ?? ????? ?????? ????????? x, ???????? ?????? ??????? ?? mesh
			(
				modPanel.addModToSelection(sliceModifier())
				--addmodifier i (sliceModifier())
				local modTM = getModContextTM i i.modifiers[1]
				local objTM = i.objecttransform
				i.modifiers[1].Clean = true
				i.modifiers[1].SliceFormat = 0 --plane
				i.modifiers[1].Slice_Type = 0
				i.modifiers[1].Faces___Polygons_Toggle = 0 --mesh
				i.modifiers[1].slice_plane.rotation = eulerangles 0 90 90
				i.modifiers[1].slice_plane.position = ([xcut, i.center.y, i.center.z] * modTM * (inverse objTM)) 
				if i.modifiers.count > 10 then 
				(
					converttopoly i
					if do_part then subObjectLevel = 4
				)
			)
			
			converttopoly i
			if do_part then subObjectLevel = 4
			for ycut = (ymin - yt - 1) to (ymax - yt + 1) by 1 where not keyboard.escPressed do with redraw off --???????? ?? ????? ?????? ????????? y, ???????? ?????? ??????? ?? mesh
			(
				modPanel.addModToSelection(sliceModifier()) 
				--addmodifier i (sliceModifier())
				local modTM = getModContextTM i i.modifiers[1]
				local objTM = i.objecttransform
				i.modifiers[1].Clean = true
				i.modifiers[1].SliceFormat = 0 --plane
				i.modifiers[1].Slice_Type = 0
				i.modifiers[1].Faces___Polygons_Toggle = 0 --mesh
				i.modifiers[1].slice_plane.rotation = eulerangles 90 0 90
				i.modifiers[1].slice_plane.position = ([i.center.x, ycut, i.center.z] * modTM * (inverse objTM)) 
				if i.modifiers.count > 10 then
				(
					converttopoly i
					if do_part then subObjectLevel = 4
				)
			)

			addmodifier i (edit_poly()) --????????? ???, ????? ?????????????? ?? mesh ? poly, ????? ?? ????? ????????? ? ??????
			
			converttopoly i
			max create mode
				
			ChannelInfo.CopyChannel i 3 2 --???????? ????????? ??????? ??????
			ChannelInfo.PasteChannel i 1 0 --????????? ????????? ? ??????? ????? (?????????? ??????????? ????? ? ?????? ????????? ????????? ? ????? ?????????, ?? ?? ??? ????????)

			ChannelInfo.ClearChannel i 2 
			ChannelInfo.ClearChannel i 3	
				
			--???? ????????? ??????? ????????
			converttopoly i
			max hold
	
			/*	
			--local j = sphere radius:1.0 pos:i.pos rotation:i.rotation scale:i.scale name:i.name material:i.material
			--converttopoly j
			
			--polyop.deleteFaces j #all delIsoVerts:true
			--polyop.attach j i
			--polyop.CollapseDeadStructs j
				
			--i = j
			--free j
							
			--converttopoly i	
			--select i
			*/

/*
			max modify mode
			
			if not alt then 
			(
				converttopoly i
				addmodifier i (VertexWeld threshold: 0.001)	
				converttopoly i
			)
				
			if not ctrl then 
			(
				converttopoly i
				max modify mode
				--panel_mode = getCommandPanelTaskMode()
				--sub_level = subObjectLevel
				thePoly = i --selection[1] 
				--max create mode 
				numEdges = polyop.getNumEdges thePoly
				numVerts = polyop.getNumVerts thePoly
				Edges_sel = polyop.getEdgeSelection thePoly
				Verts_Err = #{}
				Verts = #{1..numVerts} 

				--for v in Verts where (nEdges = thePoly.GetVertexEdgeCount v) == 2 do 
				for v in Verts where (nEdges = polyop.getEdgesUsingVert thePoly v).numberset == 2 do
				(
					if keyboard.escPressed then exit
					vv = #{} --????? ?????? ?? ?????? ?????
					for e in nEdges do vv += polyop.getVertsUsingEdge thePoly #{e} --???????? ?? ?????? ?????? ? ????? ????? ??????
					vv -= #{v} --????????? ?? ?????? ????? ???????
					p1 = polyop.getVert thePoly v --??????? ????? ? ????? ???????
					pp = for w in vv collect polyop.getVert thePoly w --??????? ??? ??? ????? ?? ?????? ??????
					if p1 != undefined and pp[1] != undefined and pp[2] != undefined then
					(
						local v1 = p1 - pp[1]
						local v2 = p1 - pp[2]
						angle = acos (dot (normalize v1) (normalize v2) )
						if angle >= abs(180 - 0.1) or angle <= abs(0.1) then Verts_Err += #{v} --???? ???? ????? ?????????, ?????????? ?? ????? ?????, ??????????? ? == 180 ????????, ?? ??? ? ???? ?????? - ??????? ???????; ?????, ???? ??????? ?????????? ???? ? ????? ?? ?????? ?????; ?????, ???? ?????????? ? ???? ??????? ?? ?????? ?????, ????? ???? ????? 0 --if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
					)
				)

				if Verts_Err.numberset > 0 then
				(
					polyop.setVertSelection thePoly Verts_Err
					thePoly.Remove selLevel:#Vertex flag:1 --polyop.deleteEdges thePoly vert_edges delIsoVerts:true
				)
				--setCommandPanelTaskMode panel_mode
				--if sub_level != undefined then subObjectLevel = sub_level
			)			
			addmodifier i (Unwrap_UVW())
*/			
		)
		else messageBox ("Select single object")
		
		/*
		ChannelInfo.CopyChannel sel <integer>channelType <integer>channel Copies the specified channel of specified channel type in the supplied node. 
		Possible channelType values are: 
		1 - Geometry 
		2 - Selection 
		3 - Map 
		*/
	)
	
	on btn_uv_cut pressed do with redraw off with undo "UDIM Slicer" on 
	(
		sel = selection as array
		if not keyboard.controlPressed then 
		(
			for i in sel do 
			(
				udims.btn_bricks_flatten.pressed()
				converttopoly i
			)
		)
		TAG sel true
	)
	
	on btn_guess_slice pressed do
	(
		theMapSize = case (ddl_texture_size.selection as integer) of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)
		spn_gor_X.value = spn_gor_Y.value = spn_vert_Z.value = theMapSize/spn_guess_slice.value
	)
	
	on btn_guess_slice rightclick do
	(
		theMapSize = case (ddl_texture_size.selection as integer) of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)
		case of
		(
			(keyboard.altPressed): spn_guess_slice.value = theMapSize/spn_gor_X.value
			(keyboard.controlPressed): spn_guess_slice.value = theMapSize/spn_gor_Y.value
			default: spn_guess_slice.value = theMapSize/spn_vert_Z.value
		)	
	)
	
	on btn_slice_copy pressed do with undo "Copy Slice Modifier" on with redraw off  
	(
		for s in selection where s.modifiers.count > 0 do
		(
			if s.modifiers[1].name == "Slice" then
			(
			addmodifier s (copy s.modifiers[1])
			/*
			modPanel.addModToSelection(sliceModifier()) 
			modTM = getModContextTM selection[1] selection[1].modifiers[1]
			objTM = selection[1].objecttransform
			selection[1].modifiers[1].Clean = true
			selection[1].modifiers[1].SliceFormat = selection[1].modifiers[2].SliceFormat
			selection[1].modifiers[1].Slice_Type = selection[1].modifiers[2].Slice_Type
			selection[1].modifiers[1].Faces___Polygons_Toggle = selection[1].modifiers[2].Faces___Polygons_Toggle
			selection[1].modifiers[1].slice_plane.rotation = selection[1].modifiers[2].slice_plane.rotation
			selection[1].modifiers[1].slice_plane.position = selection[1].modifiers[2].slice_plane.position
			[0,0,0] * modTM * (inverse objTM)) 
			*/
				objTM = s.objecttransform
				modTM = getModContextTM s s.modifiers[1]
				print objTM
				print modTM
				if chk_x.checked then s.modifiers[1].slice_plane.position.x += spn_slice_copy_offset.value --selection[1].modifiers[1].slice_plane.position += [spn_slice_copy_offset.value,0,0] * modTM * (inverse objTM)
				if chk_y.checked then s.modifiers[1].slice_plane.position.y += spn_slice_copy_offset.value --[0,spn_slice_copy_offset.value,0] * modTM * (inverse objTM)
				if chk_z.checked then s.modifiers[1].slice_plane.position.z += spn_slice_copy_offset.value --[0,0,spn_slice_copy_offset.value] * modTM * (inverse objTM)
			)
		)
	)
	
	on btn_delete pressed do with undo "Delete Slice Modifiers" on with redraw off 
	(
		for s in selection do
			while (try(s.modifiers[1].name == "Slice")catch(false)) do
			(
				try(deletemodifier s 1)catch()
				if s.modifiers.count == 0 then exit
			)
	)
	
	on btn_slice pressed do with undo "Slices" on with redraw off 
	(
		--ctrl = keyboard.controlpressed
		sel = selection
		
		if rdo_mods.state == 2 then
		(
			for i in sel where not keyboard.escPressed do
			(
				if chk_x.checked then -- x axis
				(
					if chk_gor_Xfuses.checked then
					(
						if chk_gor_side_x.checked then
						(
							for s = i.max.x - spn_gor_Xoffset.value + (spn_gor_Xfuses.value / 2) to i.min.x by -spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepoly i [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
								slicepoly i [s - spn_gor_Xfuses.value, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)	
						)	
						else
						(
							for s = i.min.x + spn_gor_Xoffset.value - (spn_gor_Xfuses.value / 2) to i.max.x by spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepoly i [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
								slicepoly i [s + spn_gor_Xfuses.value, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)							
						)
					)
					else
					(
						if chk_gor_side_x.checked then
						(
							for s = i.max.x - spn_gor_Xoffset.value to i.min.x by -spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepoly i [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)
						)
						else
						(
							for s = i.min.x + spn_gor_Xoffset.value to i.max.x by spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepoly i [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)						
						)
					)

				)
				
				if chk_y.checked then -- y axis
				(
					if chk_gor_Yfuses.checked then
					(
						if chk_gor_side_y.checked then
						(
							for s = i.max.y - spn_gor_Yoffset.value + (spn_gor_Yfuses.value / 2) to i.min.y by -spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
								slicepoly i [i.center.x, s - spn_gor_Yfuses.value, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)	
						)
						else
						(
							for s = i.min.y + spn_gor_Yoffset.value - (spn_gor_Yfuses.value / 2) to i.max.y by spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
								slicepoly i [i.center.x, s + spn_gor_Yfuses.value, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)							
						)
					)
					else
					(
						if chk_gor_side_y.checked then
						(
							for s = i.max.y - spn_gor_Yoffset.value to i.min.y by -spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)
						)
						else
						(
							for s = i.min.y + spn_gor_Yoffset.value to i.max.y by spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)						
						)
					)

				)	
				
				if chk_z.checked then -- z axis 
				(
					if chk_vert_Zfuses.checked then
					(
						if chk_vert_side_Z.checked then
						(
							for s = i.max.z - spn_vert_Zoffset.value + (spn_vert_Zfuses.value / 2) to i.min.z by -spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
								slicepoly i [i.center.x, i.center.y, s - spn_vert_Zfuses.value] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)	
						)
						else	
						(
							for s = i.min.z + spn_vert_Zoffset.value - (spn_vert_Zfuses.value / 2) to i.max.z by spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
								slicepoly i [i.center.x, i.center.y, s + spn_vert_Zfuses.value] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)	
						)	
					)
					else
					(
						if chk_vert_side_Z.checked then
						(
							for s = i.max.z - spn_vert_Zoffset.value to i.min.z by -spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed  do
							(
								slicepoly i [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)
						)
						else
						(
							for s = i.min.z + spn_vert_Zoffset.value to i.max.z by spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed do
							(
								slicepoly i [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)						
						)
					)
				)	
		
			)
		)
		else
		(
			for i in sel where not keyboard.escPressed do
			(
				if chk_x.checked then -- x axis
				(
					if chk_gor_Xfuses.checked then
					(
						if chk_gor_side_x.checked then
						(
							for s = i.max.x - spn_gor_Xoffset.value + (spn_gor_Xfuses.value / 2) to i.min.x by -spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepl i 0 [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
								slicepl i 0 [s - spn_gor_Xfuses.value, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)	
						)	
						else
						(
							for s = i.min.x + spn_gor_Xoffset.value - (spn_gor_Xfuses.value / 2) to i.max.x by spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepl i 0 [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
								slicepl i 0 [s + spn_gor_Xfuses.value, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)							
						)
					)
					else
					(
						if chk_gor_side_x.checked then
						(
							for s = i.max.x - spn_gor_Xoffset.value to i.min.x by -spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepl i 0 [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)
						)
						else
						(
							for s = i.min.x + spn_gor_Xoffset.value to i.max.x by spn_gor_X.value where s <= i.max.x and s >= i.min.x and not keyboard.escPressed do
							(
								slicepl i 0 [s, i.center.y, i.center.z] (eulerangles spn_eu_xx.value spn_eu_yx.value spn_eu_zx.value)
							)						
						)
					)

				)
				
				if chk_y.checked then -- y axis
				(
					if chk_gor_Yfuses.checked then
					(
						if chk_gor_side_y.checked then
						(
							for s = i.max.y - spn_gor_Yoffset.value + (spn_gor_Yfuses.value / 2) to i.min.y by -spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
								slicepl i 0 [i.center.x, s - spn_gor_Yfuses.value, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)	
						)
						else
						(
							for s = i.min.y + spn_gor_Yoffset.value - (spn_gor_Yfuses.value / 2) to i.max.y by spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
								slicepl i 0 [i.center.x, s + spn_gor_Yfuses.value, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)							
						)
					)
					else
					(
						if chk_gor_side_y.checked then
						(
							for s = i.max.y - spn_gor_Yoffset.value to i.min.y by -spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)
						)
						else
						(
							for s = i.min.y + spn_gor_Yoffset.value to i.max.y by spn_gor_Y.value where s <= i.max.y and s >= i.min.y and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, s, i.center.z] (eulerangles spn_eu_xy.value spn_eu_yy.value spn_eu_zy.value)
							)						
						)
					)

				)	
				
				if chk_z.checked then -- z axis 
				(
					if chk_vert_Zfuses.checked then
					(
						if chk_vert_side_Z.checked then
						(
							for s = i.max.z - spn_vert_Zoffset.value + (spn_vert_Zfuses.value / 2) to i.min.z by -spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
								slicepl i 0 [i.center.x, i.center.y, s - spn_vert_Zfuses.value] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)	
						)
						else	
						(
							for s = i.min.z + spn_vert_Zoffset.value - (spn_vert_Zfuses.value / 2) to i.max.z by spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
								slicepl i 0 [i.center.x, i.center.y, s + spn_vert_Zfuses.value] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)	
						)	
					)
					else
					(
						if chk_vert_side_Z.checked then
						(
							for s = i.max.z - spn_vert_Zoffset.value to i.min.z by -spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed  do
							(
								slicepl i 0 [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)
						)
						else
						(
							for s = i.min.z + spn_vert_Zoffset.value to i.max.z by spn_vert_Z.value where s <= i.max.z and s >= i.min.z and not keyboard.escPressed do
							(
								slicepl i 0 [i.center.x, i.center.y, s] (eulerangles spn_eu_xz.value spn_eu_yz.value spn_eu_zz.value)
							)						
						)
					)
				)	
		
			)
		)
	)
	
	on btn_conv pressed do with undo "Convert to poly" on with redraw off
	(
		for i in selection do converttopoly i
	)
	
	on btn_remove pressed do undo "Remove Error-Verts" on with redraw off
	(
		for sel in selection do
		(
			if classof sel == editable_poly then
			(
			/*
			thePoly = selection[1] 
			max modify mode --switch to modify panel  
			modPanel.setCurrentObject selection[1].baseobject --set the base object as current level:
			subObjectLevel = 1 --set sub-object level to vertex level
			numVerts = (polyop.getNumVerts thePoly) --get the total vertex count
			for v = numVerts to 1 by -1 do --loop backwards from the last to the first vertex
			(
				nVerts = (polyop.getEdgesUsingVert thePoly v) as array  --get the edges using the vertex to check the count
				if nVerts.count == 2 do --if only two edges found, then
				(
					edge1verts = (polyop.getVertsUsingEdge thePoly nVerts[1]) as array --get the verts of the first egde
					vector1 = (polyop.getVert thePoly edge1verts[1]) - (polyop.getVert thePoly edge1verts[2])  --calculate the vector defined by the two vertices in the first edge
					edge2verts = (polyop.getVertsUsingEdge thePoly nVerts[2] as array) --get the verts of the second edge
					vector2 = (polyop.getVert thePoly edge2verts[1]) - (polyop.getVert thePoly edge2verts[2]) --calculate the vector defined by the two vertices in the second edge
					angle = acos (dot (normalize vector1) (normalize vector2)) --calculate the angle between the two normalized vectors
					--print angle
					
					if angle >= abs(180-spn_remove.value) or angle <= abs(spn_remove.value) do --???? ???? ????? ?????????, ?????????? ?? ????? ?????, ??????????? ? == 180 ????????, ?? ??? ? ???? ?????? - ??????? ???????; ?????, ???? ??????? ?????????? ???? ? ????? ?? ?????? ?????; ?????, ???? ?????????? ? ???? ??????? ?? ?????? ?????, ????? ???? ????? 0 --if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
					(
						select thePoly.verts[v]--then select the current vertex
						thePoly.EditablePoly.buttonOp #Remove --and hit the remove button
					)
				)--end if
			)--end v loop
			*/
			
				ctrl = keyboard.controlPressed
				alt = keyboard.altPressed
				panel_mode = getCommandPanelTaskMode()
				sub_level = subObjectLevel
				thePoly = sel --selection[1] 
				max create mode 
				numEdges = polyop.getNumEdges thePoly
				numVerts = polyop.getNumVerts thePoly
				Edges_sel = polyop.getEdgeSelection thePoly
				Verts = #{}
				Verts_Err = #{}
				
				--???? ???? ????????? ??????, ?? ?????????? ??? ??? ????????? ??????
				if Edges_sel.isempty then
				(
					Verts = #{1..numVerts} 
				)
				else 
				(
					if querybox ("Selected edges found,\nuse them as borders for searching?\nUsual press NO.") then
						for e in Edges_sel do Verts += polyop.getVertsUsingEdge thePoly #{e}
					else Verts = #{1..numVerts} 
				)
				spn = spn_remove.value
				cou = Verts.count
				--Verts_ = for v in Verts where (polyop.getEdgesUsingVert thePoly v).numberset == 2 collect v
				--for v in Verts where (nEdges = thePoly.GetVertexEdgeCount v) == 2 do 
				for v in Verts where (nEdges = polyop.getEdgesUsingVert thePoly v).numberset == 2 do
				(
					if keyboard.escPressed then exit
					vv = #{} --????? ?????? ?? ?????? ?????
					for e in nEdges do vv += polyop.getVertsUsingEdge thePoly #{e} --???????? ?? ?????? ?????? ? ????? ????? ??????
					vv -= #{v} --????????? ?? ?????? ????? ???????
					p1 = polyop.getVert thePoly v --??????? ????? ? ????? ???????
					pp = for w in vv collect polyop.getVert thePoly w --??????? ??? ??? ????? ?? ?????? ??????
					if p1 != undefined and pp[1] != undefined and pp[2] != undefined then
					(
						local v1 = p1 - pp[1]
						local v2 = p1 - pp[2]
						angle = acos (dot (normalize v1) (normalize v2))		
						if angle >= abs(180 - spn) or angle <= abs(spn) then Verts_Err += #{v} --???? ???? ????? ?????????, ?????????? ?? ????? ?????, ??????????? ? == 180 ????????, ?? ??? ? ???? ?????? - ??????? ???????; ?????, ???? ??????? ?????????? ???? ? ????? ?? ?????? ?????; ?????, ???? ?????????? ? ???? ??????? ?? ?????? ?????, ????? ???? ????? 0 --if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
					)
				)
				if Verts_Err.numberset > 0 then
				(
					polyop.setVertSelection thePoly Verts_Err
					if not alt then thePoly.Remove selLevel:#Vertex flag:1 --polyop.deleteEdges thePoly vert_edges delIsoVerts:true
				)
				setCommandPanelTaskMode panel_mode
				if sub_level != undefined then subObjectLevel = sub_level
			)
			else Messagebox ("Selected object is not an Editable Poly!")
		)
	)	
	
	on btn_remove rightclick do undo "Remove Error-Verts" on with redraw off
	(
		for sel in selection do
		(
			if classof sel == editable_poly then
			(
				ctrl = keyboard.controlPressed
				alt = keyboard.altPressed
				panel_mode = getCommandPanelTaskMode()
				sub_level = subObjectLevel
				if ctrl then -- ??????? ? ?????????? ???? ?????????, ??????? ???????????? ?????
				(
					t = 0.01 --????? ?????????? ?? ???????????? ???
					thePoly = sel --selection[1] 
					max create mode 
					numEdges = polyop.getNumEdges thePoly
					numVerts = polyop.getNumVerts thePoly
					Edges_sel = #{1..numEdges}
					vert_edges = #{}
					top_edges = #{}
					top_vert = 1
					for e in Edges_sel do 
					(
						vv = polyop.getVertsUsingEdge thePoly #{e}
						pp = for v in vv collect polyop.getVert thePoly v
						--print #(pp)
						if abs (pp[1].x - pp[2].x) <= t and abs (pp[1].y - pp[2].y) <= t then 
						(   
							edges = polyop.getEdgesUsingVert thePoly vv
							if edges.numberset < 6 then 
							(
								vv_ = vv as array
								if pp[1].z < pp[2].z then
								(
									top_edges = polyop.getEdgesUsingVert thePoly vv_[2]
									top_vert = vv_[2]
								)
								else
								(
									top_edges = polyop.getEdgesUsingVert thePoly vv_[1]
									top_vert = vv_[1]
								)
								point_top_vert = polyop.getVert thePoly top_vert
								ppp = #{}
								for ee in top_edges do join ppp (polyop.getVertsUsingEdge thePoly #{ee})
								ppp -= vv

								point_plane = for p in ppp collect polyop.getVert thePoly p
								
								if point_top_vert != undefined and point_plane[1] != undefined and point_plane[2] != undefined then 
								(
									vec1 = point_top_vert - [point_plane[1].x, point_plane[1].y, point_top_vert.z]
									vec2 = point_top_vert - [point_plane[2].x, point_plane[2].y, point_top_vert.z]
								
									angle = acos (dot (normalize vec1) (normalize vec2))

									if angle >= abs(180 - spn_remove.value) or angle <= abs(spn_remove.value) then vert_edges += #{e}
								)
							)
						)
					)
					--print #(vert_edges)
					if vert_edges.numberset > 0 then
					(		
						polyop.setEdgeSelection thePoly vert_edges
						if not alt then thePoly.Remove selLevel:#Edge flag:1 --polyop.deleteEdges thePoly vert_edges delIsoVerts:true
					)
				)
				else --???????? ?????? ?? ???????? ?? ?????????????? ?????????
				(
					thePoly = sel --selection[1] 
					max create mode 
					numEdges = polyop.getNumEdges thePoly
					numVerts = polyop.getNumVerts thePoly
					Edges_sel = polyop.getEdgeSelection thePoly
					Verts = #{}
					Verts_Err = #{}
					if Edges_sel.numberset == 0 then
					(
						Verts = #{1..numVerts} 
					)
					else 
					(
						if querybox ("Selected edges found,\nuse them as borders for searching?") then
							for e in Edges_sel do join Verts (polyop.getVertsUsingEdge thePoly #{e})
						else Verts = #{1..numVerts} 
					)
					
					for v in Verts do
					(
						nEdges = polyop.getEdgesUsingVert thePoly v 
						if nEdges.numberset == 2 then 
						(
							vv = #{} --????? ?????? ?? ?????? ?????
							for e in nEdges do vv += polyop.getVertsUsingEdge thePoly #{e}
							vv -= #{v} --????????? ?? ?????? ????? ???????
							p1 = polyop.getVert thePoly v --??????? ????? ? ????? ???????
							pp = for w in vv collect polyop.getVert thePoly w --??????? ??? ??? ????? ?? ?????? ??????
							--print #(pp)
							if p1 != undefined and pp[1] != undefined and pp[2] != undefined then
							(
								vec1 = p1 - [pp[1].x, pp[1].y, p1.z]
								vec2 = p1 - [pp[2].x, pp[2].y, p1.z]
								angle = acos (dot (normalize vec1) (normalize vec2))			
								if angle >= abs(180 - spn_remove.value) or angle <= abs(spn_remove.value) then Verts_Err += #{v} --???? ???? ????? ?????????, ?????????? ?? ????? ?????, ??????????? ? == 180 ????????, ?? ??? ? ???? ?????? - ??????? ???????; ?????, ???? ??????? ?????????? ???? ? ????? ?? ?????? ?????; ?????, ???? ?????????? ? ???? ??????? ?? ?????? ?????, ????? ???? ????? 0 --if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
							)
						)
					)
					if Verts_Err.numberset > 0 then
					(
						polyop.setVertSelection thePoly Verts_Err
						if not alt then thePoly.Remove selLevel:#Vertex flag:1 --polyop.deleteEdges thePoly vert_edges delIsoVerts:true
					)
				)
				setCommandPanelTaskMode panel_mode
				if sub_level != undefined then subObjectLevel = sub_level
			)
			else Messagebox ("Selected object is not an Editable Poly!")
		)
	)	
)

rollout UDIMs "UDIMs operations" autoLayoutOnResize:true
(
	group "Make Multi-Material from UDIMs and its textures"
	(
		edittext edt_material_object_number "Object" text:"001" fieldwidth:50 across:4 align:#left tooltip:"??????? ????? ??????? 001,002,003 ??? Ground | Object 001,002,003 or Ground"
		dropdownlist ddl_material_object_number "" items:#("","001","002","003","004","005","Ground","GroundEl","Flora") selection:2 width:75 offset:[25,0] tooltip:"??????? ??????? 001,002,003 ??? Ground | Object 001,002,003 or Ground"
 		edittext edt_material_mat_number "" text:"1" fieldwidth:20 offset:[35,0] tooltip:"?????? ? ?????????????, ????? ????????? ? ???????? ???????? 1,2,3,..,7 | Rare, Material number in texture name 1,2,3,..,7"
		edittext edt_multimat_count "Count" text:"" fieldwidth:30 readonly:true align:#right offset:[0,0] tooltip:"????? ????????? ?????????? ?? ????? ? ??????? ????? | The number of found by mask files in the current folder" --style_sunkenedge:true 	

		button btn_rename "Rename Textures\Objs&Mats" across:2 align:#left tooltip:"?????????????\nLMB: ????? PNG ? ??????? ????????\nCTRL+LMB: ??? ???? ??????\nRMB: ????????? ???????\nRMB+CTRL: ??? ????????? ?????\nRMB+ALT: ???? ? ?????????? ????????? ???????? | Rename\nLMB: PNG files in current directory\nCTRL+LMB: All type of files\nRMB: Selected Objects\nRMB+CTRL: All scene Materials\nRMB+ALT: Materials Paths of selected objects"
		button btn_multimat_read "Check files" align:#right offset:[0,0] tooltip:"????????? ????? ?????? ? ??????? ???????? ? ?????????? ?? ?????????? | Check filenames of files in current directory and count quantity"
			
		edittext edt_tex_find "To Find" text:"SM_" across:2 align:#left offset:[-5,0] tooltip:"????? | To Find"
		edittext edt_tex_rename "To Rename" text:"T_" align:#right offset:[5,0] tooltip:"???????? | To Rename"

		radiobuttons rdo_type_mat labels: #("Standart","Physical") default:1 columns:2 rows:1 offset:[0,0] across:3 align:#left tooltip:"Standart Material (Legacy) ?????? ???????? ??? Unreal Engine\nPhysical Material - ??? Autodesk FBX Viewer | Standart Material (Legacy) more suitable for Unreal Engine\nPhysical Material - for Autodesk FBX Viewer"
		button btn_singlemat "Material LP" width:65 offset:[30,0] tooltip:"LMB: ??????? ???????? ??? Lowpoly ?????? ?? ?????? ?? ?????\nCTRL+LMB: ???????? ????? ?? ???????? ?????????? ??????? | LMB: Make Material for Lowpoly model from files by filter mask\nCTRL+LMB: get mask from selected object name"
		button btn_multimat "Multimat HP" width:65 offset:[0,0] align:#right tooltip: "LMB: ??????? Multimat ??? Highpoly ?????? ?? ?????? ?? ?????\nCTRL+LMB: ???????? ????? ?? ????? ?????????? ??????? | LMB: Make Multimat for Highpoly model from files by filter mask\nCTRL+LMB: get mask from selected object name"
	)	
	group "Path"
	(	
		button btn_get_multimat_path "Get Current Path" across:3 align:#left offset:[0,0] tooltip:"???????? ???? ??????????? ????? ????? ? ???????? ????????? ???????? | Get path from currently saved scene folder and add specified subfolder"
		button btn_get_multimat_folder "Select Path" offset:[0,0] tooltip:"??????? ???? ? ?????????? ???? ???????????? ?????? ????? | Select path via standart selection folder dialog"
		button btn_open_multimat_path "Show Folder" offset:[0,0] align:#right tooltip: "??????? ??????? ???? ? ???????? ????? ? ???????? ???????? | Open current path in browser and show folder"

		radiobuttons rdo_path labels: #("Maps\\","Images\\","Custom") default:1 columns:3 rows:1 across:2 align:#left offset:[0,-1]
		edittext edt_path_end "" text:("") fieldWidth:80 align:#right offset:[5,0]	

		edittext edt_multimat_path "" text:(maxFilePath + "Maps\\") align:#left bold:true fieldWidth:260 --text:"E:\\Projects\\Maxim3\\Images\\"
		
		label lbl_multimat_path "Search mask:" width:260 align:#left style_sunkenedge:false 	
	)	

	group "Textures maker for UDIMs"
	(	
		radiobuttons rdo_tex labels: #("256","512","1024","2048","4096") default:5 columns:5 rows:1 align:#left tooltip:"?????? ????????, ??????? ????? ????????????? | Dimension of texture to be generated"
		button btn_name_from_sel "Get Name" width:55 offset:[35,0] align:#left across:3 tooltip:"??????????? ??? ???????? ?????????? ??????? | Copy name of current selected object"
		button btn_name_to_sel "Set Name" width:55 offset:[-10,0] tooltip:"???????? ???????? ???????? ?????????? ??????? | Paste name of current selected object"
		spinner spn_tex_udim "UDIM number" range:[1001, 1100, 1001] type:#integer fieldWidth:35 offset:[0,0] align:#right tooltip:"UDIM - ????? ????????, ??????? ????? ?????????????, ?????? ??????????? ? ???????? ???????? | UDIM number of texture to be generated, index adds to name texture"
		
		edittext edt_object_name "Object " text:"SM_GolevskiyPrd_3_Ground" labelOnTop:true bold:true width:260 fieldWidth:260 readonly:false offset:[0,-20] tooltip:"???, ?????? ?? ???????? ?????????? ??????? | Name taken from selected object name"

		colorpicker color_diffuse "" color:[200,200,200] alpha:false modal:false title: "Diffuse color" across:4 offset:[50,0] align:#left tooltip:"???? ??????? ??? ???????? Diffuse | Diffuse color"
		button btn_color_diffuse_ral "RAL Select" offset:[40,0] tooltip:"??????? ?????????? ???? ?????? ????? RAL | Create RAL color selector Dialog"		
		button btn_make_tex_diffuse "Make" offset:[40,0] tooltip:"LMB: ??????? ???????? ? ??????? ????? ???????\nRMB: ?????????? ??????????? ???????? | LMB: Make texture with fill color\nRMB: Display saved texture"
		button btn_open_tex_diffuse "Set" align:#right offset:[0,0] tooltip:"LMB: ??????? ???????? ???????, ????? ???????, ????????????? ? ???????? ?????? ????????\nRMB: ??????????? ???? ? ????? | LMB: Open file browser to select, rename and resize texture\nRMB: View file in folder"
		edittext edt_tex_diffuse_name "Diffuse " text:"T_GolevskiyPrd_3_Ground_Diffuse_1.1001.png" labelOnTop:true width:260 fieldWidth:260 readonly:true offset:[0,-20] tooltip:"???????? ???????? Diffuse, ??????????????? ?? ???????? ??????? | Diffuse texture name generated from object name"

		colorpicker color_erm "" color:[0,255,0] alpha:false modal:false title:"R-emission(0 nolight);G-rougness(0 gloss,255 matt);B-metallness(0 no reflect,255 mirror)" across:3 offset:[50,0] align:#left tooltip:"???? ??????? ??? ???????? ERM, R-????????? (0 ??? ?????); G-????????????? (0 ?????????, 255 ???????); B-????????????? (0 ??? ?????????, 255 ???????) | R-emission (0 no light); G-rougness (0 gloss, 255 matt); B-metallness (0 no reflect, 255 mirror)"
		button btn_make_tex_erm "Make" offset:[75,0] tooltip:"LMB: ??????? ???????? ? ??????? ????? ???????\nRMB: ?????????? ??????????? ???????? | LMB: Make texture with fill color\nRMB: Display saved texture"
		button btn_open_tex_erm "Set" align:#right tooltip:"LMB: ??????? ???????? ???????, ????? ???????, ????????????? ? ???????? ?????? ????????\nRMB: ??????????? ???? ? ????? | LMB: Open file browser to select, rename and resize texture\nRMB: View file in folder"
		edittext edt_tex_erm_name "ERM" text:"T_GolevskiyPrd_3_Ground_ERM_1.1001.png" labelOnTop:true width:260 fieldWidth:260 readonly:true offset:[0,-20] tooltip:"???????? ???????? ERM, ??????????????? ?? ?????? ????? ??????? | ERM texture name generated from object name"
	
		colorpicker color_normal "" color:[128,128,255] alpha:false modal:false title:"Normal color, neutral:[128,128,255]" across:3 offset:[50,0] align:#left tooltip:"???? ??????? ??? ???????? Normal, ???????????: [128,128,255] | Normal color, neutral:[128,128,255]"
		button btn_make_tex_normal "Make" offset:[75,0] tooltip:"LMB: ??????? ???????? ? ??????? ????? ???????\nRMB: ?????????? ??????????? ???????? | LMB: Make texture with fill color\nRMB: Display saved texture"
		button btn_open_tex_normal "Set" align:#right tooltip:"LMB: ??????? ???????? ???????, ????? ???????, ????????????? ? ???????? ?????? ????????\nRMB: ??????????? ???? ? ????? | LMB: Open file browser to select, rename and resize texture\nRMB: View file in folder"
		edittext edt_tex_normal_name "Normal" text:"T_GolevskiyPrd_3_Ground_Normal_1.1001.png" labelOnTop:true width:260 fieldWidth:260 readonly:true offset:[0,-20] tooltip:"???????? ???????? Normal, ??????????????? ?? ?????? ????? ??????? | Normal texture name generated from object name"
		--button btn_make_all_tex "Make All" align:#right	
		
		edittext edt_object_addr "Adress " text:"" labelOnTop:true width:260 fieldWidth:260 readonly:false offset:[0,0] tooltip:""
		button btn_check_copy "Copy" across:4 align:#left tooltip:"??????????? ??? ? ????? ?????? ?? ???????? ?????? | Copy name to Clipboard from adress-line"
		button btn_check_paste "Paste" offset:[-37,0] tooltip:"???????? ??? ?? ?????? ?????? ? ???????? ?????? | Paste name from Clipboard to adress-line"
		button btn_check_names "Check Adress" offset:[-40,0] tooltip:"????????? ????? ?? ???????????? ???????? ? ???????? ??????, ???????????? ? ??????????? | Check adress with rules and show errors and recomendations"
		button btn_Streets_List "Open Streets List" align:#right tooltip:"??????? ????? ?????? ?? ??????? ?????????? ???? ??? ?????? ????? ??? ???????? ?? ?????? | Create new dialog with Moscow streets list to select from"
	)
	group "Tables"
	(	
		button btn_multimat_table "Browser Tex" across:3 align:#left tooltip:"??????? ?????????? ???? ? ?????? ??????? ? ????????? ??? ?????? ?????? ? ?????????? ? UDIM | Create Dialog to findout mistakes with textures and UDIMs"
		button btn_alpha_remove "Format & Alpha Tex" offset:[5,0] tooltip:"??????? ?????????? ???? ?? ??????? ??????? ? ?? ??????????? ??? ?????? ?????? ? ?????-??????? ? ???????? ??????? ? ????? | Create Dialog to findout mistakes with alpha-channel and bit-depth of textures"
		button btn_count_colors "Colors Tex" align:#right tooltip:"??????? ?????????? ???? ?? ??????? ??????? ? ?? ??????????? ??? ?????? ?????? ? ??????????? ?????? ? ????????? | Create Dialog to findout mistakes with colors quantity of textures"
	
		button btn_count_texel "Texels Density UDIMs" width:150 across:2 align:#left offset:[0,0] tooltip:"??????? ?????????? ???? ??? ?????? ? ??????????? ???????? ?????????? ??????? | Create Dialog to work with texels densities of selected object"
		button btn_count_area "Areas Poly" width:110 align:#right tooltip:"??????? ?????????? ???? ??? ?????? ??? ???????? ????????? ?????????? ??????? | Create Dialog to work with polygons errors of selected object"
	)
	group "Materials, IDs, Textures and UDIMs"
	(
		button btn_ids_as_udims "UDIMs To IDs" across:3 align:#left offset:[0,0] tooltip:"LMB: ?????????? ID ??? ???? ???????? ? ???????????? ? ??????? UDIMs, ??? ?????????? ??? ???????? Multimat\nLMB+CTRL: ?????? ????? | Set IDs to all islands according to UDIMs number, need for Multimat\nLMB+CTRL: Alternate method"
		button btn_udims_as_ids "IDs to UDIMs" offset:[0,0] tooltip:"?????????? ??? ??????? ?? UDIMS ???????? ?? ID | Fits all islands in UDIMS by IDs"
		button btn_render_mat "Render Material" offset:[0,0] align:#right tooltip:"LMB: ??????????? ??? VIZ ????????? Multimaterial ?????????? ??????? ? ???????? ???????? ??????? UDIM ? ????????? ?? ???????? ????\n\nRMB: ??????????? VIZ ???????? ?? ?????????? ?????????? ???????, ????????????? ? ????????? ???????? ?? ???????? ???? | LMB: Render VIZ materials of selected object to textures with UDIM numbers, to current path\n\nRMB: Copy textures from VIZ materials of selected object and rename textures, to current path"

		button btn_Condense "Condense" offset:[0,0] across:4 align:#left tooltip:"LMB: ????????? Multimaterial ?? ????? ???????????? ? ??????? ID, ??????? ????? ?????? ? ????????. ????? ????? ?????? ?????? IDs to UDIMS | LMB: Condense MultiMaterial and Object's IDs, makes new object and material. After press IDs to UDIMS"
		button btn_id_roll "IDs Roll" offset:[-5,0] tooltip:"LMB: ???????? ID ? ??????? ?? ????????? ?????, ?????? ????????? ?????????? ?????? ID ??? ????????? ?????????? ? ???????? | LMB: Rolls IDs of object to specified number, usually need to free first ID for Render To Texture Procedure"
		spinner spn_id_roll "ID offset" range:[-100, 100, 1] scale:1 type:#integer fieldwidth:25 width:30 offset:[50,0] tooltip:""
		button btn_editor " Editor... " align:#right tooltip:"LMB: ??????? ?????????? ???? ??? ???????? ??????? Opacity ? ERM\nRMB: ??????? ?????????? ???? ??? ?????????????? ??????? ??? ????????? UVW ? ?????????? ??????? | LMB: Create Dialog for creation Opacity and ERM textures\nRMB: Create Dialog to Edit textures and UVWs"
	)		
	group "UDIMs Unwrap HighPoly"
	(
		button btn_bricks_unwrap_pressed "" width:1 height:1 across:5 align:#left tooltip:""
		button btn_bricks_unwrap_rightclick "" width:1 height:1 offset:[0,2] align:#left tooltip:""
		button btn_bricks_unwrap "Unwrap Tiles" width:100 offset:[-104,0] align:#left tooltip:"LMB: ??????? ??? ????? ????????? ? ???? UDIM, ???????? c ?????????? ????????? ?????????, ????? ???????????? ?????? ?????? ??? ????????? ?????????????\nRMB: ??????? ????????? ?????????? ???????, ????????? ??????? ????????? ?????? | LMB: Unwrap Tiles to one UDIM, may work with different methods or fully automatical\nRMB: Make packing with speed method, use current FACES selection"
		button btn_poly_to_edges_selector "Faces to Edges" offset:[-38,0] width:80 tooltip:"LMB: ??????? ?????????? FACES ?? ???????????? EDGES ?? EDITABLE POLY ? ????? ??????????? UVW UNWRAP, ??????? ????????? ??? ???????? ????? ?? ?????????? ???????\nLMB+CTRL: ??????? ?????????? FACES ?? EDGES ? ????????????????? ???????? | LMB: Transfer selected FACES to parallel EDGES from EDITABLE POLY to new UVW UNWRAP modifier, need for breaking edges for texels islands.\nLMB+CTRL: Transfer selected FACES to EDGES with triangulated object"
		button btn_bricks_flatten "W Flatten UVW" offset:[0,0] width:80 align:#right tooltip:"?????? ??? ??????? ????????? ? ???? ?? ??? W | Flatten UVW texels to zero in W-Axiz"

		--spinner spn_bricks_unwrap_udim "UDIM" range:[1001, 1100, 1001] offset:[0,0] enabled:false type:#integer width:30 fieldWidth:30 align:#right tooltip:"Move result to selected tile"
	
		button btn_bricks_unwrap_new "Unwrap Landscape" width:100 across:3 align:#left tooltip:"LMB: ??????? ??? ????? ????????? ? ???? UDIM, ???????? ? ????????? ?????????\nLMB+CTRL: ??????? ????????? ? ?????????? ????? ? ????????????????? ??????\nRMB: ??????? ????????? ?????????? ???????, ????????? ??????? ????????? ?????\n??????? EDGES ????? ???-? FACES ? ??????? ?????? | LMB: Make Landscape Unwrap packing to UDIM with selection of parallel edges\nLMB+CTRL: Make packing with EDGES selection in triangulated model\nRMB: Make packing with speed method, use current edges selection\nSelect EDGES or-and FACES and press button"
		button btn_edges_selector "Select Edges" offset:[10,0] width:80 tooltip:"LMB: ??????? ???????????? ????? ? EDITABLE POLY ???????, ????? ????? ????????? ???????? ????? Slice\nRMB: ??????? '??????????' ????? ? ????????????????? EDITABLE POLY ??????? | LMB: Select parallel edges in EDITABLE POLY object, need if lost selection after Slice modifiers\nRMB: Select 'good' edges in triangulated EDITABLE POLY object"
		button btn_transfer_edges "Transfer Edges" offset:[0,0] width:80 align:#right tooltip:"???????? ????????? ????? ?? EDITABLE POLY ? ????? ??????????? ????????? UVW UNWRAP, ?????????? ??? ?????????? ????? ? ?????????? ???????? | Transfer selected EDGES from EDITABLE POLY to new UVW UNWRAP modifier, need for breaking edges for texels islands"

		button btn_bricks_unwrap_get_num "Get Texel" width:60 offset:[0,0] enabled:false align:#left across:3 tooltip:"??????? ???? ??????? ?? ?????????, ???? ??????? ????? ???????? ??? ???????? ?????? ????????, ?? ?????? ???? ???? ? ????, ??? ????? ?????? | Get single texel from selection, this texel will be main to tile other texels, it should be higher and wider than anyone"
		spinner spn_bricks_unwrap_num "Num" range:[1, 10000000, 1] offset:[-35,2] type:#integer fieldWidth:40 enabled:false tooltip:"????????? ??????? ??? ??????? | To be selected texel for tiling"
		radiobuttons rdo_unwrap_method labels: #("Centers","ul","ur","Integers","dl","dr") offsets:#([0,0], [0,0], [-30,0], [0,0], [0,0], [-30,0]) default:5 columns:3 rows:2 offset:[65,0] align:#right tooltip:"???????????? ??? ??????????? ???? ???????? ul: ????-?????, ur: ????-??????, dl: ????-?????, dr: ????-??????\nCenter: ?????????? ?????? ???????? ? ??????? UDIM\nIntegers: ?????????? ??????????? ????????? ???????? ? ??????? UDIM | Corners, ul: up-left, ur: up-right, dl: down-left, dr: down-right.\nTiles using corners by maximum dimension of texel island, usually produce better results of tiling small parts\nCenters: Tiles by moving via centers of islands to centers of UDIMs\nIntegers: Tiles by moving via centers of islands by integer parts in UDIMs"

		button btn_bricks_unwrap_get_island "Get Island" width:60 offset:[0,-10] enabled:false align:#left across:4 tooltip:"??????? ?????? ???????? ?? ??????????, ???? ?????? ????? ???????? ??? ??????? ?????? ????????, ?? ?????? ???? ???? ? ???? ???? ????????? | Get texels island from selection, this island will be main to tile other texels, it should be higher and wider than anyone"
		label lbl_bricks_unwrap_get_island "#{}" width:70 align:#left height:16 offset:[0,-8] style_sunkenedge:true enabled:false tooltip:"????????? ??????? EDITABLE POLY ??? ??????? | To be selected texels or polys for tiling"
		checkbox chk_bricks_unwrap_treshold "Treshold" checked:true offset:[25,0] tooltip:"???????????? ????? ??? ?????????? ???????? | Use treshhold for placing texels"
		spinner spn_bricks_unwrap_treshold "" range:[-1, 1, 0.05] align:#right offset:[0,0] type:#float fieldWidth:30 tooltip:""

		checkbox chk_unwrap_texel_or_poly "Find maxi texel / island" checked:true align:#left across:3 offset:[0,0] tooltip:"?????? ??????? (??? ??????) ? ????????????? ?????????, ?????????? ??? ??????????? ???????? | Find texel (or texels island) with maximum dimensions, need to findout Scale"
		checkbox chk_bricks_unwrap_unfold "Unfold" checked:false offset:[70,0] tooltip:"??????? ????? ????????? ??? ???? ???????? ?????? ????????????? ???????????? ????????? | Use new UNFOLD to all texels instead of using existing mapping"
		checkbox chk_bricks_unwrap_pack "Pack" checked:false offset:[0,0] align:#right tooltip:"??????? ??????? ???????? ???????\?????? ??? ????? ????? ? UDIM, ??? ????????? ?????? ???????\???????, ?? ????????? ????????? ???????? ? ???????? | Set main texel\island to UDIM as much close as possible, this will pack closer other texels\islands, but destroy initial offset in texture"

		checkbox chk_bricks_unwrap_scale "Scale Texels" checked:false align:#left across:4 offset:[0,0] tooltip:"???????????? ??????????????? ????????, ????? ??????? ?? ? UDIM ???????; ?????????? ????????? ???????? ? ???????? | Use scale texels to fit in UDIMs,\ndestroys initial offset in texture"
		checkbox chk_bricks_unwrap_width "Width" checked:true offset:[25,0] tooltip:"???????????? ?????? ??? ????????? ???????? ???????? | Use width to rescale texels to fit in UDIMs"
		checkbox chk_bricks_unwrap_height "Height" checked:true offset:[20,0] tooltip:"???????????? ?????? ??? ????????? ???????? ???????? | Use height to rescale texels to fit in UDIMs"
		checkbox chk_bricks_unwrap_redo "Move" checked:true align:#right offset:[0,0] tooltip:"??????????? ? ????? ??????????? ??????? ? ?????? UDIM | After all job done, try to move missed texels to first UDIM"
	
		checkbox chk_bricks_unwrap_cut "UDIM UV Slicer" checked:false align:#left across:4 offset:[0,0] tooltip:"?????????????? ??????? ??????? ?? ????? ??? ??????? UDIM, ????? ?1. ?????????? POLY ?????, ????? ??????? ?????, friedrich@3d-io.com\n?????????, ??? ? ??? ???? UV-??????? ???????? ????? ?????? UDIM | Auto Slice object for every UDIM Grid of UV texels, Method #1: uses Poly Slices, by Friedrich Hanisch, friedrich@3d-io.com\nBe sure you have UV islands larger than one UDIM"
		checkbox chk_bricks_unwrap_cut2 "#2" checked:false offset:[40,0] tooltip:"?????????????? ??????? ??????? ?? ????? ??? ??????? UDIM, ????? ?2. ?????????, ??? ? ??? ??? ????????? ? ?????????? W ? UVW, ?? ?????? ?????? ????? W ??????????. ?????????, ??? ? ??? ???? UV-??????? ???????? ????? ?????? UDIM. ?????????? ??????? ?????? ??????? ? ????????? ?????? ?????? | Auto Slice object for every UDIM Grid of UV texels, Method #2\nBe sure, you do not have unwrap in W coordinate of UVW, its do not cut along W.\nBe sure you have UV islands larger than one UDIM\nYou should after Remove bad Verts and do Vertex Weld"
		checkbox chk_bricks_unwrap_rescale "Density" checked:false offset:[15,0] tooltip:"???????? ??????? ????????? ???????? ?? ??????? ????????? ??????? (??. ????), ????????? ????????? ???????? ? ???????? | Also Rescale selected texels to Target Texels Density (see lower), destroys initial offset in texture"
		checkbox chk_bricks_unwrap_undo "Undo Off" checked:false align:#right offset:[10,0] tooltip:"????????? ????? ?????? ?? ????? ?????? ??? ???????? ??????. ????? ??????? ??????????? Unwrap UVW, ????? ???????? ????????? | Turn Undo buffer Off during operation for memory saving. Delete Unwrap UVW modifier to undo result"

		button btn_Udim_Rescale "ReScale Density" width:80 across:3 align:#left tooltip:"LMB: ??????????????? ?? ??????? ????????? ????????: ????? ??????? ???????? ?? ???? ?????????? ?????????? ???????? ? ???????????????? UV-????????? ?? ??????? ????????? ????????\n????????? ??. ? ???? Texels Density UDIMs | LMB: Rescale UV unwrap to target texels density: take a middle value of all densities of selection and rescales UV unwrap to target texels density\nSee more in dialog: Texels Density UDIMs"
		dropdownlist ddl_texture_Rescale_size "" items:#("256", "512", "1024", "2048", "4096") selection:5 width:52 fieldWidth:52 offset:[-5,0] tooltip:"??????? ????????:\n256*256 ????????,\n512*512 ????????,\n1024*1024 ????????,\n?????????? ????????: 2048*2048 ????????,\n?????????? ????????: 4096*4096 ???????? | Texture dimensions:\n256*256 pixels,\n512*512 pixels,\n1024*1024 pixels,\nvalid: 2048*2048 pixels,\nvalid: 4096*4096 pixels" 
		spinner spn_Udim_Rescale_Density "Target density" range:[0.001, 100000.0, 1380.0] scale:0.1 type:#float offset:[0,0] fieldWidth:45 width:60 align:#right tooltip:"??????? ???????? ????????? ???????? [512..1706] | Target texels density value [512..1706]"

		button btn_unwrap_windows "Unwrap Windows" width:100 across:3 align:#left offset:[0,10] tooltip:"?????????? ??? ???? ? ???? UDIM ? ?????????? ?????????? ????????\n?????? ????????? ??? ?????? ???????? ?? ???????????? ??? | Unwrap all windows to single UDIM with equal texel density\nBetter result with manual rotation to parallel axis"
		spinner spn_unwrap_windows "Sash" range:[0.001, 1000.0, 1.0] scale:0.1 type:#float fieldWidth:35 width:110 offset:[-25,10] tooltip:"?????????? ??? ?????? ??????? ??????, ?????? ????? ?????????? ??????????, ?????????????? ??? ??????? | Distance range to search windows glasses, near distance treats as single cluster"
		spinner spn_unwrap_windows_rotation_acc "Accuracy" range:[0.0, 360.0, 1.0] scale:0.1 type:#float fieldWidth:35 width:110 align:#right offset:[0,10] tooltip:"???????? ???? ???????? | Accuracy of rotation step"

		checkbox chk_unwrap_windows_rotation "Rotate UV" checked:true offset:[0,0] across:3 align:#left tooltip:"????????? UVW ????? ? ???? | Rotate UVW map to window"
		checkbox chk_unwrap_windows_align "Align" checked:false offset:[40,0] tooltip:"????????? UVW ????? ? ???? | Align UVW map to window"
		checkbox chk_unwrap_windows_flatten "Flatten" checked:true offset:[0,0] align:#right tooltip:"???????? ????????? UVW ?? ??? W | Flatten UVW in W-axis"
	)
	group "UDIMs Unwrap LowPoly"
	(	
		dropdownlist ddl_size_atlas "" items: #("256","512","1024","2048","4096") selection:4 width:60 fieldWidth:60 across:3 tooltip:"?????? ???????? ??? ??????????????????? ??????: ?????????? ??????? - 256, 512, 1024, 2048, ? 4096 ?????? ??? ???????????? | Texture size for lowpoly atlas:\ngood - 256, 512, 1024, 2048\nfor testing only - 4096"
		button btn_unwrap_lowpoly_from_material "Unwrap to Atlas" width:90 align:#left offset:[-20,0] tooltip:"LMB: ??????? ??? ???????? ? ????????? ????????? ???????? ? ????? ????? ???. ?????????????? ????? ?????? Multisub HP\nLMB+CTRL: ??????? ????????\nLMB+ALT: ?????????????? ? ???????? ????????? [10..40]\nLMB+Shift: ?????????? Lancos | LMB: Collect all textures from selected objects and all UDIMs to 5 Lowpoly Atlases\nMay press Render Material or Multisub HP before\nLMB+CTRL: Large 256x256 textures\nLMB+ALT: Fit densites range [10..40]\nLMB+Shift: Use Lancos resize filter"
		--button btn_MakePlanes "Make Planes" width:70 across:2 offset:[0,0] tooltip:"Make lowpoly planes around selected plants objects"
		button btn_MakeLowpolyPlant "Make LowPoly Tree" width:100 align:#right tooltip:"??????? ?????????????????? ?????? ?? ???????????????????? ?????? | Make lowpoly tree from highpoly tree"		
	)		
	group "UDIMs Transforms"
	(	
		button btn_UdimLeft "UDIM <" width:48 across:6 align:#left tooltip:"??????????? ?????????? ??????? ? ????? UDIM | Move selected texels to LEFT UDIM"
		button btn_UdimRight "UDIM >" width:48 offset:[11,0] tooltip:"??????????? ?????????? ??????? ? ?????? UDIM | Move selected texels to RIGHT UDIM"
		button btn_UdimUp "UDIM ^" width:48 offset:[16,0] tooltip:"??????????? ?????????? ??????? ? ??????? UDIM | Move selected texels to UP UDIM"
		button btn_UdimDown "UDIM V" width:48 offset:[20,0] tooltip:"??????????? ?????????? ??????? ? ?????? UDIM | Move selected texels to DOWN UDIM"
		button btn_UdimRotate "Rot" width:20 offset:[15,0] tooltip:"LMB: ????????? ?????? ? ????????????? ??? ??????????? ?? ?????? ???????? ????\nLMB+CTRL: ?? ??????? ?? ????? ????, ??????? ??? ????????????\nLMB+ALT: ????????????? ????????????? | LMB: Rotate island and orient it vertical by longest edge\nLMB+CTRL: by second longest edge, useful if triangulated\nLMB+ALT: orient horizontal"
		button btn_UdimMove "Move" width:40 offset:[0,0] align:#right tooltip:"LMB: ??????????? ?????????? ??????? ? ????? ??????? UDIM\nLMB+ALT: ??????????? ?????????? ??????? ?????????\nLMB+CTRL: ??????????? ?????????? ??????? ?? ??????????? ? ???????? | LMB: Move selected texels to first's UDIM center\nLMB+ALT: Move selected texels by islands\nLMB+CTRL: Move selected texels individualy with break"
		button btn_UdimScale "Scale To" offset:[0,0] across:4 align:#left tooltip:"LMB: ????? ??????? ???????????? ??????? UDIM ?? ?????? ???????? ??????????? ???????, ???????????????? ????????? ???????\nLMB+CTRL: ?????????????? ????????? ??????? ??? ????? ??????? ??????\nLMB+ALT: ?????????????? ????????? ???????, ????? ??? ??????????????? ???? ?????\nLMB+CTRL+ALT: ?????????????? ??? ????????? ??????? ?? ??????? ?????? ???????? ??????? | LMB: Find Scale relative to UDIM size from largest texel of selection, Scale selected texels.\nLMB+CTRL: Scale selected as largest island\nLMB+ALT: Scale selected individual by islands to fit each other\nLMB+CTRL+ALT: Scale all selected to size of largest island"
		spinner spn_bricks_unwrap_sc "" range:[0.0, 100.0, 0.95] offset:[-15,0] type:#float fieldWidth:40 width:40 tooltip:"?????????????? UDIM ?? ???????? [0-1] | Scale to UDIM value [0-1]"
		button btn_UdimFit "Fit To" offset:[-30,0] tooltip:"LMB: ???????? ????????? ??????? ? ?????? UDIM\nLMB+CTRL: ???????? ? ????????? UDIM ? ?????? ?????????\nLMB+ALT: ???????? ??? ???????? ? ??????? ID ?????????\n???????? Texture\Material, ????? ????? ????????? ???????? ??? ????????\n\nRMB: ????????? ???????? ? UV ??????? | LMB: Fit selected texels to first UDIM\nLMB+CTRL: Fit to UDIM with center of selection\nLMB+ALT: Fits all textures in current Mat ID\n\nCheck Texture\Material to also FIT Texture or Material\n\nRMB: Fit texture to UV island"
		checkbox chk_UdimFit "Texture\Material" checked:false align:#right offset:[0,0] tooltip:"????? ????????, ????? ???????? ??????? ???????? ??? ???? ??????? ? ????????? ??? ????? UDIM | After FITing Texels to UDIM, also rescale Texture\All Textures in Material for this UDIM"
	)
	
	on UDIMs open do
	(
		btn_name_from_sel.pressed()
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png"
		
		for i in UDIMs.controls where ValidTypeControl i /*where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_UDIMs.ini") i.name "UDIMs" 1)

	)
	
	on chk_bricks_unwrap_cut changed arg do
	(
		if arg then chk_bricks_unwrap_cut2.checked = false
	)		
	
	on chk_bricks_unwrap_cut2 changed arg do
	(
		if arg then chk_bricks_unwrap_cut.checked = false
	)		
	
	on edt_object_name changed arg do
	(
		edt_tex_diffuse_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_Diffuse_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_diffuse_name.text = (substitutestring edt_tex_diffuse_name.text "_Main" "")
		edt_tex_normal_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_Normal_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_normal_name.text = (substitutestring edt_tex_normal_name.text "_Main" "")
		edt_tex_erm_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_ERM_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_erm_name.text = (substitutestring edt_tex_erm_name.text "_Main" "")
			
		edt_object_addr.text = (substitutestring edt_object_name.text "SM_" "")
		tt = filterstring edt_object_name.text "_"
		if tt.count > 1 then
		(
			edt_object_addr.text = ""
			for t = 1 to tt.count do 
			(
				if tt[t] == "SM" or tt[t] == "M" or tt[t] == "T" then continue
				if (for t1 = 1 to tt.count where tt[t1] == "77" collect tt[t1]).count == 0  and tt[t] == "001" or tt[t] == "002" or tt[t] == "003" or tt[t] == "004" or tt[t] == "005" then continue	
				if tt[t] == "Main" then continue
				if tt[t] == "Ground" then continue
				if tt[t] == "GroundEl" then continue						
				if tt[t] == "Flora" then continue
				if tt[t] == "Glass" or tt[t] == "MainGlass" or tt[t] == "GroundGlass" or tt[t] == "GroundElGlass" then continue	
				if edt_object_addr.text != "" then edt_object_addr.text += "_"
				edt_object_addr.text += tt[t]
			)
		)
	)
	
	on edt_object_name entered arg do
	(
		edt_tex_diffuse_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_Diffuse_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_diffuse_name.text = (substitutestring edt_tex_diffuse_name.text "_Main" "")
		edt_tex_normal_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_Normal_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_normal_name.text = (substitutestring edt_tex_normal_name.text "_Main" "")
		edt_tex_erm_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_ERM_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_erm_name.text = (substitutestring edt_tex_erm_name.text "_Main" "")
			
		edt_object_addr.text = (substitutestring edt_object_name.text "SM_" "")
		tt = filterstring edt_object_name.text "_"
		if tt.count > 1 then
		(
			edt_object_addr.text = ""
			for t = 1 to tt.count do 
			(
				if tt[t] == "SM" or tt[t] == "M" or tt[t] == "T" then continue
				if (for t1 = 1 to tt.count where tt[t1] == "77" collect tt[t1]).count == 0  and tt[t] == "001" or tt[t] == "002" or tt[t] == "003" or tt[t] == "004" or tt[t] == "005" then continue	
				if tt[t] == "Main" then continue
				if tt[t] == "Ground" then continue
				if tt[t] == "GroundEl" then continue						
				if tt[t] == "Flora" then continue
				if tt[t] == "Glass" or tt[t] == "MainGlass" or tt[t] == "GroundGlass" or tt[t] == "GroundElGlass" then continue	
				if edt_object_addr.text != "" then edt_object_addr.text += "_"
				edt_object_addr.text += tt[t]
			)
		)
	)	

	on edt_object_addr changed arg do
	(
		--print arg
		local stri 
		local tt = #()
		stri = trimright (trimleft arg (parse_error_symbols arg)) (parse_error_symbols arg)
		stri = substituteString stri " " ""
		stri = substituteString stri "\\" ""
		stri = substituteString stri "." ""
		stri = substituteString stri "," ""	
		stri = substituteString stri "(" ""			
		stri = substituteString stri ")" ""			
		while findstring stri "__" != undefined do stri = substituteString stri "__" "_"	
		--stri = trimright stri "_"
		--stri = trimleft stri "_"
		
		local obj = edt_object_name.text
		local str = ""
		for i = 1 to stri.count do 
		(
			case of 
			(
				(i == 1): str += toupper stri[i]
				(i > 1): if stri[i-1] == "_" then str += toupper stri[i] else str += stri[i]
				--default: str += stri[i]
			)
		)
		stri = str	

		tt = #()
		if obj != "" then tt = filterstring obj "_" splitEmptyTokens:true			
		if tt.count > 0 then
		(
			obj = "SM_" + stri + "_"
			for t = 1 to tt.count do 
			(
				case of
				(
					--(tt[t] == "SM" or tt[t] == "M" or tt[t] == "T" ): (obj += "SM_" + stri + "_")
					(delete_only_digits tt[t] == "" ): (if findstring stri tt[t] == undefined then obj += tt[t]; if obj != "" then obj += "_")
					(tt[t] == "Main" ): (obj += tt[t])
					(tt[t] == "Ground" ): (obj += tt[t])
					(tt[t] == "GroundEl" ): (obj += tt[t])					
					(tt[t] == "Flora" ): (obj += tt[t])
					(tt[t] == "Glass" or tt[t] == "MainGlass" or tt[t] == "GroundGlass" or tt[t] == "GroundElGlass" ): (obj += tt[t])	
					default: continue --edt_object_name.text += edt_object_addr.text
				)
			)
		)	
		while findstring obj "__" != undefined do obj = substituteString obj "__" "_"
		
		edt_tex_diffuse_name.text = (substitutestring obj "SM_" "T_") + "_Diffuse_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_diffuse_name.text = (substitutestring edt_tex_diffuse_name.text "_Main" "")
		edt_tex_normal_name.text = (substitutestring obj "SM_" "T_") + "_Normal_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_normal_name.text = (substitutestring edt_tex_normal_name.text "_Main" "")
		edt_tex_erm_name.text = (substitutestring obj "SM_" "T_") + "_ERM_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_erm_name.text = (substitutestring edt_tex_erm_name.text "_Main" "")

		edt_object_name.text = if obj != "" then obj else stri
		edt_object_addr.text = stri
	)

	on edt_object_addr entered arg do
	(
		--print arg
		local stri 
		local tt = #()
		stri = trimright (trimleft arg (parse_error_symbols arg)) (parse_error_symbols arg)
		stri = substituteString stri " " ""
		stri = substituteString stri "\\" ""
		stri = substituteString stri "." ""
		stri = substituteString stri "," ""	
		stri = substituteString stri "(" ""			
		stri = substituteString stri ")" ""			
		while findstring stri "__" != undefined do stri = substituteString stri "__" "_"	
		stri = trimright stri "_"
		stri = trimleft stri "_"
		
		local obj = edt_object_name.text
		local str = ""
		for i = 1 to stri.count do 
		(
			case of 
			(
				(i == 1): str += toupper stri[i]
				(i > 1): if stri[i-1] == "_" then str += toupper stri[i] else str += stri[i]
				--default: str += stri[i]
			)
		)
		stri = str	

		tt = #()
		if obj != "" then tt = filterstring obj "_" splitEmptyTokens:true			
		if tt.count > 0 then
		(
			obj = "SM_" + stri + "_"
			for t = 1 to tt.count do 
			(
				case of
				(
					--(tt[t] == "SM" or tt[t] == "M" or tt[t] == "T" ): (obj += "SM_" + stri + "_")
					(delete_only_digits tt[t] == "" ): (if findstring stri tt[t] == undefined then obj += tt[t]; if obj != "" then obj += "_")
					(tt[t] == "Main" ): (obj += tt[t])
					(tt[t] == "Ground" ): (obj += tt[t])
					(tt[t] == "GroundEl" ): (obj += tt[t])					
					(tt[t] == "Flora" ): (obj += tt[t])
					(tt[t] == "Glass" or tt[t] == "MainGlass" or tt[t] == "GroundGlass" or tt[t] == "GroundElGlass" ): (obj += tt[t])	
					default: continue --edt_object_name.text += edt_object_addr.text
				)
			)
		)	
		while findstring obj "__" != undefined do obj = substituteString obj "__" "_"
		
		edt_tex_diffuse_name.text = (substitutestring obj "SM_" "T_") + "_Diffuse_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_diffuse_name.text = (substitutestring edt_tex_diffuse_name.text "_Main" "")
		edt_tex_normal_name.text = (substitutestring obj "SM_" "T_") + "_Normal_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_normal_name.text = (substitutestring edt_tex_normal_name.text "_Main" "")
		edt_tex_erm_name.text = (substitutestring obj "SM_" "T_") + "_ERM_1." + (spn_tex_udim.value as string) + ".png"
		edt_tex_erm_name.text = (substitutestring edt_tex_erm_name.text "_Main" "")

		edt_object_name.text = if obj != "" then obj else stri
		edt_object_addr.text = stri
	)	
	
	on edt_material_object_number changed arg do 
	(
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + arg as string + "*Diffuse*" + edt_material_mat_number.text + "*.png"
	)
	
	on edt_material_object_number entered arg do 
	(
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + arg as string + "*Diffuse*" + edt_material_mat_number.text + "*.png"
	)
	
	on edt_path_end changed arg do 
	(
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png"
	)
	
	on edt_path_end entered arg do 
	(
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png"
	)

	on edt_material_mat_number changed arg do 
	(
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + arg as string + "*.png"
	)
	
	on edt_material_mat_number entered arg do 
	(
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + arg as string + "*.png"
	)
		
	on rdo_path changed state do 
	(
		case rdo_path.state of
		(
			1: edt_multimat_path.text = maxFilePath + "Maps\\"
			2: edt_multimat_path.text = maxFilePath + "Images\\"
			3: edt_multimat_path.text = maxFilePath + edt_path_end.text + "\\"
		)
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png"		
	)
	
	on ddl_material_object_number selected txt do 
	(
		edt_material_object_number.text = ddl_material_object_number.items[txt] as string
		sub = case rdo_path.state of 
		(
			1: "Maps\\"
			2: "Images\\" 
			3: (edt_path_end.text + "\\")
		)
		lbl_multimat_path.text = "Search mask: ..." + sub + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png"		
	)

	on chk_unwrap_texel_or_poly changed state do 
	(
		case state of
		(
			true:
			(
				lbl_bricks_unwrap_get_island.enabled = false
				btn_bricks_unwrap_get_island.enabled = false
				spn_bricks_unwrap_num.enabled = false
				btn_bricks_unwrap_get_num.enabled = false
			)
			false:
			(
				--lbl_bricks_unwrap_get_island.enabled = true
				--btn_bricks_unwrap_get_island.enabled = true
				spn_bricks_unwrap_num.enabled = true
				btn_bricks_unwrap_get_num.enabled = true				
			)
		)
	)
	
	on btn_name_to_sel pressed do
	(
		if selection.count > 0 then 
			for i in selection do i.name = edt_object_name.text
	)
	
	on btn_check_copy pressed do
	(
		setclipboardText edt_object_addr.text
	)
	
	on btn_check_paste pressed do
	(
		edt_object_addr.text = getclipboardText()
	)
	
	on btn_check_names pressed do
	(
		local err = ""
		local adr = edt_object_addr.text
		--???????? ???????????? ????????
		t = parse_error_symbols adr
		if t != "" then 
		(
			if findstring t "." != undefined then err += "\x2716 " + adr + ": ????? ???????? ???????????? ??????? ????? .\n"
			else err += "\x2716 " + adr + ": ????? ???????? ???????????? ???????\n"
		)
		else err += "\x2714 " + adr + ": ????? ?? ???????? ???????????? ???????\n"

		excel_file1 = GetDir #maxroot + "GeoScripts\\abbr3.csv" --??? ???????? ?????????? ? ????? ?????? ? ???? ??????
		excel_file2 = GetDir #maxroot + "GeoScripts\\abbr4.csv" --??? ???????? ?????????? ? ????? ?????? ? ???? ????????
		stri_arr1 = #()
		stri1 = #()
		stri_long1 = #()
		stri_arr2 = #()
		stri2 = #()
		stri_long2 = #()
		stri_arr1 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file1 ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "???? abbr3.csv ?? ?????? ??? ?? ???????????")
		stri_arr2 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file2 ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "???? abbr4.csv ?? ?????? ??? ?? ???????????")
	
		if stri_arr1.count > 0 do 
		(
			for i in #{1..stri_arr1.count} do append stri1 (filterstring stri_arr1[i] ";")[2] 
			for i in #{1..stri_arr1.count} do append stri_long1 (translit (filterstring stri_arr1[i] ";")[1])
			qsort stri1 sortexcel_len --?????????? ?? ?????? ?????, ??????? ? ??????, ????? ????? ????????
			qsort stri_long1 sortexcel_len --?????????? ?? ?????? ?????, ??????? ? ??????, ????? ????? ????????										
		)
								
		if stri_arr2.count > 0 do 
		(
			for i in #{1..stri_arr2.count} do append stri2 (filterstring stri_arr2[i] ";")[2] 
			for i in #{1..stri_arr2.count} do append stri_long2 (translit (filterstring stri_arr2[i] ";")[1])
			qsort stri2 sortexcel_len --?????????? ?? ?????? ?????, ??????? ? ??????, ????? ????? ????????
			qsort stri_long2 sortexcel_len --?????????? ?? ?????? ?????, ??????? ? ??????, ????? ????? ????????										
		)

		excel_file_ul = GetDir #maxroot + "GeoScripts\\ul5.csv" --??? ???????? ???????????? ???????? ????
		excel_file_pos = GetDir #maxroot + "GeoScripts\\ul4.csv" --??? ???????? ???????????? ???????? ?????????
		stri_arr3 = #()
		stri_arr4 = #()
		stri_arr3 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file_ul ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "???? ul5.csv ?? ?????? ??? ?? ???????????")
		stri_arr4 = try ((dotNetClass "System.IO.File").ReadAllLines excel_file_pos ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "???? ul4.csv ?? ?????? ??? ?? ???????????")

		stri_ul = #()
		stri_ul_full = #()
		stri_pos = #()
		stri_pos_pre = #()

		if stri_arr3.count > 0 do 
		(
			for i in #{1..stri_arr3.count} do append stri_ul_full (filterstring stri_arr3[i] ";")[3] 
			for i in #{1..stri_arr3.count} do append stri_ul (filterstring stri_arr3[i] ";")[4] 
		)
		if stri_arr4.count > 0 do 
		(
			for i in #{1..stri_arr4.count} do append stri_pos_pre (filterstring stri_arr4[i] ";")[2] 
			for i in #{1..stri_arr4.count} do append stri_pos (filterstring stri_arr4[i] ";")[3] 
		)		

/*		
		excel_file = GetDir #maxroot +"\\GeoScripts\\abbr2.csv" --??? ???????? ?????????? ? ????? 
							
		stri_arr = #()
		stri = #()
		stri_long = #()
		stri_arr = try ((dotNetClass "System.IO.File").ReadAllLines excel_file ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "???? abbr2.csv ?? ?????? ??? ?? ???????????")
		--print #(stri_arr)
	
		if stri_arr.count > 0 do 
		(
			for i in #{1..stri_arr.count} do append stri (filterstring stri_arr[i] ";")[2] 
			for i in #{1..stri_arr.count} do append stri_long (translit (filterstring stri_arr[i] ";")[1])
			qsort stri sortexcel_len --?????????? ?? ?????? ?????, ??????? ? ??????, ????? ????? ????????
			qsort stri_long sortexcel_len --?????????? ?? ?????? ?????, ??????? ? ??????, ????? ????? ????????										
		)
		--print #(stri)	
		--print (stri_long)									
				
		excel_file_ul = GetDir #maxroot +"\\GeoScripts\\ul3.csv" --??? ???????? ???????????? ???????? ????
		stri_arr = #()
		stri_arr = try ((dotNetClass "System.IO.File").ReadAllLines excel_file_ul ((dotNetClass "System.Text.Encoding").UTF8))catch(err += "???? ul3.csv ?? ?????? ??? ?? ???????????")
		stri_ul = #()
		--print #(stri_arr)
		if stri_arr.count > 0 do 
		(
			for i in #{1..stri_arr.count} do append stri_ul (filterstring stri_arr[i] ";")[3] 
		)
*/								
		--???????? ? ????? 
		t = adr
		if t != translit t then err += "\x2716 " + adr + ": ????? ???????? ???????????? ??????? ?? ? ?????????\n"
		if findstring t " " != undefined then err += "\x2716 " + adr + ": ????? ???????? ??????? ???????  \n"
		if findstring t "_" == undefined then err += "\x2716 " + adr + ": ????? ?? ???????? ??????? ?????????? _\n"
		else
		(
			tt = #()
			tt_ini = #()
			tt = filterstring t "_"
			tt_ini = filterstring t "_"
			if tt.count > 0 then
			(
				--???????? ?????? ???? SM
				--if tt[1] != "SM" then err += "\x2716 " + adr + ": ????? ???????? ?????? ??????????, ?????? ??????? ?????? SM\n"
				--???????? ?????? ???? 

				for t1 in #{1..tt.count} do
				(		
					tt[t1][1] = toupper tt[t1][1]  
					if tt[t1] != tt_ini[t1] then err += "\x2716 " + adr + ": ????? ???????? ???????? ?????? ??????????, ?????? ????? ?????? ?????????? ? ????????? ?????: " + tt_ini[t1] + "\n"
				)
				print #(tt)		
				
				--???????? ???? ????? ?????????? ? ???????
				for t1 in #{1..tt.count} do
				(		
					tt[t1] = delete_only_digits tt[t1] 
					if tt[t1] != "" and tt[t1] != tt_ini[t1] then err += "\x2716 " + adr + ": ????? ???????? ???????? ?????? ??????????, ????? ?????????? ?? ?????? ????????? ?????? ??????????????: " + tt_ini[t1] + "\n"
				)
				print #(tt)
/*										
				--???????? ???????????? ???????? ????
				for t1 in #{1..tt.count} where tt[t1] != "" do
				(		
					for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul[t2] "" --??????????? ?????? ?????? ????
					if tt[t1] == tt_ini[t1] then err += "\x2716 " + adr + ": ????? ???????? ???????? ?????? ??????????, ???????? ?? ?????? ? ??????????? ?????????????? ????????????? ???? ??????: " + tt_ini[t1] + "\n"
				)
				print #(tt)
										
				--???????? ???? ???? ????????????? ???????? ????????? ??????
				for t1 in #{1..tt.count} where tt[t1] != "" do
				(		
					for t2 in #{1..stri_long.count} do tt[t1] = substitutestring tt[t1] stri_long[t2] "" --??????????? ?????? ?????? ??-??? ??????
					if tt[t1] != tt_ini[t1] then err += "\x2716 " + adr + ": ????? ???????? ???????? ?????? ??????????, ?? ????????? ???????? ??????: " + tt_ini[t1] + "\n"
				)
				print #(tt)

				-- ???????? ????? ?? ?????? ??????????? ?????? ??????????????, ? ?????? ???? ???????? ??????, ??? ???? ?????? ????? ????? ??????? ? ??????? ?????.
				for t1 in #{1..tt.count} where tt[t1] != "" do
				(		
					for t2 in #{1..stri.count} do tt[t1] = substitutestring tt[t1] stri[t2] "" --??????????? ?????? ?????????? ??-??? ??????
					if tt[t1] != tt_ini[t1] then err += "\x2716 " + adr + ": ????? ???????? ???????? ?????? ??????????, ?? ?????? ???? ?????????? ????????? ?????? ???, ????????, ??????????? ????????? ???????? ??????, ???????? ???????? ?????? ?? ?????? ??????????? ?????? ??????????????, ? ?????? ???? ???????? ??????, ??? ???? ?????? ????? ????? ??????? ? ??????? ????? :" + tt_ini[t1] + "\n"											
				)
				print #(tt)
				
*/
				--???????? ???? ???? ????????????? ???????? ????????? ??????
				for t1 in #{1..tt.count} where tt[t1] != "" do
				(		
					for t2 in #{1..stri_long1.count} do tt[t1] = substitutestring tt[t1] stri_long1[t2] "" --??????????? ?????? ?????? ??-??? ??????
					if tt[t1] != tt_ini[t1] then err += "\x2716 " + adr + ": ????? ???????? ???????? ?????? ??????????, ?? ????????? ???????? ??????: " + tt_ini[t1] + "\n"
				)
				print #(tt)	
										
				--???????? ???????????? ???????? ???? ? ????????
				for t1 in #{1..tt.count} where tt[t1] != "" and t1 <= 3 do
				(		
					for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul_full[t2] "" --??????????? ?????? ?????? ????
					for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] ("Pos" + stri_pos[t2]) "" --??????????? ?????? ?????? ????????
					for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] (stri_pos_pre[t2] + stri_pos[t2]) "" --??????????? ?????? ?????? ????????

					for t2 in #{1..stri_ul.count} do tt[t1] = substitutestring tt[t1] stri_ul[t2] "" --??????????? ?????? ?????? ????
					for t2 in #{1..stri_pos.count} do tt[t1] = substitutestring tt[t1] stri_pos[t2] "" --??????????? ?????? ?????? ????????
			
					if tt[t1] == tt_ini[t1] then err += "\x2716 " + adr + ": ????? ???????? ???????? ?????? ???????????, ???????? ?? ?????? ? ??????????? ?????????????? ????????????? ???? ??????: " + tt_ini[t1] + "\n"
				)
				print #(tt)

				-- ???????? ????? ?? ?????? ??????????? ?????? ??????????????, ? ?????? ???? ???????? ??????, ??? ???? ?????? ????? ????? ??????? ? ??????? ?????.
				for t1 in #{1..tt.count} where tt[t1] != "" do
				(		
					for t2 in #{1..stri1.count} do tt[t1] = substitutestring tt[t1] stri1[t2] "" --??????????? ?????? ?????????? ??-??? ??????
					if tt[t1] != tt_ini[t1] then err += "\x2716 " + adr + ": ????? ???????? ???????? ?????? ??????????, ?? ?????? ???? ?????????? ????????? ?????? ???, ????????, ??????????? ????????? ???????? ??????, ???????? ???????? ?????? ?? ?????? ??????????? ?????? ??????????????, ? ?????? ???? ???????? ??????, ??? ???? ?????? ????? ????? ??????? ? ??????? ????? :" + tt_ini[t1] + "\n"
				)
				print #(tt)		

				--??????????? ????
				for t1 in #{1..tt.count} where tt[t1] != "" do
				(		
					for t2 in #{1..stri2.count} do tt[t1] = substitutestring tt[t1] stri2[t2] "" --??????????? ?????? ?????????? ??-??? ??????
					if tt[t1] == "D" or tolower tt[t1] == "dom" then err += "\x2716 ;1.3.1.; " + adr + ": ????? ???????? ???????? ?????? ??????????, ?????????? D ??? ??? ??????????: " + tt_ini[t1] + " \n"											
					if tt[t1] == "Uch" then err += "\x2716 ;1.3.1.; " + adr + ": ????? ???????? ???????? ?????? ??????????, Uch ?????????? ???????? ?? ZU: " + tt_ini[t1] + " \n"											
					if tt[t1] == tt_ini[t1] then err += "\x2716 ;1.3.1.; " + adr + ": ????? ???????? ???????? ?????? ??????????, ?????????? ???????? ?????? ?? ?????? ? ??????: " + tt_ini[t1] + " \n"											
				)
				print #(tt)									
			)
		)
		messagebox err		
	)

	on btn_unwrap_windows pressed do with undo "Unwrap Windows" on 
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			s = selection[1]
			max create mode
			faces = #{1..(polyop.getnumfaces s)}
			elems = faces_to_elements s faces 
			print #(elems)
			clusters = #()
			found = false
			first = true
			for el in elems where not keyboard.escPressed do
			(
				if first then 
				(
					append clusters el
					first = false
				)
				found = false
				ind = 1		
				for c in #{1..clusters.count} where dist s el clusters[c] spn_unwrap_windows.value and not keyboard.escPressed do 
				(			
					found = true
					ind = c
					exit
				)
				if found then 
				(
					join clusters[ind] el
					found = false
				)
				else append clusters el
			)
			print #(clusters)
			print clusters.count
			
			--max create mode
			max modify mode
			wins = #()
			gab = #()
			if clusters.count > 0 then
			(
				for c in clusters where not keyboard.escPressed do
				(
					print #(c)
					max modify mode
					--max create mode
					polyop.detachfaces s c asNode:true delete:false name:(s.name + "_window001")
					win = maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))
					if chk_unwrap_windows_rotation.checked then append gab (get_gabarites win) else append gab (amax #(win.max.x - win.min.x, win.max.y - win.min.y, win.max.z - win.min.z ))
					append wins win
				)
				sc = amax gab
				format "" sc

				if wins.count > 0 then
				(
					for win in wins where not keyboard.escPressed do
					(	
						select win
						--polyop.applyUVWMap s #box utile:1.0 vtile:1.0 wtile:1.0 uflip:false vflip:false wflip:false cap:true tm: channel:1
						centerpivot win 
						
						if chk_unwrap_windows_rotation.checked then
						(
							max modify mode --max create mode
							angles = rotate_to_min_Y win (2.0 * spn_unwrap_windows_rotation_acc.value) -90.0 90.0
							angles = rotate_to_min_Y win (0.1 * spn_unwrap_windows_rotation_acc.value) (angles - 5) (angles + 5)
							rotate win (eulerangles 0 0 angles)
							resetxform win
							converttopoly win
						)							
						addmodifier win (uvwmap length:sc width:sc height:sc maptype:4 axis:2)
						
						if chk_unwrap_windows_rotation.checked then rotate win (eulerangles 0 0 -angles)
						--giz = win.modifiers[1].Gizmo
						--giz.rotation.z = angles
						if chk_unwrap_windows_align.checked then alignUVGizmo win win.uvwmap 
						--FitUVWMapToFace win win.uvwmap 
							--polyop.freeVData <Poly poly> <int vdChannel>
							--polyop.resetVData <Poly poly> <int vdChannel>
					)
					
					if wins.count > 1 then
					(
						max modify mode
						if chk_unwrap_windows_rotation.checked then resetxform wins[1]
						converttopoly wins[1] 
						for w in #{2..wins.count} do polyop.attach wins[1] wins[w]  
					)
					addmodifier wins[1] (Unwrap_UVW())
					wins[1].name = s.name
					wins[1].pivot = s.pivot
					select wins[1]
					max modify mode	
					if chk_unwrap_windows_flatten.checked then btn_bricks_flatten.pressed()
					chk = chk_UdimFit.checked 
					wins[1].modifiers[1].selectFaces #{1..wins[1].modifiers[1].numberPolygons()}
					wins[1].modifiers[1].setTVSubObjectMode 3 
					
					chk_UdimFit.checked = false 
					btn_UdimFit.pressed()
					chk_UdimFit.checked = chk
					delete s
				)
			)
		)
	)
	
	on btn_render_mat rightclick do
	(
		if selection.count > 0 then
		(
			for i in selection where i.material != undefined and not keyboard.escPressed do
			(	
				nam = i.name
				nam = substitutestring nam "_Main" ""
				nam = substitutestring nam "SM_" "T_"
				
				m = i.material
				
				rez = case rdo_tex.state of
				(
					1: 256
					2: 512
					3: 1024
					4: 2048
					5: 4096
				)		
				
				case (classof m) of
				(
					CoronaLegacyMtl:
					(
					)
					
					CoronaPhysicalMtl:
					(
					)
					
					Physical_Material:
					(
					)
	
					Standardmaterial:
					(
					)
								
					Multimaterial: 
					(
						for id in #{1..m.numsubs} where m.materialList[id] != undefined and not keyboard.escPressed do
						(
							sub_m = m.materialList[id]
							
							udim = (id + 1000) as string
							
							difuse = edt_multimat_path.text + nam + "_Diffuse_1." + udim + ".png"
							normal = edt_multimat_path.text + nam + "_Normal_1." + udim + ".png"
							erm = edt_multimat_path.text + nam + "_ERM_1." + udim + ".png"
						
							case classof sub_m of
							(
								CoronaLegacyMtl:
								(
									--showproperties sub_m
									--format "id=% diff=% mat=%\n" id difuse sub_m.texmapDiffuse.filename
									if sub_m.texmapDiffuse != undefined then
									(
										if isProperty sub_m.texmapDiffuse #filename then copy_mat sub_m.texmapDiffuse.filename difuse (GetINI_ImageMagick())
										else render_map sub_m.texmapDiffuse rez difuse
									)
									else if not doesfileexist difuse then
									(
										b = bitmap 256 256 filename:difuse color:sub_m.colorDiffuse gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:(GetINI_ImageMagick())
									)

									if sub_m.texmapBump != undefined then
									(		
										if isProperty sub_m.texmapBump #filename then copy_mat sub_m.texmapBump.filename normal (GetINI_ImageMagick())
										else render_map sub_m.texmapBump rez normal
									)
									else if not doesfileexist normal then
									(											
										b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:(GetINI_ImageMagick())
									)
										
									if sub_m.texmapReflect != undefined then
									(
										if isProperty sub_m.texmapReflect #filename then copy_mat sub_m.texmapReflect.filename erm (GetINI_ImageMagick())
										else render_map sub_m.texmapReflect rez erm
									)
									else if not doesfileexist erm then
									(											
										b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:(GetINI_ImageMagick())
									)

									--if sub_m.texmapReflect != undefined then render_map sub_m.texmapReflect rez (edt_multimat_path.text + sub_m.name + "_Reflect" + ".png")
									--if sub_m.texmapReflectGlossiness != undefined then render_map sub_m.texmapReflectGlossiness rez (edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png")
									--if sub_m.texmapRefract != undefined then render_map sub_m.texmapRefract rez (edt_multimat_path.text + sub_m.name + "_Refract" + ".png")
									--if sub_m.texmapRefractGlossiness != undefined then render_map sub_m.texmapRefractGlossiness rez (edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png")
									--if sub_m.texmapOpacity != undefined then render_map sub_m.texmapOpacity rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
									--if sub_m.texmapTranslucency != undefined then render_map sub_m.texmapTranslucency rez (edt_multimat_path.text + sub_m.name + "_Translucency" + ".png")
									--if sub_m.texmapDisplace != undefined then render_map sub_m.texmapDisplace rez (edt_multimat_path.text + sub_m.name + "_Displace" + ".png")
									--if sub_m.texmapSelfIllum != undefined then render_map sub_m.texmapSelfIllum rez (edt_multimat_path.text + sub_m.name + "_SelfIllum" + ".png")
								)
								
								CoronaPhysicalMtl:
								(
									if sub_m.baseTexmap != undefined then
									(
										if isProperty sub_m.baseTexmap #filename then copy_mat sub_m.baseTexmap.filename difuse (GetINI_ImageMagick())
										else render_map sub_m.baseTexmap rez difuse
									)
									else if not doesfileexist difuse then
									(
										b = bitmap 256 256 filename:difuse color:sub_m.baseColor gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:(GetINI_ImageMagick())
									)
									
									if sub_m.baseBumpTexmap != undefined then
									(		
										if isProperty sub_m.baseBumpTexmap #filename then copy_mat sub_m.baseBumpTexmap.filename normal (GetINI_ImageMagick())
										else render_map sub_m.baseBumpTexmap rez normal
									)
									else if not doesfileexist normal then
									(											
										b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:(GetINI_ImageMagick())
									)
									--metalnessTexmap
									if sub_m.baseRoughnessTexmap != undefined then
									(
										if isProperty sub_m.baseRoughnessTexmap #filename then copy_mat sub_m.baseRoughnessTexmap.filename erm (GetINI_ImageMagick())
										else render_map sub_m.baseRoughnessTexmap rez erm
									)
									else if not doesfileexist erm then
									(											
										b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:(GetINI_ImageMagick())
									)																
								)
								
								Physical_Material:
								(
									if sub_m.base_color_map != undefined then
									(
										if isProperty sub_m.base_color_map #filename then copy_mat sub_m.base_color_map.filename difuse (GetINI_ImageMagick())
										else render_map sub_m.base_color_map rez difuse
									)
									else if not doesfileexist difuse then
									(
										b = bitmap 256 256 filename:difuse color:sub_m.base_color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:(GetINI_ImageMagick())
									)
									
									if sub_m.bump_map != undefined then
									(		
										if isProperty sub_m.bump_map #filename then copy_mat sub_m.bump_map.filename normal (GetINI_ImageMagick())
										else render_map sub_m.bump_map rez normal
									)
									else if not doesfileexist normal then
									(											
										b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:(GetINI_ImageMagick())
									)
										
									if sub_m.roughness_map != undefined then
									(
										if isProperty sub_m.roughness_map #filename then copy_mat sub_m.roughness_map.filename erm (GetINI_ImageMagick())
										else render_map sub_m.roughness_map rez erm
									)
									else if not doesfileexist erm then
									(											
										b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:(GetINI_ImageMagick())
									)									
									-- .emission_map : texturemap 
									--emit_color
									--if sub_m.base_color_map != undefined then copy_mat sub_m.base_color_map.filename difuse (GetINI_ImageMagick())
									--if sub_m.roughness_map != undefined then render_map sub_m.roughness_map rez (edt_multimat_path.text + sub_m.name + "_Roughness" + ".png")
									--if sub_m.metalness_map != undefined then render_map sub_m.metalness_map rez (edt_multimat_path.text + sub_m.name + "_Metalness" + ".png")	
									--if sub_m.bump_map != undefined then copy_mat sub_m.bump_map.filename normal (GetINI_ImageMagick())
									--if sub_m.cutout_map != undefined then render_map sub_m.cutout_map rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
								
								Standardmaterial:
								(
									if sub_m.DiffuseMap != undefined then
									(
										if isProperty sub_m.DiffuseMap #filename then copy_mat sub_m.DiffuseMap.filename difuse (GetINI_ImageMagick())
										else render_map sub_m.DiffuseMap.filename rez difuse
									)
									else if not doesfileexist difuse then
									(
										b = bitmap 256 256 filename:difuse color:sub_m.diffuse gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:(GetINI_ImageMagick())
									)

									if sub_m.BumpMap != undefined then
									(		
										if isProperty sub_m.BumpMap #filename then copy_mat sub_m.BumpMap.filename normal (GetINI_ImageMagick())
										else render_map sub_m.BumpMap rez normal
									)
									else if not doesfileexist normal then
									(											
										b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:(GetINI_ImageMagick())
									)
										
									if sub_m.ReflectionMap != undefined then
									(
										if isProperty sub_m.ReflectionMap #filename then copy_mat sub_m.ReflectionMap.filename erm (GetINI_ImageMagick())
										else render_map sub_m.ReflectionMap rez erm
									)
									else if not doesfileexist erm then
									(											
										b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										save b gamma:1.0 quiet:true
										close b
										free b
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:(GetINI_ImageMagick())
									)									
									
									--if sub_m.DiffuseMap != undefined then copy_mat sub_m.DiffuseMap.filename difuse	(GetINI_ImageMagick())		
									--if sub_m.BumpMap != undefined then copy_mat sub_m.BumpMap.filename normal (GetINI_ImageMagick())
									--if sub_m.ReflectionMap != undefined then render_map sub_m.ReflectionMap rez (edt_multimat_path.text + sub_m.name + "_Reflection" + ".png")
									--if sub_m.GlossinessMap != undefined then render_map sub_m.GlossinessMap rez (edt_multimat_path.text + sub_m.name + "_Glossiness" + ".png")
									--if sub_m.OpacityMap != undefined then render_map sub_m.OpacityMap rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
							)
						)
					)					
				)
			)
		)			
	)
	
	on btn_render_mat pressed do
	(
		if selection.count > 0 then
		(
			rez = case rdo_tex.state of
			(
				1: 256
				2: 512
				3: 1024
				4: 2048
				5: 4096
			)			

			for i in selection where i.material != undefined and not keyboard.escPressed do
			(	
				if not doesDirectoryExist edt_multimat_path.text then makedir edt_multimat_path.text
				m = i.material
				print edt_multimat_path.text
				print i
				print (classof m)
				case (classof m) of
				(
					CoronaLegacyMtl:
					(
						if m.texmapDiffuse != undefined then render_map m.texmapDiffuse rez (edt_multimat_path.text + m.name + "_Diffuse" + ".png")
						if m.texmapReflect != undefined then render_map m.texmapReflect rez (edt_multimat_path.text + m.name + "_Reflect" + ".png")
						if m.texmapReflectGlossiness != undefined then render_map m.texmapReflectGlossiness rez (edt_multimat_path.text + m.name + "_ReflectGlossiness" + ".png")
						if m.texmapRefract != undefined then render_map m.texmapRefract rez (edt_multimat_path.text + m.name + "_Refract" + ".png")
						if m.texmapRefractGlossiness != undefined then render_map m.texmapRefractGlossiness rez (edt_multimat_path.text + m.name + "_RefractGlossiness" + ".png")
						if m.texmapOpacity != undefined then render_map m.texmapOpacity rez (edt_multimat_path.text + m.name + "_Opacity" + ".png")
						if m.texmapBump != undefined then render_map m.texmapBump rez (edt_multimat_path.text + m.name + "_Bump" + ".png")
						if m.texmapTranslucency != undefined then render_map m.texmapTranslucency rez (edt_multimat_path.text + m.name + "_Translucency" + ".png")
						if m.texmapDisplace != undefined then render_map m.texmapDisplace rez (edt_multimat_path.text + m.name + "_Displace" + ".png")
						if m.texmapSelfIllum != undefined then render_map m.texmapSelfIllum rez (edt_multimat_path.text + m.name + "_SelfIllum" + ".png")
					)
					
					CoronaPhysicalMtl:
					(
					)
					
					Physical_Material:
					(
						if m.base_color_map != undefined then render_map m.base_color_map rez (edt_multimat_path.text + m.name + "_Diffuse" + ".png")
						if m.roughness_map != undefined then render_map m.roughness_map rez (edt_multimat_path.text + m.name + "_Roughness" + ".png")
						if m.metalness_map != undefined then render_map m.metalness_map rez (edt_multimat_path.text + m.name + "_Metalness" + ".png")	
						if m.bump_map != undefined then render_map m.bump_map rez (edt_multimat_path.text + m.name + "_Bump" + ".png")
						if m.cutout_map != undefined then render_map m.cutout_map rez (edt_multimat_path.text + m.name + "_Opacity" + ".png")
					)
	
					Standardmaterial:
					(
						if m.DiffuseMap != undefined then render_map m.DiffuseMap rez (edt_multimat_path.text + m.name + "_Diffuse" + ".png")				
						if m.BumpMap != undefined then render_map m.BumpMap rez (edt_multimat_path.text + m.name + "_Bump" + ".png")
						if m.ReflectionMap != undefined then render_map m.ReflectionMap rez (edt_multimat_path.text + m.name + "_Reflection" + ".png")
						if m.GlossinessMap != undefined then render_map m.GlossinessMap rez (edt_multimat_path.text + m.name + "_Glossiness" + ".png")
						if m.OpacityMap != undefined then render_map m.OpacityMap rez (edt_multimat_path.text + m.name + "_Opacity" + ".png")
					)
								
					Multimaterial: 
					(
						for sub_m in m.materialList where not keyboard.escPressed do
						(
							case classof sub_m of
							(
								CoronaLegacyMtl:
								(
									if sub_m.texmapDiffuse != undefined then render_map sub_m.texmapDiffuse rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")
									if sub_m.texmapReflect != undefined then render_map sub_m.texmapReflect rez (edt_multimat_path.text + sub_m.name + "_Reflect" + ".png")
									if sub_m.texmapReflectGlossiness != undefined then render_map sub_m.texmapReflectGlossiness rez (edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png")
									if sub_m.texmapRefract != undefined then render_map sub_m.texmapRefract rez (edt_multimat_path.text + sub_m.name + "_Refract" + ".png")
									if sub_m.texmapRefractGlossiness != undefined then render_map sub_m.texmapRefractGlossiness rez (edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png")
									if sub_m.texmapOpacity != undefined then render_map sub_m.texmapOpacity rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
									if sub_m.texmapBump != undefined then render_map sub_m.texmapBump rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
									if sub_m.texmapTranslucency != undefined then render_map sub_m.texmapTranslucency rez (edt_multimat_path.text + sub_m.name + "_Translucency" + ".png")
									if sub_m.texmapDisplace != undefined then render_map sub_m.texmapDisplace rez (edt_multimat_path.text + sub_m.name + "_Displace" + ".png")
									if sub_m.texmapSelfIllum != undefined then render_map sub_m.texmapSelfIllum rez (edt_multimat_path.text + sub_m.name + "_SelfIllum" + ".png")
								)
								
								CoronaPhysicalMtl:
								(
									
								)
								
								Physical_Material:
								(
									if sub_m.base_color_map != undefined then render_map sub_m.base_color_map rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")
									if sub_m.roughness_map != undefined then render_map sub_m.roughness_map rez (edt_multimat_path.text + sub_m.name + "_Roughness" + ".png")
									if sub_m.metalness_map != undefined then render_map sub_m.metalness_map rez (edt_multimat_path.text + sub_m.name + "_Metalness" + ".png")	
									if sub_m.bump_map != undefined then render_map sub_m.bump_map rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
									if sub_m.cutout_map != undefined then render_map sub_m.cutout_map rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
								
								Standardmaterial:
								(
									if sub_m.DiffuseMap != undefined then render_map sub_m.DiffuseMap rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")				
									if sub_m.BumpMap != undefined then render_map sub_m.BumpMap rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
									if sub_m.ReflectionMap != undefined then render_map sub_m.ReflectionMap rez (edt_multimat_path.text + sub_m.name + "_Reflection" + ".png")
									if sub_m.GlossinessMap != undefined then render_map sub_m.GlossinessMap rez (edt_multimat_path.text + sub_m.name + "_Glossiness" + ".png")
									if sub_m.OpacityMap != undefined then render_map sub_m.OpacityMap rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
							)
						)
					)
				)
			)
		)
	)
	
	on btn_bricks_flatten pressed do with undo "Flatten UV" on
	(
		if selection.count == 1 then
		(
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(
				faces = unwrapmod.getselectedfaces() 
				verts = #{}
				if faces.isempty then
				(
					faces = #{1..unwrapmod.numberPolygons()}
					verts = #{1..unwrapmod.NumberVertices()}
				)
				else
				(
					unwrapmod.faceToVertSelect() 
					verts = unwrapmod.getSelectedVertices() 
				)
				--print #(verts)
				if verts.numberset > 0 then
				(
					--for i in verts do
					--(
						--print i
						--poi = unwrapmod.getvertexposition currenttime i
						--print poi
						unwrapmod.selectVertices verts -- #{i}
						unwrapmod.moveZ 0.0
						--unwrapmod.moveSelected [0, 0, -poi.z]
					--)
				)
			)	
		)		
	)
	
	on btn_editor pressed do
	(
		global sel = if selection.count > 0 then selection[1].name else "None"

		try(destroyDialog ::BitmapsEDITOR)catch()
		try(closeRolloutFloater BitmapsEDITOR)catch()
		BitmapsEDITOR = newRolloutFloater "Bitmaps" 500 850
		rollout TextureEditor "Texture Editor" autoLayoutOnResize:true width:500 height:850
		(
			group "Opacity texture from Diffuse texture Maker"
			(
				label lbl_d "Diffuse texture" across:2
				label lbl_o "Opacity texture" 
				imgtag img_tag_diffuse bitmap:(bitmap 200 200 color:(color 10 10 10) gamma:1.0 hdr:false alpha:true) width:200 height:200 style:#bmp_stretch across:3 align:#left
				label lbl_a "=>" offset:[0,100]
				imgtag img_tag_opacity bitmap:(bitmap 200 200 color:(color 255 255 255) gamma:1.0 hdr:false alpha:false) width:200 height:200 style:#bmp_stretch align:#right

				edittext edt_diffuse text:"" width:200 align:#left across:2
				edittext edt_opacity text:"" width:200 align:#right
						
				button bnt_get_diffuse_map "Open Diffuse texture" align:#left width:200 across:2 tooltip:""
				button btn_make_opacity_map "Make Opacity Texture" align:#right width:200 tooltip:""
				
			)
			group "ERM texture from Three other textures Maker"
			(
				--??????? ??????? ???????, ???????? ?????? ??????? ?? ???, ????? ????? ??? ???????? ?? ?????
				label lbl_e "Emission texture" across:3
				label lbl_r "Roughness texture" 	
				label lbl_m "Metallicity texture"
				imgtag img_tag_emission bitmap:(bitmap 150 150 color:(color 255 255 255) gamma:1.0 hdr:false alpha:true) width:150 height:150 style:#bmp_stretch align:#left across:3
				imgtag img_tag_roughness bitmap:(bitmap 150 150 color:(color 255 255 255) gamma:1.0 hdr:false alpha:false) width:150 height:150 style:#bmp_stretch align:#center
				imgtag img_tag_metallicity bitmap:(bitmap 150 150 color:(color 255 255 255) gamma:1.0 hdr:false alpha:false) width:150 height:150 style:#bmp_stretch align:#right
				edittext edt_emission text:"" width:150 align:#left across:3
				edittext edt_roughness text:"" width:150 align:#center
				edittext edt_metallicity text:"" width:150 align:#right
				radiobuttons rdo_emission labels:#("R", "G", "B") enabled:false offset:[30,0] width:150 height:10 default:1 columns:3 rows:1 across:3 align:#left tooltip:"Take selected Channel as R component for ERM texture"
				radiobuttons rdo_roughness labels:#("R", "G", "B") enabled:false offset:[30,0] width:150 height:10 default:2 columns:3 rows:1 align:#center tooltip:"Take selected Channel as G component for ERM texture"
				radiobuttons rdo_metallicity labels:#("R", "G", "B") enabled:false offset:[30,0] width:150 height:10 default:3 columns:3 rows:1 align:#right tooltip:"Take selected Channel as B component for ERM texture"

				button bnt_get_emission_map "Open Emission texture" align:#left width:150 across:3 tooltip:""
				button bnt_get_roughness_map "Open Roughness texture" align:#center width:150 tooltip:""
				button bnt_get_metallicity_map "Open Metallicity texture" align:#right width:150 tooltip:""
				spinner spn_emission "Emission power" range:[0, 255, 0] scale:1 type:#integer fieldwidth:50 width:150 align:#left across:3 tooltip:"0 - no light, 255 - maximum emission of light (color comes from diffuse color)"
				spinner spn_roughness "Roughness power" range:[0, 255, 255] scale:1 type:#integer fieldwidth:50 width:150 align:#center tooltip:"0 - completely gloss, 255 - completely matte, may use middle values"
				spinner spn_metallicity "Metallicity power" range:[0, 255, 0] scale:1 type:#integer fieldwidth:50 width:150 align:#right tooltip:"0 - means none metallic, 255 - means metallic, usually do not use middle values"
				
				label lbl_erm "ERM texture" align:#center
				imgtag img_tag_ERM bitmap:(bitmap 150 150 color:(color 0 255 0) gamma:1.0 hdr:false alpha:false) width:150 height:150 style:#bmp_stretch align:#center
				label lbl_erm2 "Name will be get from last open texture, Size as maximum of all sizes" align:#center
				edittext edt_ERM text:(UDIMs.edt_multimat_path.text + "ERM.png") width:450 align:#center
				button btn_make_ERM_map "Make ERM Texture" width:450 
			)
			--vec3 rgb_normal = normal * 0.5 + 0.5; // ??????? ?? [-1,1] ? [0,1]   
			
			on btn_make_ERM_map pressed do
			(
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity
				local bitmap_large_ERM, bitmap_small_ERM
				
				if img_tag_emission.bitmap.filename != "" then
				(
					if doesfileexist img_tag_emission.bitmap.filename then bitmap_large_emission = openBitMap img_tag_emission.bitmap.filename else bitmap_large_emission = bitmap 150 150 color:(color 255 255 255)
				)
				else bitmap_large_emission = bitmap 150 150 color:(color 255 255 255)

				if img_tag_roughness.bitmap.filename != "" then
				(
					if doesfileexist img_tag_roughness.bitmap.filename then bitmap_large_roughness = openBitMap img_tag_roughness.bitmap.filename else bitmap_large_roughness = bitmap 150 150 color:(color 255 255 255)
				)
				else bitmap_large_roughness = bitmap 150 150 color:(color 255 255 255)
				
				if img_tag_metallicity.bitmap.filename != "" then
				(
					if doesfileexist img_tag_metallicity.bitmap.filename then bitmap_large_metallicity = openBitMap img_tag_metallicity.bitmap.filename else bitmap_large_metallicity = bitmap 150 150 color:(color 255 255 255) 
				)
				else bitmap_large_metallicity = bitmap 150 150 color:(color 255 255 255) 
				
				bitmap_small_ERM = img_tag_ERM.bitmap

				width = amax #(bitmap_large_emission.width, bitmap_large_roughness.width, bitmap_large_metallicity.width)
				height = amax #(bitmap_large_emission.height, bitmap_large_roughness.height, bitmap_large_metallicity.height)	

				bitmap_small_emission = bitmap width height color:(color 255 255 255) filename:bitmap_large_emission.filename
				bitmap_small_roughness = bitmap width height color:(color 255 255 255) filename:bitmap_large_roughness.filename
				bitmap_small_metallicity = bitmap width height color:(color 255 255 255) filename:bitmap_large_metallicity.filename
				
				bitmap_large_ERM = bitmap width height color:(color 255 255 255) alpha:false hdr:false gamma:1.0 --filename:(UDIMs.edt_multimat_path.text + "ERM.png") 
				
				copy bitmap_large_emission bitmap_small_emission
				copy bitmap_large_roughness bitmap_small_roughness
				copy bitmap_large_metallicity bitmap_small_metallicity
				
				line_bitmap_emission = #()
				line_bitmap_roughness = #()
				line_bitmap_metallicity = #()
				line_bitmap_ERM = #()

					for line_num in #{1..height} do
					(
						line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
						line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
						line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

						if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
						(		
							line_bitmap_ERM = #()
							for p in #{1..width} do 
							(
								p_emission = line_bitmap_emission[p]
								p_roughness = line_bitmap_roughness[p]
								p_metallicity = line_bitmap_metallicity[p]
								p_ERM = color (p_emission.r * spn_emission.value / 255) (p_roughness.g * spn_roughness.value / 255) (p_metallicity.b * spn_metallicity.value / 255)
								append line_bitmap_ERM p_ERM
							)	
						)				
						setPixels bitmap_large_ERM [0, line_num - 1] line_bitmap_ERM 
					)
	
					img_tag_ERM.bitmap = bitmap_small_ERM
					--edt_ERM.text = bitmap_large_ERM.filename
					if doesfileexist (getfilenamepath edt_ERM.text) then
					(
						bitmap_large_ERM.filename = edt_ERM.text
						save bitmap_large_ERM gamma:1.0 quiet:true --(UDIMs.edt_multimat_path.text + "ERM.png") 
					)
					close bitmap_large_ERM
					free bitmap_large_ERM
					close bitmap_small_emission
					close bitmap_small_roughness
					close bitmap_small_metallicity	
					free bitmap_small_emission
					free bitmap_small_roughness
					free bitmap_small_metallicity							
					close bitmap_large_emission						
					free bitmap_large_emission
					close bitmap_large_roughness
					free bitmap_large_roughness						
					close bitmap_large_metallicity
					free bitmap_large_metallicity
			)
			
			on TextureEditor open do
			(
				gc()
				img_tag_emission.bitmap = bitmap 150 150 color:(color ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer + 1))
				img_tag_roughness.bitmap = bitmap 150 150 color:(color ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer))
				img_tag_metallicity.bitmap = bitmap 150 150 color:(color ((255*spn_metallicity.value/255) as integer + 1) ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer))
				img_tag_ERM.bitmap = bitmap 150 150 color:(color ((255*spn_emission.value/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_metallicity.value/255) as integer))
			)
			
			on TextureEditor close do
			(
				gc()
				close img_tag_diffuse.bitmap
				close img_tag_emission.bitmap
				close img_tag_roughness.bitmap
				close img_tag_metallicity.bitmap
				close img_tag_ERM.bitmap
				free img_tag_diffuse.bitmap				
				free img_tag_emission.bitmap
				free img_tag_roughness.bitmap
				free img_tag_metallicity.bitmap
				free img_tag_ERM.bitmap				
			)
			
			on spn_emission changed valit do 
			(
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity
				
				val = if valit == 0 then 1 else valit 
				if img_tag_emission.bitmap.filename != "" then
				(
					if doesfileexist img_tag_emission.bitmap.filename then 
					(
						bitmap_large_emission = openBitMap img_tag_emission.bitmap.filename
						bitmap_small_emission = bitmap 150 150 filename:bitmap_large_emission.filename
						copy bitmap_large_emission bitmap_small_emission
						close bitmap_large_emission
						free bitmap_large_emission
					)
					else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) --bitmap_small_emission = bitmap 150 150 color:(color ((255*valit/255) as integer) ((255*valit/255) as integer) ((255*valit/255) as integer + 1))

				)
				else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255)

				if img_tag_roughness.bitmap.filename != "" then
				(
					if doesfileexist img_tag_roughness.bitmap.filename then 
					(					
						bitmap_large_roughness = openBitMap img_tag_roughness.bitmap.filename
						bitmap_small_roughness = bitmap 150 150 filename:bitmap_large_roughness.filename
						copy bitmap_large_roughness bitmap_small_roughness
						close bitmap_large_roughness
						free bitmap_large_roughness
					)
					else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) -- bitmap 150 150 color:(color ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer + 1))

				)
				else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer + 1))

				if img_tag_metallicity.bitmap.filename != "" then
				(
					if doesfileexist img_tag_metallicity.bitmap.filename then 
					(					
						bitmap_large_metallicity = openBitMap img_tag_metallicity.bitmap.filename
						bitmap_small_metallicity = bitmap 150 150 filename:bitmap_large_metallicity.filename
						copy bitmap_large_metallicity bitmap_small_metallicity
						close bitmap_large_metallicity
						free bitmap_large_metallicity
					)
					else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer + 1))

				)
				else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer + 1))

				bitmap_small_ERM = img_tag_ERM.bitmap
				
				line_bitmap_emission = #()
				line_bitmap_roughness = #()
				line_bitmap_metallicity = #()
				line_bitmap_ERM = #()

				width = 150 --pixels.width
				height = 150 --pixels.height				
				if bitmap_small_emission != undefined then
				(
					for line_num in #{1..height} do
					(
						line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
						line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
						line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

						if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
						(		
							line_bitmap_ERM = #()
							for p in #{1..width} do 
							(
								p_emission = line_bitmap_emission[p]
								p_roughness = line_bitmap_roughness[p]
								p_metallicity = line_bitmap_metallicity[p]
								p_ERM = color (p_emission.r * val / 255) (p_roughness.g * spn_roughness.value / 255) (p_metallicity.b * spn_metallicity.value / 255)
								append line_bitmap_ERM p_ERM
							)	
						)				
						line_bitmap_emission = for pixel in line_bitmap_emission collect (color (pixel.r * val / 255) (pixel.g * val / 255) (pixel.b * val / 255))
	
						setPixels bitmap_small_emission [0, line_num - 1] line_bitmap_emission 
						setPixels bitmap_small_ERM [0, line_num - 1] line_bitmap_ERM 
					)
					img_tag_emission.bitmap = bitmap_small_emission
					img_tag_ERM.bitmap = bitmap_small_ERM

					close bitmap_small_roughness
					close bitmap_small_metallicity				
					free bitmap_small_roughness
					free bitmap_small_metallicity	
				)
				--if img_tag_emission.bitmap.filename == "" and img_tag_roughness.bitmap.filename == "" and img_tag_metallicity.bitmap.filename == "" then 
				--(
				--	img_tag_emission.bitmap = bitmap 150 150 color:(color ((255*val/255) as integer) ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer + 1))
				--	img_tag_ERM.bitmap = bitmap 150 150 color:(color ((255*val/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_metallicity.value/255) as integer))
				--)
			)

			on spn_roughness changed valit do 
			(
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity
				
				val = if valit == 0 then 1 else valit 
				if img_tag_emission.bitmap.filename != "" then
				(
					if doesfileexist img_tag_emission.bitmap.filename then 
					(
						bitmap_large_emission = openBitMap img_tag_emission.bitmap.filename
						bitmap_small_emission = bitmap 150 150 filename:bitmap_large_emission.filename
						copy bitmap_large_emission bitmap_small_emission
						close bitmap_large_emission
						free bitmap_large_emission
					)
					else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer + 1))


				)
				else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer + 1))


				if img_tag_roughness.bitmap.filename != "" then
				(
					if doesfileexist img_tag_roughness.bitmap.filename then 
					(					
						bitmap_large_roughness = openBitMap img_tag_roughness.bitmap.filename
						bitmap_small_roughness = bitmap 150 150 filename:bitmap_large_roughness.filename
						copy bitmap_large_roughness bitmap_small_roughness
						close bitmap_large_roughness
						free bitmap_large_roughness
					)
					else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*valit/255) as integer) ((255*valit/255) as integer) ((255*valit/255) as integer + 1))

				)
				else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*valit/255) as integer) ((255*valit/255) as integer) ((255*valit/255) as integer + 1))

				if img_tag_metallicity.bitmap.filename != "" then
				(
					if doesfileexist img_tag_metallicity.bitmap.filename then 
					(					
						bitmap_large_metallicity = openBitMap img_tag_metallicity.bitmap.filename
						bitmap_small_metallicity = bitmap 150 150 filename:bitmap_large_metallicity.filename
						copy bitmap_large_metallicity bitmap_small_metallicity
						close bitmap_large_metallicity
						free bitmap_large_metallicity
					)
					else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer + 1))

				)
				else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer) ((255*spn_metallicity.value/255) as integer + 1))

				bitmap_small_ERM = img_tag_ERM.bitmap
				
				line_bitmap_emission = #()
				line_bitmap_roughness = #()
				line_bitmap_metallicity = #()
				line_bitmap_ERM = #()

				width = 150 --pixels.width
				height = 150 --pixels.height				
				if bitmap_small_roughness != undefined then
				(
					for line_num in #{1..height} do
					(
						line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
						line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
						line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

						if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
						(		
							line_bitmap_ERM = #()
							for p in #{1..width} do 
							(
								p_emission = line_bitmap_emission[p]
								p_roughness = line_bitmap_roughness[p]
								p_metallicity = line_bitmap_metallicity[p]
								p_ERM = color (p_emission.r * spn_emission.value / 255) (p_roughness.g * val / 255) (p_metallicity.b * spn_metallicity.value / 255)
								append line_bitmap_ERM p_ERM
							)	
						)				
						line_bitmap_roughness = for pixel in line_bitmap_roughness collect (color (pixel.r * val / 255) (pixel.g * val / 255) (pixel.b * val / 255))
	
						setPixels bitmap_small_roughness [0, line_num - 1] line_bitmap_roughness 
						setPixels bitmap_small_ERM [0, line_num - 1] line_bitmap_ERM 
					)
					img_tag_roughness.bitmap = bitmap_small_roughness
					img_tag_ERM.bitmap = bitmap_small_ERM

					close bitmap_small_emission
					close bitmap_small_metallicity				
					free bitmap_small_emission
					free bitmap_small_metallicity	
				)
			)

			on spn_metallicity changed valit do 
			(
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity
				
				val = if valit == 0 then 1 else valit 
				if img_tag_emission.bitmap.filename != "" then
				(
					if doesfileexist img_tag_emission.bitmap.filename then 
					(
						bitmap_large_emission = openBitMap img_tag_emission.bitmap.filename
						bitmap_small_emission = bitmap 150 150 filename:bitmap_large_emission.filename
						copy bitmap_large_emission bitmap_small_emission
						close bitmap_large_emission
						free bitmap_large_emission
					)
					else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer + 1))

				)
				else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer) ((255*spn_emission.value/255) as integer + 1))

				if img_tag_roughness.bitmap.filename != "" then
				(
					if doesfileexist img_tag_roughness.bitmap.filename then 
					(					
						bitmap_large_roughness = openBitMap img_tag_roughness.bitmap.filename
						bitmap_small_roughness = bitmap 150 150 filename:bitmap_large_roughness.filename
						copy bitmap_large_roughness bitmap_small_roughness
						close bitmap_large_roughness
						free bitmap_large_roughness
					)
					else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer + 1))

				)
				else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer) ((255*spn_roughness.value/255) as integer + 1))

				if img_tag_metallicity.bitmap.filename != "" then
				(
					if doesfileexist img_tag_metallicity.bitmap.filename then 
					(					
						bitmap_large_metallicity = openBitMap img_tag_metallicity.bitmap.filename
						bitmap_small_metallicity = bitmap 150 150 filename:bitmap_large_metallicity.filename
						copy bitmap_large_metallicity bitmap_small_metallicity
						close bitmap_large_metallicity
						free bitmap_large_metallicity
					)
					else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*valit/255) as integer) ((255*valit/255) as integer) ((255*valit.value/255) as integer + 1))

				)
				else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) --bitmap 150 150 color:(color ((255*valit/255) as integer) ((255*valit/255) as integer) ((255*valit/255) as integer + 1))

				bitmap_small_ERM = img_tag_ERM.bitmap
				
				line_bitmap_emission = #()
				line_bitmap_roughness = #()
				line_bitmap_metallicity = #()
				line_bitmap_ERM = #()

				width = 150 --pixels.width
				height = 150 --pixels.height				
				if bitmap_small_metallicity != undefined then
				(
					for line_num in #{1..height} do
					(
						line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
						line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
						line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

						if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
						(		
							line_bitmap_ERM = #()
							for p in #{1..width} do 
							(
								p_emission = line_bitmap_emission[p]
								p_roughness = line_bitmap_roughness[p]
								p_metallicity = line_bitmap_metallicity[p]
								p_ERM = color (p_emission.r * spn_emission.value / 255) (p_roughness.g * spn_roughness.value / 255) (p_metallicity.b * val / 255)
								append line_bitmap_ERM p_ERM
							)	
						)				
						line_bitmap_metallicity = for pixel in line_bitmap_metallicity collect (color (pixel.r * val / 255) (pixel.g * val / 255) (pixel.b * val / 255))
	
						setPixels bitmap_small_metallicity [0, line_num - 1] line_bitmap_metallicity
						setPixels bitmap_small_ERM [0, line_num - 1] line_bitmap_ERM 
					)
					img_tag_metallicity.bitmap = bitmap_small_metallicity
					img_tag_ERM.bitmap = bitmap_small_ERM

					close bitmap_small_roughness
					close bitmap_small_emission				
					free bitmap_small_roughness
					free bitmap_small_emission	
				)
			)
			
			on bnt_get_diffuse_map pressed do
			(
				source = getOpenFileName "Select Diffuse map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then	
					(
						img_tag_diffuse.bitmap = openBitMap source 
						edt_diffuse.text = source --getfilenamefile source + getfilenametype source
						edt_opacity.text = getfilenamepath (img_tag_diffuse.bitmap.filename) + getfilenamefile (img_tag_diffuse.bitmap.filename) + "_Opacity" + getfilenametype (img_tag_diffuse.bitmap.filename)
					)
				)
			)
			
			on btn_make_opacity_map pressed do
			(
				if img_tag_diffuse.bitmap.filename != "" then
				(
					source = if edt_opacity.text != "" then edt_opacity.text else getfilenamepath (img_tag_diffuse.bitmap.filename) + getfilenamefile (img_tag_diffuse.bitmap.filename) + "_Opacity" + getfilenametype (img_tag_diffuse.bitmap.filename)
					if doesfileexist (getfilenamepath source) then HiddenDOSCommand ("magick " + "\"" + img_tag_diffuse.bitmap.filename + "\"" + " -transparent black -alpha extract -define png:color-type=6 " + "\"" + source + "\"") startpath:(GetINI_ImageMagick())
					edt_opacity.text = source --getfilenamefile source + getfilenametype source
					img_tag_opacity.bitmap = openBitMap source				
				)
				else messagebox "Make Opacity texture first"
			)
			
			on img_tag_diffuse mousedown do try(display (openBitMap (img_tag_diffuse.bitmap.filename) ))catch(bnt_get_diffuse_map.pressed())
			on img_tag_opacity mousedown do try(display (openBitMap (img_tag_opacity.bitmap.filename) ))catch(messagebox "Make Opacity texture first")

			on img_tag_emission mousedown do try(display (openBitMap (img_tag_emission.bitmap.filename) ))catch(bnt_get_emission_map.pressed())
			on img_tag_roughness mousedown do try(display (openBitMap (img_tag_roughness.bitmap.filename) ))catch(bnt_get_roughness_map.pressed())
			on img_tag_metallicity mousedown do try(display (openBitMap (img_tag_metallicity.bitmap.filename) ))catch(bnt_get_metallicity_map.pressed())
				
			on bnt_get_emission_map pressed do
			(
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity
				source = getOpenFileName "Select Emission map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then 		
					(
						bitmap_large_emission = openBitMap source
						bitmap_small_emission = bitmap 150 150 filename:bitmap_large_emission.filename
						copy bitmap_large_emission bitmap_small_emission
						img_tag_emission.bitmap = bitmap_small_emission
						edt_emission.text = getfilenamefile source + getfilenametype source
						spn_emission.value = 255

						if img_tag_roughness.bitmap.filename != "" then
						(
							if doesfileexist img_tag_roughness.bitmap.filename then 
							(					
								bitmap_large_roughness = openBitMap img_tag_roughness.bitmap.filename
								bitmap_small_roughness = bitmap 150 150 filename:bitmap_large_roughness.filename
								copy bitmap_large_roughness bitmap_small_roughness
								close bitmap_large_roughness
								free bitmap_large_roughness
							)
							else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) 
						)
						else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255)
						
						if img_tag_metallicity.bitmap.filename != "" then
						(
							if doesfileexist img_tag_metallicity.bitmap.filename then 
							(					
								bitmap_large_metallicity = openBitMap img_tag_metallicity.bitmap.filename
								bitmap_small_metallicity = bitmap 150 150 filename:bitmap_large_metallicity.filename
								copy bitmap_large_metallicity bitmap_small_metallicity
								close bitmap_large_metallicity
								free bitmap_large_metallicity
							)
							else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255)
						)
						else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) 
						
						bitmap_small_ERM = img_tag_ERM.bitmap
						
						line_bitmap_emission = #()
						line_bitmap_roughness = #()
						line_bitmap_metallicity = #()
						line_bitmap_ERM = #()

						width = 150 
						height = 150 				
						if bitmap_small_metallicity != undefined then
						(
							for line_num in #{1..height} do
							(
								line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
								line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
								line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

								if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
								(		
									line_bitmap_ERM = #()
									for p in #{1..width} do 
									(
										p_emission = line_bitmap_emission[p]
										p_roughness = line_bitmap_roughness[p]
										p_metallicity = line_bitmap_metallicity[p]
										p_ERM = color (p_emission.r * spn_emission.value / 255) (p_roughness.g * spn_roughness.value / 255) (p_metallicity.b * spn_metallicity.value / 255)
										append line_bitmap_ERM p_ERM
									)	
								)				
								setPixels bitmap_small_ERM [0, line_num - 1] line_bitmap_ERM 
							)
							img_tag_ERM.bitmap = bitmap_small_ERM
							edt_erm.text = UDIMs.edt_multimat_path.text + getfilenamefile source + "_ERM.png" 
							close bitmap_small_roughness
							close bitmap_small_metallicity				
							free bitmap_small_roughness
							free bitmap_small_metallicity	
						)
					)
				)
			)				
				
			on bnt_get_roughness_map pressed do
			(
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity				
				source = getOpenFileName "Select Roughness map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then 		
					(
						bitmap_large_roughness = openBitMap source
						bitmap_small_roughness = bitmap 150 150 filename:bitmap_large_roughness.filename
						copy bitmap_large_roughness bitmap_small_roughness
						img_tag_roughness.bitmap = bitmap_small_roughness
						edt_roughness.text = getfilenamefile source + getfilenametype source
						spn_roughness.value = 255

						if img_tag_emission.bitmap.filename != "" then
						(
							if doesfileexist img_tag_emission.bitmap.filename then 
							(
								bitmap_large_emission = openBitMap img_tag_emission.bitmap.filename
								bitmap_small_emission = bitmap 150 150 filename:bitmap_large_emission.filename
								copy bitmap_large_emission bitmap_small_emission
								close bitmap_large_emission
								free bitmap_large_emission
							)
							else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) 
						)
						else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255)

						if img_tag_metallicity.bitmap.filename != "" then
						(
							if doesfileexist img_tag_metallicity.bitmap.filename then 
							(					
								bitmap_large_metallicity = openBitMap img_tag_metallicity.bitmap.filename
								bitmap_small_metallicity = bitmap 150 150 filename:bitmap_large_metallicity.filename
								copy bitmap_large_metallicity bitmap_small_metallicity
								close bitmap_large_metallicity
								free bitmap_large_metallicity
							)
							else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255)
						)
						else bitmap_small_metallicity = bitmap 150 150 color:(color 255 255 255) 
						
						bitmap_small_ERM = img_tag_ERM.bitmap
						
						line_bitmap_emission = #()
						line_bitmap_roughness = #()
						line_bitmap_metallicity = #()
						line_bitmap_ERM = #()

						width = 150 
						height = 150 				
						if bitmap_small_roughness != undefined then
						(
							for line_num in #{1..height} do
							(
								line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
								line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
								line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

								if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
								(		
									line_bitmap_ERM = #()
									for p in #{1..width} do 
									(
										p_emission = line_bitmap_emission[p]
										p_roughness = line_bitmap_roughness[p]
										p_metallicity = line_bitmap_metallicity[p]
										p_ERM = color (p_emission.r * spn_emission.value / 255) (p_roughness.g * spn_roughness.value / 255) (p_metallicity.b * spn_metallicity.value / 255)
										append line_bitmap_ERM p_ERM
									)	
								)				
								setPixels bitmap_small_ERM [0, line_num - 1] line_bitmap_ERM 
							)
							img_tag_ERM.bitmap = bitmap_small_ERM
							edt_erm.text = UDIMs.edt_multimat_path.text + getfilenamefile source + "_ERM.png" 
							close bitmap_small_emission
							close bitmap_small_metallicity				
							free bitmap_small_emission
							free bitmap_small_metallicity	
						)
					)
				)				
			)
			
			on bnt_get_metallicity_map pressed do
			(				
				local bitmap_large_emission, bitmap_small_emission
				local bitmap_large_roughness, bitmap_small_roughness
				local bitmap_large_metallicity, bitmap_small_metallicity
				source = getOpenFileName "Select Metallicity map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then 		
					(
						bitmap_large_metallicity = openBitMap source
						bitmap_small_metallicity = bitmap 150 150 filename:bitmap_large_metallicity.filename
						copy bitmap_large_metallicity bitmap_small_metallicity
						img_tag_metallicity.bitmap = bitmap_small_metallicity
						edt_metallicity.text = getfilenamefile source + getfilenametype source
						spn_metallicity.value = 255
						
						if img_tag_emission.bitmap.filename != "" then
						(
							if doesfileexist img_tag_emission.bitmap.filename then 
							(
								bitmap_large_emission = openBitMap img_tag_emission.bitmap.filename
								bitmap_small_emission = bitmap 150 150 filename:bitmap_large_emission.filename
								copy bitmap_large_emission bitmap_small_emission
								close bitmap_large_emission
								free bitmap_large_emission
							)
							else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255) 
						)
						else bitmap_small_emission = bitmap 150 150 color:(color 255 255 255)

						if img_tag_roughness.bitmap.filename != "" then
						(
							if doesfileexist img_tag_roughness.bitmap.filename then 
							(					
								bitmap_large_roughness = openBitMap img_tag_roughness.bitmap.filename
								bitmap_small_roughness = bitmap 150 150 filename:bitmap_large_roughness.filename
								copy bitmap_large_roughness bitmap_small_roughness
								close bitmap_large_roughness
								free bitmap_large_roughness
							)
							else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255) 
						)
						else bitmap_small_roughness = bitmap 150 150 color:(color 255 255 255)
						
						bitmap_small_ERM = img_tag_ERM.bitmap
						
						line_bitmap_emission = #()
						line_bitmap_roughness = #()
						line_bitmap_metallicity = #()
						line_bitmap_ERM = #()

						width = 150 
						height = 150 				
						if bitmap_small_metallicity != undefined then
						(
							for line_num in #{1..height} do
							(
								line_bitmap_emission = getPixels bitmap_small_emission [0, line_num - 1] width linear:true
								line_bitmap_roughness = getPixels bitmap_small_roughness [0, line_num - 1] width linear:true
								line_bitmap_metallicity = getPixels bitmap_small_metallicity [0, line_num - 1] width linear:true

								if line_bitmap_emission != undefined and line_bitmap_roughness != undefined and line_bitmap_metallicity != undefined then 
								(		
									line_bitmap_ERM = #()
									for p in #{1..width} do 
									(
										p_emission = line_bitmap_emission[p]
										p_roughness = line_bitmap_roughness[p]
										p_metallicity = line_bitmap_metallicity[p]
										p_ERM = color (p_emission.r * spn_emission.value / 255) (p_roughness.g * spn_roughness.value / 255) (p_metallicity.b * spn_metallicity.value / 255)
										append line_bitmap_ERM p_ERM
									)	
								)				
								setPixels bitmap_small_ERM [0, line_num - 1] line_bitmap_ERM 
							)
							img_tag_ERM.bitmap = bitmap_small_ERM
							edt_erm.text = UDIMs.edt_multimat_path.text + getfilenamefile source + "_ERM.png" 
							close bitmap_small_roughness
							close bitmap_small_emission				
							free bitmap_small_roughness
							free bitmap_small_emission	
						)
					)
				)				
			)				
		)
		addRollout TextureEditor BitmapsEDITOR
		
	)
	
	on btn_id_roll pressed do with undo "Offset IDs" on
	(
		for i in selection where classof i == editable_poly do
		(
			for j in #{1..(polyOp.getNumFaces i)} do polyop.setFaceMatID i #{j} (spn_id_roll.value + (polyop.getFaceMatID i j))
		)
	)
	
	on btn_Condense pressed do with undo "Condense IDs" on
	(
		/*
		local compilerParams = dotNetObject "System.CodeDom.Compiler.CompilerParameters" #(
			"System.dll", "System.Core.dll", getDir #maxRoot + "Autodesk.Max.dll",
			getDir #maxRoot + "\bin\assemblies\Autodesk.Max.Wrappers.dll")
		compilerParams.GenerateInMemory = on
	 
		local compilerResults = (dotNetObject "Microsoft.CSharp.CSharpCodeProvider").CompileAssemblyFromSource compilerParams #(
			"using System;
			using System.Linq;
			using System.Collections.Generic;
			using Autodesk.Max;
			using Autodesk.Max.Wrappers;
	 
			internal static class TabExtensions {
				public static IEnumerable<T> ToEnumerable<T>(this ITab<T> tab) {
					for (int i = 0; i < tab.Count; i++)
						yield return tab[i];
				}
			}
	 
			class Poly {
				internal static readonly IGlobal Global = GlobalInterface.Instance;
	 
				public static int[] GetSelectedObjMatIDs() {
					var pIgame = Global.IGameInterface;
					pIgame.InitialiseIGame(true);
					pIgame.SetStaticFrame(0);
	 
					using (var currNode = Global.COREInterface.GetSelNode(0))
					using (var gameNode = pIgame.GetIGameNode(currNode))
					using (var gameMesh = Global.IGameMesh.Marshal((gameNode.IGameObject as Autodesk.Max.Wrappers.IGameObject).INativeObject__NativePointer)) {
						return gameMesh.InitializeData ? gameMesh.ActiveMatIDs.ToEnumerable().Select(id => id + 1).ToArray() : new int[0];
					}
				}
			}"
		)
		::poly = compilerResults.CompiledAssembly.CreateInstance "Poly"

		if selection.count == 1 and isKindOf selection[1] GeometryClass do 
		(
			IDs = #()
			IDs = Poly.GetSelectedObjMatIDs()
			print #(IDs)
		)
		*/		
		
		if selection.count == 1 and classof selection[1] == Editable_Poly and selection[1].material != undefined and classof selection[1].material == Multimaterial then
		(
			max modify mode
			s = selection[1]
			ss = copy s
			ss.name = s.name + "_new"
			
			ids_mat = s.material.materialIDList
			ids_obj = #()
			for id in ids_mat where not keyboard.escPressed do 
			(
				s.selectbymaterial id clearCurrentSelection:true
				faceSel = #{}
				faceSel = polyOp.getFaceSelection s
				if not faceSel.isempty then appendIfUnique ids_obj id
			)
			print #(ids_obj)
			print #(ids_mat)
			
			ids_new = #{}
			id_new = 0
			m = multimaterial numsubs:1 name:(s.material.name + "_new")
			ss.material = m
			for id in ids_obj do
			(
				id_new += 1
				m.numsubs = id_new
				m.materialList[id_new] = copy s.material.materialList[id]
				m.materialList[id_new].name = s.material.materialList[id].name
				m.names[id_new] = s.material.names[id]
				ss.selectbymaterial id clearCurrentSelection:true
				faceSel = #{}
				faceSel = polyOp.getFaceSelection ss
				if not faceSel.isempty then polyop.setFaceMatID ss faceSel id_new			
			)
			
			
			/*
			for i in selection where classof i == editable_poly do
			(
				IDs = for j in #{1..(polyOp.getNumFaces i)} collect polyop.getFaceMatID i j
				(
					polyop.setFaceMatID i #{j} (spn_id_roll.value + (polyop.getFaceMatID i j))
				)
			)
			*/
		)
	)
	
	on btn_transfer_edges pressed do
	(
		if selection.count == 1 then transfer_edges()
	)
	
	on btn_edges_selector rightclick do
	(
		Obj_Spln.chk_DetriangulateSel.checked = true --?????? ????????
		Obj_Spln.chk_DetriangulateUV.checked = true
		Obj_Spln.chk_DetriangulateSM.checked = true
		Obj_Spln.chk_DetriangulateAn.checked	= true
		Obj_Spln.spn_DetriangulateAngle.value = 10.0
		--chk_DetriangulateDisputed.checked = false
		Obj_Spln.btn_Detriangulate.pressed()
		Obj_Spln.chk_DetriangulateSel.checked = false
	)
	
	on btn_edges_selector pressed do
	(
		if selection.count == 1 and selection[1].modifiers.count == 0 and classof selection[1].baseobject == Editable_Poly then
		(
			max create mode
			sel = selection[1]
			t = 0.01
			need = #{}
			for edge in #{1..polyop.getNumEdges sel} do
			(
				verts = polyop.getVertsUsingEdge sel edge
				poses = for v in verts collect polyop.getVert sel v
				if abs (poses[1].x - poses[2].x) <= t or abs (poses[1].y - poses[2].y) <= t then append need edge 
			)
			polyop.setEdgeSelection sel need
			max modify mode
			try(subobjectlevel = 2)catch()
		)
		else messagebox "Select single editable poly object."
	)
	
	on btn_poly_to_edges_selector pressed do
	(
		if keyboard.controlPressed then --????????? ????????????? ?????
		(
			Obj_Spln.chk_DetriangulateSel.checked = true --?????? ????????
			Obj_Spln.chk_DetriangulateUV.checked = true
			Obj_Spln.chk_DetriangulateSM.checked = true
			Obj_Spln.chk_DetriangulateAn.checked	= true
			Obj_Spln.spn_DetriangulateAngle.value = 10.0
			--Obj_Spln.chk_DetriangulateDisputed.checked = false
			Obj_Spln.btn_Detriangulate.pressed()
			Obj_Spln.chk_DetriangulateSel.checked = false
		)
		else
		if selection.count == 1 and selection[1].modifiers.count == 0 and classof selection[1].baseobject == Editable_Poly then --????????? ?????? ???????????? ?????
		(
			max create mode
			sel = selection[1]
			t = 0.01
			need = #{}
			edges = #{}
			polys = if (polyop.getFaceSelection sel).numberset > 0 then polyop.getFaceSelection sel else #{1..polyop.getNumFaces sel}
			polys_other = #{1..polyop.getNumFaces sel} - polys
			edges = polyop.getEdgesUsingFace sel polys
			edges_other = polyop.getEdgesUsingFace sel polys_other
			
			for edge in edges do
			(
				verts = polyop.getVertsUsingEdge sel edge
				poses = for v in verts collect polyop.getVert sel v
				if abs (poses[1].x - poses[2].x) <= t or abs (poses[1].y - poses[2].y) <= t then append need edge 
			)
			need += edges * edges_other --???? ?????????			
			
			polyop.setEdgeSelection sel need
			max modify mode
			try(subobjectlevel = 2)catch()
			--transfer_edges()
		)
		else messagebox "Select single editable poly object."
	)

/*	
	on btn_UdimFit pressed do
	(
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		sc = 1.0
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.numberset > 0 then
			(
				unwrapmod.faceToVertSelect()
				verts = unwrapmod.getSelectedVertices()
				poi_x = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).x)
				poi_y = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).y)
				sc = if abs (amax poi_y - amin poi_y) >= abs (amax poi_x - amin poi_x) then spn_bricks_unwrap_sc.value/(amax poi_y - amin poi_y) else spn_bricks_unwrap_sc.value/(amax poi_x - amin poi_x)
				print sc
				unwrapmod.scaleSelectedCenter sc 0
				pos = unwrapmod.getSelCenter()
				print pos
				format "offset: x = %, y = %\n" (0.5 - pos.x) (0.5 - pos.y)
				unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0]
				
				if chk_UdimFit.checked then
				(

				)					
			)
		)		
	)
*/

	on btn_UdimFit pressed do with undo "Fit texels to UDIM" on
	(
		local ctrl = keyboard.controlPressed
		local alt = keyboard.altPressed
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		sc = 1.0
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.numberset > 0 then
			(
				unwrapmod.faceToVertSelect()
				verts = unwrapmod.getSelectedVertices()
				poi_x = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).x)
				poi_y = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).y)
				sc = if abs (amax poi_y - amin poi_y) >= abs (amax poi_x - amin poi_x) then spn_bricks_unwrap_sc.value/(amax poi_y - amin poi_y) else spn_bricks_unwrap_sc.value/(amax poi_x - amin poi_x)
				--print sc
				pos_ini = unwrapmod.getSelCenter()
				unwrapmod.scaleSelectedCenter sc 0
				pos = unwrapmod.getSelCenter()
				--print pos
				if ctrl then unwrapmod.moveSelected [pos_ini.x as integer + 0.5 - pos.x, pos_ini.y as integer + 0.5 - pos.y, 0] else unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0]
				pos2 = unwrapmod.getSelCenter()

				if chk_UdimFit.checked then
				(
					format "scale=% ini_pos:% fin_pos:% offset:x=%, y=% \n" sc pos pos2 (0.5 - pos.x) (0.5 - pos.y)
					if alt then
					(
						arr = #()
						rez = case rdo_tex.state of
						(
							1: 256
							2: 512
							3: 1024
							4: 2048
							5: 4096
						)
						m = selection[1].material
						if m != undefined then
						(
							case (classof m) of
							(
								--??? multitile --for i in #{1..$.material.base_color_map.tileCount()} collect ($.material.base_color_map.getTileTexmap i).filename
								Multimaterial: 
								(	
									ids = #()
									id = 1
									for f in faces where not keyboard.escPressed do
									( 
										unwrapmod.selectfaces #{f}
										id = unwrapmod.getSelectMatID()
										appendIfUnique ids id
										--exit
									)
									unwrapmod.selectfaces faces
									if ids.count > 0 then
									(
										for id in ids where id != undefined and id > 0 do 
										(
											sub_m = m.materialList[id]
											case classof sub_m of
											(
												CoronaLegacyMtl:
												(
													if sub_m.texmapDiffuse != undefined then (render_map sub_m.texmapDiffuse rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapDiffuse = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapReflect != undefined then (render_map sub_m.texmapReflect rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapReflect = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapReflectGlossiness != undefined then (render_map sub_m.texmapReflectGlossiness rez (t = edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapReflectGlossiness = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapRefract != undefined then (render_map sub_m.texmapRefract rez (t = edt_multimat_path.text + sub_m.name + "_Refract" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapRefract = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapRefractGlossiness != undefined then (render_map sub_m.texmapRefractGlossiness rez (t = edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapRefractGlossiness = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapOpacity != undefined then (render_map sub_m.texmapOpacity rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapOpacity = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapBump != undefined then (render_map sub_m.texmapBump rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapBump = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapTranslucency != undefined then (render_map sub_m.texmapTranslucency rez (t = edt_multimat_path.text + sub_m.name + "_Translucency" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapTranslucency = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapDisplace != undefined then (render_map sub_m.texmapDisplace rez (t = edt_multimat_path.text + sub_m.name + "_Displace" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapDisplace = bitmaptexture filename:(t + ".png"))
												)

												CoronaPhysicalMtl:
												(
													if sub_m.baseTexmap != undefined then (render_map sub_m.baseTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseTexmap = bitmaptexture filename:(t + ".png"))
													if sub_m.baseRoughnessTexmap != undefined then (render_map sub_m.baseRoughnessTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseRoughnessTexmap = bitmaptexture filename:(t + ".png"))
													if sub_m.baseBumpTexmap != undefined then (render_map sub_m.baseBumpTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseBumpTexmap = bitmaptexture filename:(t + ".png"))
													if sub_m.opacityTexmap != undefined then (render_map sub_m.opacityTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseBumpTexmap = bitmaptexture filename:(t + ".png"))
												)
								
												Physical_Material:
												(
													if sub_m.base_color_map != undefined then (render_map sub_m.base_color_map rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.base_color_map = bitmaptexture filename:(t + ".png"))
													if sub_m.roughness_map != undefined then (render_map sub_m.roughness_map rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.roughness_map = bitmaptexture filename:(t + ".png"))
													if sub_m.bump_map != undefined then (render_map sub_m.bump_map rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.bump_map = bitmaptexture filename:(t + ".png"))
													if sub_m.cutout_map != undefined then (render_map sub_m.cutout_map rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.bump_map = bitmaptexture filename:(t + ".png"))
													--emission_map 
													--emit_color
													--metalness_map
												)
								
												Standardmaterial:
												(
													if sub_m.DiffuseMap != undefined then (render_map sub_m.DiffuseMap rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
													if sub_m.ReflectionMap != undefined then (render_map sub_m.ReflectionMap rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.ReflectionMap = bitmaptexture filename:(t + ".png"))
													if sub_m.BumpMap != undefined then (render_map sub_m.BumpMap rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.BumpMap = bitmaptexture filename:(t + ".png"))
													if sub_m.OpacityMap != undefined then (render_map sub_m.OpacityMap rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
													--GlossinessMap 
												)

												Vraymtl:
												(
													if sub_m.texmap_diffuse != undefined then (render_map sub_m.texmap_diffuse rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
													if sub_m.texmap_reflection != undefined then (render_map sub_m.texmap_reflection rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.ReflectionMap = bitmaptexture filename:(t + ".png"))
													if sub_m.texmap_bump != undefined then (render_map sub_m.texmap_bump rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.BumpMap = bitmaptexture filename:(t + ".png"))
													if sub_m.texmap_opacity != undefined then (render_map sub_m.texmap_opacity rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
												)
												
												default: (messageBox "Do not supported this type of sub-material")
											)
										)
									)
								)
								
								default: (messageBox "Do not supported this type of material, use only Multimaterial")
							)
							/*
							if arr.count > 0 then
							(								
								for sourcepath in arr do 
								(									
									finalpath = (getfilenamepath sourcepath) + (getfilenamefile sourcepath) + "_fit.png"
									HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:(GetINI_ImageMagick())
									wid = rez
									hei = rez
									x_ = -(pos.x - 0.5)
									y_ = -(pos.y - 0.5)
									x = ((x_ * wid ) as integer) 
									y = ((y_ * hei ) as integer) 
									x = if x >= 0 then "+" + (x as string) else (x as string)
									y = if y >= 0 then "+" + (y as string) else (y as string)
									
									format "scale=% x=% % y=% %\n" sc x_ x y_ y
									
									cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
									--print cmd
									
									HiddenDOSCommand cmd startpath:(GetINI_ImageMagick())
									--HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -distort SRT '" + X + "," + Y + " " + sc + " 0 " + NewX + "," + NewY + "'" + "\"" + sourcepath + ".png" + "\"") startpath:(GetINI_ImageMagick())
									HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:(GetINI_ImageMagick())	
								)
							)	
							*/
						)
					)
					else
					(
						sourcepath = getOpenFileName "Select file for fit map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
						print sourcepath
						if sourcepath != undefined then
						(
							--??????????????
							may_backup_file = false
							finalpath = sourcepath
							if getfilenamepath sourcepath != edt_multimat_path.text then
							(
								messagebox "Output file will be renamed and placed near initial as .png file.\nChange material to see it.\nInitial file will be not changed."
								finalpath = sourcepath + ".png"
								may_backup_file = false
							)
							else 
							(
								messagebox "Initial file will be backuped and placed near output as +(.png) file.\nFinal file will be saved as .png with initial name and may be overwritten."
								may_backup_file = true
								finalpath = (getfilenamepath sourcepath) + (getfilenamefile sourcepath) + ".png"
							)
		
							a = openBitMap sourcepath
							
							if a != undefined then
							(
								if doesfileexist (sourcepath + ".png") then deletefile (sourcepath + ".png")
								if not doesfileexist (sourcepath + ".png") and may_backup_file then copyfile sourcepath (sourcepath + ".png")
								
								hei = a.height
								wid = a.width 
								close a
								free a

								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -distort SRT '" + X + "," + Y + " " + "1" + " 0 " + NewX + "," + NewY + "' " + "\"" + sourcepath + ".png" + "\"")
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile  -distort SRT '0 90' " + "\"" + sourcepath + ".png" + "\"")
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -resize 50% -virtual-pixel tile -extent 2048x2048 -roll +200+200 " + "\"" + sourcepath + ".png" + "\"")
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -resize 50% -virtual-pixel tile -extent 2048x2048 -roll +200+200 " + "\"" + sourcepath + ".png" + "\"")
								
								--print ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"")
								HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:(GetINI_ImageMagick())
							
								x_ = -(pos.x - 0.5)
								y_ = -(pos.y - 0.5)
								x = ((x_ * wid ) as integer) 
								y = ((y_ * hei ) as integer) 
								x = if x >= 0 then "+" + (x as string) else (x as string)
								y = if y >= 0 then "+" + (y as string) else (y as string)
								
								format "scale=% x=% % y=% %\n" sc x_ x y_ y
								
								cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
								--print cmd
								
								HiddenDOSCommand cmd startpath:(GetINI_ImageMagick())
								--HiddenDOSCommand ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -distort SRT '" + X + "," + Y + " " + sc + " 0 " + NewX + "," + NewY + "'" + "\"" + sourcepath + ".png" + "\"") startpath:(GetINI_ImageMagick())
								HiddenDOSCommand ("magick  " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:(GetINI_ImageMagick())	
								--deletefile (sourcepath + ".png")
							)
						)
					)
				)					
			)
		)		
	)
	
	on btn_UdimFit rightclick do with undo "Fit texture to Unwrap" on
	(
		local ctrl = keyboard.controlPressed
		local alt = keyboard.altPressed
		max modify mode
		--sel_ini = selection[1]
		--sel = copy sel_ini
		--select sel
		local sel = selection[1]
		local unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		local sc = 1.0
		local pos_ini, pos, pos2
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			local faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.numberset > 0 then
			(
				local mX, mY, mWidth, mHeight, mAreaUVW, mAreaGeom
				unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
				format "mWidth=% mHeight=% mX=% mY=%\n" mWidth mHeight mX mY
				if mHeight <= 1.0 and mWidth <= 1.0 then
				(
					sc = if mHeight >= mWidth then mHeight else mWidth
					--sc = if mHeight >= mWidth then 1/mHeight else 1/mWidth
					--unwrapmod.moveSelected [0.5 - pos_ini.x, 0.5 - pos_ini.y, 0]
					pos = unwrapmod.getSelCenter()
					--unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter sc 0
					--pos2 = unwrapmod.getSelCenter()

					
					--format "scale=% ini_pos:% offset:x=%, y=% \n" sc pos (0.5 - pos.x) (0.5 - pos.y)

					if alt then
					(
						arr = #()
						rez = case rdo_tex.state of
						(
							1: 256
							2: 512
							3: 1024
							4: 2048
							5: 4096
						)
						m = selection[1].material
						if m != undefined then
						(
							case (classof m) of
							(
								--??? multitile --for i in #{1..$.material.base_color_map.tileCount()} collect ($.material.base_color_map.getTileTexmap i).filename
								Multimaterial: 
								(	
									ids = #()
									id = 1
									for f in faces where not keyboard.escPressed do
									( 
										unwrapmod.selectfaces #{f}
										id = unwrapmod.getSelectMatID()
										appendIfUnique ids id
										--exit
									)
									unwrapmod.selectfaces faces
									if ids.count > 0 then
									(
										for id in ids where id != undefined and id > 0 do 
										(
											sub_m = m.materialList[id]
											case classof sub_m of
											(
												CoronaLegacyMtl:
												(
													if sub_m.texmapDiffuse != undefined then (render_map sub_m.texmapDiffuse rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapDiffuse = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapReflect != undefined then (render_map sub_m.texmapReflect rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapReflect = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapReflectGlossiness != undefined then (render_map sub_m.texmapReflectGlossiness rez (t = edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapReflectGlossiness = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapRefract != undefined then (render_map sub_m.texmapRefract rez (t = edt_multimat_path.text + sub_m.name + "_Refract" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapRefract = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapRefractGlossiness != undefined then (render_map sub_m.texmapRefractGlossiness rez (t = edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapRefractGlossiness = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapOpacity != undefined then (render_map sub_m.texmapOpacity rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapOpacity = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapBump != undefined then (render_map sub_m.texmapBump rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapBump = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapTranslucency != undefined then (render_map sub_m.texmapTranslucency rez (t = edt_multimat_path.text + sub_m.name + "_Translucency" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapTranslucency = bitmaptexture filename:(t + ".png"))
													if sub_m.texmapDisplace != undefined then (render_map sub_m.texmapDisplace rez (t = edt_multimat_path.text + sub_m.name + "_Displace" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.texmapDisplace = bitmaptexture filename:(t + ".png"))
												)

												CoronaPhysicalMtl:
												(
													if sub_m.baseTexmap != undefined then (render_map sub_m.baseTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseTexmap = bitmaptexture filename:(t + ".png"))
													if sub_m.baseRoughnessTexmap != undefined then (render_map sub_m.baseRoughnessTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseRoughnessTexmap = bitmaptexture filename:(t + ".png"))
													if sub_m.baseBumpTexmap != undefined then (render_map sub_m.baseBumpTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseBumpTexmap = bitmaptexture filename:(t + ".png"))
													if sub_m.opacityTexmap != undefined then (render_map sub_m.opacityTexmap rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.baseBumpTexmap = bitmaptexture filename:(t + ".png"))
												)
								
												Physical_Material:
												(
													if sub_m.base_color_map != undefined then (render_map sub_m.base_color_map rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.base_color_map = bitmaptexture filename:(t + ".png"))
													if sub_m.roughness_map != undefined then (render_map sub_m.roughness_map rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.roughness_map = bitmaptexture filename:(t + ".png"))
													if sub_m.bump_map != undefined then (render_map sub_m.bump_map rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.bump_map = bitmaptexture filename:(t + ".png"))
													if sub_m.cutout_map != undefined then (render_map sub_m.cutout_map rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.bump_map = bitmaptexture filename:(t + ".png"))
													--emission_map 
													--emit_color
													--metalness_map
												)
								
												Standardmaterial:
												(
													if sub_m.DiffuseMap != undefined then (render_map sub_m.DiffuseMap rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
													if sub_m.ReflectionMap != undefined then (render_map sub_m.ReflectionMap rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.ReflectionMap = bitmaptexture filename:(t + ".png"))
													if sub_m.BumpMap != undefined then (render_map sub_m.BumpMap rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.BumpMap = bitmaptexture filename:(t + ".png"))
													if sub_m.OpacityMap != undefined then (render_map sub_m.OpacityMap rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
													--GlossinessMap 
												)	

												Vraymtl:
												(
													if sub_m.texmap_diffuse != undefined then (render_map sub_m.texmap_diffuse rez (t = edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
													if sub_m.texmap_reflection != undefined then (render_map sub_m.texmap_reflection rez (t = edt_multimat_path.text + sub_m.name + "_Reflect" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.ReflectionMap = bitmaptexture filename:(t + ".png"))
													if sub_m.texmap_bump != undefined then (render_map sub_m.texmap_bump rez (t = edt_multimat_path.text + sub_m.name + "_Bump" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.BumpMap = bitmaptexture filename:(t + ".png"))
													if sub_m.texmap_opacity != undefined then (render_map sub_m.texmap_opacity rez (t = edt_multimat_path.text + sub_m.name + "_Opacity" + ".png"); fit_map t (t + ".png") pos sc rez (GetINI_ImageMagick()); sub_m.DiffuseMap = bitmaptexture filename:(t + ".png"))
												)												
											)
										)
									)
								)
							)

						)
					)
					else
					(
						local sourcepath = getOpenFileName "Select file for fit map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
						print sourcepath
						if sourcepath != undefined then
						(
							--??????????????
							local may_backup_file = false
							local finalpath = sourcepath + ".png"
							if getfilenamepath sourcepath != edt_multimat_path.text then
							(
								messagebox "Output file will be renamed and placed near initial as .png file.\nChange material to see it.\nInitial file will be not changed."
								finalpath = sourcepath + ".png"
								may_backup_file = false
							)
							else 
							(
								messagebox "Initial file will be backuped and placed near output as +(.png) file.\nFinal file will be saved as .png with initial name and may be overwritten."
								may_backup_file = true
								finalpath = (getfilenamepath sourcepath) + (getfilenamefile sourcepath) + ".png"
							)
/*
							local rez = 4096
								
							a = openBitMap sourcepath
							
							if a != undefined then
							(
								if doesfileexist (sourcepath + ".png") then deletefile (sourcepath + ".png")
								if not doesfileexist (sourcepath + ".png") and may_backup_file then copyfile sourcepath (sourcepath + ".png")
								
								hei = a.height
								wid = a.width 
								close a
								free a
								
								if hei != undefined and wid != undefined then
								(
									if hei == wid then rez = hei
									else rez = 4096 
								)
							)
*/							
					

							fit_map_edge sourcepath finalpath pos sc mX mY mWidth mHeight (GetINI_ImageMagick())	
								
							/*	
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -distort SRT '" + X + "," + Y + " " + "1" + " 0 " + NewX + "," + NewY + "' " + "\"" + sourcepath + ".png" + "\"")
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -distort SRT '0 90' " + "\"" + sourcepath + ".png" + "\"")
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -resize 50% -virtual-pixel tile -extent 2048x2048 -roll +200+200 " + "\"" + sourcepath + ".png" + "\"")
								--cmd = ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -resize 50% -virtual-pixel tile -extent 2048x2048 -roll +200+200 " + "\"" + sourcepath + ".png" + "\"")
								
								--print ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"")
								HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:(GetINI_ImageMagick())
							
								x_ = 0.5 - pos.x --mX-pos.x -- - mX --0.5 - pos.x
								y_ = 0.5 - pos.y --mY-pos.y -- - mY --0.5 - pos.y
								x = ((x_ * wid) as integer) 
								y = ((y_ * hei) as integer) 
								x = if x >= 0 then "+" + (x as string) else (x as string)
								y = if y >= 0 then "+" + (y as string) else (y as string)
								
								format "scale=% x=% % y=% %\n" sc x_ x y_ y
								
								cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel edge -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
								print cmd
								
								HiddenDOSCommand cmd startpath:(GetINI_ImageMagick())
								--HiddenDOSCommand ("convert " + "\"" + sourcepath + "\"" + " -virtual-pixel tile -distort SRT '" + X + "," + Y + " " + sc + " 0 " + NewX + "," + NewY + "'" + "\"" + sourcepath + ".png" + "\"") startpath:(GetINI_ImageMagick())
								HiddenDOSCommand ("convert " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:(GetINI_ImageMagick())	
								--deletefile (sourcepath + ".png")
								*/
							--)
						)
					)
				)
				else
				(
					messagebox "Selected object have unwrap larger than one UDIM, no need to upscale texture." 
				)
			)
		)		
	)	
	
	on btn_UdimLeft pressed do
	(
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.count > 0 then
			(
				unwrapmod.moveSelected [-1.0, 0.0, 0.0]
			)
		)
	)
	
	on btn_UdimRight pressed do
	(
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.count > 0 then
			(
				unwrapmod.moveSelected [1.0, 0.0, 0.0]
			)
		)
	)
	
	on btn_UdimUp pressed do
	(
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.count > 0 then
			(
				unwrapmod.moveSelected [0.0, 1.0, 0.0]
			)
		)
	)
	
	on btn_UdimDown pressed do
	(
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
			if faces.count > 0 then
			(
				unwrapmod.moveSelected [0.0, -1.0, 0.0]
			)
		)
	)

	on btn_unwrap_lowpoly_from_material pressed do with undo "Unwrap Atlas" on 
	(
		if selection.count > 0 then
		(
			if selection.count >= 2 then
			(
				sel = selection as Array
				converttopoly sel[1]
				for s in #{2..sel.count} do 
				(
					converttopoly sel[s]
					polyop.attach sel[1] sel[s]
				)
				select sel[1]
			)
			if selection.count == 1 then converttopoly selection[1]
		)
		
		if selection.count == 1 then
		(
			if selection[1].material != undefined then
			(
				--local atlas_size = 2048 
				local atlas_size = case (ddl_size_atlas.selection as integer) of
				(
					1: 256
					2: 512
					3: 1024
					4: 2048
					5: 4096
				)
				
				local rez = 1024				
				local size_thumb = 256
				
				local i = selection[1]
				local m = selection[1].material 
				local num = if classof (selection[1].material) == Multimaterial then selection[1].material.numsubs else 0
				local nam = substituteString (selection[1].name) "SM_" "T_"

				local ids_colors = #()
				
				local alt = not keyboard.altPressed
				local ctrl = keyboard.controlPressed
				local shift = keyboard.shiftPressed
				
				local start = GetINI_ImageMagick()
				
/*				
				for i in #{1..num} do 
				(
					print ((classof m.materialList[i]) as string) 
					case ((classof m.materialList[i]) as string) of 
					(
						
						"UndefinedClass": continue 
						
						"Standard":
						(
							if m.materialList[i].DiffuseMap == undefined then 
							(
								append colors (m.materialList[i].Diffuse)
								append ids_colors i
							)
						)
						
						"Physical_Material":
						(
							if m.materialList[i].base_color_map == undefined then 
							(
								append colors (m.materialList[i].base_color)
								append ids_colors i
							)
							
						)
						
						"CoronaLegacyMtl":
						(
							if m.materialList[i].texmapDiffuse == undefined then 
							(
								append colors (m.materialList[i].colorDiffuse) 
								append ids_colors i
							)
						)
					)
					
				)
*/

				if not doesDirectoryExist edt_multimat_path.text then makedir edt_multimat_path.text
				print edt_multimat_path.text
				print i
				print (classof m)
				makedir (edt_multimat_path.text + "rendered_textures\\")
				
				difuse = edt_multimat_path.text + "rendered_textures\\" + nam + "_Diffuse_" + ".png"
				normal = edt_multimat_path.text + "rendered_textures\\" + nam + "_Normal_" + ".png"
				erm = edt_multimat_path.text + "rendered_textures\\" + nam + "_ERM_" + ".png"
				opacity = edt_multimat_path.text + "rendered_textures\\" + nam + "_Opacity_" + ".png"
		
				case (classof m) of
				(
					default: (messagebox "No support this single type of material yet")	
					
					CoronaPhysicalMtl: (messagebox "No support for single CoronaPhysicalMtl yet")
					Physical_Material: (messagebox "No support for single Physical_Material yet")
					Standardmaterial: (messagebox "No support for single Standardmaterial yet")
					CoronaLayeredMtl: (messagebox "No support for single CoronaLayeredMtl yet")
					
					CoronaLegacyMtl: 
					(
						if m.texmapDiffuse != undefined then
						(
							--if isProperty sub_m.texmapDiffuse #filename then copy_mat sub_m.texmapDiffuse.filename difuse (GetINI_ImageMagick())
							--else render_map sub_m.texmapDiffuse rez difuse
							render_map_rect m.texmapDiffuse rez size_thumb difuse ctrl start "Diffuse"
						)
						else if not doesfileexist difuse then
						(
							HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX m.colorDiffuse + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
							--b = bitmap 256 256 filename:difuse color:m.colorDiffuse gamma:1.0 hdr:false
							--save b gamma:1.0 quiet:true
							--close b
							--free b
							--HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
							HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start
						)

						if m.texmapBump != undefined then
						(		
							--if isProperty sub_m.texmapBump #filename then copy_mat sub_m.texmapBump.filename normal (GetINI_ImageMagick())
							--else render_map sub_m.texmapBump rez normal
							render_map_rect m.texmapBump rez size_thumb normal ctrl start "Bump"
						)
						else if not doesfileexist normal then
						(			
							HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
							--b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
							--save b gamma:1.0 quiet:true
							--close b
							--free b
							--HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
							HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start --(GetINI_ImageMagick())
						)
										
						if m.texmapReflect != undefined then
						(
							--if isProperty sub_m.texmapReflect #filename then copy_mat sub_m.texmapReflect.filename erm (GetINI_ImageMagick())
							--else render_map sub_m.texmapReflect rez erm
							render_map_rect m.texmapReflect rez size_thumb erm	ctrl start "Reflect"
						)
						else if not doesfileexist erm then
						(		
							HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
							--b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
							--save b gamma:1.0 quiet:true
							--close b
							--free b
							--HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
							HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start --(GetINI_ImageMagick())
						)

						if m.texmapOpacity != undefined then
						(
							--if isProperty sub_m.texmapOpacity #filename then copy_mat sub_m.texmapOpacity.filename opacity (GetINI_ImageMagick())
							--else render_map sub_m.texmapOpacity rez opacity
							render_map_rect m.texmapOpacity rez size_thumb opacity	ctrl start "Opacity"
						)
						else if not doesfileexist opacity then
						(	
							HiddenDOSCommand ("magick -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " +  "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
							--b = bitmap 256 256 filename:opacity color:white gamma:1.0 hdr:false
							--save b gamma:1.0 quiet:true
							--close b
							--free b
							--HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " -alpha remove -alpha off " + "\"" + opacity + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
							HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " PNG24:" + "\""+ opacity + "\"") startpath:start --(GetINI_ImageMagick())
						)

						--if sub_m.texmapReflect != undefined then render_map sub_m.texmapReflect rez (edt_multimat_path.text + sub_m.name + "_Reflect" + ".png")
						--if sub_m.texmapReflectGlossiness != undefined then render_map sub_m.texmapReflectGlossiness rez (edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png")
						--if sub_m.texmapRefract != undefined then render_map sub_m.texmapRefract rez (edt_multimat_path.text + sub_m.name + "_Refract" + ".png")
						--if sub_m.texmapRefractGlossiness != undefined then render_map sub_m.texmapRefractGlossiness rez (edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png")
						--if sub_m.texmapTranslucency != undefined then render_map sub_m.texmapTranslucency rez (edt_multimat_path.text + sub_m.name + "_Translucency" + ".png")
						--if sub_m.texmapDisplace != undefined then render_map sub_m.texmapDisplace rez (edt_multimat_path.text + sub_m.name + "_Displace" + ".png")
						--if sub_m.texmapSelfIllum != undefined then render_map sub_m.texmapSelfIllum rez (edt_multimat_path.text + sub_m.name + "_SelfIllum" + ".png")
						
						id = 1
						
						--append ids_colors #(id, amax #((d = openBitMap difuse).width, d.height, (n = openBitMap normal).width, n.height, (e = openBitMap erm).width, e.height, (o = openBitMap opacity).width, o.height ), difuse, normal, erm, opacity)
							
						local d = if doesfileexist difuse then openBitMap difuse else undefined
						local n = if doesfileexist normal then openBitMap normal else undefined
						local e = if doesfileexist erm then openBitMap erm else undefined
						local o = if doesfileexist opacity then openBitMap opacity else undefined
							
						if d != undefined and n != undefined and e != undefined and o != undefined then 
						(
							append ids_colors #(id, amax #(d.width, d.height, n.width, n.height, e.width, e.height, o.width, o.height), difuse, normal, erm, opacity)
							close d; close n; close e; close o;
							free d; free n; free e;	free o;	
						)
						else 
						(
							messagebox (id as string + " ID: Error, one or few maps do not generated or found") 
							continue
						)								

					)
					
					Multimaterial: 
					(
						for id in #{1..m.numsubs} where m.materialList[id] != undefined and not keyboard.escPressed do
						(
							sub_m = m.materialList[id]
							difuse = edt_multimat_path.text + "rendered_textures\\" + nam + "_Diffuse_" + id as string + ".png"
							normal = edt_multimat_path.text + "rendered_textures\\" + nam + "_Normal_" + id as string + ".png"
							erm = edt_multimat_path.text + "rendered_textures\\" + nam + "_ERM_" + id as string + ".png"
							opacity = edt_multimat_path.text + "rendered_textures\\" + nam + "_Opacity_" + id as string + ".png"
							
							case classof sub_m of
							(
								CoronaLegacyMtl:
								(
									--showproperties sub_m
									--format "id=% diff=% mat=%\n" id difuse sub_m.texmapDiffuse.filename
									if sub_m.texmapDiffuse != undefined then
									(
										--if isProperty sub_m.texmapDiffuse #filename then copy_mat sub_m.texmapDiffuse.filename difuse (GetINI_ImageMagick())
										--else render_map sub_m.texmapDiffuse rez difuse
										render_map_rect sub_m.texmapDiffuse rez size_thumb difuse ctrl start "Diffuse"
									)
									else if not doesfileexist difuse then
									(
										HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX sub_m.colorDiffuse + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:difuse color:sub_m.colorDiffuse gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start --(GetINI_ImageMagick())
									)

									if sub_m.texmapBump != undefined then
									(		
										--if isProperty sub_m.texmapBump #filename then copy_mat sub_m.texmapBump.filename normal (GetINI_ImageMagick())
										--else render_map sub_m.texmapBump rez normal
										render_map_rect sub_m.texmapBump rez size_thumb normal ctrl start "Bump"
									)
									else if not doesfileexist normal then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start --(GetINI_ImageMagick())
									)
										
									if sub_m.texmapReflect != undefined then
									(
										--if isProperty sub_m.texmapReflect #filename then copy_mat sub_m.texmapReflect.filename erm (GetINI_ImageMagick())
										--else render_map sub_m.texmapReflect rez erm
										render_map_rect sub_m.texmapReflect rez size_thumb erm	ctrl start "Reflect"
									)
									else if not doesfileexist erm then
									(			
										HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start --(GetINI_ImageMagick())
									)

									if sub_m.texmapOpacity != undefined then
									(
										--if isProperty sub_m.texmapOpacity #filename then copy_mat sub_m.texmapOpacity.filename opacity (GetINI_ImageMagick())
										--else render_map sub_m.texmapOpacity rez opacity
										render_map_rect sub_m.texmapOpacity rez size_thumb opacity	ctrl start "Opacity"
									)
									else if not doesfileexist opacity then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " +  "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:opacity color:white gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " -alpha remove -alpha off " + "\"" + opacity + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " PNG24:" + "\""+ opacity + "\"") startpath:start --(GetINI_ImageMagick())
									)

									--if sub_m.texmapReflect != undefined then render_map sub_m.texmapReflect rez (edt_multimat_path.text + sub_m.name + "_Reflect" + ".png")
									--if sub_m.texmapReflectGlossiness != undefined then render_map sub_m.texmapReflectGlossiness rez (edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png")
									--if sub_m.texmapRefract != undefined then render_map sub_m.texmapRefract rez (edt_multimat_path.text + sub_m.name + "_Refract" + ".png")
									--if sub_m.texmapRefractGlossiness != undefined then render_map sub_m.texmapRefractGlossiness rez (edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png")
									--if sub_m.texmapTranslucency != undefined then render_map sub_m.texmapTranslucency rez (edt_multimat_path.text + sub_m.name + "_Translucency" + ".png")
									--if sub_m.texmapDisplace != undefined then render_map sub_m.texmapDisplace rez (edt_multimat_path.text + sub_m.name + "_Displace" + ".png")
									--if sub_m.texmapSelfIllum != undefined then render_map sub_m.texmapSelfIllum rez (edt_multimat_path.text + sub_m.name + "_SelfIllum" + ".png")
								)
								
								CoronaPhysicalMtl:
								(
									if sub_m.baseTexmap != undefined then
									(
										--if isProperty sub_m.baseTexmap #filename then copy_mat sub_m.baseTexmap.filename difuse (GetINI_ImageMagick())
										--else render_map sub_m.baseTexmap rez difuse
										render_map_rect sub_m.baseTexmap rez size_thumb difuse ctrl start "Diffuse"
									)
									else if not doesfileexist difuse then
									(
										--print ("convert -size 256x256 canvas:" + RGBtoHEX sub_m.baseColor + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX sub_m.baseColor + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:difuse color:sub_m.baseColor gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start --(GetINI_ImageMagick())
									)
									
									if sub_m.baseBumpTexmap != undefined then
									(		
										--if isProperty sub_m.baseBumpTexmap #filename then copy_mat sub_m.baseBumpTexmap.filename normal (GetINI_ImageMagick())
										--else render_map sub_m.baseBumpTexmap rez normal
										render_map_rect sub_m.baseBumpTexmap rez size_thumb normal	ctrl start "Bump"
									)
									else if not doesfileexist normal then
									(		
										--print ("convert -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start --(GetINI_ImageMagick())
									)
									--metalnessTexmap
									if sub_m.baseRoughnessTexmap != undefined then
									(
										--if isProperty sub_m.baseRoughnessTexmap #filename then copy_mat sub_m.baseRoughnessTexmap.filename erm (GetINI_ImageMagick())
										--else render_map sub_m.baseRoughnessTexmap rez erm
										render_map_rect sub_m.baseRoughnessTexmap rez size_thumb erm ctrl start "Reflect"
									)
									else if not doesfileexist erm then
									(		
										--print ("convert -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start --(GetINI_ImageMagick())
									)
									--opacityTexmap 
									if sub_m.opacityTexmap != undefined then
									(
										--if isProperty sub_m.texmapOpacity #filename then copy_mat sub_m.texmapOpacity.filename opacity (GetINI_ImageMagick())
										--else render_map sub_m.texmapOpacity rez opacity
										render_map_rect sub_m.opacityTexmap rez size_thumb opacity	ctrl start "Opacity"
									)
									else if not doesfileexist opacity then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " +  "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:opacity color:white gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " -alpha remove -alpha off " + "\"" + opacity + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " PNG24:" + "\""+ opacity + "\"") startpath:start --(GetINI_ImageMagick())
									)
								)
								
								Physical_Material:
								(
									if sub_m.base_color_map != undefined then
									(
										--if isProperty sub_m.base_color_map #filename then copy_mat sub_m.base_color_map.filename difuse (GetINI_ImageMagick())
										--else render_map sub_m.base_color_map rez difuse
										render_map_rect sub_m.base_color_map rez size_thumb difuse ctrl start "Diffuse"
									)
									else if not doesfileexist difuse then
									(
										--print ("convert -size 256x256 canvas:" + RGBtoHEX sub_m.base_color + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX sub_m.base_color + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:difuse color:sub_m.base_color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") 
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start --(GetINI_ImageMagick())
									)
									
									if sub_m.bump_map != undefined then
									(		
										--if isProperty sub_m.bump_map #filename then copy_mat sub_m.bump_map.filename normal (GetINI_ImageMagick())
										--else render_map sub_m.bump_map rez normal
										render_map_rect sub_m.bump_map rez size_thumb normal ctrl start "Bump"
									)
									else if not doesfileexist normal then
									(		
										--print ("convert -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start --(GetINI_ImageMagick())
									)
										
									if sub_m.roughness_map != undefined then
									(
										--if isProperty sub_m.roughness_map #filename then copy_mat sub_m.roughness_map.filename erm (GetINI_ImageMagick())
										--else render_map sub_m.roughness_map rez erm
										render_map_rect sub_m.roughness_map rez size_thumb erm ctrl start "Reflect"
									)
									else if not doesfileexist erm then
									(		
										--print ("convert -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + erm + "\""+ " PNG24:" + "\"" + erm + "\"")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
									)	

									if sub_m.cutout_map != undefined then
									(
										--if isProperty sub_m.cutout_map #filename then copy_mat sub_m.cutout_map.filename opacity (GetINI_ImageMagick())
										--else render_map sub_m.cutout_map rez opacity
										render_map_rect sub_m.cutout_map rez size_thumb opacity ctrl start "Opacity"
									)
									else if not doesfileexist opacity then
									(	
										--print ("convert -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " +  "\"" + opacity + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " +  "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:opacity color:white gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + opacity + "\""+ " -alpha remove -alpha off " + "\"" + opacity + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + opacity + "\""+ " PNG24:" + "\""+ opacity + "\"")
										HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " PNG24:" + "\""+ opacity + "\"") startpath:start --(GetINI_ImageMagick())
									)
									
									-- .emission_map : texturemap 
									--emit_color
									--if sub_m.base_color_map != undefined then copy_mat sub_m.base_color_map.filename difuse (GetINI_ImageMagick())
									--if sub_m.roughness_map != undefined then render_map sub_m.roughness_map rez (edt_multimat_path.text + sub_m.name + "_Roughness" + ".png")
									--if sub_m.metalness_map != undefined then render_map sub_m.metalness_map rez (edt_multimat_path.text + sub_m.name + "_Metalness" + ".png")	
									--if sub_m.bump_map != undefined then copy_mat sub_m.bump_map.filename normal (GetINI_ImageMagick())
									--if sub_m.cutout_map != undefined then render_map sub_m.cutout_map rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
								
								Standardmaterial:
								(
									if sub_m.DiffuseMap != undefined then
									(
										--if isProperty sub_m.DiffuseMap #filename then copy_mat sub_m.DiffuseMap.filename difuse (GetINI_ImageMagick())
										--else render_map sub_m.DiffuseMap.filename rez difuse
										render_map_rect sub_m.DiffuseMap rez size_thumb difuse ctrl start "Diffuse"
									)
									else if not doesfileexist difuse then
									(
										--print ("convert -size 256x256 canvas:" + RGBtoHEX sub_m.diffuse + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX sub_m.diffuse + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:difuse color:sub_m.diffuse gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + difuse + "\""+ " -alpha remove -alpha off " + "\"" + difuse + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"")
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start --(GetINI_ImageMagick())
									)

									if sub_m.BumpMap != undefined then
									(		
										--if isProperty sub_m.BumpMap #filename then copy_mat sub_m.BumpMap.filename normal (GetINI_ImageMagick())
										--else render_map sub_m.BumpMap rez normal
										render_map_rect sub_m.BumpMap rez size_thumb normal ctrl start "Bump"
									)
									else if not doesfileexist normal then
									(		
										--print ("convert -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:normal color:color_normal.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + normal + "\""+ " -alpha remove -alpha off " + "\"" + normal + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"")
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start --(GetINI_ImageMagick())
									)
										
									if sub_m.ReflectionMap != undefined then
									(
										--if isProperty sub_m.ReflectionMap #filename then copy_mat sub_m.ReflectionMap.filename erm (GetINI_ImageMagick())
										--else render_map sub_m.ReflectionMap rez erm
										render_map_rect sub_m.ReflectionMap rez size_thumb erm ctrl start "Reflect"
									)
									else if not doesfileexist erm then
									(		
										--print ("convert -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"")
										HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:erm color:color_erm.color gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close b
										--free b
										--HiddenDOSCommand ("convert " + "\"" + erm + "\""+ " -alpha remove -alpha off " + "\"" + erm + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"")
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start --(GetINI_ImageMagick())
									)									
									
									if sub_m.OpacityMap != undefined then
									(
										--if isProperty sub_m.OpacityMap #filename then copy_mat sub_m.OpacityMap.filename opacity (GetINI_ImageMagick())
										--else render_map sub_m.OpacityMap rez opacity
										render_map_rect sub_m.OpacityMap rez size_thumb opacity ctrl start "Opacity"
									)
									else if not doesfileexist opacity then
									(	
										--print ("convert -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " + "\"" + opacity + "\"") 
										HiddenDOSCommand ("magick -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " + "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
										--b = bitmap 256 256 filename:opacity color:white gamma:1.0 hdr:false
										--save b gamma:1.0 quiet:true
										--close bs
										--free b
										--HiddenDOSCommand ("convert " + "\"" + opacity + "\""+ " -alpha remove -alpha off " + "\"" + opacity + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
										--print ("convert " + "\"" + opacity + "\""+ " PNG24:" + "\""+ opacity + "\"")
										HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " PNG24:" + "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
									)
									
									--if sub_m.DiffuseMap != undefined then copy_mat sub_m.DiffuseMap.filename difuse	(GetINI_ImageMagick())		
									--if sub_m.BumpMap != undefined then copy_mat sub_m.BumpMap.filename normal (GetINI_ImageMagick())
									--if sub_m.ReflectionMap != undefined then render_map sub_m.ReflectionMap rez (edt_multimat_path.text + sub_m.name + "_Reflection" + ".png")
									--if sub_m.GlossinessMap != undefined then render_map sub_m.GlossinessMap rez (edt_multimat_path.text + sub_m.name + "_Glossiness" + ".png")
									--if sub_m.OpacityMap != undefined then render_map sub_m.OpacityMap rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
								
								Vraymtl:
								(
									--texmap_diffuse
									--texmap_reflection
									--texmap_bump
									--texmap_opacity
									
									if sub_m.texmap_diffuse != undefined then
									(
										render_map_rect sub_m.texmap_diffuse rez size_thumb difuse ctrl start "Diffuse"
									)
									else if not doesfileexist difuse then
									(
										HiddenDOSCommand ("magick -size 256x256 canvas:" + RGBtoHEX sub_m.diffuse + " -alpha remove -alpha off -define png:color-type=6 " +  "\"" + difuse + "\"") startpath:start --(GetINI_ImageMagick())
										HiddenDOSCommand ("magick " + "\"" + difuse + "\""+ " PNG24:" + "\""+ difuse + "\"") startpath:start --(GetINI_ImageMagick())
									)

									if sub_m.texmap_bump != undefined then
									(		
										render_map_rect sub_m.texmap_bump rez size_thumb normal ctrl start "Bump"
									)
									else if not doesfileexist normal then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:#8080FF -alpha remove -alpha off -define png:color-type=6 " +  "\"" + normal + "\"") startpath:start --(GetINI_ImageMagick())
										HiddenDOSCommand ("magick " + "\"" + normal + "\""+ " PNG24:" + "\""+ normal + "\"") startpath:start --(GetINI_ImageMagick())
									)
										
									if sub_m.texmap_reflection != undefined then
									(
										render_map_rect sub_m.texmap_reflection rez size_thumb erm ctrl start "Reflect"
									)
									else if not doesfileexist erm then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:#00FF00 -alpha remove -alpha off -define png:color-type=6 " +  "\"" + erm + "\"") startpath:start --(GetINI_ImageMagick())
										HiddenDOSCommand ("magick " + "\"" + erm + "\""+ " PNG24:" + "\""+ erm + "\"") startpath:start --(GetINI_ImageMagick())
									)									
									
									if sub_m.texmap_opacity != undefined then
									(
										render_map_rect sub_m.texmap_opacity rez size_thumb opacity ctrl start "Opacity"
									)
									else if not doesfileexist opacity then
									(		
										HiddenDOSCommand ("magick -size 256x256 canvas:white -alpha remove -alpha off -define png:color-type=6 " + "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
										HiddenDOSCommand ("magick " + "\"" + opacity + "\""+ " PNG24:" + "\"" + opacity + "\"") startpath:start --(GetINI_ImageMagick())
									)
								)
								
								CoronaLayeredMtl:
								(
									messagebox "No support for CoronaLayeredMtl in Multisub yet" 
									continue
								)
								
								default:
								(
									messagebox "No support of this material type yet" 
									continue									
								)
							)
							
							local d = if doesfileexist difuse then openBitMap difuse else undefined
							local n = if doesfileexist normal then openBitMap normal else undefined
							local e = if doesfileexist erm then openBitMap erm else undefined
							local o = if doesfileexist opacity then openBitMap opacity else undefined
							
							if d != undefined and n != undefined and e != undefined and o != undefined then 
							(
								append ids_colors #(id, amax #(d.width, d.height, n.width, n.height, e.width, e.height, o.width, o.height), difuse, normal, erm, opacity)
								close d; close n; close e; close o;
								free d; free n; free e; free o;	
							)
							else 
							(
								messagebox (id as string + " ID: Error, one or few maps do not generated or found") 
								continue
							)								
						)
					)					
				)

				print #(ids_colors)
				
				local ids_z = #()
				local ids_l = #()
				
				local scales = #()
				local errored_texelDensities = ""

		
				--?????????????? ???????? ????????? ? 0 ?? W
				--?????????????? ????????????? ????????? ? ???????? ? ?????? ????
				if ids_colors.count > 0 then 
				(
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(	
						verts = #{}
						verts = #{1..unwrapmod.NumberVertices()} 
				
						if verts.numberset > 0 then
						(
							unwrapmod.selectVertices verts 
							unwrapmod.moveZ 0.0
						)	
						
						for i in #{1..ids_colors.count} where not keyboard.escPressed do
						(
							unwrapmod.setPolygonMode true
							unwrapmod.setTVSubObjectMode 3
							unwrapmod.unhide() 
							unwrapmod.selectByMatID ids_colors[i][1]
							--print ids_colors[i][1]
							unwrapmod.polygonSelect()
							local sel_face_pre = #{}
							local sc_pre = 1.0	
							local pos_pre = [0,0,0]
							sel_face_pre = unwrapmod.getselectedfaces()
							
							if not sel_face_pre.isempty then
							(
								unwrapmod.getarea sel_face_pre &nX &nY &nWidth &nHeight &nAreaUVW &nAreaGeom
								--if nWidth > 1.0 or nHeight > 1.0 then 

								sc_pre = if nWidth > nHeight then 0.95/nWidth else 0.95/nHeight
								pos_pre = unwrapmod.getSelCenter()
								unwrapmod.scaleSelectedXY sc_pre sc_pre [pos_pre.x, pos_pre.y, 0]
								unwrapmod.moveSelected [0.5 - pos_pre.x, 0.5 - pos_pre.y, 0]

								if ids_colors[i][2] != size_thumb then
								(
									fit_map_new (ids_colors[i][3]) (ids_colors[i][3]) ([-0.5 + pos_pre.x, 0.5 - pos_pre.y, 0]) sc_pre (rez as integer) start
									fit_map_new (ids_colors[i][4]) (ids_colors[i][4]) ([-0.5 + pos_pre.x, 0.5 - pos_pre.y, 0]) sc_pre (rez as integer) start
									fit_map_new (ids_colors[i][5]) (ids_colors[i][5]) ([-0.5 + pos_pre.x, 0.5 - pos_pre.y, 0]) sc_pre (rez as integer) start
									fit_map_new (ids_colors[i][6]) (ids_colors[i][6]) ([-0.5 + pos_pre.x, 0.5 - pos_pre.y, 0]) sc_pre (rez as integer) start
									ids_colors[i][2] = rez as integer
								)
								else
								(
									fit_map_new (ids_colors[i][3]) (ids_colors[i][3]) ([-0.5 + pos_pre.x, 0.5 - pos_pre.y, 0]) sc_pre (size_thumb as integer) start
									fit_map_new (ids_colors[i][4]) (ids_colors[i][4]) ([-0.5 + pos_pre.x, 0.5 - pos_pre.y, 0]) sc_pre (size_thumb as integer) start
									fit_map_new (ids_colors[i][5]) (ids_colors[i][5]) ([-0.5 + pos_pre.x, 0.5 - pos_pre.y, 0]) sc_pre (size_thumb as integer) start
									fit_map_new (ids_colors[i][6]) (ids_colors[i][6]) ([-0.5 + pos_pre.x, 0.5 - pos_pre.y, 0]) sc_pre (size_thumb as integer) start
									ids_colors[i][2] = size_thumb as integer
								)
							)
						)
					)
					addmodifier selection[1] (Unwrap_UVW()) --converttopoly selection[1]
				)

				if ids_colors.count > 0 then 
				(
					ids_z = for i in #{1..ids_colors.count} where ids_colors[i][2] == size_thumb collect ids_colors[i]
					ids_l = for i in #{1..ids_colors.count} where ids_colors[i][2] != size_thumb collect ids_colors[i]

					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						local sel_face = #{}
						local quant = ids_l.count + (if ids_z.count == 0 then 0 else 1)
						local uv_h, uv_hs = #()
						local uv_w, uv_ws = #()
						local poi_x, poi_xs = #()
						local poi_y, poi_ys = #()
						local pos
						local texelDensities = #()
						
						print quant
						
						local size_h_row = 1.0
						local size_g_col = 1.0	
						local quota_g = 1.0 / size_g_col
						local quota_h = 1.0 / size_h_row	
						local padding_w = 1.052631 -- ==1/0.95
						local padding_h = 1.052631 -- ==1/0.95
						
						/*
						case of
						(
							(quant == 1): (size_h_row = 1; size_g_col = 1)	--Num Images Tile Setting 1 1x1
							(quant == 2): (size_h_row = 1; size_g_col = 2)  --2 2x1
							(quant == 3): (size_h_row = 1; size_g_col = 3)  --3 3x1
							(quant == 4): (size_h_row = 2; size_g_col = 2)	--4	2x2
							(quant == 5 or quant == 6): (size_h_row = 2; size_g_col = 3) --5-6	3x2
							(quant == 7 or quant == 8): (size_h_row = 2; size_g_col = 4)  --7-8	4x2
							(quant == 9): (size_h_row = 3; size_g_col = 3)  --9	3x3
							(quant == 10 or quant == 11 or quant == 12): (size_h_row = 3; size_g_col = 4) --10- 12 4x3
							(quant == 13 or quant == 14 or quant == 15): (size_h_row = 3; size_g_col = 5) --13-15 5x3
							(quant == 16 or quant == 17 or quant == 18 or quant == 19 or quant == 20): (size_h_row = 4; size_g_col = 5) --16-20 5x4
							(quant == 21 or quant == 22 or quant == 23 or quant == 24): (size_h_row = 4; size_g_col = 6) --21-24 6x4
							(quant == 25): (size_h_row = 5; size_g_col = 5) --25 5x5
							(quant == 26 or quant == 27 or quant == 28 or quant == 29 or quant == 30): (size_h_row = 5; size_g_col = 6) --26-30	6x5
							(quant == 31 or quant == 32 or quant == 33 or quant == 34 or quant == 35): (size_h_row = 5; size_g_col = 7) --31-35	7x5						
							(quant == 36): (size_h_row = 6; size_g_col = 6) --36 6x6
							(quant == 37 or quant == 38 or quant == 39 or quant == 40 or quant == 41 or quant == 42): (size_h_row = 6; size_g_col = 7) --37-42 7x6								
							(quant == 43 or quant == 44 or quant == 45 or quant == 46 or quant == 47 or quant == 48): (size_h_row = 6; size_g_col = 8) --43-48 8x6							
						)
						*/
						size_h_row = (ceil (sqrt (quant))) as integer
						size_g_col = size_h_row
						
						quota_g = 1.0 / size_g_col
						quota_h = 1.0 / amax #(size_g_col, size_h_row)	
						
						local size_g = 0.0
						local size_h = 0.0

						local page = 0.0
						local sc_h = 1.0
						local sc_g = 1.0
						local sc = 1.0	
					
						for i in #{1..ids_colors.count} where ids_colors[i][2] != size_thumb and not keyboard.escPressed do
						(
							local mWidths = #()
							local mHeights = #()
							unwrapmod.setPolygonMode true
							unwrapmod.setTVSubObjectMode 3
							unwrapmod.unhide() 
							unwrapmod.selectByMatID ids_colors[i][1]
							--print ids_colors[i][1]
							unwrapmod.polygonSelect()
							sel_face = unwrapmod.getselectedfaces()
							
							if not sel_face.isempty then 
							(
								unwrapmod.getarea sel_face &mXX &mYY &mWidth &mHeight &mAreaUVW &mAreaGeom
								sc_h = 1.0
								sc_g = 1.0
								
								padding_w = if mWidth <= 1.0 then 1.0/mWidth else 1.052631
								padding_h = if mHeight <= 1.0 then 1.0/mHeight else 1.052631
								
								case of
								(
									(mHeight > quota_h and mWidth > quota_g): (sc_h = quota_h / mHeight; sc_g = quota_g / mWidth)
									(mHeight > quota_h and mWidth <= quota_g): sc_h = quota_h / mHeight
									(mHeight <= quota_h and mWidth > quota_g): sc_g = quota_g / mWidth
									(mHeight <= quota_h and mWidth <= quota_g):	(sc_h = quota_h / mHeight; sc_g = quota_g / mWidth)  
								)

								sc = if sc_h < sc_g then sc_h else sc_g
									
								--amax #(sc/padding_w, sc/padding_h)
								
								pos = unwrapmod.getSelCenter()
								--print pos
								unwrapmod.scaleSelectedXY (amax #(sc/padding_w, sc/padding_h)) (amax #(sc/padding_w, sc/padding_h)) [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter (sc) 0
								pos = unwrapmod.getSelCenter()
								posX = (size_g * quota_g) + (0.5 / size_g_col) - pos.x
								posY = 1 - ( (size_h * quota_h) + (0.5 / amax #(size_g_col, size_h_row) ) ) - pos.y
								unwrapmod.moveSelected [posX, posY, 0]
									
								pos = unwrapmod.getSelCenter()	
								local textureArea = atlas_size ^ 2	
								texelDensities = #()		

								unwrapmod.getarea sel_face &mX__ &mY__ &mWidth__ &mHeight__ &mAreaUVW__ &mAreaGeom__	
								for t in sel_face do
								(
									unwrapmod.getarea #{t} &mXXX &mYYY &mWidth_ &mHeight_ &mAreaUVW_ &mAreaGeom_
									local texelDensity = sqrt ((mAreaUVW_ * textureArea) / mAreaGeom_)	
									append texelDensities texelDensity
								)	
								local t_min = amin(texelDensities)
								local t_max = amax(texelDensities)								
								
								local sc_min = 10.01 / t_min
								local sc_max = 39.90 / t_max 
								--print (sc_max * t_min)
								
								if (sc_max * t_min) <= 10 then append errored_texelDensities (i as string + ": not fited to lower border of densities [10..40]\n")

								if (mWidth__ * sc_max ) > (quota_g * 0.95) or (mHeight__ * sc_max) > (quota_h * 0.95) then 
								(
									if (mWidth__ * sc_max) > (mHeight__ * sc_max) then sc_max = 0.95 * quota_g / mWidth__ else sc_max = 0.95 * quota_h / mHeight__  
									errored_texelDensities += i as string + ": not fited to quadrant borders, downscaled to fit\n"
								)
								
								/*
								if sc_max < 0.5 then --need to re unwrap
								(
									unwrapmod.flattenMap 45.0 #([1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]) 0.001 true 0 true true 
									unwrapmod.selectByMatID ids_colors[i][1]
									unwrapmod.breakSelected()
									unwrapmod.selectByMatID ids_colors[i][1]
									unwrapmod.faceToEdgeSelect() 
									--local edges_ = #{}
									--edges_ = unwrapmod.getSelectedEdges()
									--unwrapmod.selectElement()
									unwrapmod.breakSelected()
									--edges_ = unwrapmod.getSelectedEdges()
									--unwrapmod.edgeToFaceSelect() 
									unwrapmod.selectByMatID ids_colors[i][1]
									sel_face = unwrapmod.getselectedfaces()
									for f in sel_face where not keyboard.escPressed do 
									(
										local pp = unwrapmod.getSelCenter()
										unwrapmod.selectFaces #{f} 
										unwrapmod.moveSelected [pos.x - pp.x, pos.x - pp.y, 0]
									)
									unwrapmod.getarea sel_face &mX__ &mY__ &mWidth__ &mHeight__ &mAreaUVW__ &mAreaGeom__
									local sc_max = 39.90 / sqrt ((mAreaUVW__ * textureArea) / mAreaGeom__) 
								)	
								*/
								
								if not alt then unwrapmod.scaleSelectedXY (sc_max) (sc_max) [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter (sc) 0
								
								unwrapmod.getarea sel_face &mX___ &mY___ &mWidth___ &mHeight___ &mAreaUVW___ &mAreaGeom___

								format "id=% t_min=% t_max=% mHeight=% mWidth=%  sc=%  sc_g=%  sc_h=% padding_h=% padding_w=% size=% mHeight_new=% mWidth_new=% sc_max=% quota_h=% quota_g=% *=% *=%\n" ids_colors[i][1] t_min t_max mHeight mWidth sc sc_g sc_h padding_h padding_w ids_colors[i][2] mWidth__ mHeight__ sc_max quota_h quota_g (mWidth__ * sc_max) (mHeight__ * sc_max)
								append scales #(i, amax #(sc/padding_w, sc/padding_h), (sc_max), mX__, mY__, mWidth__, mHeight__, mX___, mY___, mWidth___, mHeight___)
							)
							
							if size_g + 1.0 >= size_g_col then 
							(
								if size_h + 1.0 >= amax #(size_g_col, size_h_row) then 
								(
									page += 1.0
									size_h = 0.0
									size_g = 0.0
								)
								else
								(
									size_h += 1.0
									size_g = 0.0
								)
							)
							else
							(
								size_g += 1.0
							)							
						)
						
						--print scales
						
						--?????? ???????????? ?? ????? ????? ? ????????? ????????? ?? ???????? ????????? ??????????
						quant = ids_z.count
						padding_w = 1.052631 -- ==1/0.95
						padding_h = 1.052631 -- ==1/0.95
							/*
							case of
							(
								(quant == 1): (size_h_row = 1; size_g_col = 1)	--Num Images Tile Setting 1 1x1
								(quant == 2): (size_h_row = 1; size_g_col = 2)  --2 2x1
								(quant == 3): (size_h_row = 1; size_g_col = 3)  --3 3x1
								(quant == 4): (size_h_row = 2; size_g_col = 2)	--4	2x2
								(quant == 5 or quant == 6): (size_h_row = 2; size_g_col = 3) --5-6	3x2
								(quant == 7 or quant == 8): (size_h_row = 2; size_g_col = 4)  --7-8	4x2
								(quant == 9): (size_h_row = 3; size_g_col = 3)  --9	3x3
								(quant == 10 or quant == 11 or quant == 12): (size_h_row = 3; size_g_col = 4) --10- 12 4x3
								(quant == 13 or quant == 14 or quant == 15): (size_h_row = 3; size_g_col = 5) --13-15 5x3
								(quant == 16 or quant == 17 or quant == 18 or quant == 19 or quant == 20): (size_h_row = 4; size_g_col = 5) --16-20 5x4
								(quant == 21 or quant == 22 or quant == 23 or quant == 24): (size_h_row = 4; size_g_col = 6) --21-24 6x4
								(quant == 25): (size_h_row = 5; size_g_col = 5) --25 5x5
								(quant == 26 or quant == 27 or quant == 28 or quant == 29 or quant == 30): (size_h_row = 5; size_g_col = 6) --26-30	6x5
								(quant == 31 or quant == 32 or quant == 33 or quant == 34 or quant == 35): (size_h_row = 5; size_g_col = 7) --31-35	7x5						
								(quant == 36): (size_h_row = 6; size_g_col = 6) --36 6x6
								(quant == 37 or quant == 38 or quant == 39 or quant == 40 or quant == 41 or quant == 42): (size_h_row = 6; size_g_col = 7) --37-42 7x6								
								(quant == 43 or quant == 44 or quant == 45 or quant == 46 or quant == 47 or quant == 48): (size_h_row = 6; size_g_col = 8) --43-48 8x6							
							)
							*/
						size_h_row = (ceil (sqrt (quant))) as integer
						size_g_col = size_h_row

						local size_g_old = size_g * quota_g --???????? ?? ????????? ??????? ?????????
						local size_h_old = size_h * quota_h --???????? ?? ????????? ??????? ?????????

						quota_g = amax #(quota_g, quota_h) / size_g_col
						quota_h = amax #(quota_g, quota_h) / amax #(size_g_col, size_h_row)	

						size_g = 0.0
						size_h = 0.0
							
						page = 0.0
						sc_h = 1.0
						sc_g = 1.0
						sc = 1.0	

						for i in #{1..ids_colors.count} where ids_colors[i][2] == size_thumb and not keyboard.escPressed do
						(
							local mWidths = #()
							local mHeights = #()
							unwrapmod.setPolygonMode true
							unwrapmod.setTVSubObjectMode 3
							unwrapmod.unhide() 
							unwrapmod.selectByMatID ids_colors[i][1]
							--print ids_colors[i][1]
							unwrapmod.polygonSelect()
							sel_face = unwrapmod.getselectedfaces()
							
							if not sel_face.isempty then 
							(
								unwrapmod.getarea sel_face &mXX &mYY &mWidth &mHeight &mAreaUVW &mAreaGeom
								sc_h = 1.0
								sc_g = 1.0
								
								padding_w = if mWidth <= 1.0 then 1.0/mWidth else 1.052631
								padding_h = if mHeight <= 1.0 then 1.0/mHeight else 1.052631
								
								case of
								(
									(mHeight > quota_h and mWidth > quota_g): (sc_h = quota_h / mHeight; sc_g = quota_g / mWidth)
									(mHeight > quota_h and mWidth <= quota_g): sc_h = quota_h / mHeight
									(mHeight <= quota_h and mWidth > quota_g): sc_g = quota_g / mWidth
									(mHeight <= quota_h and mWidth <= quota_g):	(sc_h = quota_h / mHeight; sc_g = quota_g / mWidth)  
								)

								sc = if sc_h < sc_g then sc_h else sc_g
								format "id=% mHeight=% mWidth=% sc=% sc_g=% sc_h=% padding_h=% padding_w=% size=%\n" ids_colors[i][1] mHeight mWidth sc sc_g sc_h padding_h padding_w ids_colors[i][2]
								pos = unwrapmod.getSelCenter()
								--print pos
								unwrapmod.scaleSelectedXY (amax #(sc/padding_w, sc/padding_h)) (amax #(sc/padding_w, sc/padding_h)) [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter (sc) 0
								pos = unwrapmod.getSelCenter()
								posX = size_g_old + ((size_g - 1) * quota_g) + (0.5 / size_g_col) - pos.x
								posY = 1 - (size_h_old + ((size_h - 1) * quota_h) + (0.5 / amax #(size_g_col, size_h_row) )) - pos.y
								unwrapmod.moveSelected [posX, posY, 0]
								if ids_l.count == 0 then unwrapmod.moveSelected [quota_g, -quota_h, 0]
							)
							
							if size_g + 1.0 >= size_g_col then 
							(
								if size_h + 1.0 >= amax #(size_g_col, size_h_row) then 
								(
									page += 1.0
									size_h = 0.0
									size_g = 0.0
								)
								else
								(
									size_h += 1.0
									size_g = 0.0
								)
							)
							else
							(
								size_g += 1.0
							)		
						)
/*						
						q = selection[1].modifiers[1]
						--for id in ids_colors do
							--for p in #{1..q.numberPolygons()} where not keyboard.escpressed  do --or getSelectMatID id do
							--(
								--print (p as string + " " + q.numberPolygons() as string)
								--q.unwrap2.setTVSubObjectMode 3
								--q.selectFacesByNode #{p} selection[1]
								--q.unwrap2.faceToVertSelect()
								--sel = q.unwrap.getselectedvertices()
								--poi = (for i in sel collect (q.unwrap.getvertexposition currenttime i))[1]
								--poi = [(amax (for i in sel collect (q.unwrap.getvertexposition currenttime i).x) - amin (for i in sel collect (q.unwrap.getvertexposition currenttime i).x))/2, (amax (for i in sel collect (q.unwrap.getvertexposition currenttime i).y) - amin (for i in sel collect (q.unwrap.getvertexposition currenttime i).y))/2,0]

								uvMax = [-99999,-99999,0]
								uvMin = [99999,99999,0]
								for i in #{1..sel.count} do 
								(
									uvPos = q.unwrap.getvertexposition currenttime i
									if uvPos.x > uvMax.x then 
									(
										uvMax.x = uvPos.x
									)
									else 
									(
										if uvPos.x < uvMin.x do
										(
											uvMin.x = uvPos.x
										)
									)
									if uvPos.y > uvMax.y then 
									(
										uvMax.y = uvPos.y
									)
									else 
									(
										if uvPos.y < uvMin.y do 
										(
											uvMin.y = uvPos.y
										)
									)
								)
								q.unwrap2.setTVSubObjectMode 3
								poi = (uvMax+uvMin)/2 

								--poi = q.unwrap.getvertexposition currenttime sel[1]
								
							
								--print poi
								--id = (poi.x as integer) + 1 + 10 * (poi.y as integer)
								--q.unwrap2.setTVSubObjectMode 3
								--q.selectFacesByNode #{p} selection[1]
								--print id
								--q.setSelectMatID id

						--)
*/					
					)

					local picpath = edt_multimat_path.text + "rendered_textures\\" + nam + "_d_1.png"
					local picpath_z = edt_multimat_path.text + "rendered_textures\\" + nam + "_d_1z.png"	
					
					local o_picpath = edt_multimat_path.text + "rendered_textures\\" + nam + "_o_1.png" --opacity
					local o_picpath_z = edt_multimat_path.text + "rendered_textures\\" + nam + "_o_1z.png"	
					
					local n_picpath = edt_multimat_path.text + "rendered_textures\\" + nam + "_n_1.png" --normals
					local n_picpath_z = edt_multimat_path.text + "rendered_textures\\" + nam + "_n_1z.png"						
					
					local m_picpath = edt_multimat_path.text + "rendered_textures\\" + nam + "_m_1.png" --metallicity
					local m_picpath_z = edt_multimat_path.text + "rendered_textures\\" + nam + "_m_1z.png"	

					local r_picpath = edt_multimat_path.text + "rendered_textures\\" + nam + "_r_1.png" --roughness
					local r_picpath_z = edt_multimat_path.text + "rendered_textures\\" + nam + "_r_1z.png"	
					
					print picpath
					
					/*
					if alt then
					(
						size = 2048
						size_thumb = 256
						size_pic = 1024
						--if ids_colors.count == m.materialList.count then size_thumb = (size / floor (sqrt ids_colors.count)) as integer
						print size
						print size_thumb	
						picpath = maxFilePath + "Images\\" + m.name + "_d_0000.png"
						picpath_thumb = maxFilePath + "Images\\" + m.name + "_d_0000+.png"
						makeDir (maxFilePath + "Images\\")
						
						texture = bitmap size size gamma:1.0 color:(color 0 0 0 255) filename:picpath hdr:false 
						row = 0
						stolb = 0
						
						size_thumb = 1024
						for i in #{1..ids_colors.count} where ids_colors[i][2] == 1024 do 
						(
							thumb = openBitMap ids_colors[i][3]
							
							pasteBitmap thumb texture [0,0] [size_thumb*stolb, size_thumb*row] type:#paste alphaMultiplier:1.0

							--thumb = bitmap size_thumb size_thumb gamma:1.0 color:colors[i] filename:picpath_thumb hdr:false 
							--save thumb gamma:1.0 quiet:true
							--pasteBitmap thumb texture [0,0] [size_thumb*stolb, size_thumb*row] type:#paste alphaMultiplier:1.0
							stolb += 1
							if stolb >= size / size_thumb or stolb * size_thumb >= size then 
							(
								stolb = 0
								row += 1
							)
							close thumb
							free thumb						
						)
						
						size_thumb = 256
						for i in #{1..ids_colors.count} where ids_colors[i][2] == 256 do 
						(
							thumb = openBitMap ids_colors[i][3]
							
							pasteBitmap thumb texture [0,0] [size_thumb*stolb, size_thumb*row] type:#paste alphaMultiplier:1.0

							--thumb = bitmap size_thumb size_thumb gamma:1.0 color:colors[i] filename:picpath_thumb hdr:false 
							--save thumb gamma:1.0 quiet:true
							--pasteBitmap thumb texture [0,0] [size_thumb*stolb, size_thumb*row] type:#paste alphaMultiplier:1.0
							stolb += 1
							if stolb >= size / size_thumb or stolb * size_thumb >= size then 
							(
								stolb = 0
								row += 1
							)
							close thumb
							free thumb						
						)					
						
						save texture gamma:1.0 quiet:true
						close texture
						free texture
					
					)
					else
					(
					*/
					
					--local cmd = ""
					--local pics = ""
					
					--local o_cmd = ""
					--local o_pics = ""
					--local n_cmd = ""
					--local n_pics = ""
					--local m_cmd = ""
					--local m_pics = ""
					--local r_cmd = ""
					--local r_pics = ""
					
					--for i in #{1..ids_colors.count} do pics += "\"" + ids_colors[i][3] + "\"" + " "

					if ids_z.count > 0 then 
					(
						local tile_z = ((ceil (sqrt (ids_z.count))) as integer) as string 
						/*	
						pics = ""
						o_pics = ""
						n_pics = ""
						m_pics = ""
						r_pics = ""
						
						for i in #{1..ids_colors.count} where ids_colors[i][2] == size_thumb do
						(
							--difuse - 3, normal - 4, erm - 5, opacity - 6
							pics += "\"" + ids_colors[i][3] + "\"" + " " --difuse
							o_pics += "\"" + ids_colors[i][6] + "\"" + " " --opacity
							n_pics += "\"" + ids_colors[i][4] + "\"" + " " --normal
							m_pics += "\"" + ids_colors[i][5] + "\"" + " " --erm
							r_pics += "\"" + ids_colors[i][5] + "\"" + " " --erm
						)
						*/	

						--composite {overlay} {background} [{mask}] [-compose {method}]   {result}
						--magick {background} {overlay} [{mask}] [-compose {method}] -composite   {result}
						-- -compose src-over modulate -define compose:args=100 -composite 
						local poi_x = 0
						local poi_y = 0
						local t = 0
						HiddenDOSCommand ("magick -size " + (256 * (tile_z as integer)) as string + "x" + (256 * (tile_z as integer)) as string + " canvas:black -define png:color-type=6 " +  "\"" + picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick -size " + (256 * (tile_z as integer)) as string + "x" + (256 * (tile_z as integer)) as string + " canvas:white -define png:color-type=6 " +  "\"" + o_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick -size " + (256 * (tile_z as integer)) as string + "x" + (256 * (tile_z as integer)) as string + " canvas:#8080FF -define png:color-type=6 " +  "\"" + n_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick -size " + (256 * (tile_z as integer)) as string + "x" + (256 * (tile_z as integer)) as string + " canvas:black -define png:color-type=6 " +  "\"" + m_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick -size " + (256 * (tile_z as integer)) as string + "x" + (256 * (tile_z as integer)) as string + " canvas:white -define png:color-type=6 " +  "\"" + r_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())

						for i in #{1..ids_colors.count} where ids_colors[i][2] == size_thumb do
						(	
							poi_x = 256 * ((mod t (tile_z as integer)) as integer)
							poi_y = (256 * ((tile_z as integer) - 1)) - (256 * (floor (t / (tile_z as integer))))
							--print poi_x
							--print poi_y
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + ids_colors[i][3] + "\"" + " " + "\"" + picpath_z + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + ids_colors[i][6] + "\"" + " " + "\"" + o_picpath_z + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + o_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + ids_colors[i][4] + "\"" + " " + "\"" + n_picpath_z + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + n_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + ids_colors[i][5] + "\"" + " " + "\"" + m_picpath_z + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + m_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + ids_colors[i][5] + "\"" + " " + "\"" + r_picpath_z + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + r_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
							t += 1
						)						
						
							/*
							case of  
							(
								default: cmd = ""
								--???? ???????? 256?256 ? ??????? 1024?1024, ??? ?? 4?4??
								(ids_z.count > 0 and ids_z.count <= 4 and ids_l.count > 0 and ids_l.count <= 3): cmd = "magick montage " + pics + " -geometry 512x512+0+0 -tile 2x2 -border 0 -background black " + "\"" + picpath_z + "\""
								(ids_z.count > 0 and ids_z.count <= 4 and ids_l.count > 3): cmd = "magick montage " + pics + " -geometry 256x256+0+0 -tile 1x4 -border 0 -background black " + "\"" + picpath_z + "\""
								(ids_z.count > 4 and ids_z.count <= 9 and ids_l.count > 0 and ids_l.count <= 3): cmd = "magick montage " + pics + " -geometry 256x256+0+0 -tile 3x3 -border 0 -background black " + "\"" + picpath_z + "\""
								(ids_z.count > 4 and ids_z.count <= 8): cmd = "magick montage " + pics + " -geometry 256x256+0+0 -tile 2x4 -border 0 -background black " + "\"" + picpath_z + "\""
								(ids_z.count > 8 and ids_z.count <= 16): cmd = "magick montage " + pics + " -geometry 256x256+0+0 -tile 4x4 -border 0 -background black " + "\"" + picpath_z + "\""
							)
							*/
						
						--cmd = "magick montage " + pics + " -filter point -tile " + tile_z + "x" + tile_z + " -geometry 256x256+0+0 -border 0 -background black " + "\"" + picpath_z + "\""
						--o_cmd = "magick montage " + o_pics + " -filter point -tile " + tile_z + "x" + tile_z + " -geometry 256x256+0+0 -border 0 -background white " + "\"" + o_picpath_z + "\""
						--n_cmd = "magick montage " + n_pics + " -filter point -tile " + tile_z + "x" + tile_z + " -geometry 256x256+0+0 -border 0 -background black " + "\"" + n_picpath_z + "\""
						--m_cmd = "magick montage " + m_pics + " -filter point -tile " + tile_z + "x" + tile_z + " -geometry 256x256+0+0 -border 0 -background black " + "\"" + m_picpath_z + "\""	
						--r_cmd = "magick montage " + r_pics + " -filter point -tile " + tile_z + "x" + tile_z + " -geometry 256x256+0+0 -border 0 -background black " + "\"" + r_picpath_z + "\""							
						
						--cmd = "magick montage " + pics + " -filter point -geometry 256x256+0+0 -border 0 -background black " + "\"" + picpath_z + "\""
						--o_cmd = "magick montage " + o_pics + " -filter point -geometry 256x256+0+0 -border 0 -background white " + "\"" + o_picpath_z + "\""
						--n_cmd = "magick montage " + n_pics + " -filter point -geometry 256x256+0+0 -border 0 -background black " + "\"" + n_picpath_z + "\""
						--m_cmd = "magick montage " + m_pics + " -filter point -geometry 256x256+0+0 -border 0 -background black " + "\"" + m_picpath_z + "\""	
						--r_cmd = "magick montage " + r_pics + " -filter point -geometry 256x256+0+0 -border 0 -background black " + "\"" + r_picpath_z + "\""							
						
						--print cmd
						--HiddenDOSCommand (cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + picpath_z + "\"" + " -interpolate Integer -filter point -resize 1024x1024 +repage -gravity NorthEast -background black -extent 1024x1024 -define png:color-type=6 " + "\"" + picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
	
						--HiddenDOSCommand (o_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + o_picpath_z + "\"" + " -interpolate Integer -filter point -resize 1024x1024 +repage -gravity NorthEast -background white -extent 1024x1024 -define png:color-type=6 " + "\"" + o_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (n_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + n_picpath_z + "\"" + " -interpolate Integer -filter point -resize 1024x1024 +repage -gravity NorthEast -background black -extent 1024x1024 -define png:color-type=6 " + "\"" + n_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						
						--HiddenDOSCommand (m_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + m_picpath_z + "\"" + " -interpolate Integer -filter point -resize 1024x1024 +repage -gravity NorthEast -background black -extent 1024x1024 -define png:color-type=6 " + "\"" + m_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + m_picpath_z + "\"" + " -channel B -separate " + "\"" + m_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
							
						--HiddenDOSCommand (r_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + r_picpath_z + "\"" + " -interpolate Integer -filter point -resize 1024x1024 +repage -gravity NorthEast -background black -extent 1024x1024 -define png:color-type=6 " + "\"" + r_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + r_picpath_z + "\"" + " -channel G -separate " + "\"" + r_picpath_z + "\"") startpath:start --(GetINI_ImageMagick())
						/*	
						pics = ""	
						o_pics = ""
						n_pics = ""
						m_pics = ""
						r_pics = ""
							
						for i in #{1..ids_colors.count} where ids_colors[i][2] != size_thumb do 
						(
							pics += "\"" + ids_colors[i][3] + "\"" + " " --difuse
							o_pics += "\"" + ids_colors[i][6] + "\"" + " " --opacity
							n_pics += "\"" + ids_colors[i][4] + "\"" + " " --normal
							m_pics += "\"" + ids_colors[i][5] + "\"" + " " --erm
							r_pics += "\"" + ids_colors[i][5] + "\"" + " " --erm

						)
						
						pics += "\"" + picpath_z + "\"" 
						o_pics += "\"" + o_picpath_z + "\"" 
						n_pics += "\"" + n_picpath_z + "\"" 
						m_pics += "\"" + m_picpath_z + "\"" 
						r_pics += "\"" + r_picpath_z + "\"" 
						*/
					)	

					local tile = if ctrl then ((ceil (sqrt (ids_l.count + ids_z.count))) as integer) as string else ((ceil (sqrt (ids_l.count + (if ids_z.count == 0 then 0 else 1) ))) as integer) as string 

					--convert *.png -append sprites.png (append vertically)
					--convert *.png +append sprites.png (append horizontally)
						
					local poi_x = 0
					local poi_y = 0
					local t = 0
					
					HiddenDOSCommand ("magick -size " + (1024 * (tile as integer)) as string + "x" + (1024 * (tile as integer)) as string + " canvas:black -define png:color-type=6 " +  "\"" + picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("magick -size " + (1024 * (tile as integer)) as string + "x" + (1024 * (tile as integer)) as string + " canvas:white -define png:color-type=6 " +  "\"" + o_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("magick -size " + (1024 * (tile as integer)) as string + "x" + (1024 * (tile as integer)) as string + " canvas:#8080FF -define png:color-type=6 " +  "\"" + n_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("magick -size " + (1024 * (tile as integer)) as string + "x" + (1024 * (tile as integer)) as string + " canvas:black -define png:color-type=6 " +  "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("magick -size " + (1024 * (tile as integer)) as string + "x" + (1024 * (tile as integer)) as string + " canvas:white -define png:color-type=6 " +  "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())

					for i in #{1..ids_colors.count} where ids_colors[i][2] != size_thumb and not keyboard.escPressed do
					(		
						--?????????? ???? ??? ????????
						
						local scale_proc = "100"
						
						--local hei = "1024"
						--local wid = "1024"
						--local ofs_x = "0"
						--local ofs_y = "0"
						--local need = false
						
						if scales.count > 0 then 
							for j in #{1..scales.count} where scales[j][1] == i and scales[j][3] != "OK" do scale_proc = ((scales[j][3] as float) * 100.0) as string
							
						scale_proc = substitutestring scale_proc "," "."
							
						format "i=% scale_proc=% \n" i scale_proc
							
						poi_x = 1024 * ((mod t (tile as integer)) as integer)
						poi_y = (1024 * ((tile as integer) - 1)) - (1024 * (floor (t / (tile as integer))))
							
							/*						
							--if scales[i][3] != undefined then
							try
							(
								--format "scales=%  sc=%     1024/scales[j][3]=% \n" scales[j][3] scales[j][2] (1024/scales[j][3])
								need = if scales[j][3] == 1.0 then false else true
								hei = if (round (1024 / scales[j][3])) <= 10240 then (round (1024 / scales[j][3])) as string else "10240"
								wid = hei
								if hei == "10240" then errored_texelDensities += i as string + ": wrong scale leaded to oversized texture\n"
								scale_proc = (scales[j][3] * 100) as string
								ofs_x = round ( ((1024 / scales[j][3]) / -2) + 512 )
								ofs_y = round ( ((1024 / scales[j][3]) / -2) + 512 )
								if ofs_x > 10240 then ofs_x = 0 
								if ofs_x < -10240 then ofs_x = 0	
								if ofs_y > 10240 then ofs_y = 0 
								if ofs_y < -10240 then ofs_y = 0	
									
								ofs_x = if ofs_x >= 0 then "+" + (ofs_x) as string else (ofs_x) as string
								ofs_y = if ofs_y >= 0 then "+" + (ofs_y) as string else (ofs_y) as string
								format "i=% sc=% scales=% x=% y=% \n" i scales[j][3] scales[j] ofs_x ofs_y --#(i, amax #(sc/padding_w, sc/padding_h), sc_max, mX__, mY__, mWidth__, mHeight__, mX___, mY___, mWidth___, mHeight___ )
							)
							catch(need = false)
									
						poi_x = 1024 * ((mod t (tile as integer)) as integer)
						poi_y = (1024 * ((tile as integer) - 1)) - (1024 * (floor (t / (tile as integer))))
						--print poi_x
						--print poi_y
						*/	
						
						if not alt then -- and need then
						(
							--??????? ????? ??????? ??????? ?? ??????? ???????????, ?????? ??? ?????????? ? ???? ?????? ? ??????????????? ?????????? ?????? ????????
		
							HiddenDOSCommand ("magick " + "\"" + ids_colors[i][3] + "\"" + " -interpolate Integer -filter point -resize " + scale_proc + "%% +repage -gravity Center -background black -extent 1024x1024 -define png:color-type=6 " + "\"" + ids_colors[i][3] + "\"") startpath:start
							HiddenDOSCommand ("magick " + "\"" + ids_colors[i][4] + "\"" + " -interpolate Integer -filter point -resize " + scale_proc + "%% +repage -gravity Center -background #8080FF -extent 1024x1024 -define png:color-type=6 " + "\"" + ids_colors[i][4] + "\"") startpath:start
							HiddenDOSCommand ("magick " + "\"" + ids_colors[i][5] + "\"" + " -interpolate Integer -filter point -resize " + scale_proc + "%% +repage -gravity Center -background white -extent 1024x1024 -define png:color-type=6 " + "\"" + ids_colors[i][5] + "\"") startpath:start
							HiddenDOSCommand ("magick " + "\"" + ids_colors[i][6] + "\"" + " -interpolate Integer -filter point -resize " + scale_proc + "%% +repage -gravity Center -background white -extent 1024x1024 -define png:color-type=6 " + "\"" + ids_colors[i][6] + "\"") startpath:start

							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][3] + "\"" + " -resize " + scale_proc + "^% " + "\"" + ids_colors[i][3] + "\"") startpath:start
								
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][3] + "\"" + " -set option:distort:viewport " + wid + "x" + hei + ofs_x + ofs_y + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][3] + "\"") startpath:start --(GetINI_ImageMagick())	
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][6] + "\"" + " -set option:distort:viewport " + wid + "x" + hei + ofs_x + ofs_y + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][6] + "\"") startpath:start --(GetINI_ImageMagick())	
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][4] + "\"" + " -set option:distort:viewport " + wid + "x" + hei + ofs_x + ofs_y + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][4] + "\"") startpath:start --(GetINI_ImageMagick())	
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][5] + "\"" + " -set option:distort:viewport " + wid + "x" + hei + ofs_x + ofs_y + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][5] + "\"") startpath:start --(GetINI_ImageMagick())	
						
							--HiddenDOSCommand ("magick " + "\"" + ids_colors[i][5] + "\"" + " -set option:distort:viewport " + wid + "x" + hei + ofs_x + ofs_y + " -virtual-pixel Edge -filter point -distort SRT 0 +repage " + "\"" + ids_colors[i][5] + "\"") startpath:(GetINI_ImageMagick())	
						)
					
						if not shift then 	
						(
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024^! " + "\"" + ids_colors[i][3] + "\"" + " ) " + "\"" + picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024^! " + "\"" + ids_colors[i][6] + "\"" + " ) " + "\"" + o_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + o_picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024^! " + "\"" + ids_colors[i][4] + "\"" + " ) " + "\"" + n_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + n_picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024^! " + "\"" + ids_colors[i][5] + "\"" + " ) " + "\"" + m_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024^! " + "\"" + ids_colors[i][5] + "\"" + " ) " + "\"" + r_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())
						)
						else
						(
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -filter Lanczos2Sharp -resize 1024x1024^! " + "\"" + ids_colors[i][3] + "\"" + " ) " + "\"" + picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -filter Lanczos2Sharp -resize 1024x1024^! " + "\"" + ids_colors[i][6] + "\"" + " ) " + "\"" + o_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + o_picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -filter Lanczos2Sharp -resize 1024x1024^! " + "\"" + ids_colors[i][4] + "\"" + " ) " + "\"" + n_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + n_picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -filter Lanczos2Sharp -resize 1024x1024^! " + "\"" + ids_colors[i][5] + "\"" + " ) " + "\"" + m_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())
							HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -filter Lanczos2Sharp -resize 1024x1024^! " + "\"" + ids_colors[i][5] + "\"" + " ) " + "\"" + r_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())
						)
						t += 1
					)	
					
					--??????? ????? ????????
					poi_x = 1024 * ((mod t (tile as integer)) as integer)
					poi_y = (1024 * ((tile as integer) - 1)) - (1024 * (floor (t / (tile as integer))))
					HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024 " + "\"" + picpath_z + "\"" + " ) " + "\"" + picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024 " + "\"" + o_picpath_z + "\"" + " ) " + "\"" + o_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + o_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024 " + "\"" + n_picpath_z + "\"" + " ) " + "\"" + n_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + n_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024 " + "\"" + m_picpath_z + "\"" + " ) " + "\"" + m_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( -interpolate Nearest -filter point -resize 1024x1024 " + "\"" + r_picpath_z + "\"" + " ) " + "\"" + r_picpath + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--		HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:(GetINI_ImageMagick())
						--		cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
						--		HiddenDOSCommand cmd startpath:(GetINI_ImageMagick())
						--		HiddenDOSCommand ("convert " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:(GetINI_ImageMagick())	

						--cmd = "magick montage " + pics + " -filter point -tile " + tile + "x" + tile + " -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + picpath + "\""	--point Lanczos2Sharp				

						--cmd = "magick montage " + pics + " -filter point -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + picpath + "\""	--point Lanczos2Sharp				
						
						--cmd = "magick montage " + pics + " -geometry 1024x1024+0+0^> -border 0 -background black " + "\"" + picpath + "\""
						--cmd = "magick montage " + pics + " -geometry 1024x1024+0+0 -border 0 -background black -resize 2048x2048^> " + "\"" + picpath + "\""
						--print cmd
						
						--o_cmd = "magick montage " + o_pics + " -filter point -geometry 1024x1024+0+0 -border 0 -background white " + "\"" + o_picpath + "\""
						--n_cmd = "magick montage " + n_pics + " -filter point -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + n_picpath + "\""
						--m_cmd = "magick montage " + m_pics + " -filter point -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + m_picpath + "\""
						--r_cmd = "magick montage " + r_pics + " -filter point -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + r_picpath + "\""	

						--o_cmd = "magick montage " + o_pics + " -filter point -tile " + tile + "x" + tile + " -geometry 1024x1024+0+0 -border 0 -background white " + "\"" + o_picpath + "\""
						--n_cmd = "magick montage " + n_pics + " -filter point -tile " + tile + "x" + tile + " -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + n_picpath + "\""
						--m_cmd = "magick montage " + m_pics + " -filter point -tile " + tile + "x" + tile + " -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + m_picpath + "\""
						--r_cmd = "magick montage " + r_pics + " -filter point -tile " + tile + "x" + tile + " -geometry 1024x1024+0+0 -border 0 -background black " + "\"" + r_picpath + "\""						
						--print cmd
						
					if not shift then
					(
						--HiddenDOSCommand (cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + picpath + "\"" + " -interpolate Nearest -filter point -resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (o_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + o_picpath + "\"" + " -interpolate Nearest -filter point -resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background white -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + o_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (n_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + n_picpath + "\"" + " -interpolate Nearest -filter point -resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + n_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (m_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + m_picpath + "\"" + " -interpolate Nearest -filter point -resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + m_picpath + "\"" + " -channel B -separate " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (r_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + r_picpath + "\"" + " -interpolate Nearest -filter point -resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + r_picpath + "\"" + " -channel G -separate " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					)
					else
					(
						--HiddenDOSCommand (cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + picpath + "\"" + " -filter Lanczos2Sharp -adaptive-resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (o_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + o_picpath + "\"" + " -filter Lanczos2Sharp -adaptive-resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background white -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + o_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (n_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + n_picpath + "\"" + " -filter Lanczos2Sharp -adaptive-resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + n_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (m_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + m_picpath + "\"" + " -filter Lanczos2Sharp -adaptive-resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + m_picpath + "\"" + " -channel B -separate " + "\"" + m_picpath + "\"") startpath:start --(GetINI_ImageMagick())

						--HiddenDOSCommand (r_cmd) startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + r_picpath + "\"" + " -filter Lanczos2Sharp -adaptive-resize " + atlas_size as string + "x" + atlas_size as string + " +repage -gravity NorthEast -background black -extent " + atlas_size as string + "x" + atlas_size as string + " -define png:color-type=6 " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + r_picpath + "\"" + " -channel G -separate " + "\"" + r_picpath + "\"") startpath:start --(GetINI_ImageMagick())
					)
					
					if doesFileExist picpath_z then deleteFile picpath_z
					if doesFileExist o_picpath_z then deleteFile o_picpath_z
					if doesFileExist n_picpath_z then deleteFile n_picpath_z
					if doesFileExist m_picpath_z then deleteFile m_picpath_z	
					if doesFileExist r_picpath_z then deleteFile r_picpath_z	

					i.material = shell_material name:m.name viewportMtlIndex:1 renderMtlIndex:1 originalMaterial:m bakedMaterial:(standardmaterial name:m.name DiffuseMap:(bitmaptexture filename:picpath) BumpMap:(bitmaptexture filename:n_picpath) ReflectionMap:(bitmaptexture filename:m_picpath) GlossinessMap:(bitmaptexture filename:r_picpath) OpacityMap:(bitmaptexture filename:o_picpath))
					gc light:true
					if not alt then if errored_texelDensities.count > 0 then messageBox ("There are IDs with problems:\n" + (errored_texelDensities) as string)
				)
			)
		)
	)

	on btn_UdimScale pressed do with undo "Scale Selection of Texel" on
	(
		if selection.count > 0 then 
		(	
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(
				faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
				if faces.count > 0 then
				(
					if ctrl and alt then
					(
						areas = #()
						arr = faces
						while not arr.isempty do
						(
							if keyboard.escPressed then exit
							for i in arr do (unwrapmod.selectFaces #{i}; exit)
							unwrapmod.selectElement()
							elem = unwrapmod.getselectedfaces()
							pos = unwrapmod.getSelCenter()
							--unwrapmod.breakSelected()
							unwrapmod.getArea elem &x &y &width &height &areaUVW &areaGeom
							if width > height then append areas width else append areas height 
							arr -= elem
						)
						scal = amax areas		
						arr = faces
						while not arr.isempty do
						(
							if keyboard.escPressed then exit
							for i in arr do (unwrapmod.selectFaces #{i}; exit)
							unwrapmod.selectElement()
							elem = unwrapmod.getselectedfaces()
							pos = unwrapmod.getSelCenter()
							unwrapmod.getArea elem &x &y &width &height &areaUVW &areaGeom
							sc = if width > height then width else height 
							unwrapmod.scaleSelectedXY (scal/sc) (scal/sc) [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter sc 0
							arr -= elem
						)
						unwrapmod.selectFaces faces						
					)
					
					if ctrl and not alt then
					(
						areas = #()
						arr = faces
						pos = unwrapmod.getSelCenter()
						while not arr.isempty do
						(
							if keyboard.escPressed then exit
							for i in arr do (unwrapmod.selectFaces #{i}; exit)
							unwrapmod.selectElement()
							elem = unwrapmod.getselectedfaces()
							--unwrapmod.breakSelected()
							unwrapmod.getArea elem &x &y &width &height &areaUVW &areaGeom
							if width > height then append areas width else append areas height --???????? ??? ?????? ???????? ? ????? ????? ????????????, ? ???? ???????? ??? ?? ?????????
							arr -= elem
						)
						sc = spn_bricks_unwrap_sc.value/(amax areas) --equal to udim borders = 1/(amax areas) 
						unwrapmod.selectFaces faces	
						unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter sc 0							
					)
					
					if alt and not ctrl then
					(
						arr = faces
						while not arr.isempty do
						(
							areas = #()
							if keyboard.escPressed then exit
							for i in arr do (unwrapmod.selectFaces #{i}; exit)
							unwrapmod.selectElement()
							elem = unwrapmod.getselectedfaces()
							pos = unwrapmod.getSelCenter()
							--unwrapmod.breakSelected()
							unwrapmod.getArea elem &x &y &width &height &areaUVW &areaGeom
							if width > height then append areas width else append areas height --???????? ??? ?????? ???????? ? ????? ????? ????????????, ? ???? ???????? ??? ?? ?????????
							arr -= elem
							sc = spn_bricks_unwrap_sc.value/(amax areas) --equal to udim borders = 1/(amax areas) 		
							unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter sc 0								
						)
						unwrapmod.selectFaces faces	
					)
					
					if not ctrl and not alt then
					(
						areas = #()
						pos = unwrapmod.getSelCenter()
						for i in faces where not keyboard.escPressed do
						(
							unwrapmod.getArea #{i} &x &y &width &height &areaUVW &areaGeom
							if width > height then append areas width else append areas height --???????? ??? ?????? ???????? ? ????? ????? ????????????, ? ???? ???????? ??? ?? ?????????
						)
						sc = spn_bricks_unwrap_sc.value/(amax areas) --equal to udim borders = 1/(amax areas) 
						unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter sc 0
					)
				)
			)
		)
	)
	
	on btn_Editor rightclick do with undo "Edit Texture" on
	(
		global id = 1
		global m = undefined
		global tex = undefined
		global textures = #()
		global unwrapmod 
		global faces
		global pos
		global img_tag_initial_large
		global img_tag_scaled_large
		
		if selection.count > 0 then 
		(
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(
				faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
				if faces.count > 0 then
				(
					pos = unwrapmod.getSelCenter()
					--unwrapmod.getArea faces &mX &mY &width &height &areaUVW &areaGeom
					id = (pos.x as integer) + 1 + 10 * (pos.y as integer)
					--UDIM = id + 1000
				)
			)
			
			if selection[1].material != undefined then
			(
				m = selection[1].material
				case classof m of
				(
					CoronaLegacyMtl:
					(
						if m.texmapDiffuse != undefined then tex = m.texmapDiffuse
						--if m.texmapReflect != undefined then render_map m.texmapReflect rez (edt_multimat_path.text + m.name + "_Reflect" + ".png")
						--if m.texmapReflectGlossiness != undefined then render_map m.texmapReflectGlossiness rez (edt_multimat_path.text + _m.name + "_ReflectGlossiness" + ".png")
						--if m.texmapRefract != undefined then render_map m.texmapRefract rez (edt_multimat_path.text + m.name + "_Refract" + ".png")
						--if m.texmapRefractGlossiness != undefined then render_map m.texmapRefractGlossiness rez (edt_multimat_path.text + m.name + "_RefractGlossiness" + ".png")
						--if m.texmapOpacity != undefined then render_map m.texmapOpacity rez (edt_multimat_path.text + m.name + "_Opacity" + ".png")
						--if m.texmapBump != undefined then render_map m.texmapBump rez (edt_multimat_path.text + m.name + "_Bump" + ".png")
						--if m.texmapTranslucency != undefined then render_map m.texmapTranslucency rez (edt_multimat_path.text + m.name + "_Translucency" + ".png")
						--if m.texmapDisplace != undefined then render_map m.texmapDisplace rez (edt_multimat_path.text + m.name + "_Displace" + ".png")
						--if m.texmapSelfIllum != undefined then render_map m.texmapSelfIllum rez (edt_multimat_path.text + m.name + "_SelfIllum" + ".png")
					)
					
					CoronaPhysicalMtl:
					(
					)
					
					Physical_Material:
					(
						if m.base_color_map != undefined then tex = m.base_color_map --render_map m.base_color_map rez (edt_multimat_path.text + _m.name + "_Diffuse" + ".png")
						--if m.roughness_map != undefined then render_map m.roughness_map rez (edt_multimat_path.text + _m.name + "_Roughness" + ".png")
						--if m.metalness_map != undefined then render_map m.metalness_map rez (edt_multimat_path.text + _m.name + "_Metalness" + ".png")	
						--if m.bump_map != undefined then render_map m.bump_map rez (edt_multimat_path.text + m.name + "_Bump" + ".png")
						--if m.cutout_map != undefined then render_map m.cutout_map rez (edt_multimat_path.text + m.name + "_Opacity" + ".png")
					)
	
					Standardmaterial:
					(
						if m.DiffuseMap != undefined then tex = m.DiffuseMap --render_map m.DiffuseMap rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")				
						--if m.BumpMap != undefined then render_map m.BumpMap rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
						--if m.ReflectionMap != undefined then render_map m.ReflectionMap rez (edt_multimat_path.text + sub_m.name + "_Reflection" + ".png")
						--if m.GlossinessMap != undefined then render_map m.GlossinessMap rez (edt_multimat_path.text + sub_m.name + "_Glossiness" + ".png")
						--if m.OpacityMap != undefined then render_map m.OpacityMap rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
					)
								
					Multimaterial: 
					(
						sub_m = m.materialList[id]
						if sub_m != undefined then
						(
							case classof sub_m of
							(
								CoronaLegacyMtl:
								(
									if sub_m.texmapDiffuse != undefined then tex = sub_m.texmapDiffuse --render_map sub_m.texmapDiffuse rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")
									--if sub_m.texmapReflect != undefined then render_map sub_m.texmapReflect rez (edt_multimat_path.text + sub_m.name + "_Reflect" + ".png")
									--if sub_m.texmapReflectGlossiness != undefined then render_map sub_m.texmapReflectGlossiness rez (edt_multimat_path.text + sub_m.name + "_ReflectGlossiness" + ".png")
									--if sub_m.texmapRefract != undefined then render_map sub_m.texmapRefract rez (edt_multimat_path.text + sub_m.name + "_Refract" + ".png")
									--if sub_m.texmapRefractGlossiness != undefined then render_map sub_m.texmapRefractGlossiness rez (edt_multimat_path.text + sub_m.name + "_RefractGlossiness" + ".png")
									--if sub_m.texmapOpacity != undefined then render_map sub_m.texmapOpacity rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
									--if sub_m.texmapBump != undefined then render_map sub_m.texmapBump rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
									--if sub_m.texmapTranslucency != undefined then render_map sub_m.texmapTranslucency rez (edt_multimat_path.text + sub_m.name + "_Translucency" + ".png")
									--if sub_m.texmapDisplace != undefined then render_map sub_m.texmapDisplace rez (edt_multimat_path.text + sub_m.name + "_Displace" + ".png")
									--if sub_m.texmapSelfIllum != undefined then render_map sub_m.texmapSelfIllum rez (edt_multimat_path.text + sub_m.name + "_SelfIllum" + ".png")
								)
								
								CoronaPhysicalMtl:
								(
									
								)
								
								Physical_Material:
								(
									if sub_m.base_color_map != undefined then tex = sub_m.base_color_map --render_map sub_m.base_color_map rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")
									--if sub_m.roughness_map != undefined then render_map sub_m.roughness_map rez (edt_multimat_path.text + sub_m.name + "_Roughness" + ".png")
									--if sub_m.metalness_map != undefined then render_map sub_m.metalness_map rez (edt_multimat_path.text + sub_m.name + "_Metalness" + ".png")	
									--if sub_m.bump_map != undefined then render_map sub_m.bump_map rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
									--if sub_m.cutout_map != undefined then render_map sub_m.cutout_map rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
								
								Standardmaterial:
								(
									if sub_m.DiffuseMap != undefined then tex = sub_m.DiffuseMap --render_map sub_m.DiffuseMap rez (edt_multimat_path.text + sub_m.name + "_Diffuse" + ".png")				
									--if sub_m.BumpMap != undefined then render_map sub_m.BumpMap rez (edt_multimat_path.text + sub_m.name + "_Bump" + ".png")
									--if sub_m.ReflectionMap != undefined then render_map sub_m.ReflectionMap rez (edt_multimat_path.text + sub_m.name + "_Reflection" + ".png")
									--if sub_m.GlossinessMap != undefined then render_map sub_m.GlossinessMap rez (edt_multimat_path.text + sub_m.name + "_Glossiness" + ".png")
									--if sub_m.OpacityMap != undefined then render_map sub_m.OpacityMap rez (edt_multimat_path.text + sub_m.name + "_Opacity" + ".png")
								)
							)
						)
					)
				)
				if tex != undefined then
				(
					if hasproperty tex "filename" then tex = tex --.filename
					else tex = undefined -- or render texture to file
				)
			)
		)
		
		try(destroyDialog ::ScaleEDITOR)catch()
		try(closeRolloutFloater ScaleEDITOR)catch()
		ScaleEDITOR = newRolloutFloater "Edit Bitmaps and UVW" 500 720
		rollout TextureEDITOR "Texture Editor" autoLayoutOnResize:true width:500 height:360
		(
			radiobuttons rdo_texture_source labels: #("Get texture from Material", "Get from source") offsets:#([0,0], [0,0]) default:1 columns:2 rows:1 offset:[0,0] across:2 align:#left enabled:false tooltip:""
			radiobuttons rdo_scale_corner labels: #("ul","ur","center","dl","dr") offsets:#([0,0], [0,0], [0,0], [0,0], [0,0]) default:3 columns:3 rows:2 offset:[0,0] tooltip:""
 			label lbl_d "Initial texture" across:2 align:#left
			label lbl_o "Edited texture" align:#right
			imgtag img_tag_initial bitmap:(bitmap 200 200 color:(color 100 100 100) gamma:1.0 hdr:false alpha:true) width:200 height:200 style:#bmp_stretch across:3 align:#left
			label lbl_a "=>" offset:[0,100]
			imgtag img_tag_Scaled bitmap:(bitmap 200 200 color:(color 100 100 100) gamma:1.0 hdr:false alpha:true) width:200 height:200 style:#bmp_stretch align:#right

			edittext edt_Initial text:"" width:200 align:#left across:2
			edittext edt_Scaled text:"" width:200 align:#right
			
			spinner spn_materialID "Material ID" range:[1, 1000, id] type:#integer width:50 fieldWidth:20 across:5 align:#left tooltip:""	
			spinner spn_rotation "Rotation" range:[-360.0, 360.0, 0.0] type:#float scale:0.1 offset:[70,0] width:50 fieldWidth:50 tooltip:""			
			spinner spn_scale "Scale" range:[0.001, 10000.0, 1.0] type:#float scale:0.001 width:50 fieldWidth:40 offset:[20,0] tooltip:""
			spinner spn_roll_x "Roll X" range:[-10000.0, 10000.0, 0.0] type:#float scale:0.001 width:50 fieldWidth:40 align:#right tooltip:""
			spinner spn_roll_y "Roll Y" range:[-10000.0, 10000.0, 0.0] type:#float scale:0.001 width:50 fieldWidth:40 align:#right tooltip:""
			button bnt_get_Initial_map "Open Initial texture" width:150 align:#left across:4 tooltip:""
			button btn_make_Scaled_map "Edit Texture" width:100 offset:[30,0] tooltip:""
			checkbox chk_do_all_texs "Do all maps" checked:false offset:[50,0] 
			checkbox chk_scale_uv "Also Edit UVW" checked:false align:#right
			
			on bnt_get_Initial_map pressed do
			(
				source = getOpenFileName "Select Initial map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then	
					(
						img_tag_initial.bitmap = openBitMap source 
						edt_Initial.text = source --getfilenamefile source + getfilenametype source
						edt_Scaled.text = getfilenamepath (img_tag_initial.bitmap.filename) + getfilenamefile (img_tag_initial.bitmap.filename) + "_Edited" + getfilenametype (img_tag_initial.bitmap.filename)
					)
				)
			)
			
			on img_tag_initial mousedown do try(display (openBitMap (img_tag_initial.bitmap.filename) ))catch(bnt_get_Initial_map.pressed())
			on img_tag_Scaled mousedown do try(display (openBitMap (img_tag_Scaled.bitmap.filename) ))catch(messagebox "Make Edited texture first")
	
			on btn_make_Scaled_map pressed do
			(	
				if img_tag_initial.bitmap.filename != "" then
				(
					sourcepath = if edt_Initial.text != "" then edt_Initial.text  
					finalpath = if edt_Scaled.text != "" then edt_Scaled.text else getfilenamepath (img_tag_initial.bitmap.filename) + getfilenamefile (img_tag_initial.bitmap.filename) + "_Edited" + getfilenametype (img_tag_initial.bitmap.filename)

					a = openBitMap sourcepath
					if a != undefined then
					(
						if doesfileexist finalpath then deletefile finalpath
														
						hei = a.height
						wid = a.width 
						alfa = false
						if a.hasalpha != undefined then alfa = a.hasAlpha
						close a
						free a
						
						sc = spn_scale.value
						
						HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath + "\"") startpath:(GetINI_ImageMagick())

						--x_ = -(spn_roll_x.value - 0.5)
						--y_ = -(spn_roll_y.value - 0.5)
						x_ = spn_roll_x.value
						y_ = spn_roll_y.value							
						x = ((x_ * wid ) as integer) 
						y = ((y_ * hei ) as integer) 
						x = if x >= 0 then "+" + (x as string) else (x as string)
						y = if y >= 0 then "+" + (y as string) else (y as string)
								
						format "scale=% x=% % y=% %\n" sc x_ x y_ y
								
						--cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
						--cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT " + spn_rotation.value as string + " +repage " + "\"" + finalpath + "\""

						if alfa then
						(
							cmd = "magick " + "\"" + finalpath + "\"" + " -alpha set -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT " + spn_rotation.value as string + " +repage " + "\"" + finalpath + "\""
						)	
						else
						(
							cmd = "magick " + "\"" + finalpath + "\"" + " -alpha off -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT " + spn_rotation.value as string + " +repage " + "\"" + finalpath + "\""
						)
						
						--magick checks.png -alpha set -virtual-pixel tile -distort ScaleRotateTranslate  '20,20  .5  30' checks_srt_tile.png
						HiddenDOSCommand cmd startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:(GetINI_ImageMagick())	
					)			
					img_tag_Scaled.bitmap = openBitMap finalpath				
				)
				else messagebox "Load Initial texture first"	
				
				if chk_scale_uv.checked then
				if selection.count > 0 then 
				(
					--ctrl = keyboard.controlPressed
					--alt = keyboard.altPressed
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						faces = unwrapmod.getselectedfaces() --unwrapmod.selectFaces faces
						if faces.count > 0 then
						(
							pos = unwrapmod.getSelCenter()
							unwrapmod.getArea faces &x &y &width &height &areaUVW &areaGeom
							sc = spn_bricks_unwrap_sc.value
							unwrapmod.selectFaces faces	
							
							case rdo_scale_corner.state of
							(
								3: unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter sc 0		
							)
							unwrapmod.moveSelected [spn_roll_x.value, spn_roll_y.value, 0.0]
							unwrapmod.rotateSelectedCenter spn_rotation.value
							--unwrapmod.rotateSelected <float>angle <point3>axis 
						)
					)
				)
			)
			
			on TextureEditor open do
			(
				gc()
				if tex != undefined then --if hasproperty filename checked upper
				(
					img_tag_initial_large = openBitMap tex.filename
					img_tag_initial.bitmap = copy img_tag_initial_large 
					img_tag_initial.bitmap.filename = tex.filename
					img_tag_Scaled.bitmap = copy img_tag_initial_large
					img_tag_scaled_large = copy img_tag_initial_large
					
					edt_Initial.text = tex.filename
					edt_Scaled.text = getfilenamepath (img_tag_initial.bitmap.filename) + getfilenamefile (img_tag_initial.bitmap.filename) + "_Edited" + getfilenametype (img_tag_initial.bitmap.filename)
				)					
			)
			
			on TextureEditor close do
			(
				if img_tag_initial != undefined then close img_tag_initial.bitmap
				if img_tag_Scaled != undefined then close img_tag_Scaled.bitmap
				if img_tag_initial_large != undefined then close img_tag_initial_large
				if img_tag_initial_large != undefined then free img_tag_initial_large
				if img_tag_initial != undefined then free img_tag_initial.bitmap				
				if img_tag_Scaled != undefined then free img_tag_Scaled.bitmap
				gc()
			)
			
			--on spn_rotation changed val do 
			--(
			--)
		)
		addRollout TextureEDITOR ScaleEDITOR
		
		rollout BlendEDITOR "Blend Editor" autoLayoutOnResize:true width:500 height:360
		(
 			imgtag img_tag_initial1 bitmap:(bitmap 200 200 color:(color 100 100 100) gamma:1.0 hdr:false alpha:true) width:200 height:200 style:#bmp_stretch across:4 align:#left
			imgtag img_tag_initial2 bitmap:(bitmap 200 200 color:(color 100 100 100) gamma:1.0 hdr:false alpha:true) width:200 height:200 offset:[-115, 205] style:#bmp_stretch align:#left
			label lbl_a "=>" offset:[-60, 190]
			imgtag img_tag_blend bitmap:(bitmap 200 200 color:(color 100 100 100) gamma:1.0 hdr:false alpha:true) width:200 height:200 style:#bmp_stretch align:#right
		
			radiobuttons rdo_scale_corner labels: #("ul","ur","center","dl","dr") offsets:#([0,0], [0,0], [0,0], [0,0], [0,0]) default:3 columns:5 rows:1 offset:[0,0] align:#left tooltip:""
 
			spinner spn_rotation "Rotation" range:[-360.0, 360.0, 0.0] type:#float scale:0.1 offset:[0,0] width:50 across:5 fieldWidth:50 align:#left tooltip:""			
			spinner spn_scale "Scale" range:[0.001, 10000.0, 1.0] type:#float scale:0.001 width:50 fieldWidth:40 offset:[20,0] tooltip:""
			spinner spn_roll_x "Roll X" range:[-10000.0, 10000.0, 0.0] type:#float scale:0.001 width:50 fieldWidth:40 tooltip:""
			spinner spn_roll_y "Roll Y" range:[-10000.0, 10000.0, 0.0] type:#float scale:0.001 width:50 fieldWidth:40 tooltip:""
			spinner spn_gamma "gamma" range:[0.01, 100.0, 1.0] type:#float scale:0.001 width:50 fieldWidth:40 align:#right tooltip:""
	
			edittext edt_Initial1 text:"" width:150 align:#left across:3
			edittext edt_Initial2 text:"" width:150
			edittext edt_Blend text:"" width:150 align:#right	

			button bnt_get_Initial_map1 "Open Initial texture 1" width:150 align:#left across:3 tooltip:""
			button bnt_get_Initial_map2 "Open Initial texture 2" width:150 tooltip:""
			button btn_make_blend_map "Edit Texture" width:150 align:#right offset:[0,0] tooltip:""

			on BlendEDITOR open do
			(
				gc()
			)
			
			on BlendEDITOR close do
			(
				gc()
			)
			
			on bnt_get_Initial_map1 pressed do
			(
				source = getOpenFileName "Select Initial map 1" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then	
					(
						img_tag_initial1.bitmap = openBitMap source 
						edt_Initial1.text = source --getfilenamefile source + getfilenametype source
						edt_Blend.text = getfilenamepath (img_tag_initial1.bitmap.filename) + getfilenamefile (img_tag_initial1.bitmap.filename) + "_Edited" + getfilenametype (img_tag_initial1.bitmap.filename)
					)
				)
			)
			
			on bnt_get_Initial_map2 pressed do
			(
				source = getOpenFileName "Select Initial map 2" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
				print source
				if source != undefined then
				(
					if doesfileexist source then	
					(
						img_tag_initial2.bitmap = openBitMap source 
						edt_Initial2.text = source --getfilenamefile source + getfilenametype source
						--edt_Blended.text = getfilenamepath (img_tag_initial1.bitmap.filename) + getfilenamefile (img_tag_initial1.bitmap.filename) + "_Edited" + getfilenametype (img_tag_initial1.bitmap.filename)
					)
				)
			)
			
			on img_tag_initial1 mousedown do try(display (openBitMap (img_tag_initial1.bitmap.filename) ))catch(bnt_get_Initial_map1.pressed())
			on img_tag_initial2 mousedown do try(display (openBitMap (img_tag_initial2.bitmap.filename) ))catch(bnt_get_Initial_map2.pressed())
				
			on img_tag_blend mousedown do try(display (openBitMap (img_tag_blend.bitmap.filename) ))catch(messagebox "Make Edited texture first")
	
			on btn_make_blend_map pressed do
			(	
				if img_tag_initial1.bitmap.filename != "" and img_tag_initial2.bitmap.filename != "" then
				(
					sourcepath1 = if edt_Initial1.text != "" then edt_Initial1.text  
					sourcepath2 = if edt_Initial2.text != "" then edt_Initial2.text  
					finalpath = if edt_Blend.text != "" then edt_Blend.text else getfilenamepath (img_tag_initial1.bitmap.filename) + getfilenamefile (img_tag_initial1.bitmap.filename) + "_Edited" + getfilenametype (img_tag_initial1.bitmap.filename)
					finalpath2 = getfilenamepath (img_tag_initial2.bitmap.filename) + getfilenamefile (img_tag_initial2.bitmap.filename) + "_Edited" + ".png"

					a = openBitMap sourcepath1
					b = openBitMap sourcepath2
					if a != undefined and b != undefined then
					(
						if doesfileexist finalpath then deletefile finalpath
						if doesfileexist finalpath2 then deletefile finalpath2
														
						--hei = a.height
						--wid = a.width 
						alfa = false
						if a.hasalpha != undefined then alfa = a.hasAlpha
						close a
						free a
						
						--hei2 = b.height
						--wid2 = b.width 
						alfa2 = false
						if b.hasalpha != undefined then alfa2 = b.hasAlpha
						close b
						free b						
						
						sc = spn_scale.value
						x_ = spn_roll_x.value
						y_ = spn_roll_y.value							
						--x = ((x_ * wid2 ) as integer) 
						--y = ((y_ * hei2 ) as integer) 
						x = if x_ >= 0 then "+" + (x_ as string) else (x_ as string)
						y = if y_ >= 0 then "+" + (y_ as string) else (y_ as string)
								
						format "scale=% x=% % y=% %\n" sc x_ x y_ y			
						
						HiddenDOSCommand ("magick " + "\"" + sourcepath2 + "\"" + " -resize " + (sc*100) as string + "^% " + "\"" + finalpath2 + "\"") startpath:(GetINI_ImageMagick())
								
						--cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT 0 +repage " + "\"" + finalpath + "\""
						--cmd = "magick " + "\"" + finalpath + "\"" + " -set option:distort:viewport " + wid as string + "x" + hei as string + x + y + " -virtual-pixel tile -filter point -distort SRT " + spn_rotation.value as string + " +repage " + "\"" + finalpath + "\""

						local cmd_alpha = if alfa then "set" else "off"
		
						local corner = case rdo_scale_corner.state of 
						(
							--#("ul","ur","center","dl","dr")
							1: "northwest"
							2: "northeast"
							3: "center"
							4: "southwest"
							5: "southeast"
						)
						
						--cmd = "magick " + "\"" + finalpath2 + "\"" + " -alpha " + cmd_alpha + " -set option:distort:viewport " + wid2 as string + "x" + hei2 as string + x + y + " -virtual-pixel tile -filter point -distort SRT " + spn_rotation.value as string + " +repage " + "\"" + finalpath + "\""
						--HiddenDOSCommand ("convert " + "\"" + sourcepath1 + "\"" + " "+ "\"" + finalpath2 + "\"" + " -gravity center -geometry +0+0 -compose src-over modulate -define compose:args=100 -composite -define png:color-type=6 " + "\""+ finalpath + "\"") startpath:(getINISetting (GetDir #maxroot +"\\GeoScripts\\GeoScripts.ini") "Directories" "ImageMagick")

						cmd = "magick " + "\"" + sourcepath1 + "\"" + " -gamma " + (substitutestring (spn_gamma.value as string) "," ".") + " " + "\"" + finalpath2 + "\"" + " -gravity " + corner + " " + cmd_alpha + " -geometry " + x + y + " -compose src-over modulate -define compose:args=100 -composite -define png:color-type=6 " + "\""+ finalpath + "\""

						print cmd
						HiddenDOSCommand cmd startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + finalpath + "\""+ " PNG24:" + "\""+ finalpath + "\"") startpath:(GetINI_ImageMagick())	
					)			
					img_tag_blend.bitmap = openBitMap finalpath				
				)
				else messagebox "Load Initial texture first"	
				
			)
		)
		addRollout BlendEDITOR ScaleEDITOR
	)
	
	on btn_UdimRotate pressed do with undo "Rotate Selection to Axis" on
	(
		fn getAngleDiff dx dy=
		(
			local _a_abs_ = ""
			local _a_abs = mod ((atan2 dx dy) + 4*360) 360	--the angle in closed 360 degrees			
			local _a_off = (mod _a_abs 90)	--angle offset
			--print _a_abs
			--print _a_off
			if (_a_abs > 45 and _a_abs < 135) or (_a_abs > 225 and _a_abs < 335) then
			(
				_a_abs_ = "v"
			)
			else
			(
				_a_abs_ = "h"
			)
			if (_a_off > 45)then
			(
				_a_off = -(90 - _a_off)
			)
			#(_a_off,_a_abs_)
			--_a_off 
			--_a_off
		)
		
		if selection.count > 0 then
		(
			alt = keyboard.altPressed
			ctrl = keyboard.controlPressed
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(	
				local elems = #()
				local faces = unwrapmod.getselectedfaces()
				if faces.count > 0 then
				(
					local arr = faces
					while not arr.isempty do
					(
						if keyboard.escPressed then exit
						for i in arr do (unwrapmod.selectFaces #{i}; exit)
						unwrapmod.selectElement()
						elem = unwrapmod.getselectedfaces()
						append elems elem
						arr -= elem
					)

					for elem in elems do
					(
						unwrapmod.selectFaces elem
						local pos = unwrapmod.getSelCenter()
						unwrapmod.FaceToEdgeSelect() 
						local edges = unwrapmod.getSelectedEdges() 		
						if edges.count > 0 then
						(
							local angles = #()
							local dists = #()
							local verts = #{}
							local pp = #()
							for e in edges do
							(
								unwrapmod.selectEdges #{e}
								unwrapmod.edgeToVertSelect()
								local verts = unwrapmod.getSelectedVertices()
								local p = for v in verts collect unwrapmod.getvertexposition currenttime v
								append dists #(e, distance p[1] p[2], p[1], p[2])
							)
							local longest = amax (for e in dists collect e[2])
							local longest2 = amax (for e in dists where e[2] < longest collect e[2])
							local need = for e in dists where e[2] == longest2 do exit with e
							if ctrl then need = for e in dists where e[2] == longest do exit with e
							local pp = #(need[3], need[4]) 
							
							if pp[1].y <= pp[2].y then angle = acos (dot y_axis (normalize (pp[2] - pp[1]))) else angle = acos (dot y_axis (normalize (pp[1] - pp[2])))
							--if pp[1].x > pp[2].x then append angles #(angle, angle, distance pp[1] pp[2]) else append angles #(-angle, angle, distance pp[1] pp[2])
							angles = if pp[1].x <= pp[2].x then angle else -angle
							--print angles
							unwrapmod.RotateSelected (degToRad -angles /** 0.0174533*/) pos
							if alt then unwrapmod.RotateSelected (degToRad 90) pos
							
								--local ptA = pp[1]
								--local ptB = pp[2]
								--local dx = ptB.x - ptB.y
								--local dy = ptA.x - ptA.y
								--append angles (getAngleDiff dx dy)
								--unwrapmod.RotateSelected (degToRad -(getAngleDiff 1 dy)[1] ) pos
									
								--if vh == "v" do unwrapmod.RotateSelected (degToRad 90) pos
								--if vh == "h" do unwrapmod.RotateSelected (degToRad 90) pos
								--append angles a_off
								
							
							--local dist = amin (for a in angles collect a[3])
							--local angle = for a in angles where a[3] == dist do exit with a[1]
							--unwrapmod.RotateSelected (-angles[1][1] * 0.0174533) pos
							--local angle = amin (for a in angles collect a[1])
							--local vh = for a in angles where a[1] == b do exit with a[2]
							--unwrapmod.RotateSelected  (-angle * 0.0174533) pos --[(ptA.x + dx/2),(ptA.y + dy/2),0]
							--if vh == "v" do unwrapmod.RotateSelected (degToRad 90) pos
							--if vh == "h" do unwrapmod.RotateSelected (degToRad 90) pos

						)
					)
					unwrapmod.selectFaces faces
				)
				
			)				
		)
	)
	
	on btn_UdimMove pressed do with undo "Move Selection to First UDIM" on --??????? ???????? ? ????? ?????
	(
		if selection.count > 0 then
		(
			alt = keyboard.altPressed
			ctrl = keyboard.controlPressed
			max modify mode
			unwrapmod = modpanel.getcurrentobject()
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(	
				faces = unwrapmod.getselectedfaces()
				if faces.count > 0 then
				(
					if ctrl then
					(
						for i in faces where not keyboard.escPressed do
						(
							unwrapmod.selectFaces #{i}
							unwrapmod.breakSelected()
							pos = unwrapmod.getSelCenter()
							unwrapmod.moveSelected [(0.5 - pos.x), (0.5 - pos.y), 0]
						)
						unwrapmod.selectFaces faces
					)
					
					if alt then
					(
						arr = faces
						while not arr.isempty do --for i in faces do
						(
							if keyboard.escPressed then exit
							for i in arr do (unwrapmod.selectFaces #{i}; exit)
							unwrapmod.selectElement()
							elem = unwrapmod.getselectedfaces()
							--unwrapmod.breakSelected()
							pos = unwrapmod.getSelCenter()
							unwrapmod.moveSelected [(0.5 - pos.x), (0.5 - pos.y), 0]
							arr -= elem
						)
						unwrapmod.selectFaces faces						
					)
					
					if not ctrl and not alt then
					(
						--unwrapmod.selectFaces faces
						unwrapmod.breakSelected()
						pos = unwrapmod.getSelCenter()
						--unwrapmod.moveSelected [(0.5 - (dr pos.x)), (0.5 - (dr pos.y)), 0]
						unwrapmod.moveSelected [(0.5 - pos.x), (0.5 - pos.y), 0]
						--btn_UdimScale.pressed()
					)
				)
			)
		)
	)
	
	on btn_bricks_unwrap_get_num pressed do --????????? ?????? ?????? ?????????? ???????, ?? ???????? ?? ????????? ?????????
	(
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces()
			if (faces as array).count == 1 then
			(
				spn_bricks_unwrap_num.value = (faces as array)[1]
			)
			else messagebox "Select single face."
		)
	)
	
	on btn_bricks_unwrap pressed do
	(
		if chk_bricks_unwrap_undo.checked then 
		(
			clearUndoBuffer()
			gc()
			with undo off 
			(
				if chk_bricks_unwrap_rescale.checked then btn_Udim_Rescale.pressed()
				if chk_bricks_unwrap_cut.checked then 
				(
					TAG (selection as array) false
					--slicers.btn_uv_cut.pressed() 
					addmodifier selection[1] (Unwrap_UVW())
				)
				if chk_bricks_unwrap_cut2.checked then 
				(
					slicers.btn_uv_cut_pressed.pressed()
					addmodifier selection[1] (Unwrap_UVW())
				)				
				btn_bricks_unwrap_pressed.pressed()
			)
			gc()
		)
		else 
		(
			with undo "Tiles Unwrap" on 
			(
				if chk_bricks_unwrap_rescale.checked then btn_Udim_Rescale.pressed()
				if chk_bricks_unwrap_cut.checked then 
				(
					TAG (selection as array) false
					--slicers.btn_uv_cut.pressed()
					addmodifier selection[1] (Unwrap_UVW())
				)
				if chk_bricks_unwrap_cut2.checked then 
				(
					slicers.btn_uv_cut_pressed.pressed()
					addmodifier selection[1] (Unwrap_UVW())
				)	
				btn_bricks_unwrap_pressed.pressed() 
			)
		)
	)
	
	on btn_bricks_unwrap rightclick do
	(
		if chk_bricks_unwrap_undo.checked then 
		(
			clearUndoBuffer()
			gc()
			with undo off 
			(
				if chk_bricks_unwrap_cut.checked then 
				(
					TAG (selection as array) false
					--slicers.btn_uv_cut.pressed() 
					addmodifier selection[1] (Unwrap_UVW())
				)
				if chk_bricks_unwrap_cut2.checked then 
				(
					slicers.btn_uv_cut_pressed.pressed()
					addmodifier selection[1] (Unwrap_UVW())
				)	
				btn_bricks_unwrap_rightclick.pressed()
			)
			gc()
		)
		else 
		(
			with undo "Tiles Unwrap" on 
			(
				if chk_bricks_unwrap_cut.checked then 
				(
					TAG (selection as array) false
					--slicers.btn_uv_cut.pressed()
					addmodifier selection[1] (Unwrap_UVW())
				)	
				if chk_bricks_unwrap_cut2.checked then 
				(
					slicers.btn_uv_cut_pressed.pressed()
					addmodifier selection[1] (Unwrap_UVW())
				)					
				btn_bricks_unwrap_rightclick.pressed() 
			)
		)
	)
	
	on btn_bricks_unwrap_pressed pressed do --with undo "Tiles Unwrap" on
	(
		gc light:true
		sc = 1.0
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			unwrapmod.setTVSubObjectMode 3 --unwrapmod.setPolygonMode true
			faces = #{}
			faces = unwrapmod.getselectedfaces()
			if faces.isempty then faces = #{1..unwrapmod.numberPolygons()}
			t = spn_bricks_unwrap_treshold.value --0.05
			if not faces.isempty then
			(
				if chk_bricks_unwrap_unfold.checked then
					try
					(
						unwrapmod.unfoldMapNoParams() --unwrapmod.unfoldMap 1
						--unwrapmod.selectFaces faces
						--unwrapmod.breakSelected()
					)catch() 
				unwrapmod.faceToEdgeSelect()
				unwrapmod.setTVSubObjectMode 2
				--edges = unwrapmod.getSelectedEdges()
				unwrapmod.breakSelected()
				unwrapmod.setTVSubObjectMode 3
				
				unwrapmod.selectFaces faces --?????????????
				for f in faces where not keyboard.escPressed do
				(
					unwrapmod.selectFaces #{f}
					unwrapmod.breakSelected()
				)
				
				unwrapmod.selectFaces faces
				face = if not chk_unwrap_texel_or_poly.checked then spn_bricks_unwrap_num.value else 10000000
				have = false
				if not chk_unwrap_texel_or_poly.checked then 
					for i in faces where spn_bricks_unwrap_num.value == i and not keyboard.escPressed do 
					(
						have = true
						exit
					) --if not chk_bricks_unwrap_unfold.checked then

				--areas = #()
				dims_h = #()
				dims_w = #()
				if not have then 
				(
					for i in faces where not keyboard.escPressed do
					(
						unwrapmod.getArea #{i} &x &y &width &height &areaUVW &areaGeom
						--if chk_bricks_unwrap_height.checked then append areas height else append areas width
						append dims_h height 
						append dims_w width
					)
				)
				else 
				(
					unwrapmod.getArea #{face} &x &y &width &height &areaUVW &areaGeom
					--if chk_bricks_unwrap_height.checked then append areas height else append areas width
					append dims_h height 
					append dims_w width				
				)
				
				hei = amax dims_h
				wid = amax dims_w		
				
				if chk_bricks_unwrap_scale.checked then
				(
					--if not chk_bricks_unwrap_unfold.checked then 
					if chk_bricks_unwrap_height.checked and chk_bricks_unwrap_width.checked then sc = 1.0 / amax #(hei, wid)
					if chk_bricks_unwrap_height.checked and not chk_bricks_unwrap_width.checked then sc = 1.0 / hei
					if not chk_bricks_unwrap_height.checked and chk_bricks_unwrap_width.checked then sc = 1.0 / wid		
					if not chk_bricks_unwrap_height.checked and not chk_bricks_unwrap_width.checked then sc = 1.0 
					--sc = 1.0/(amax areas) 
					--spn_bricks_unwrap_sc.value as float/(amax areas) else 1.0
				)
				else sc = 1.0
				format "scale=%\n" sc
				--?????? ?????????????? ?? ??????, ??? ??????? ???????? ? ????????, ???? ?????????????? ? ????? ?? ??????????? ???????
				--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0

				case rdo_unwrap_method.state of
				(
					1: --"Centers"
					(
						if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0
						for i in faces where not keyboard.escPressed do
						(
							unwrapmod.selectFaces #{i}
							pos = unwrapmod.getSelCenter()
							unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0] 
						)
					)
					
					2: --"??"
						(
							unwrapmod.setPolygonMode true
							
							--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0

							if chk_unwrap_texel_or_poly.checked then --???? ?????? ???????
							(
								unwrapmod.selectFaces faces
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()		
								
								--?????????? x ? y ???? ???????? ? ???????? ?? ???? ??? ???????
								minX = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								maxY = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
							
								--???? ????????? ???????? ???????, ????? ??????? ?? ???? ???????????? ?????? ?? ???? ??????????, 
								--???? ???????? ????? ??????, ?? ?????? ????? ?????????, ???? ???, ?? ????????? ???????

								for f in faces where not keyboard.escPressed do
								(
									unwrapmod.selectFaces #{f}
									unwrapmod.getArea #{f} &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										maxY = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minX = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
									)								
								)												
								unwrapmod.selectFaces faces 
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, maxY, 0]
									
								--??????? ??? ????? ?? ????? ?????, ?? ????? ????? ?? ????????
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (maxY - t)), 0] 
								else unwrapmod.moveSelected [-(minX as integer), -(maxY as integer), 0] 										
							)
							else
							(
								unwrapmod.selectFaces #{face}
								unwrapmod.getArea #{face} &x &y &width &height &areaUVW &areaGeom	
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								maxY = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								minX = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
								unwrapmod.selectFaces faces 	
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, maxY, 0]
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (maxY - t)), 0] 
								else unwrapmod.moveSelected [-(minX as integer), -(maxY as integer), 0]															
							)

							arr = #()
							for f in faces where not keyboard.escPressed do 	
							(
								unwrapmod.selectFaces #{f}
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								poi_min_x = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								poi_max_x = 0 --amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								poi_min_y = 0 --amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								poi_max_y = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								append arr #(#{f}, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
							)		
							for a in arr where not keyboard.escPressed do
							(
								unwrapmod.selectFaces a[1]
								--??? ?????? ???????? ???????? ? ???????? ??????? ?? ????? ????? ? ?????? ????
								
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[2] + t)), -(floor (a[5] - t)), 0] 
								else unwrapmod.moveSelected [ -(a[2] as integer), -(a[5] as integer), 0] 	
							)
						)
						
					3: --"??"
						(
							unwrapmod.setPolygonMode true
							
							--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0
								
							if chk_unwrap_texel_or_poly.checked then --???? ?????? ???????
							(
								unwrapmod.selectFaces faces
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()		
								
								--?????????? x ? y ???? ???????? ? ???????? ?? ???? ??? ???????
								maxX = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								maxY = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
							
								--???? ????????? ???????? ???????, ????? ??????? ?? ???? ???????????? ?????? ?? ???? ??????????, 
								--???? ???????? ????? ??????, ?? ?????? ????? ????????, ???? ???, ?? ????????? ???????

								for f in faces where not keyboard.escPressed do
								(
									unwrapmod.selectFaces #{f}
									unwrapmod.getArea #{f} &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										maxY = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										maxX = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
									)								
								)												
								unwrapmod.selectFaces faces 
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, maxY, 0]
								--??????? ??? ????? ?? ????? ?????, ?? ????? ????? ?? ????????
								--unwrapmod.moveSelected [-(maxX as integer), -(maxY as integer), 0] 	
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (maxY - t)), 0] 
								else unwrapmod.moveSelected [-(maxX as integer), -(maxY as integer), 0]									
							)
							else
							(
								unwrapmod.selectFaces #{face}
								unwrapmod.getArea #{face} &x &y &width &height &areaUVW &areaGeom	
								unwrapmod.faceToVertSelect()
								v = unwrapmod.getselectedvertices()
								maxY = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								maxX = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
								unwrapmod.selectFaces faces 	
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, maxY, 0]
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (maxY - t)), 0] 
								else unwrapmod.moveSelected [-(maxX as integer), -(maxY as integer), 0]																
							)

							arr = #()
							for f in faces where not keyboard.escPressed do 	
							(
								unwrapmod.selectFaces #{f}
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								poi_min_x = 0 --amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
								poi_max_x = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
								poi_min_y = 0 --amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
								poi_max_y = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
								append arr #(#{f}, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
							)		
							for a in arr where not keyboard.escPressed do
							(
								unwrapmod.selectFaces a[1]
								--??? ?????? ???????? ???????? ? ???????? ??????? ?? ????? ????? ? ?????? ????
								
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[3] - t)), -(floor (a[5] - t)), 0] 
								else unwrapmod.moveSelected [ -(a[3] as integer), -(a[5] as integer), 0]
							)							
						)
						
					4: --"Integers"
					(
						unwrapmod.selectFaces faces
						if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0
						for i in faces where not keyboard.escPressed do
						(
							unwrapmod.selectFaces #{i}
							pos = unwrapmod.getSelCenter()
							if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (pos.x)), -(floor (pos.y)), 0]
							else unwrapmod.moveSelected [ -(pos.x as integer), -(pos.y as integer), 0]
							
						)	
					)	
					
					5: --"??"
						(
							unwrapmod.setPolygonMode true

							if chk_unwrap_texel_or_poly.checked then --???? ?????? ???????
							(
								unwrapmod.selectFaces faces --#{1..unwrapmod.numberPolygons()}
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()		
								
								--?????????? ??????? x,y ???? ???????? ? ???????? ?? ?????? ??????? ???? ??? ???????
								minX = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								minY = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								--print minX
								--print minY
							
								--???? ????????? ???????? ??????? (????? ? ????? ??????), ????? ??????? ?? ???? ???????????? ?????? ?? ???? ??????????, 
								--???? ???????? ????? ??????, ?? ?????? ????? ????????, ???? ???, ?? ????????? ???????
								
								--sc = if not chk_bricks_unwrap_scale.checked then 1.0 / amax #(hei, wid) else 1.0
								for f in faces where not keyboard.escPressed do
								(
									unwrapmod.selectFaces #{f}
									unwrapmod.getArea #{f} &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minY = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minX = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
									)								
								)							
								--print minX
								--print minY					
								unwrapmod.selectFaces faces --#{1..unwrapmod.numberPolygons()}
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, minY, 0] --unwrapmod.scaleSelected sc 0 [minX, minY, 0]
								
								if chk_bricks_unwrap_pack.checked then
								(
									--?????? ??? ??????? ????? ?????? ????? ? ?????? ???? - ??????, ???????? ????? ?? ????????
									unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0] 
									--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelected sc 0 [0, 0, 0]
								)
								else
								(
									--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelected sc 0 [minX, minY, 0]
									--unwrapmod.moveSelected [-(minX as integer), -(minY as integer), 0] 
									--??????? ??? ????? ?? ????? ?????, ?? ????? ????? ?? ????????
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] 
									else unwrapmod.moveSelected [-(minX as integer), -(minY as integer), 0]
								)
							)
							else
							(
								unwrapmod.selectFaces #{face}
								--unwrapmod.getArea #{face} &x &y &width &height &areaUVW &areaGeom	
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								minY = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								minX = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
								
								unwrapmod.selectFaces faces --#{1..unwrapmod.numberPolygons()}		
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelected sc 0 [minX, minY, 0] --??????? ??????, ???????? ? ???????
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, minY, 0]	
								
								if chk_bricks_unwrap_pack.checked then
								(
									--?????? ??? ??????? ????? ?????? ????? (???????? ???????) ? ?????? ????									
									unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0] 
									--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelected sc 0 [0, 0, 0]
								)
								else
								(
									--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelected sc 0 [minX, minY, 0]
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] 
									else unwrapmod.moveSelected [-(minX as integer), -(minY as integer), 0]						
								)
							)

							--????? ??????? ?? ??????? ????? ????????? (? ??? ????? ??????? ??? ??????? ?? ???????????? ? ?????????????? ???????? ?? ?????? ?? ????????)
							arr = #()
							for f in faces where not keyboard.escPressed do 	
							(
								unwrapmod.selectFaces #{f}
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								poi_min_x = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								poi_max_x = 0 --amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								poi_min_y = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								poi_max_y = 0 --amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								append arr #(#{f}, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
							)		
							--print arr
							
							for a in arr where not keyboard.escPressed do
							(
								unwrapmod.selectFaces a[1]
								--??? ?????? ???????? ???????? ? ???????? ??????? ?? ????? ????? ? ?????? ???? (?????????? ? ?????? ?????? ????)
								--(??? ???????? ????????, ???????? ???? ????? ???????, ??????????? ??????? ?? ??????? ???????)
								
								--????? ??????????? ???????, ????????? ? ??????????? ?????, ????? ?? ???????? ? ???????? ???? (??? ???????????? ????? ???? ????? ???????? ???)
								--????? ?? ????? ??? integer ?????? floor

								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[2] + t)), -(floor (a[4] + t)), 0] 
								else unwrapmod.moveSelected [ -(a[2] as integer), -(a[4] as integer), 0]
							)
						)
						
					6: --"??"
						(
							unwrapmod.setPolygonMode true
							
							--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0
								
							if chk_unwrap_texel_or_poly.checked then --???? ?????? ???????
							(
								unwrapmod.selectFaces faces
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()		

								--?????????? x,y ???? ???????? ? ???????? ?? ???? ??? ???????
								maxX = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								minY = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
							
								--???? ????????? ???????? ???????, ????? ??????? ?? ???? ???????????? ?????? ?? ???? ??????????, 
								--???? ???????? ????? ??????, ?? ?????? ????? ????????, ???? ???, ?? ????????? ???????

								for f in faces where not keyboard.escPressed do
								(
									unwrapmod.selectFaces #{f}
									unwrapmod.getArea #{f} &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minY = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										maxX = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
									)								
								)							
							
								unwrapmod.selectFaces faces
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, minY, 0]
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (minY + t)), 0] 
								else unwrapmod.moveSelected [-(maxX as integer), -(minY as integer), 0]	
								--??????? ??? ????? ?? ????? ?????, ?? ????? ????? ?? ????????
							)
							else
							(
								unwrapmod.selectFaces #{face}
								unwrapmod.getArea #{face} &x &y &width &height &areaUVW &areaGeom	
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								minY = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								maxX = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)									
								unwrapmod.selectFaces faces	
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, minY, 0]
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (minY + t)), 0] 
								else unwrapmod.moveSelected [-(maxX as integer), -(minY as integer), 0]							
							)

							--????? ??????? ?? ??????? ????? ????????? (? ??? ????? ??????? ??? ??????? ?? ???????????? ? ?????????????? ???????? ?? ?????? ?? ????????)
							arr = #()
							for f in faces where not keyboard.escPressed do 	
							(
								unwrapmod.selectFaces #{f}
								unwrapmod.faceToVertSelect() 
								v = unwrapmod.getselectedvertices()
								poi_min_x = 0 -- amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								poi_max_x = amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).x)
								poi_min_y = amin (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								poi_max_y = 0 --amax (for i in v where not keyboard.escPressed collect (unwrapmod.getvertexposition currenttime i).y)
								append arr #(#{f}, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
							)		
							for a in arr where not keyboard.escPressed do
							(
								unwrapmod.selectFaces a[1]
								--??? ?????? ???????? ???????? ? ???????? ??????? ?? ????? ????? ? ?????? ????
								if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[3] - t)), -(floor (a[4] + t)), 0] 
								else unwrapmod.moveSelected [ -(a[3] as integer), -(a[4] as integer), 0]
							)							
						)
				)
				unwrapmod.selectFaces faces --#{1..unwrapmod.numberPolygons()}	
				if chk_bricks_unwrap_redo.checked then 
				(
					unwrapmod.setPolygonMode true
					for f in faces where not keyboard.escPressed do 	
					(
						unwrapmod.selectFaces #{f}
						local pos = unwrapmod.getSelCenter()
						if pos.x > 1.0 then unwrapmod.moveSelected [-1, 0, 0]
						if pos.x < 0.0 then unwrapmod.moveSelected [1, 0, 0]
						if pos.y > 1.0 then	unwrapmod.moveSelected [0, -1, 0]
						if pos.y < 0.0 then unwrapmod.moveSelected [0, 1, 0]	
					)	
					unwrapmod.selectFaces faces
				)
			)
			gc light:true
		)
	)

	on btn_bricks_unwrap_rightclick pressed do --with undo "Tiles Unwrap" on 
	(
		gc light:true
		local ctrl = keyboard.controlPressed
		local sc = 1.0
		local t = spn_bricks_unwrap_treshold.value --0.05
		max modify mode
		local unwrapmod = modpanel.getcurrentobject()
		local faces = #{}
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			unwrapmod.setTVSubObjectMode 3 --unwrapmod.setPolygonMode true
			faces = #{}
			faces = unwrapmod.getselectedfaces()
			--if faces.isempty then faces = #{1..unwrapmod.numberPolygons()}
		)
		if not faces.isempty then	
		(
			for f in faces where not keyboard.escPressed do 	
			(
				unwrapmod.selectFaces #{f}
				unwrapmod.breakSelected()
				if ctrl then 
				(
					unwrapmod.faceToEdgeSelect()
					unwrapmod.breakSelected()
					unwrapmod.selectFaces #{f}
				)
				unwrapmod.faceToVertSelect() 
				local vv = unwrapmod.getselectedvertices()
				local pp = for i in vv collect (unwrapmod.getvertexposition currenttime i)
				local poi_min_x = amin (for i in pp collect i.x)
				local poi_min_y = amin (for i in pp collect i.y)

				if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (poi_min_x - t)), -(floor (poi_min_y + t)), 0] 
				else unwrapmod.moveSelected [-(poi_min_x as integer), -(poi_min_y as integer), 0]

				if chk_bricks_unwrap_redo.checked then 
				(
					local pos = unwrapmod.getSelCenter()
					if pos.x > 1.0 then unwrapmod.moveSelected [-1, 0, 0]
					if pos.x < 0.0 then unwrapmod.moveSelected [1, 0, 0]
					if pos.y > 1.0 then	unwrapmod.moveSelected [0, -1, 0]
					if pos.y < 0.0 then unwrapmod.moveSelected [0, 1, 0]	
				)
			)	
			unwrapmod.selectFaces faces	
			gc light:true			
		)	
	)
	
/*	
	on btn_bricks_unwrap rightclick do with undo "Tiles Unwrap" on 
	(
		sc = 1.0
		areas = 1.0
		max modify mode
		unwrapmod = modpanel.getcurrentobject()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			unwrapmod.setTVSubObjectMode 3 --unwrapmod.setPolygonMode true
			faces = unwrapmod.getselectedfaces() 
			if faces.count > 0 then
			(
				face = spn_bricks_unwrap_num.value --?? ??????? ???????? ??? ???? ???? ?????????? ? ????????? ??? ? ??????
				unwrapmod.selectFaces #{face}
				if (unwrapmod.getselectedfaces()).count > 0 then
				(
					unwrapmod.getArea #{face} &x &y &width &height &areaUVW &areaGeom
					if chk_bricks_unwrap_height.checked then areas = height else areas = width 
					sc = 1.0/areas --(spn_bricks_unwrap_sc.value as float)/areas 
					unwrapmod.selectFaces faces
					
					--unwrapmod.unfoldMapNoParams() --unwrapmod.unfoldMap 1
					unwrapmod.faceToEdgeSelect()
					unwrapmod.setTVSubObjectMode 2
					edges = unwrapmod.getSelectedEdges()
					unwrapmod.breakSelected()
					unwrapmod.setTVSubObjectMode 3
					unwrapmod.selectFaces faces
					unwrapmod.scaleSelectedCenter sc 0
					for i in faces do
					(
						unwrapmod.selectFaces #{i}
						pos = unwrapmod.getSelCenter()
						unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0]
					)
				)
			)
		)
	)
*/
	
	on btn_bricks_unwrap_new pressed do with undo "Tiles Landscape" on 
	(
		--????? ?????????? ? ??????????? ?????? ????? ??????, ??? ???????? ????? ???????
		--?????? ?????, ???????? ? ????? ????, ???????? ????? ??????? ???????, ??????? ????????? ???????? ? ??????????? ?? ?????????? ????????? ???????
		--??? ????? ???????? ?????? ?? ????? ????????? ??? ??????? ???????
		--???????? ??? ??????? ?? ?????? ????, ????????, ????? ???????
		--???????? ????? ? ??????
		--??????? ???? ? ??????? (???????? ?????????)
		--???? ????? ??????? ?? ????????? ??????? ? ???????
		--?????????? ??????? ?? ???? ??? ????????? ? ????
		--???????????? ??? ???????? ??? ?????
		
		--?????? 1
			--??????? ??? ??????? ?? ????????????? ????? ?? ?????? ??????? ???? ? ???? ??????? UDIM (????????? ??? ???????? ? ???? ??? ????? ?????, ???????? ? ???????? ??????)
		
		--?????? 2
			--????????? ? ????? ?????? ????? ??? ????????		
		
		--??????????:
		--?????? ??? ??????? ?????? ? ????????? ??????? ? ?????? ???? ????? ?????? ?????, ???????????? ? ???? ?????, ??????? ?? ????????????? ????? ?????? ????? ?????? ???? ???? ????????
		
		if selection.count == 1 and classof selection[1].baseobject == Editable_Poly and selection[1].modifiers.count == 0 then
		(
			gc()
			max modify mode 
			
			FacesSelection = polyop.getFaceSelection selection[1]
			EdgesSelection = polyop.getEdgeSelection selection[1]
			FacesTotal = #{1..polyop.getNumFaces selection[1]}
			EdgesTotal = #{1..polyop.getNumEdges selection[1]}			
			FacesTotalNum = polyop.getNumFaces selection[1]
			EdgesTotalNum = polyop.getNumEdges selection[1]
			
			
			if EdgesSelection.numberSet == 0 and FacesSelection.numberSet == 0 then
			(
				print "Selected object is undefined type, no selection of faces and edges..."
				FacesSelection = FacesTotal 
				btn_edges_selector.pressed() --btn_poly_to_edges_selector.pressed()
				EdgesSelection = polyop.getEdgeSelection selection[1]
			)
			
			if EdgesSelection.numberSet == 0 and FacesTotalNum == FacesSelection.numberSet then 
			(
				print "Selected object is a whole Ground without another elements, but no selected edges..."
				btn_poly_to_edges_selector.pressed()
				EdgesSelection = polyop.getEdgeSelection selection[1]
				FacesSelection = FacesTotal 
			)
			
			--??????, ????? ? ?????? Ground ???????? ?????? ?????, ???? ?????? ???????, ??????? ?? ????? ??????? ? ?????????  			
			if EdgesSelection.numberSet == 0 and FacesSelection.numberSet != FacesTotalNum and FacesSelection.numberSet > 0 then 
			(
				print "Selected object is a Ground with another elements, selected faces is ground surface, but no edges selected, try to select parallel edges..."
				--???????? ?????? ?? ???????????? ????, ??????? ??????????? ?????????? ?????????				
				btn_poly_to_edges_selector.pressed()
				EdgesSelection = polyop.getEdgeSelection selection[1]
				FacesSelection = polyop.getFaceSelection selection[1]
			)

			--??????, ????? ? ?????? Ground ???????? ?????? ?????, ???? ?????? ???????, ??????? ?? ????? ??????? ? ?????????, ????? ???????? ???? ??? ?????????  	
			if EdgesSelection.numberSet > 0 and FacesSelection.numberSet != FacesTotalNum and FacesSelection.numberSet > 0 then 
			(
				print "Selected object is a Ground with another elements, selected faces is ground surface, parallel edges selected..."
				EdgesSelection = polyop.getEdgeSelection selection[1]
				FacesSelection = polyop.getFaceSelection selection[1]			
			)			
			
			if EdgesSelection.numberSet > 0 and FacesTotalNum == FacesSelection.numberSet then
			(
				print "Selected object is a whole Ground without another elements, with edges selected"
				EdgesSelection = polyop.getEdgeSelection selection[1]
				FacesSelection = polyop.getFaceSelection selection[1]	
			)
			
			if EdgesSelection.numberSet > 0 and FacesSelection.numberSet == 0 then
			(
				print "Selected object is undefined type, no face selection, but there are edges selection..."
				EdgesSelection = polyop.getEdgeSelection selection[1]
				FacesSelection = FacesTotal	
			)
				
			sel = selection[1]
			FacesOther = FacesTotal - FacesSelection
			EdgesOther = polyop.getEdgesUsingFace sel FacesOther		
			
			if chk_bricks_unwrap_unfold.checked then
			(
				sel_copy = copy selection[1]

				--?????? ????? ???????, ????? ??? ?? ???????? ????? ?????????? ????? ? ??????? ??? ???????? ????? ?????? ???????? ???????? ? ?????? ??? ????????? ??????, ???????? ??? ?? ???????? ??????
				elems_poly = #()

				--print #(FacesOther)
				if EdgesSelection.count > 0 then --(polyop.getEdgeSelection sel_copy).count > 0 then 
				(
					polyop.splitEdges sel_copy EdgesSelection --(EdgesSelection + EdgesOther)         (polyop.getEdgeSelection sel_copy)
					for i in FacesSelection do --#{1..(polyop.getNumFaces sel_copy)} do
					(
						elem = polyOp.getElementsUsingFace sel_copy #{i}
						appendifunique elems_poly elem
					)
				)
				--print #(elems_poly)
				
				areas = #()
				areas_ = #()
				for elem in elems_poly do 
				(
					area_ = 0.0
					for el in elem do area_ += polyop.getFaceArea sel_copy el
					append areas area_ 
					append areas_ #(area_, elem)
				)
				--elem_largest = #{}
				elem_largest = for a in areas_ where amax areas == a[1] do exit with a[2]
				--print #(elem_largest)
				
				select sel_copy
				--polyop.deleteFaces sel_copy (FacesOther + FacesSelection - elem_largest) delIsoVerts:true --polyop.setFaceSelection sel_copy elem_largest
				polyop.deleteFaces sel_copy (#{1..(polyop.getNumFaces sel_copy)} - elem_largest) delIsoVerts:true --polyop.setFaceSelection sel_copy elem_largest
				
				if (polyop.getNumFaces sel_copy) > 0 then
				(
					addmodifier sel_copy (uvwmap maptype:0 axis:2)
					
					lModifier = copy $.modifiers[1]
					select sel
					addModifier sel lModifier
					delete sel_copy
					convertToPoly sel
					sel = selection[1] --.baseobject					
				)
				else messagebox "No unwrap made, error."
			)

				if selection.count == 1 and classof selection[1].baseobject == Editable_Poly then	
				(
					--if (polyop.getEdgeSelection sel).count > 0 then transfer_edges() --?????????????? ?????????? ???? ?? ??????? ???? ? ????????? ???? ? ???????
					if not EdgesSelection.isempty then transfer_edges() --?????????????? ?????????? ???? ?? ??????? ???? ? ????????? ???? ? ???????
					--????? ????????? ???? ????? ??????
					--???????? ??????? ???? ????????? unwrap
					unwrapmod = modpanel.getcurrentobject()
					
					--if FacesSelection.numberset != FacesTotalNum then 
					--(
						--unwrapmod.selectFaces FacesSelection
						--unwrapmod.setTVSubObjectMode 3 
						--unwrapmod.selectFaces FacesSelection
						--unwrapmod.breakSelected() --????????? ?? ??????? ?????????? ?????????
					--)
					unwrapmod.setTVSubObjectMode 2
					unwrapmod.breakSelected() --????????? ?? ??????? ????? ?????????? ????? ??? ????????? ??????
					unwrapmod.selectFaces FacesSelection --#{1..unwrapmod.numberPolygons()}
					faces = #{}
					faces = unwrapmod.getSelectedFaces()
					unwrapmod.setTVSubObjectMode 3 
					unwrapmod.breakSelected() --????????? ?? ??????? ?????????? ?????????
					unwrapmod.setPolygonMode true
					
					--unwrapmod.unfoldMapNoParams() 
					--unwrapmod.unfoldMap 1
					--unwrapmod.normalMapNoParams()
		
					sc = 1.0 
					hei = 0.0
					wid = 0.0
					t = spn_bricks_unwrap_treshold.value  --0.05
					if faces.count > 0 then
					(
						elems = #()
						for f in faces do --??????? ?? ????? ?????? ?????? - ???????, ?????????? ??
						(
							unwrapmod.selectFaces #{f}
							unwrapmod.selectElement()	
							elem = unwrapmod.getSelectedFaces()
							appendifunique elems elem
						)
						
						--???????? ????? ??????? ??????, ???????????? ?? ?????? ? 1.0?1.0 ?? ?????????, ?.?. ????? ????????? UVW_MAP
						dims_h = #()
						dims_w = #()
						
						--???????? ???? ??????? ?? ?????????? ???????
						
						for f in elems do --???????? ????? ??????? ????????? ????????, ?? ?????? ? ?????? (?????? ???????? ? ?????? ???????? ?????? ????? ? ?? ????)
						(
							unwrapmod.selectFaces f
							unwrapmod.getArea f &x &y &width &height &areaUVW &areaGeom
							append dims_h height 
							append dims_w width
						)
						hei = amax dims_h
						wid = amax dims_w
						--print sc
				
						if chk_bricks_unwrap_scale.checked then
						(
							if chk_bricks_unwrap_height.checked and chk_bricks_unwrap_width.checked then sc = 1.0 / amax #(hei, wid)
							if chk_bricks_unwrap_height.checked and not chk_bricks_unwrap_width.checked then sc = 1.0 / hei
							if not chk_bricks_unwrap_height.checked and chk_bricks_unwrap_width.checked then sc = 1.0 / wid		
							if not chk_bricks_unwrap_height.checked and not chk_bricks_unwrap_width.checked then sc = 1.0 
						)
						else sc = 1.0							

						unwrapmod.selectFaces FacesSelection --#{1..unwrapmod.numberPolygons()}
						--?????????????? ??? ????????? ? ?????????, ??????????? ?? ?????? ???????? ??????? ? ??????? ?????, 
						--?????? ?? ??????, ?.?. ??? ???????? ? ???????? ?? ???????? 
						--unwrapmod.scaleSelectedCenter sc 0 
						
						--print #(elems)
						case rdo_unwrap_method.state of
						(
							1: --"Centers"
							(
								unwrapmod.setTVSubObjectMode 3
								unwrapmod.setPolygonMode true
								for f in elems do
								(
									unwrapmod.selectFaces f
									pos = unwrapmod.getSelCenter()
									unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0] --??????? ??? ??????? ? ????? ??????? ?????, ?????? ???????? ?? ?????? ???????
									if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0
								)									
							)
							
							4: --"Integers"
							(
								unwrapmod.setTVSubObjectMode 3
								unwrapmod.setPolygonMode true
								for f in elems do
								(
									unwrapmod.selectFaces f
									pos = unwrapmod.getSelCenter()
									--unwrapmod.moveSelected [ -(floor pos.x), -(floor pos.y), 0] 
									--??????? ??? ??????? ?? ????? ????? ?????? ? ?????? ????, ?????? ???????? ?? ?????? ???????
									
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [ -(floor pos.x), -(floor pos.y), 0]
									else unwrapmod.moveSelected [ -(pos.x as integer), -(pos.y as integer), 0]

									if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedCenter sc 0
								)									
							)
							
							5: --"Corner Landscape ??"
							(
								unwrapmod.setPolygonMode true
								unwrapmod.faceToVertSelect() 
								VertsSelectionMod = unwrapmod.getselectedvertices()
								--?????????? ??????? x,y ???? ???????? ? ???????? ? ?????? ??????? ???? ??? ???????, ????? ?? ????? ????? ??? ????????????????
								minX = amin (for i in VertsSelectionMod collect (unwrapmod.getvertexposition currenttime i).x)
								minY = amin (for i in VertsSelectionMod collect (unwrapmod.getvertexposition currenttime i).y)
								
								--minX = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								--minY = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								--print minX
								--print minY
								
								--???? ????????? ???????? ??????? (????? ? ????? ??????), ????? ??????? ? ???? ???????????? ?????? ?? ???? ??????????, 
								--???? ???????? ????? ??????, ?? ?????? ????? ????????, ???? ???, ?? ????????? ???????
								for f in elems do
								(
									unwrapmod.selectFaces f
									unwrapmod.getArea f &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minY = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minX = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)									
									)								
								)							
								--print minX
								--print minY

								unwrapmod.selectFaces FacesSelection --#{1..unwrapmod.numberPolygons()}
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, minY, 0]  --unwrapmod.scaleSelected sc 0 [minX, minY, 0]
								
								if chk_bricks_unwrap_pack.checked then
								(
									--?????? ??? ??????? ????? ?????? ????? ? ?????? ????, ??? ???????? ???????? ?????? ?? ????????	
									unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0]
								)
								else
								(
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] 
									else unwrapmod.moveSelected [ -(minX as integer), -(minY as integer), 0]
								)
								
								--????? ??????? ?? ??????? ????? ????????? (? ??? ????? ??????? ??? ??????? ?? ???????????? ? ?????????????? ???????? ?? ?????? ?? ????????)
								arr = #()
								for f in elems do 	
								(
									unwrapmod.selectFaces f
									unwrapmod.faceToVertSelect() 
									v = unwrapmod.getselectedvertices()
									poi_min_x = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_max_x = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_min_y = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									poi_max_y = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									append arr #(f, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
								)		
								--print arr
																
								for a in arr do
								(
									unwrapmod.selectFaces a[1]
									--??? ?????? ???????? ???????? ? ???????? ??????? ?? ????? ????? ? ?????? ???? (?????????? ? ?????? ?????? ????)
									--(??? ???????? ????????, ???? ????? ???????, ??????????? ??????? ?? ??????? ???????)
									
									--????? ??????????? ???????, ????????? ? ??????????? ?????, ????? ?? ???????? ? ???????? ???? (??? ???????????? ????? ???? ????? ???????? ???)

									--??????????? ? ?????????? ???????, ?? ?????? ??????? ?????		
									--unwrapmod.moveSelected [-(floor (a[2] + t)), -(floor (a[4] + t)), 0] 
									--unwrapmod.moveSelected [-(a[2] as integer), -(a[4] as integer), 0]

									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[2] + t)), -(floor (a[4] + t)), 0] 
									else unwrapmod.moveSelected [-(a[2] as integer), -(a[4] as integer), 0]
								)
							)
							
							2: --"Corner Landscape ??"
							(
								unwrapmod.setPolygonMode true
								
								--?????????? ??????? x,y ???? ???????? ? ???????? ? ?????? ??????? ???? ??? ???????, ????? ?? ????? ????? ??? ????????????????
								minX = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								--minY = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								--maxX = amax (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								maxY = amax (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								
								--???? ????????? ???????? ??????? (????? ? ????? ??????), ????? ??????? ? ???? ???????????? ?????? ?? ???? ??????????, 
								--???? ???????? ????? ??????, ?? ?????? ????? ????????, ???? ???, ?? ????????? ???????
								for f in elems do
								(
									unwrapmod.selectFaces f
									unwrapmod.getArea f &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										--minY = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
										maxY = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minX = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
										--maxX = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									)								
								)							

								unwrapmod.selectFaces #{1..unwrapmod.numberPolygons()}
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, minY, 0]
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, minY, 0]
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, maxY, 0]
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, maxY, 0]									
								
								if chk_bricks_unwrap_pack.checked then
								(
									--?????? ??? ??????? ????? ?????? ????? ? ?????? ????, ??? ???????? ???????? ?????? ?? ????????	
									--unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0]
									--unwrapmod.moveSelected [0.0 - maxX, 0 - minY, 0]
									unwrapmod.moveSelected [0.0 - minX, 0 - maxY, 0]
									--unwrapmod.moveSelected [0.0 - maxX, 0 - maxY, 0]									
								)
								else
								(
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] else unwrapmod.moveSelected [ -(minX as integer), -(minY as integer), 0]
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (maxY + t)), 0] else unwrapmod.moveSelected [ -(minX as integer), -(maxY as integer), 0]
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (minY + t)), 0] else unwrapmod.moveSelected [ -(maxX as integer), -(minY as integer), 0]
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (maxY - t)), 0] else unwrapmod.moveSelected [ -(maxX as integer), -(maxY as integer), 0]
								)
								
								--????? ??????? ?? ??????? ????? ????????? (? ??? ????? ??????? ??? ??????? ?? ???????????? ? ?????????????? ???????? ?? ?????? ?? ????????)
								arr = #()
								for f in elems do 	
								(
									unwrapmod.selectFaces f
									unwrapmod.faceToVertSelect() 
									v = unwrapmod.getselectedvertices()
									poi_min_x = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_max_x = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_min_y = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									poi_max_y = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									append arr #(f, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
								)		
								--print arr
																
								for a in arr do
								(
									unwrapmod.selectFaces a[1]
									--??? ?????? ???????? ???????? ? ???????? ??????? ?? ????? ????? ? ?????? ???? (?????????? ? ?????? ?????? ????)
									--(??? ???????? ????????, ???? ????? ???????, ??????????? ??????? ?? ??????? ???????)
									--????? ??????????? ???????, ????????? ? ??????????? ?????, ????? ?? ???????? ? ???????? ???? (??? ???????????? ????? ???? ????? ???????? ???)

									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[2] + t)), -(floor (a[5] + t)), 0] else unwrapmod.moveSelected [-(a[2] as integer), -(a[5] as integer), 0]
								)
							)
														
							3: --"Corner Landscape ??"
							(
								unwrapmod.setPolygonMode true
								
								--?????????? ??????? x,y ???? ???????? ? ???????? ? ?????? ??????? ???? ??? ???????, ????? ?? ????? ????? ??? ????????????????
								--minX = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								--minY = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								maxX = amax (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								maxY = amax (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								
								--???? ????????? ????????? ??????? (????? ? ????? ??????), ????? ??????? ? ???? ???????????? ?????? ?? ???? ??????????, 
								--???? ???????? ????? ??????, ?? ?????? ????? ????????, ???? ???, ?? ????????? ???????
								for f in elems do
								(
									unwrapmod.selectFaces f
									unwrapmod.getArea f &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										--minY = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
										maxY = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										--minX = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
										maxX = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									)								
								)							

								unwrapmod.selectFaces #{1..unwrapmod.numberPolygons()}
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, minY, 0]
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, minY, 0]
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, maxY, 0]
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, maxY, 0]									
								
								if chk_bricks_unwrap_pack.checked then
								(
									--?????? ??? ??????? ????? ?????? ????? ? ?????? ????, ??? ???????? ???????? ?????? ?? ????????	
									--unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0]
									--unwrapmod.moveSelected [0.0 - maxX, 0 - minY, 0]
									--unwrapmod.moveSelected [0.0 - minX, 0 - maxY, 0]
									unwrapmod.moveSelected [0.0 - maxX, 0 - maxY, 0]									
								)
								else
								(
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] else unwrapmod.moveSelected [ -(minX as integer), -(minY as integer), 0]
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (maxY - t)), 0] else unwrapmod.moveSelected [ -(minX as integer), -(maxY as integer), 0]
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (minY + t)), 0] else unwrapmod.moveSelected [ -(maxX as integer), -(minY as integer), 0]
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (maxY - t)), 0] else unwrapmod.moveSelected [ -(maxX as integer), -(maxY as integer), 0]
								)
								
								--????? ??????? ?? ??????? ????? ????????? (? ??? ????? ??????? ??? ??????? ?? ???????????? ? ?????????????? ???????? ?? ?????? ?? ????????)
								arr = #()
								for f in elems do 	
								(
									unwrapmod.selectFaces f
									unwrapmod.faceToVertSelect() 
									v = unwrapmod.getselectedvertices()
									poi_min_x = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_max_x = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_min_y = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									poi_max_y = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									append arr #(f, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
								)		
								--print arr
																
								for a in arr do
								(
									unwrapmod.selectFaces a[1]
									--??? ?????? ???????? ???????? ? ???????? ??????? ?? ????? ????? ? ?????? ???? (?????????? ? ?????? ?????? ????)
									--(??? ???????? ????????, ???? ????? ???????, ??????????? ??????? ?? ??????? ???????)
									--????? ??????????? ???????, ????????? ? ??????????? ?????, ????? ?? ???????? ? ???????? ???? (??? ???????????? ????? ???? ????? ???????? ???)

									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[3] + t)), -(floor (a[5] + t)), 0] else unwrapmod.moveSelected [-(a[3] as integer), -(a[5] as integer), 0]
								)
							)
							
							6: --"Corner Landscape ??"
							(
								unwrapmod.setPolygonMode true
								
								--?????????? ??????? x,y ???? ???????? ? ???????? ? ?????? ??????? ???? ??? ???????, ????? ?? ????? ????? ??? ????????????????
								--minX = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								minY = amin (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								maxX = amax (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).x)
								--maxY = amax (for i in #{1..unwrapmod.NumberVertices()} collect (unwrapmod.getvertexposition currenttime i).y)
								
								--???? ????????? ???????? ??????? (????? ? ????? ??????), ????? ??????? ? ???? ???????????? ?????? ?? ???? ??????????, 
								--???? ???????? ????? ??????, ?? ?????? ????? ????????, ???? ???, ?? ????????? ???????
								for f in elems do
								(
									unwrapmod.selectFaces f
									unwrapmod.getArea f &x &y &width &height &areaUVW &areaGeom
									if height == hei*sc then
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										minY = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
										--maxY = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									)
									if width == wid*sc then 	
									(
										unwrapmod.faceToVertSelect() 
										v = unwrapmod.getselectedvertices()
										--minX = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
										maxX = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									)								
								)							

								unwrapmod.selectFaces #{1..unwrapmod.numberPolygons()}
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, minY, 0]
								if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, minY, 0]
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [minX, maxY, 0]
								--if chk_bricks_unwrap_scale.checked then unwrapmod.scaleSelectedXY sc sc [maxX, maxY, 0]									
								
								if chk_bricks_unwrap_pack.checked then
								(
									--?????? ??? ??????? ????? ?????? ????? ? ?????? ????, ??? ???????? ???????? ?????? ?? ????????	
									--unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0]
									unwrapmod.moveSelected [0.0 - maxX, 0 - minY, 0]
									--unwrapmod.moveSelected [0.0 - minX, 0 - maxY, 0]
									--unwrapmod.moveSelected [0.0 - maxX, 0 - maxY, 0]									
								)
								else
								(
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] else unwrapmod.moveSelected [ -(minX as integer), -(minY as integer), 0]
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (maxY - t)), 0] else unwrapmod.moveSelected [ -(minX as integer), -(maxY as integer), 0]
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX + t)), -(floor (minY + t)), 0] else unwrapmod.moveSelected [ -(maxX as integer), -(minY as integer), 0]
									--if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (maxX - t)), -(floor (maxY - t)), 0] else unwrapmod.moveSelected [ -(maxX as integer), -(maxY as integer), 0]
								)
								
								--????? ??????? ?? ??????? ????? ????????? (? ??? ????? ??????? ??? ??????? ?? ???????????? ? ?????????????? ???????? ?? ?????? ?? ????????)
								arr = #()
								for f in elems do 	
								(
									unwrapmod.selectFaces f
									unwrapmod.faceToVertSelect() 
									v = unwrapmod.getselectedvertices()
									poi_min_x = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_max_x = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_min_y = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									poi_max_y = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									append arr #(f, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
								)		
								--print arr
																
								for a in arr do
								(
									unwrapmod.selectFaces a[1]
									--??? ?????? ???????? ???????? ? ???????? ??????? ?? ????? ????? ? ?????? ???? (?????????? ? ?????? ?????? ????)
									--(??? ???????? ????????, ???? ????? ???????, ??????????? ??????? ?? ??????? ???????)
									--????? ??????????? ???????, ????????? ? ??????????? ?????, ????? ?? ???????? ? ???????? ???? (??? ???????????? ????? ???? ????? ???????? ???)
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[3] + t)), -(floor (a[4] + t)), 0] else unwrapmod.moveSelected [-(a[3] as integer), -(a[4] as integer), 0]
								)
							)							
						)
						unwrapmod.selectFaces #{1..unwrapmod.numberPolygons()}
					)
				)
				--else messagebox "Select parallel edges after square slices!"
		)
		else messagebox "Select single EDITABLE POLY object with NO MODIFICATORS!"
	)

	
	on btn_bricks_unwrap_new rightclick do
	(
		if selection.count == 1 and classof selection[1].baseobject == Editable_Poly and selection[1].modifiers.count == 0 then
		(
			gc()
			max modify mode 
			sel = selection[1]

			FacesTotal = #{1..polyop.getNumFaces sel}
			EdgesTotal = #{1..polyop.getNumEdges sel}			
			
			FacesTotalNum = polyop.getNumFaces sel
			EdgesTotalNum = polyop.getNumEdges sel
			
			FacesSelection = polyop.getFaceSelection sel
			EdgesSelection = polyop.getEdgeSelection sel
			
			if FacesSelection.isempty then FacesSelection = FacesTotal
			if EdgesSelection.isempty then EdgesSelection = EdgesTotal

				if selection.count == 1 and classof selection[1].baseobject == Editable_Poly then	
				(
					if not EdgesSelection.isempty then transfer_edges() --?????????????? ?????????? ???? ?? ??????? ???? ? ????????? ???? ? ???????
					--????? ????????? ???? ????? ??????
					--???????? ??????? ???? ????????? unwrap
					unwrapmod = modpanel.getcurrentobject()
					
					unwrapmod.setTVSubObjectMode 2
					unwrapmod.breakSelected() --????????? ?? ??????? ????? ?????????? ????? ??? ????????? ??????
					unwrapmod.selectFaces FacesSelection --#{1..unwrapmod.numberPolygons()}
					faces = #{}
					faces = unwrapmod.getSelectedFaces()
					unwrapmod.setTVSubObjectMode 3 
					unwrapmod.breakSelected() --????????? ?? ??????? ?????????? ?????????
					unwrapmod.setPolygonMode true
		
					sc = 1.0 
					hei = 1.0
					wid = 1.0
					t = spn_bricks_unwrap_treshold.value  --0.05
					if faces.count > 0 then
					(
						elems = #()
						for f in faces do --??????? ?? ????? ?????? ?????? - ???????, ?????????? ??
						(
							unwrapmod.selectFaces #{f}
							unwrapmod.selectElement()	
							elem = unwrapmod.getSelectedFaces()
							appendifunique elems elem
						)
						unwrapmod.selectFaces FacesSelection

							--"Corner Landscape ??"
								unwrapmod.setPolygonMode true
								unwrapmod.faceToVertSelect() 
								VertsSelectionMod = unwrapmod.getselectedvertices()
								--?????????? ??????? x,y ???? ???????? ? ???????? ? ?????? ??????? ???? ??? ???????, ????? ?? ????? ????? ??? ????????????????
								minX = amin (for i in VertsSelectionMod collect (unwrapmod.getvertexposition currenttime i).x)
								minY = amin (for i in VertsSelectionMod collect (unwrapmod.getvertexposition currenttime i).y)

								unwrapmod.selectFaces FacesSelection
								
								if chk_bricks_unwrap_pack.checked then
								(
									unwrapmod.moveSelected [0.0 - minX, 0 - minY, 0]
								)
								else
								(
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (minX + t)), -(floor (minY + t)), 0] 
									else unwrapmod.moveSelected [ -(minX as integer), -(minY as integer), 0]
								)
								
								arr = #()
								for f in elems do 	
								(
									unwrapmod.selectFaces f
									unwrapmod.faceToVertSelect() 
									v = unwrapmod.getselectedvertices()
									poi_min_x = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_max_x = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).x)
									poi_min_y = amin (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									poi_max_y = amax (for i in v collect (unwrapmod.getvertexposition currenttime i).y)
									append arr #(f, poi_min_x, poi_max_x, poi_min_y, poi_max_y) 
								)		

								for a in arr do
								(
									unwrapmod.selectFaces a[1]
									if chk_bricks_unwrap_treshold.checked then unwrapmod.moveSelected [-(floor (a[2] + t)), -(floor (a[4] + t)), 0] 
									else unwrapmod.moveSelected [-(a[2] as integer), -(a[4] as integer), 0]
								)
						unwrapmod.selectFaces #{1..unwrapmod.numberPolygons()}
					)
				)
				--else messagebox "Select parallel edges after square slices!"
		)
		else messagebox "Select single EDITABLE POLY object with NO MODIFICATORS!"
	)

	on btn_udims_as_ids pressed do with undo "Place to UDIMs by IDs" on with redraw off --?????????? ?? ID
	(
		if selection.count == 1 then
		(
			if (classof selection[1] == editable_poly and selection[1].modifiers.count == 0) or (classof selection[1].modifiers[1] == Unwrap_UVW and classof selection[1].baseobject == editable_poly and selection[1].modifiers.count > 0) then 
			(
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
				(
					addmodifier selection[1] (Unwrap_UVW())
					unwrapmod = modpanel.getcurrentobject()
				)
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					max modify mode	
					unwrapmod.setTVSubObjectMode 3
					sc = 1.0
					for id in #{1..100} do --unwrapmod.numberMatIDs()} do 
					(
						faces = #{}
						unwrapmod.selectByMatID (id as integer)
						faces = unwrapmod.getselectedfaces()

						if not faces.isempty then
						(					
							unwrapmod.breakSelected()
							unwrapmod.faceToVertSelect()
							verts = unwrapmod.getSelectedVertices()
							poi_x = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).x)
							poi_y = (for i in verts collect (unwrapmod.unwrap.getvertexposition currenttime i).y)
							sc = if abs (amax poi_y - amin poi_y) >= abs (amax poi_x - amin poi_x) then spn_bricks_unwrap_sc.value/(amax poi_y - amin poi_y) else spn_bricks_unwrap_sc.value/(amax poi_x - amin poi_x)
							--print sc
							unwrapmod.scaleSelectedCenter sc 0
							pos = unwrapmod.getSelCenter()
							--print pos
							--format "offset: x = %, y = %\n" (0.5 - pos.x) (0.5 - pos.y)
							unwrapmod.moveSelected [0.5 - pos.x, 0.5 - pos.y, 0]
							case of
							(
								(id > 0  and id <= 10): unwrapmod.moveSelected [id - 1, 0, 0]	
								(id > 10 and id <= 20): unwrapmod.moveSelected [id - 11, 1, 0]
								(id > 20 and id <= 30): unwrapmod.moveSelected [id - 21, 2, 0]					
								(id > 30 and id <= 40): unwrapmod.moveSelected [id - 31, 3, 0]	
								(id > 40 and id <= 50): unwrapmod.moveSelected [id - 41, 4, 0]
								(id > 50 and id <= 60): unwrapmod.moveSelected [id - 51, 5, 0]
								(id > 60 and id <= 70): unwrapmod.moveSelected [id - 61, 6, 0]	
								(id > 70 and id <= 80): unwrapmod.moveSelected [id - 71, 7, 0]	
								(id > 80 and id <= 90): unwrapmod.moveSelected [id - 81, 8, 0]	
								(id > 90 and id <= 100): unwrapmod.moveSelected [id - 91, 9, 0]						
							)
						)
					)
				)
			) 
			else messagebox "Selected object is not an EDITABLE POLY!"
			
			gc light:true
		)
		else messagebox "Select single EDITABLE POLY object with Unwrap UVW modifier!"
	)
	
	on btn_count_area pressed do
	(
		if selection.count == 1 then
		(
			gc()
			if classof selection[1] != editable_poly then 
			(
				messagebox "Selected object is not an EDITABLE POLY!"
				with undo "Convert to EDITABLE POLY" on
				(
					convertToPoly selection[1]
				)
			)
			max modify mode
			xViewChecker.on = false
			global dirs_select = #()
			global selmod = modpanel.getcurrentobject()
			global faces = #()
			
			if selmod != undefined and classof selmod == editable_poly then
			(
				faces = selmod.GetSelection #Face 
				if faces.count > 0 then
				(
					--print faces
					--for f in faces do
					--(
					--	append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
					--)
				)
			)
			
			try(destroyDialog ::ro_count_area)catch()
			rollout ro_count_area "Counts Area of Polygons" 
			(
				fn defColor r g b = ((dotNetClass "System.Drawing.Color").FromArgb r g b)
				
				local maxBC = defColor 60 60 60
				local maxFC = defColor 200 200 200
				
				fn autoResizeColumn lv columns: = 
				(
					vScrollWidth = 21 -- vertical scrollbar width
					for c = 0 to columns-1 do
					(
						lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
						vScrollWidth += lv.Columns.Item[c].Width
					) 
					vScrollWidth
				)
	
				fn compileListItemSorter =
				(
					source =  "using System;\n"
					source += "using System.Windows.Forms;\n"
					source += "using System.Collections;\n"
					source += "class ListViewItemComparer : IComparer\n"
					source += "{\n"
					source += "    private int c;\n"
					source += "    private bool num = false;\n"
					source += "    private int dir = 1;\n"
					source += "    public ListViewItemComparer() { c = 0; }\n"
					source += "    public ListViewItemComparer(int column, bool numeric, bool reverse)\n"
					source += "    { c = column; num = numeric; dir = reverse ? -1 : 1; }\n"
					source += "    public int Compare(object x, object y)\n"
					source += "    {\n"
					source += "        if (num) return Convert.ToInt32(((ListViewItem)x).SubItems[c].Text).CompareTo(\n"
					source += "            Convert.ToInt32(((ListViewItem)y).SubItems[c].Text)) * dir;\n"
					source += "        else return String.Compare(((ListViewItem)x).SubItems[c].Text,\n"
					source += "            ((ListViewItem)y).SubItems[c].Text) * dir;\n"
					source += "    }\n"
					source += "}"
				 
					local csharpProvider = dotNetObject "Microsoft.CSharp.CSharpCodeProvider"
					local compilerParams = dotNetObject "System.CodeDom.Compiler.CompilerParameters"
					compilerParams.GenerateInMemory = true
					compilerParams.ReferencedAssemblies.Add("System.Windows.Forms.dll")
					compilerResults = csharpProvider.CompileAssemblyFromSource compilerParams #(source)
					compilerResults.CompiledAssembly
				)
				
				fn qsort_csv arr1 arr2 = 
				(
					case of 
					(
						(arr1[1] as float < arr2[1] as float): -1
						(arr1[1] as float > arr2[1] as float): 1
						default:0
					)
				)

				fn qsort_csv3 arr1 arr2 = 
				(
					case of 
					(
						(arr1[3] as float < arr2[3] as float): -1
						(arr1[3] as float > arr2[3] as float): 1
						default:0
					)
				)
				
				fn PopulateList lv dirs_select faces =
				(
					qsort dirs_select qsort_csv
					
					lv.Items.Clear()
					lv.view = (dotNetClass "system.windows.forms.view").details
					lv.HideSelection = true 
					lv.HeaderStyle = (dotNetClass "System.Windows.Forms.ColumnHeaderStyle").clickable
					--lv.height = 390
					lv.FullRowSelect = true    
					lv.MultiSelect = false --true    
					lv.AllowColumnReorder = true
					lv.GridLines = true
					lv.checkBoxes = false --true 
					lv.Scrollable = true
					lv.ShowItemToolTips = true
					columnsAr = #("Poly Area", "ID", ("Number Of " + dirs_select.count as string))
					lv.columns.Clear()
					for i = 1 to 3 do lv.columns.add columnsAr[i] 0	
					--lv.width = autoResizeColumn lv columns:3
					--lv.width = 490
					--lv.Update()
					
					rows = #()
					for t = 1 to dirs_select.count do
					(
						li = dotNetObject "System.Windows.Forms.ListViewItem" (dirs_select[t][1])
						li.UseItemStyleForSubItems = true
						if dirs_select[t][1] as float <= 0.00001 then li.forecolor = li.forecolor.fromARGB 200 0 0
						li.subitems.add dirs_select[t][2]
						li.subitems.add dirs_select[t][3]
						append rows li
					)
					lv.items.addRange rows
					--lv.Update()
					lv.width = autoResizeColumn lv columns:3
					lv.width = 490
					lv.Update()
				)
				
				dotNetControl lv "ListView" pos:[5,5] width:490 height:300
				--label lbmin "" pos:[470,20]
				--label lbmax "" pos:[470,290]
				group "filter"
				(
					button btnFilterZero "Filter with Zero Area" across:4 align:#left tooltip:"??????? ?? ???? ?????????? ????????? ?????? ?????? ? ???????????? ???????? | List faces with zero area only"
					edittext edt_tresh "Treshold" text: "0.00001" width:100 fieldWidth:80 				
					button btnFilterAll "Show All Selected" offset: [0,0] tooltip:"??????? ?????? ???? ?????? ? ?? ???????? | List all selected faces with their areas"
					button btnRightClk "View Selected" align:#right tooltip:"???????? ????????? ????? ? ???? ???????? | View selected face in viewport" --offset: [20,0]	
				)
				group "edit"
				(
					button btnDeleteZero "Delete\Collapse Face" across:2 align:#left tooltip:"LMB: ??????? ????????? ?????\nLMB+CTRL: ???????? ????????? ????? | LMB: Delete selected face\nLMB+CTRL: Collapse selected face" --offset: [-30,0]
					button btnDeleteEdge "Remove Overlayed Edges\Verts of Selected Face" align:#right tooltip:"LMB: ??????? ??????????? ????????? ????? ? ????????? ?????\nLMB+CTRL: ?????? ??????? ?????\??????? | LMB: Delete (dublicated) overlayed edge in selected face\nLMB+CTRL: select edges\verts only"
				)
				group "selection"	
				(
					label lbl "Selected:" across:5 width:150 align:#left style_sunkenedge:true
					button btnSelectionAll "Select All Faces" offset:[55,0]  tooltip:"???????? ??? ????? ??????? | Select all faces of object"
					button btnSelectID "Select Faces by ID" offset:[60,0] tooltip:"??????? ????? ? ??????? ID ??????? | Select faces with current ID of object"
					spinner spn_ID "ID" range:[1, 10000, 1] type:#integer offset:[40,0] tooltip:"ID ??????? | ID of object"
					button btnClose "Close" align:#right tooltip:"??????? ?????????? ???? | Close dialog"
				)	
				
				on lv columnClick columnHeader do
				(
					lv.ListViewItemSorter = dotnetobject "MXS_dotNet.ListViewItemComparer" columnHeader.column
					lv.ListViewItemSorter = undefined
				)
				
				on btnSelectionAll pressed do
				(
					max modify mode
					selmod = modpanel.getcurrentobject()
					if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then 
					(
						polyop.setFaceSelection selmod #all
						faces = selmod.GetSelection #Face 
						if faces.count > 0 then
						(
							dirs_select = #()
							--print faces
							for f in faces do
							(
								append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
							)
						)
						--PopulateList lv dirs_select faces	
						lbl.text = "Selected: " + (faces.numberset as string)
					)
				)
				
				on btnSelectID pressed do with undo "View Checked" on
				(
					max modify mode
					selmod = modpanel.getcurrentobject()
					if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then 
					(
						selID = #{}
						for i in #{1..(polyop.getNumFaces selmod)} where (polyop.getFaceMatID selmod i) == (spn_ID.value as integer) do append selID i 
						polyop.setFaceSelection selmod selID
						faces = selmod.GetSelection #Face 
						if faces.count > 0 then
						(
							dirs_select = #()
							--print faces
							for f in faces do
							(
								append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
							)
						)
						--PopulateList lv dirs_select faces		
						lbl.text = "Selected: " + (faces.numberset as string)						
					)
					
				)
				
				on btnDeleteZero pressed do with undo "Delete Selected Poly" on
				(
					--delete polygon (may be with zero area)
					ctrl = keyboard.controlPressed
					max modify mode
					sel_faces = #{}
					for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected /*and (dirs_select[val+1][1] as float) <= 0.00001*/ do append sel_faces (dirs_select[val+1][3] as integer)
					print sel_faces
					selmod = modpanel.getcurrentobject()
					if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
					(
						polyop.setFaceSelection selmod sel_faces
						--subObjectLevel = 4
						if ctrl then polyop.collapseFaces selmod sel_faces else polyop.deleteFaces selmod sel_faces
						polyop.setFaceSelection selmod #all
						faces = selmod.GetSelection #Face 
						if faces.count > 0 then
						(
							dirs_select = #()
							--print faces
							for f in faces do
							(
								append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
							)
						)
						PopulateList lv dirs_select faces
						lbl.text = "Selected: " + (faces.numberset as string)
					)
				)

				on btnDeleteEdge pressed do --delete edges/verts on polygon with zero area
				(
					max modify mode
					ctrl = keyboard.controlPressed
					if selection.count == 1 and classof selection[1] == Editable_Poly and selection[1].modifiers.count == 0 then
					(
						selmod = modpanel.getcurrentobject()
						sel_faces = #{}
						equal = false
						edges_eq = #{}
						verts_eq = #{}
						for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected /* and (dirs_select[val+1][1] as float) <= 0.00001 */ do append sel_faces (dirs_select[val+1][3] as integer)
						print sel_faces
						if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
						(
							polyop.setFaceSelection selmod sel_faces
							--subObjectLevel = 4
							arr = #{}
							verts_ini = polyop.getVertsUsingFace selmod sel_faces
							verts_close = #()
							for v in verts_ini do 
								for w in verts_ini where w > v do
									if distance (polyop.getvert selmod v) (polyop.getvert selmod w) <= 0.002 then append verts_close #{v,w}
							--???? ????????, ? ??????? ????? ?????? ???? ? ?????, ???? ????? ????, ?????? ??? ?? ????????? ????????????, 
							--? ?????????? ?????, ??????????? ??????? ??????? ???????
							
							if verts_close.count == 0 then --??? ????????? ????????????
							(
								for i in (polyop.getVertsUsingFace selmod sel_faces) do	
								(			
									if keyboard.escPressed then exit
									edges = polyop.getEdgesUsingVert selmod #{i}
									verts = #{}
									for j in edges do join verts (polyop.getVertsUsingEdge selmod #{j})
									p1 = polyop.getvert selmod i
									verts = verts - #{i}
									for k in verts do 
									(
										p2 = polyop.getvert selmod k
										for l in verts where l > k do 
										(
											if keyboard.escPressed then exit
											p3 = polyop.getvert selmod l
											v1 = p2 - p1
											v2 = p3 - p1
											if (acos(dot (normalize v1) (normalize v2))) <= 0.001 then --== 0.0
											(
												edge_k = 0
												edge_l = 0
												for m in edges do
												(
													pp = polyop.getVertsUsingEdge selmod #{m}
													if finditem pp i > 0 and finditem pp k > 0 then edge_k = m
													if finditem pp i > 0 and finditem pp l > 0 then edge_l = m
												)
												if (distance p2 p1) >= (distance p3 p1) then append arr edge_k else append arr edge_l
												
												if abs((distance p2 p1) - (distance p3 p1)) <= 0.001 then 
												(
													edges_eq += #{edge_k, edge_l}
													verts_eq += #{p2,p3}
													equal = true
													print "equal"
												)
												
											)
										)
									)		
								)
								polyOp.setEdgeSelection selmod arr
							
								print arr
								
								if ctrl then 
								(
									max modify mode
									subObjectLevel = 2
								)
								else
								(
									if equal then 
									(	
										
										--selmod.weldEdges edges_eq[1] edges_eq[2]
										pos = polyop.getvert selmod verts_eq[1]
										undo "Remove Overlay Verts" on selmod.weldVerts verts_eq[1] verts_eq[2] pos
									)
									else
										undo "Remove Overlay Edges" on selmod.remove selLevel:#edge
								)
							)
							else --??? ?????????? ?????????
							(
								print #(verts_close)
								case verts_close.count of
								(
									1:
									(
										if ctrl then 
										(
											selmod.SetSelection #Vertex verts_close[1]
											subobjectlevel = 1
										)
										else
										(
											pos = polyop.getvert selmod verts_close[1][1]
											undo "Remove Overlay Verts" on selmod.weldVerts verts_close[1][1] verts_close[1][1] pos
										)
									)
									default: 
									(
										all = #{}
										for vw in verts_close do join all vw 
										if ctrl then 
										(
											selmod.SetSelection #Vertex all	
											subobjectlevel = 1
										)
										else
										(
											selmod.weldThreshold = 0.002
											undo "Remove Overlay Verts" on polyop.weldVertsByThreshold selmod all
										)
									)
								)
							)
							
							polyop.setFaceSelection selmod #all
							
							faces = selmod.GetSelection #Face 
							if faces.count > 0 then
							(
								dirs_select = #()
								--print faces
								for f in faces where (polyop.getFaceArea selmod f) <= (edt_tresh.text as float) do
								(
									append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
								)
							)
							PopulateList lv dirs_select faces
							lbl.text = "Selected: " + (faces.numberset as string)
						)
					)
				)

				on ro_count_area open do
				(  
					PopulateList lv dirs_select faces
					lbl.text = "Selected: " + (faces.numberset as string)
					--lbmin.text = ""
					--lbmax.text = ""
					
					for i in ro_count_area.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_rocount_area.ini") i.name "rocount_area" (syssetup.rdo_lang.state))
				)
				
				on lv MouseDown arg do
				(
					if arg.button == arg.button.middle then
					(                
						if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
						(
						)                
					)
					if arg.button == arg.button.right then
					(                
						if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
						(
							val = hitNode.index + 1
							max modify mode
							selmod = modpanel.getcurrentobject()
							if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
							(
								faces_curr = selmod.GetSelection #Face 
								sel_face = dirs_select[val][3] as integer
								polyop.setFaceSelection selmod #{sel_face}
								subObjectLevel = 4
								max zoomext sel all
								max zoomext sel all
							)
						)           
					)
				)

				on btnRightClk pressed do
				(
					sel_face = #{}
					for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected do append sel_face (dirs_select[val+1][3] as integer)
					if sel_face.count > 0 then
					(
						max modify mode
						selmod = modpanel.getcurrentobject()
						if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
						(
							faces_curr = selmod.GetSelection #Face 
							polyop.setFaceSelection selmod sel_face
							subObjectLevel = 4
							max zoomext sel all
							max zoomext sel all
						)
						lbl.text = "Selected: " + (faces.numberset as string)
					)
				)
				
				on btnFilterZero pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					selmod = modpanel.getcurrentobject()
					if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
					(
						faces = selmod.GetSelection #Face 
						if faces.count > 0 then
						(
							--print faces
							for f in faces where (polyop.getFaceArea selmod f) <= (edt_tresh.text as float) do
							(
								append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
							)
						)
						PopulateList lv dirs_select faces
						lbl.text = "Selected: " + (faces.numberset as string)
					)
				)

				on btnFilterAll pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					selmod = modpanel.getcurrentobject()
					if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
					(
						faces = selmod.GetSelection #Face 
						if faces.count > 0 then
						(
							--print faces
							for f in faces do
							(
								append dirs_select #((polyop.getFaceArea selmod f) as string, (polyop.getFaceMatID selmod f) as string, f as string)
							)
						)
					)
					PopulateList lv dirs_select faces
					lbl.text = "Selected: " + faces.numberset as string
				)

				on btnClose pressed do
				(
					try(destroyDialog ::ro_count_area)catch()
				)	
				
			)
			createDialog ro_count_area width:500 height:470 style:#(#style_titlebar, #style_border, #style_sysmenu, #style_resizing)		
		)
		else
		(
			messagebox "Select one EDITABLE POLY object."
		)
	)
	
	on btn_count_area rightclick do
	(
		global dirs_select = #()
		global selmod = modpanel.getcurrentobject()
		global faces
		if selmod != undefined and classof selmod == editable_poly then
		(
			faces = selmod.GetSelection #Face 
			if faces.count > 0 then
			(
				--print faces
				for f in faces do
				(
					append dirs_select ((polyop.getFaceArea selmod f) as string + "  " + f as string)
				)
			)
		)
		
		try(destroyDialog ::ro_count_area)catch()
		rollout ro_count_area "Counts Area of Polygons" width:200 --height:1000
		(
			--progressBar pb13 "ProgressBar" width:950 height:10
			edittext edt "count: " style_sunkenedge:true
			MultiListBox mlbList "polyarea num" items:(dirs_select as array) width:170 height:40 selection:#()
			button btnFilterZero "Zero" across:4
			button btnFilterAll "All"
			button btnDeleteZero "Del"
			button btnClose "Close"
			
			on mlbList rightClick val do 
			(
				selmod = modpanel.getcurrentobject()
				if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
				(
					faces_curr = selmod.GetSelection #Face 
					sel_face = (filterstring dirs_select[val] " ")[(filterstring dirs_select[val] " ").count] as float
					polyop.setFaceSelection selmod #{sel_face}
					subObjectLevel = 4
					max zoomext sel all
					max zoomext sel all
				)
			)
			
			on btnDeleteZero pressed do
			(		
				--delete polygon with zero area
			)
			
			on btnFilterAll pressed do
			(
				dirs_select = #()
				selmod = modpanel.getcurrentobject()
				if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
				(
					faces = selmod.GetSelection #Face 
					if faces.count > 0 then
					(
						--print faces
						for f in faces do
						(
							append dirs_select ((polyop.getFaceArea selmod f) as string + "  " + f as string)
						)
					)
				)
				mlbList.items = dirs_select as array
				edt.text = (dirs_select as array).count as string
			)
			
			on btnFilterZero pressed do
			(
				dirs_select = #()
				selmod = modpanel.getcurrentobject()
				if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
				(
					faces = selmod.GetSelection #Face 
					if faces.count > 0 then
					(
						--print faces
						for f in faces where (polyop.getFaceArea selmod f) < 0.000001 do
						(
							append dirs_select ((polyop.getFaceArea selmod f) as string + "  " + f as string)
						)
					)
				)
				mlbList.items = dirs_select as array	
				edt.text = (dirs_select as array).count as string				
			)
			
			on btnClose pressed do
			(
				try(destroyDialog ::ro_count_area)catch()
			)
		) --rollout
		createDialog ro_count_area style:#(#style_sunkenedge,#style_titlebar,#style_sysmenu,#style_minimizebox,#style_maximizebox)		
	)	
	
	on btn_count_texel pressed do
	(
		gc()
		if selection.count == 1 then
		(
			if (classof selection[1] == editable_poly and selection[1].modifiers.count == 0) or (classof selection[1].modifiers[1] == Unwrap_UVW and classof selection[1].baseobject == editable_poly and selection[1].modifiers.count > 0) then () else messagebox "Selected object is not an EDITABLE POLY!"
			max modify mode
			xViewChecker.on = false
			global dirs_select = #()
			global theMapSize = 2048 
			global textureArea = theMapSize^2 -- Calculate the total texture area
			global unwrapmod = modpanel.getcurrentobject()
			global faces = #{} --#()
			global last_pressed = "All"
			global selected_from = 0
			global mouse_down = 0
			global scroll_down = 0
			
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(
				faces = unwrapmod.getselectedfaces()
				/*
				if faces.count > 0 then
				(
					unwrapmod.setPolygonMode true
					unwrapmod.setTVSubObjectMode 3				
					--print faces
					for f in faces where not keyboard.escPressed do
					(
						--unwrapmod.selectFaces #{f}
						--unwrapmod.polygonSelect() 
						unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
						usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
						texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
						--print texelDensity
						append dirs_select #(texelDensity as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
					)
					--unwrapmod.selectFaces faces
					--unwrapmod.polygonSelect() 
				)
				*/
			)

			try(destroyDialog ::rocount_texel)catch()
			rollout rocount_texel "Counts texels density in UDIMS" 
			(
				fn defColor r g b = ((dotNetClass "System.Drawing.Color").FromArgb r g b)
				
				local maxBC = defColor 50 50 50
				local maxFC = defColor 200 200 200
				
				fn autoResizeColumn lv columns: = 
				(
					vScrollWidth = 21 -- vertical scrollbar width
					for c = 0 to columns-1 do
					(
						lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
						vScrollWidth += lv.Columns.Item[c].Width
					) 
					vScrollWidth
				)
				
				fn compileListItemSorter =
				(
					source =  "using System;\n"
					source += "using System.Windows.Forms;\n"
					source += "using System.Collections;\n"
					source += "class ListViewItemComparer : IComparer\n"
					source += "{\n"
					source += "    private int c;\n"
					source += "    private bool num = false;\n"
					source += "    private int dir = 1;\n"
					source += "    public ListViewItemComparer() { c = 0; }\n"
					source += "    public ListViewItemComparer(int column, bool numeric, bool reverse)\n"
					source += "    { c = column; num = numeric; dir = reverse ? -1 : 1; }\n"
					source += "    public int Compare(object x, object y)\n"
					source += "    {\n"
					source += "        if (num) return Convert.ToInt32(((ListViewItem)x).SubItems[c].Text).CompareTo(\n"
					source += "            Convert.ToInt32(((ListViewItem)y).SubItems[c].Text)) * dir;\n"
					source += "        else return String.Compare(((ListViewItem)x).SubItems[c].Text,\n"
					source += "            ((ListViewItem)y).SubItems[c].Text) * dir;\n"
					source += "    }\n"
					source += "}"
				 
					local csharpProvider = dotNetObject "Microsoft.CSharp.CSharpCodeProvider"
					local compilerParams = dotNetObject "System.CodeDom.Compiler.CompilerParameters"
					compilerParams.GenerateInMemory = true
					compilerParams.ReferencedAssemblies.Add("System.Windows.Forms.dll")
					compilerResults = csharpProvider.CompileAssemblyFromSource compilerParams #(source)
					compilerResults.CompiledAssembly
				)
				
				fn qsort_csv arr1 arr2 = 
				(
					case of 
					(
						(arr1[1] as float < arr2[1] as float): -1
						(arr1[1] as float > arr2[1] as float): 1
						default:0
					)
				)

				fn qsort_csv3 arr1 arr2 = 
				(
					case of 
					(
						(arr1[3] as float < arr2[3] as float): -1
						(arr1[3] as float > arr2[3] as float): 1
						default:0
					)
				)
				
				fn PopulateList lv dirs_select =
				(
					/*
					Me.lvBlah.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
					Me.lvBlah.CheckBoxes = True
					Me.lvBlah.Columns.AddRange(New System.Windows.Forms.ColumnHeader() {Me.colNum, Me.colStatic, Me.colKinetic})
					Me.lvBlah.Font = New System.Drawing.Font("Courier New", 8.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
					Me.lvBlah.FullRowSelect = True
					Me.lvBlah.GridLines = True
					Me.lvBlah.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable
					Me.lvBlah.HideSelection = False
					Me.lvBlah.Location = New System.Drawing.Point(21, 285)
					Me.lvBlah.Name = "lvBlah"
					Me.lvBlah.ShowGroups = False
					Me.lvBlah.Size = New System.Drawing.Size(346, 205)
					Me.lvBlah.TabIndex = 13
					Me.lvBlah.UseCompatibleStateImageBehavior = False
					Me.lvBlah.View = System.Windows.Forms.View.Details
					*/
					
					try (qsort dirs_select qsort_csv)catch()
					
					lv.Items.Clear()
					lv.view = (dotNetClass "system.windows.forms.view").details --lv.view = (dotNetClass "View").details
					lv.HideSelection = true 
					lv.HeaderStyle = (dotNetClass "System.Windows.Forms.ColumnHeaderStyle").clickable
					--lv.Font = dotNetObject "System.Drawing.Font" "Tahoma" 18 (dotNetClass "System.Drawing.FontStyle").Regular (dotNetClass "System.Drawing.GraphicsUnit").Pixel
					--lv.backcolor = maxBC 
					--lv.forecolor = maxFC
					--lv.height = 390
					lv.FullRowSelect = true    
					lv.MultiSelect = false --true    
					lv.AllowColumnReorder = true
					lv.GridLines = true
					lv.checkBoxes = true 
					lv.Scrollable = true
					lv.ShowItemToolTips = true
					--for i = 0 to lv.Items.count-1 do lv.Items.Item[i].checked = true
					columnsAr = #("Density           ", "UDIM  ", "ID    ", "Area Geometry  ", "Area UV          ", ("Number Of " + dirs_select.count as string))
					lv.columns.Clear()
					for i = 1 to 6 do lv.columns.add columnsAr[i] 0	
					lv.width = autoResizeColumn lv columns:6
					lv.width = 440
					--lv.Update()
					rows = #()
					for t = 1 to dirs_select.count do
					(
						li = dotNetObject "System.Windows.Forms.ListViewItem" (dirs_select[t][1])
						li.UseItemStyleForSubItems = true
						--??????????? ??????
						--colAdd = 240 + (if (mod t 2) == 0 then 10 else -10)
						--li.BackColor = li.backcolor.fromARGB colAdd colAdd colAdd
						try 
						(
							if dirs_select[t][5] as float <= 0.000001 then li.forecolor = li.forecolor.fromARGB 0 0 200								
							if dirs_select[t][4] as float <= 0.00001 then li.forecolor = li.forecolor.fromARGB 0 200 0							
							if dirs_select[t][1] as float <= 0.1 then li.forecolor = li.forecolor.fromARGB 200 0 0
						)catch()
						li.subitems.add dirs_select[t][2]
						li.subitems.add dirs_select[t][3]
						li.subitems.add dirs_select[t][4]
						li.subitems.add dirs_select[t][5]
						li.subitems.add dirs_select[t][6]
						append rows li
					)
					lv.items.addRange rows
					--lv.Update()
					--lv.width = autoResizeColumn lv columns:6
					--lv.width = 440
					lv.Update()
				)
				
				dotNetControl lv "ListView" pos:[5,5] width:440 height:300
				label lbmin "" pos:[470,20]
				label lbmax "" pos:[470,290]
				
				group "View items" --grp1 "" width:480 height:35 
				(
					label itm "Texture Dims" across:6 offset:[0, 0]
					dropdownlist dl_tex_dim "" items:#("256", "512", "1024", "2048", "4096") selection:4 width:60 fieldWidth:60 offset:[0, 0]
					button btnSelect "View Checked" offset:[0, 0] tooltip:"???????? ?????????? ??????? ????????? ? ???? ???????? | View checked items in viewport"
					button btnRightClk "View RMB" offset:[0, 0] tooltip:"???????? ?????????? ???????? ? ???? ???????? (?????????? ??????? ???) | View rightclicked single item in viewport"
					button btnSelectAll "Check All" offset:[0, 0] tooltip:"???????? ??????? ??? ???????? ? ?????? | Check all items in list"
					button btnDeselectAll "Uncheck All" offset:[0, 0] tooltip:"????? ????? ? ???? ????????? ? ?????? | Uncheck all items in list"
				)
				group "Filter items"
				(
					button btnFilterZero "Bad Zero" across:5 align:#left offset:[0,0] tooltip:"???????? ?? ?????????? ???????? ?????? ??, ??? ? ???????? = 0 ??? ??????? ? 0 | Show selected texels with area = 0 or near 0" 
					button btnFilterBadLP "Bad LowPoly" offset:[-20,0] tooltip:"???????? ?? ?????????? ???????? ?????? ??, ??????? ?? ?????? ? ???????? [10 >= ????????? >= 40], ????????? ?????? ??? ??? Ground ??????! | Show selected texels that do not enter interval\n[10 >= density >= 40],\nactual only for Lowpoly Ground model!"
					button btnFilterBadHP "Bad HighPoly" offset:[-20,0] tooltip:"???????? ?? ?????????? ???????? ?????? ??, ??????? ?? ?????? ? ???????? [512 >= ????????? >= 1706], ????????? ??? ??? ??????? ? ?????????? | Show selected texels that do not enter interval\n[512 >= density >= 1706],\nactual for Highpoly models with textures"
					button btnFilterBadHPMat "Bad HighPoly by Mat" offset:[0,0] tooltip:"?????????????????! ???????? ?? ?????????? ???????? ?????? ??, ??????? ?? ?????? ? ????????\n[512 >= ????????? >= 1706], ? ?????? ??? ??????? ????????, ???????????? 256?256 ???????? ? ???????? ?????????, ????????? ??? ??? ??????? ? ?????????? | Experimental! Show selected texels that do not enter interval\n[512 >= density >= 1706],\nand only for texture size bigger than 256 in assigned material, actual for Highpoly models with textures"
					button btnFilterAll "All \ Refresh" offset:[0,0] align:#right tooltip:"???????? ????????? ???????? ??? ???? ????????? ???????? | Show texels density for ALL selected texels"
				)
				group "Set texels density"
				(
					button btnSetAll "Set checked" across:4 align:#left offset:[0,0] tooltip:"?????????? ????????? ???????? ? ????????? ???????? | Set texels density to specified value"
					spinner spn_target_density "Target density" range:[0.001, 10000.0, 1380.0] width:60 fieldWidth:60 offset:[70,0] tooltip:"????????????? ????????? ????????? ??????? ??? ??? [512 >= ????????? >= 1706], ??? ??? Ground [10 >= ????????? >= 40] | Recomended texel density ranges\nfor Highpoly [512 >= density >= 1706]\nfor Lowpoly Ground [10 >= density >= 40]"
					checkbox chk_clean_memory "Conserve memory" checked:false offset:[10,0] tooltip:"????????? ??????, ???????? ?????????, ?? ?????????? ?????? ?????? ?, ??? ???????, ??? ?????? ???????? | Conserve memory, slower but uses less memory, and usually with no undo"
					button btnReFlatten "ReFlatten checked" align:#right offset:[0,0] tooltip:"?????????????? ????????? ? ?????????? ?????? ????????? | Re Unwrap as flatten checked items"
					radiobuttons rdo labels:#("scale by island by enumeration", "scale individual", "scale whole", "scale by island by average", "scale individual with break") default:1 columns:3 rows:2 offset:[0,0] align:#left tooltip:"Scale by island by enumeration - ??????????????? ?? ???????? ????? ????????????: ??????????? ??????? ??????? ??????? ??????????? ???????, ??????? ?????????????? ?? ??????? ??? ??????? ?????????? ??????? (?? ??? ???????? ???????? ?? ?????? ???????? ?? ???????), ????????? ?????? ???????? ?? ???????? ????? ???? ??????\nScale by island by average - ??????????????? ?? ???????? ?? ???????? ???????? : ??????????? ??????? ??????? ??????? ??????????? ???????, ?????????????? ?? ??????? ???????? ??? ?????? ???????? ?? ???????, ????????? ???? ???????? ?? ???????? ????? ???? ????????????\nScale individual - ?????????????? ?????????????: ????? ?????? ?? ????????? ???????? ????????, ??? ????? ???? ?? ??????? ? ?????????? ??? ???????????????????\nScale individual with break - ?????????????? ????????????? ? ????????: ????????? ????????? ??????? ????? ?????????? ????????, ?? ?????? ?? ???????? ???????\nScale whole - ??????????????? ???????? ???????: ?????????? ???? ????????? ???????? ? ??????? ????????? | Scale by island by enumeration: try to select element of each checked texel, scale computes from selected texel (not for average of group of texels in island), other texels density in islands may be not equal\n\nScale by island by average: try to select element of each checked texel, scale computes for average of group of texels in island, all texels density in islands may be not equal\n\nScale individual: can influence on positions of neighbour texels, they are may be not breaked\n\nScale individual with break: breaks selected texel before rescale to density, do not influence on neighbour texels\n\nScale whole: Manage all selected texels to average density"
				)	
				group "Selection in UVW Editor"
				(
					button btnSelectionAll "Select All" across:6 tooltip:"???????? ??? ??????? ??????? | Select all texels of object"
					button btnSelectID "Select by ID" tooltip:"??????? ??????? ? ID ??????? | Select texels with current ID of object"
					spinner spn_ID "ID" range:[0, 10000, 1] type:#integer offset:[-20,0] tooltip:"ID ??????? | ID of object"
					button btnSelectUDIM "Select by UDIM" tooltip:"???????? ????? ???????, ??????????? ??????? ESC!\n??????? ??????? (?? ????????) ?????? ??? ???????? UDIM | WORKING A LOT OF TIME, USE ESC!\nSelect texels (by islands) only in current UDIM"
					spinner spn_UDIM "UDIM" range:[1001, 1100, 1001] type:#integer width:60 fieldWidth:40 offset:[30,0] tooltip:"UDIM ??????? | UDIM of object"	
					button btnOpenEditor "Editor" align: #right tooltip:"??????? UVW ???????? ????????? | Open UVW Editor"
				)
				--dotnetcontrol Slider "System.Windows.Forms.TrackBar" width:400 height:100 pos:[5,550] 
				label lbl "Selected:" width:150 align:#left across:5 style_sunkenedge:true
				button btn_Unhide_all "Unhide all" offset:[50,0] tooltip:"?????????? ??? ??????? ????? ??????? | Unhide all parts of object"
				button btn_ShowDensity "Show Density" offset:[50,0] tooltip:"?????????? ????????? ? ?????? ?? ??????? ????????? ? ?????????????? VertexColor | Show densities in viewports with colors using VertexColor"
				button btn_UnShow "UnShow" offset:[50,0] tooltip:"????????? ??????????? ?????????? | Toggle off showing densities"
				button btnClose "Close" align: #right tooltip:"??????? ??? ?????????? ???? | Close this dialog"
				
				/*
				on Slider MouseDown do
				(
				)
 
				on Slider MouseUp do
				(
				)
 
				on Slider ValueChanged val do
				( 
					--print val
					--this.trackBar1.Location = new System.Drawing.Point(40, 104);
					--this.trackBar1.Maximum = 100;
					--this.trackBar1.Name = "trackBar1";
					--this.trackBar1.Size = new System.Drawing.Size(224, 42);
					--this.trackBar1.TabIndex = 0;
					--this.trackBar1.TickFrequency = 5;
					--this.trackBar1.Scroll +=
					--new System.EventHandler(this.trackBar1_Scroll);
				)
				*/
				
				on rocount_texel open do
				(  
					gc()
					PopulateList lv dirs_select 
					--for i = 0 to lv.Items.count-1 do lv.Items.Item[i].selected = true
					--lv.SelectedIndices --: <System.Windows.Forms.ListView+SelectedIndexCollection>, read-only
					--lv.SelectedItems --: <System.Windows.Forms.ListView+SelectedListViewItemCollection>, read-only
					--lv.Alignment : <System.Windows.Forms.ListViewAlignment>	
					--showproperties lv --.Columns[0].Width = -1	
					lbmin.text = ""
					lbmax.text = ""
					lbl.text = "Selected: " + (faces.numberset as string)
					
					for i in rocount_texel.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_rocount_texel.ini") i.name "rocount_texel" (syssetup.rdo_lang.state))

				)
				
				on lv columnClick columnHeader do
				(
					lv.ListViewItemSorter = dotnetobject "MXS_dotNet.ListViewItemComparer" columnHeader.column
					lv.ListViewItemSorter = undefined
					
					--if dirs_select.count > 0 then lbmin.text = lv.Items.Item[0] 
					--if dirs_select.count > 0 then lbmax.text = lv.Items.Item[lv.Items.count-1] 
					--print columnHeader.column
				)
				
				on lv MouseUp arg do
				(
					scroll_down = false
					if arg.button == arg.button.left then
					(                
						if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
						(
							val = hitNode.index --+ 1
							if mouse_down != val then
							(
								st = if mouse_down < val then 1 else -1
								for vv = mouse_down to val by st where vv != mouse_down do 
								(
									lv.Items.Item[vv].checked = not lv.Items.Item[vv].checked
									lv.Items.Item[vv].Focused = true
									lv.Items.Item[vv].selected = true
								)
							)	
							--print selected_from
						)   
					)	
				)
		/*		
				on lv MouseHover arg do 
				(
					--print "MouseHover"
					--ScrollToBottom 
					--listView.setSelection (int position) --???? ?? ?????? ??????? ????? ? ?????? ??????? ? ??????, ?????? ???????????
					--listView.smoothScrollToPosition (int position) --? ???? ?? ?????? ?????? ??????? ? ?????? ??????? ? listView, ?????? ???????????
				)
				
				on lv MouseLeave arg do 
				(
					scroll_down = false
					--print "MouseLeave"
				)
		*/		
				on lv MouseDown arg do
				(
					shift = false
					mouse_down = 0
					scroll_down = true
					if keyboard.shiftPressed then shift = not shift
					if arg.button == arg.button.left then
					(                
						if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
						(
							val = hitNode.index --+ 1
							lv.Items.Item[val].checked = true
							--showproperties lv.Items.Item[val]
							lv.Items.Item[val].Focused = true
							lv.Items.Item[val].selected = true
							--lv.Items.Item[val].BackColor = lv.Items.Item[val].BackColor.fromARGB 200 200 200
							mouse_down = val
							if not shift then selected_from = val
							if shift then 
							(
								st = if selected_from < val then 1 else -1
								for vv = selected_from to val by st do
								(
									lv.Items.Item[vv].checked = true --not lv.Items.Item[vv].checked
									/*	
									--local selColor = (dotNetClass "System.Drawing.Color").fromARGB 238 204 85 -- custom selection color (orangey-yellow)
									--local lvBackColor = selColor.fromARGB 225 225 225
									--arg.Item.BackColor = if arg.isSelected then selColor else lvBackColor
										
									--lv.Items.Item[vv].BackColor = lv.Items.Item[vv].BackColor.fromARGB 100 100 100
									
										dnListView.OwnerDraw = true

										local selColor = (dotNetClass System.Drawing.Color).fromARGB 238 204 85  custom selection color (orangey-yellow)
										local lvBackColor = selColor.fromARGB 225 225 225

										on dnListView ItemSelectionChanged arg do
										(
											arg.Item.BackColor = if arg.isSelected then selColor else lvBackColor
										)

										on dnListView drawitem arg do
										(
											arg.DrawBackground()
											arg.DrawText()
										)
									*/
								)
							)	
							--print selected_from
						)                
					)
					if arg.button == arg.button.middle then
					(                
						if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
						(
							val = hitNode.index --+ 1
							lv.Items.Item[val].checked = true
							if not shift then selected_from = val
							if shift then 
							(
								st = if selected_from < val then 1 else -1
								for vv = selected_from to val by st do lv.Items.Item[vv].checked = false --not lv.Items.Item[vv].checked
							)	
							--print selected_from							
						)                
					)
					if arg.button == arg.button.right then
					(                
						if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
						(
							val = hitNode.index + 1
							max modify mode
							unwrapmod = modpanel.getcurrentobject()
							if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
							(
								sel_face = dirs_select[val][6] as integer
								unwrapmod.selectFaces #{sel_face}
								unwrapmod.setPolygonMode true
								unwrapmod.polygonSelect() 
								max zoomext sel all
								max zoomext sel all
							)
						)                
					)
				)

				on btn_ShowDensity pressed do
				(
					max modify mode
					color_face = #()
					
					unwrapmod = modpanel.getcurrentobject()
					sel = selection[1]
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						if lv.Items.count > 0 then 
						(
							convertToPoly sel

							p_zero = #{}
							p_low = #{}
							p_norm = #{}
							p_high = #{}
							
							for val = 0 to lv.Items.count-1 do 
							(
								p = (dirs_select[val+1][1] as float)
								case of
								(
									(p <= 1): p_zero += #{(dirs_select[val+1][6] as integer)}
									(p > 1 and p < 512): p_low += #{(dirs_select[val+1][6] as integer)}
									(p >= 512 and p < 1706): p_norm += #{(dirs_select[val+1][6] as integer)}
									(p >= 1706): p_high += #{(dirs_select[val+1][6] as integer)}
								)
							)
							
							/*
							fn color_density_HP p = 
							(
								local col = color 128 128 128
								col = case of
								(
									(p <= 1): (color 255 0 0)
									(p > 1 and p < 512): (color 255 64 64) --(color ((255 * ( p / (512 * 2) )) as integer + 128) 128 128)
									(p >= 512 and p < 1706): (color 0 255 0) --(color 128 ((255 * p / (1194 * 2)) as integer) 128)
									(p >= 1706): color 0 0 255 --(color 128 128 ((255 / (p - 1705) as integer)))
								)
								--print p
								--print col
								col
							)
							*/
							
							polyop.SetFaceColor sel 0 p_zero (color 255 0 0) 
							polyop.SetFaceColor sel 0 p_low (color 255 64 64)
							polyop.SetFaceColor sel 0 p_norm (color 0 255 0) 
							polyop.SetFaceColor sel 0 p_high (color 0 0 255) 
							
							addmodifier selection[1] (vertexpaint lightingModel:1 useMaps:true colorBy:0 mapChannel:0)

							menu = for i in (UIAccessor.GetChildWindows (DialogMonitorOPS.GetWindowHandle())) where (UIAccessor.GetWindowText i == "VertexPaint") do exit with i
							buttons = windows.getChildrenHWND menu
							UIAccessor.pressButton ((buttons[3])[1]) --???	
							--UIAccessor.pressButton ((buttons[2])[1]) --????

							convertToPoly selection[1]
							addmodifier selection[1] (Unwrap_UVW ())	
								
							--$.SetFaceColor (color 255 255 255) #VertexColor --Channel enums: {#VertexColor|#Illumination|#Alpha}	
							--select selection[1]
							--max modify mode
							--modPanel.addModToSelection (Unwrap_UVW ()) ui:on --
							--unwrapmod = modpanel.getcurrentobject()
							--unwrapmod.unwrap4.setThickOpenEdges off 
							--unwrapmod.unwrap5.setShowMapSeams off
							--unwrapmod = modpanel.getcurrentobject()
							--unwrapmod.setPeltAlwaysShowSeams = false
							--unwrapmod.setThickOpenEdges	= false
						)		
					)	
				)

				
				on btn_UnShow pressed do
				(
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						converttopoly selection[1] 
						polyop.SetFaceColor selection[1] 0 #all white
						addmodifier selection[1] (vertexpaint lightingModel:3 useMaps:true colorBy:0 mapChannel:0)
						
						menu = for i in (UIAccessor.GetChildWindows (DialogMonitorOPS.GetWindowHandle())) where (UIAccessor.GetWindowText i == "VertexPaint") do exit with i
						buttons = windows.getChildrenHWND menu
						--UIAccessor.pressButton ((buttons[3])[1]) --???	
						UIAccessor.pressButton ((buttons[2])[1]) --????
							
						converttopoly selection[1] 
						addmodifier selection[1] (Unwrap_UVW())
						--unwrapmod = modpanel.getcurrentobject()
						--selection[1].modifiers[1].setPeltAlwaysShowSeams = false
						--selection[1].modifiers[1].setThickOpenEdges	= false						
					)	
				)
				
				on btn_Unhide_all pressed do
				(
					sel = selection as array
					for i in sel do 
					(
						select i
						max modify mode
						collapseStack i						
						--subObjectLevel = 1
						i.unhideAll #Vertex
						i.unhideAll #Face						
						--subObjectLevel = 0
						unwrapmod = modpanel.getcurrentobject()
						if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
						(
							if validModifier i (Unwrap_UVW()) then addmodifier i (Unwrap_UVW())
							unwrapmod = modpanel.getcurrentobject()
						)
						if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
						(						
							unwrapmod.unhide() 
						)
					)
					select sel	
				)
				
				on btnReFlatten pressed do
				(
					max modify mode
					sel_face = #{}
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						ini_sel_face = #{}
						ini_sel_face = unwrapmod.getselectedfaces()
						sel_face = #{} 
						for val = 0 to lv.Items.count-1 where lv.Items.Item[val].checked do append sel_face (dirs_select[val+1][6] as integer)
						if sel_face.count > 0 then
						(
							unwrapmod.setTVSubObjectMode 3
							unwrapmod.setPolygonMode true
							for f in sel_face where not keyboard.escPressed do
							(
								unwrapmod.selectFaces #{f}
								unwrapmod.setPolygonMode true
								unwrapmod.polygonSelect() 	

								if rdo.state == 1 then unwrapmod.selectElement()
								if rdo.state == 3 then unwrapmod.breakSelected()
								faces = unwrapmod.getselectedfaces()
	
								if faces.count > 0 then
								(							
									pos = unwrapmod.getSelCenter()
									unwrapmod.unfoldMapNoParams() --unwrapmod.unfoldMap 1
									pos2 = unwrapmod.getSelCenter()
									unwrapmod.moveSelected (pos - pos2)
								)
							)
							unwrapmod.setPolygonMode true
							unwrapmod.selectFaces ini_sel_face
							unwrapmod.setPolygonMode true
							unwrapmod.polygonSelect() 		
							
							dirs_select = #()					
							faces = unwrapmod.getselectedfaces()
							if faces.count > 0 then
							(
								for f in faces where not keyboard.escPressed do
								(
									unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
									usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
									texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
									--print texelDensity
									id = (mX as integer) + 1 + 10 * (mY as integer)
									UDIM = id + 1000
									append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
								)
							)		
							PopulateList lv dirs_select
							lbl.text = "Selected: " + (sel_face.numberset as string)
							for val = 0 to lv.Items.count-1 where (for s in sel_face where s == (dirs_select[val+1][6] as integer) collect s).count > 0 do lv.Items.Item[val].checked = true
							if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
							if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""
						)
					)					
				)
				
				on btnSelectUDIM pressed do with undo off
				(
					max modify mode
					sel_face = #{}
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						unwrapmod.setPolygonMode true
						unwrapmod.setTVSubObjectMode 3
						unwrapmod.unhide() 
						arr = #{1..unwrapmod.numberPolygons()}
						qq = #{}
						while not arr.isempty do 
						(
							if keyboard.escpressed then exit with sel_face
							for i in arr do (unwrapmod.selectFaces #{i}; exit)
							unwrapmod.selectElement()
							qq = unwrapmod.getselectedfaces()
							arr -= qq
							local pos = unwrapmod.getSelCenter()
							
							--local y = (spn_UDIM.value - 1001) as integer 
							local y = ((spn_UDIM.value - 1001)/10) as integer
							local x = (mod ((spn_UDIM.value - 1001) as integer) 10) as integer
							if pos.x >= x and pos.x <= (x+1) and pos.y >= y and pos.y <= (y+1) then --if pos.x as integer == x and (pos.y/10) as integer == y then join sel_face qq	
							(
								join sel_face qq	 
								format "x=% y=% pos=%\n" x y pos
								--print arr.numberset
							)								
						)
						unwrapmod.selectFaces sel_face
						unwrapmod.polygonSelect()
						--btnFilterAll.pressed()
						sel_face = unwrapmod.getselectedfaces()
						lbl.text = "Selected: " + (sel_face.numberset as string)
					)
				)					
				
				on btnSelectID pressed do with undo off
				(
					max modify mode
					sel_face = #{}
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						unwrapmod.setPolygonMode true
						unwrapmod.setTVSubObjectMode 3
						unwrapmod.unhide() 
						unwrapmod.selectByMatID spn_ID.value
						unwrapmod.polygonSelect()
						--btnFilterAll.pressed()
						sel_face = unwrapmod.getselectedfaces()
						lbl.text = "Selected: " + (sel_face.numberset as string)
					)			
				)
				
				on btnSelectionAll pressed do
				(
					max modify mode
					sel_face = #{}
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						unwrapmod.setPolygonMode true
						unwrapmod.setTVSubObjectMode 3
						unwrapmod.unhide() 
						unwrapmod.selectFaces #{1..unwrapmod.numberPolygons()}
						unwrapmod.polygonSelect()
						--btnFilterAll.pressed()
						sel_face = unwrapmod.getselectedfaces()
						lbl.text = "Selected: " + (sel_face.numberset as string)
					)			
				)
				
				on btnSetAll pressed do with undo "Set Density" on
				(
					if chk_clean_memory.checked then gc()
					theMapSize = case (dl_tex_dim.selection as integer) of
					(
						1: 256
						2: 512
						3: 1024
						4: 2048
						5: 4096
					)
					textureArea = theMapSize^2
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						ini_sel_face = #{}
						ini_sel_face = unwrapmod.getselectedfaces()
						sel_face = #{} 
						for val = 0 to lv.Items.count-1 where lv.Items.Item[val].checked do append sel_face (dirs_select[val+1][6] as integer)
						if sel_face.count > 0 then
						(
							unwrapmod.setTVSubObjectMode 3
							unwrapmod.setPolygonMode true
							
							case rdo.state of
							(
								1: --"scale by island by enumeration"
								(
									for f in sel_face where not keyboard.escPressed do
									(
										unwrapmod.selectFaces #{f}
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea 
										if mAreaGeom == 0.0 then continue
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) 
										unwrapmod.selectElement()
										faces = unwrapmod.getselectedfaces()
										if faces.count > 0 and texelDensity > 0.0 then unwrapmod.scaleSelectedCenter (spn_target_density.value * (GetMetersFromGU()) / texelDensity) 0
										if chk_clean_memory.checked then gc()
									)
								)
								
								3: --"scale whole"
								(
									unwrapmod.selectFaces sel_face
									--unwrapmod.setPolygonMode true
									--unwrapmod.polygonSelect() 	
									unwrapmod.getarea sel_face &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
									usedAreaPixels = mAreaUVW * textureArea 
									if mAreaGeom != 0.0 then
									(									
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) 
										faces = unwrapmod.getselectedfaces()
										if faces.count > 0 and texelDensity > 0.0 then unwrapmod.scaleSelectedCenter (spn_target_density.value * (GetMetersFromGU()) / texelDensity) 0
									)
									if chk_clean_memory.checked then gc()
								)
								
								4: --"scale by island by average"
								(
									current_faces = sel_face
									while current_faces.numberset != 0 do
									(
										if keyboard.escpressed then exit 
										for p in current_faces do (unwrapmod.selectFaces #{p}; exit)
										unwrapmod.selectElement()
										faces = unwrapmod.getselectedfaces()
										unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea 
										if mAreaGeom != 0.0 then 
										(
											texelDensity = sqrt (usedAreaPixels/mAreaGeom) 
											faces = unwrapmod.getselectedfaces()
											if faces.count > 0 and texelDensity > 0.0 then unwrapmod.scaleSelectedCenter (spn_target_density.value * (GetMetersFromGU()) / texelDensity) 0
										)
										current_faces -= faces
										if chk_clean_memory.checked then gc()
									)									
								)
								
								5: --"scale individual with break"
								(
									for f in sel_face where not keyboard.escPressed do
									(
										unwrapmod.selectFaces #{f}
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea
										if mAreaGeom == 0.0 then continue
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) 	
										unwrapmod.breakSelected()
										faces = unwrapmod.getselectedfaces()
										if faces.count > 0 and texelDensity > 0.0 then unwrapmod.scaleSelectedCenter (spn_target_density.value * (GetMetersFromGU()) / texelDensity) 0
										if chk_clean_memory.checked then gc()
									)									
								)
								
								2: --"scale individual"
								(
									for f in sel_face where not keyboard.escPressed do
									(
										unwrapmod.selectFaces #{f}
										--unwrapmod.setPolygonMode true
										--unwrapmod.polygonSelect() 	
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea
										if mAreaGeom == 0.0 then continue
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) 
										--unwrapmod.selectFacesByNode #{p} selection[1]
										--if rdo.state == 1 then unwrapmod.selectElement()
										--if rdo.state == 3 then unwrapmod.breakSelected()
										faces = unwrapmod.getselectedfaces()
										if faces.count > 0 and texelDensity > 0.0 then unwrapmod.scaleSelectedCenter ((spn_target_density.value as float) * (GetMetersFromGU()) / texelDensity) 0
										if chk_clean_memory.checked then gc()
									)
								)
							)
							
							unwrapmod.setPolygonMode true
							unwrapmod.selectFaces ini_sel_face
							unwrapmod.setPolygonMode true
							unwrapmod.polygonSelect() 		
							
							dirs_select = #()					
							faces = unwrapmod.getselectedfaces()
							if faces.count > 0 then
							(
								for f in faces where not keyboard.escPressed do
								(
									unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
									usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
									if mAreaGeom == 0.0 then texelDensity = 0.0
									else texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
									--print texelDensity
									id = (mX as integer) + 1 + 10 * (mY as integer)
									UDIM = id + 1000
									append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
								)
							)		
							PopulateList lv dirs_select
							lbl.text = "Selected: " + (faces.numberset as string)
							for val = 0 to lv.Items.count-1 where (for s in sel_face where s == (dirs_select[val+1][6] as integer) collect s).count > 0 do lv.Items.Item[val].checked = true
							if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
							if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""
						)
					)
					if chk_clean_memory.checked then gc()
					--actionMan.executeAction 2077580866 "40207" --it will rescale the cluster to equalize the texel density
				)
				
				on btnSelectAll pressed do
				(
					max modify mode
					sel_face = #{}
					for val = 0 to lv.Items.count-1 do 
					(
						lv.Items.Item[val].checked = true
						append sel_face (dirs_select[val+1][6] as integer)
					)
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						unwrapmod.setPolygonMode true
						unwrapmod.selectFaces sel_face
						--unwrapmod.setPolygonMode true
						unwrapmod.polygonSelect() 
						max zoomext sel all
						max zoomext sel all
					)				
				)
				
				on btnDeselectAll pressed do
				(
					max modify mode
					sel_face = #{}
					for val = 0 to lv.Items.count-1 do lv.Items.Item[val].checked = false
					unwrapmod.setPolygonMode true
					unwrapmod.selectFaces sel_face
					unwrapmod.polygonSelect() 
				)			
				
				on btnRightClk pressed do
				(
					max modify mode
					sel_face = #{}
					for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected do append sel_face (dirs_select[val+1][6] as integer)
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						unwrapmod.selectFaces sel_face
						unwrapmod.setPolygonMode true
						unwrapmod.polygonSelect() 
						max zoomext sel all
						max zoomext sel all
					)
				)
				
				on dl_tex_dim selected i do 
				(
					theMapSize = case (dl_tex_dim.selection as integer) of
					(
						1: 256
						2: 512
						3: 1024
						4: 2048
						5: 4096
					)
					textureArea = theMapSize^2
					dirs_select = #()
					unwrapmod = modpanel.getcurrentobject()
							
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						faces = unwrapmod.getselectedfaces()
						if faces.count > 0 then
						(
							--print faces
							case last_pressed of
							(
								"All":
								if dirs_select.count != 0 then 
									for f in faces where not keyboard.escPressed do
									(
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
										--print texelDensity
										id = (mX as integer) + 1 + 10 * (mY as integer)
										UDIM = id + 1000
										append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)
								
								"BadHP":
								--if dirs_select.count != 0 then 
									for f in faces where not keyboard.escPressed do
									(
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
										--print texelDensity
										id = (mX as integer) + 1 + 10 * (mY as integer)
										UDIM = id + 1000
										if texelDensity <= 512 or texelDensity >= 1706 then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)
								
								"BadLP":
								--if dirs_select.count != 0 then 
									for f in faces where not keyboard.escPressed do
									(
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
										--print texelDensity
										id = (mX as integer) + 1 + 10 * (mY as integer)
										UDIM = id + 1000
										if texelDensity <= 10 or texelDensity >= 40 then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)
								
								"Zero":
								--if dirs_select.count != 0 then 
									for f in faces where not keyboard.escPressed do
									(
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
										--print texelDensity
										id = (mX as integer) + 1 + 10 * (mY as integer)
										UDIM = id + 1000
										if texelDensity <= 0.01 then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)
								
								default:
								if dirs_select.count != 0 then 
									for f in faces where not keyboard.escPressed do
									(
										unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
										usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
										texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
										--print texelDensity
										id = (mX as integer) + 1 + 10 * (mY as integer)
										UDIM = id + 1000
										append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)								
							)
						)
					)
					PopulateList lv dirs_select
					lbl.text = "Selected: " + (faces.numberset as string)
					if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
					if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""	
					if chk_clean_memory.checked then gc()					
				)

				on btnFilterBadHPMat pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						mat = #()
						if selection[1].material != undefined then
							if classof selection[1].material == multiSubMaterial then
							(
								m = selection[1].material
								num = m.materialList.count
								for i in #{1..num} do 
								(
									case classof m.materialList[i] of
									(
										Standard:
										(
											if classof m.materialList[i].DiffuseMap == BitmapTexture then
											(
												--print m.materialList[i].DiffuseMap.fileName
												bm = openbitmap m.materialList[i].DiffuseMap.fileName
												if bm != undefined then
												(
													mat[i] = bm.width --append mat #{i, bm.width}
													close bm
													free bm
												)
												else mat[i] = 0
											)
											else mat[i] = 0 -- append mat = #{i, 0}
										)
										Physical_Material:
										(			
											if classof m.materialList[i].base_color_map == BitmapTexture then --print m.materialList[i].base_color_map.fileName
											(
												--print m.materialList[i].DiffuseMap.fileName
												bm = openbitmap m.materialList[i].base_color_map.fileName
												if bm != undefined then
												(
													mat[i] = bm.width --append mat #{i, bm.width}
													close bm
													free bm
												)
												else mat[i] = 0
											)
											else mat[i] = 0 -- append mat = #{i, 0}												
										)
									)
								)
							)
							
						--print #(mat)
						faces = unwrapmod.getselectedfaces()
						--edt.text = faces.count as string	
						if faces.count > 0 then
						(
							--print faces
							for f in faces where not keyboard.escPressed do
							(
								unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
								usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
								texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
								--print texelDensity
								id = (mX as integer) + 1 + 10 * (mY as integer)
								if id <= 0 then id = 0
								UDIM = if id > 0 then id + 1000 else "wrong"
								--print id
								if id != 0 then 
									if mat[id] != undefined then
									(
										if ((texelDensity <= 512 or texelDensity >= 1706) and mat[id] > 256) or mat[id] == 0 then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)
									else
									(
										if (texelDensity <= 512 or texelDensity >= 1706) then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
									)
								else if (texelDensity <= 512 or texelDensity >= 1706) then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)

							)
						)
						last_pressed = "BadHP"
						PopulateList lv dirs_select 
						lbl.text = "Selected: " + (faces.numberset as string)
						if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
						if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""				
					)				
				)				
				
				on btnFilterBadHP pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						faces = unwrapmod.getselectedfaces()
						--edt.text = faces.count as string	
						if faces.count > 0 then
						(
							--print faces
							for f in faces where not keyboard.escPressed do
							(
								unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
								usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
								texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
								--print texelDensity
								id = (mX as integer) + 1 + 10 * (mY as integer)
								UDIM = if id > 0 then id + 1000 else "wrong"
								if texelDensity <= 512 or texelDensity >= 1706 then append dirs_select #(texelDensity as string,  UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
							)
						)
						last_pressed = "BadHP"
						PopulateList lv dirs_select 
						lbl.text = "Selected: " + (faces.numberset as string)
						if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
						if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""
					)				
				)

				on btnFilterZero pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						faces = unwrapmod.getselectedfaces()
						--edt.text = faces.count as string	
						if faces.count > 0 then
						(
							--print faces
							for f in faces where not keyboard.escPressed do
							(
								unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
								usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
								texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
								--print texelDensity
								id = (mX as integer) + 1 + 10 * (mY as integer)
								UDIM = if id > 0 then id + 1000 else "wrong"
								if texelDensity <= 0.01 then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
							)
						)
						last_pressed = "Zero"
						PopulateList lv dirs_select 
						lbl.text = "Selected: " + (faces.numberset as string)
						if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
						if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""						
					)				
				)

				on btnFilterBadLP pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						faces = unwrapmod.getselectedfaces()
						--edt.text = faces.count as string	
						if faces.count > 0 then
						(
							--print faces
							for f in faces where not keyboard.escPressed do
							(
								unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
								usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
								texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
								--print texelDensity
								id = (mX as integer) + 1 + 10 * (mY as integer)
								UDIM = if id > 0 then id + 1000 else "wrong"
								if texelDensity <= 10 or texelDensity >= 40 then append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
							)
						)
						last_pressed = "BadLP"
						PopulateList lv dirs_select 
						lbl.text = "Selected: " + (faces.numberset as string)
						if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
						if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""						
					)				
				)
				
				on btnSelect pressed do
				(
					max modify mode
					if modpanel.getcurrentobject() != undefined and classof (unwrapmod = modpanel.getcurrentobject()) == unwrap_uvw then
					(
						if (faces = unwrapmod.getselectedfaces()).count > 0 then
						(
							unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom -- Get some information about the selection
							textureArea = theMapSize^2 -- Calculate the total texture area
							usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
							texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
							print texelDensity
						)
					)
					else messagebox "Please select an object with Unwrap UVW modifier applied to it."
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						sel_faces = #{}
						for val = 0 to lv.Items.count-1 where lv.Items.Item[val].checked do append sel_faces (dirs_select[val+1][6] as integer)
						unwrapmod.selectFaces sel_faces
						unwrapmod.setPolygonMode true
						unwrapmod.polygonSelect() 
						max zoomext sel all
						max zoomext sel all
					)
				)

				on btnFilterAll pressed do
				(
					faces = #()
					dirs_select = #()
					max modify mode
					unwrapmod = modpanel.getcurrentobject()
							
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						faces = unwrapmod.getselectedfaces()
						unwrapmod.setPolygonMode true
						unwrapmod.setTVSubObjectMode 3	
						if faces.count > 0 then
						(
							--print faces
							for f in faces where not keyboard.escPressed do
							(
								--unwrapmod.selectFaces #{f}
								--unwrapmod.polygonSelect() 
								unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
								usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
								texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
								--print texelDensity
								id = (mX as integer) + 1 + 10 * (mY as integer)
								UDIM = if id > 0 then id + 1000 else "wrong"
								append dirs_select #(texelDensity as string, UDIM as string, unwrapmod.getSelectMatID() as string, mAreaGeom as string, mAreaUVW as string, f as string)
							)
							--unwrapmod.selectFaces faces
							--unwrapmod.polygonSelect() 
						)
					)
					last_pressed = "All"
					PopulateList lv dirs_select
					if faces.count > 0 then lbl.text = "Selected: " + (faces.numberset as string)
					if dirs_select.count > 0 then lbmin.text = dirs_select[1][1] else lbmin.text = ""
					if dirs_select.count > 0 then lbmax.text = dirs_select[dirs_select.count][1] else lbmax.text = ""				
					--lv.width = 450
					--lv.Update()
				)

				on btnClose pressed do
				(
					try(destroyDialog ::rocount_texel)catch()
					gc()
				)	
				
				on btnOpenEditor pressed do
				(
					max modify mode
					
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						--UIAccessor.PressButton (for i in (windows.getChildrenHWND (windows.getDesktopHWND())) where findstring i[5] "Open UV Editor" != undefined do (print i; exit with i[1]))
						unwrapmod.edit()
						unwrapmod.fit() 
					)
				)
			)
			createDialog rocount_texel width:500 height:580 style:#(#style_titlebar, #style_border, #style_sysmenu, #style_resizing)	
		)
		else
		(
			messagebox "Select one EDITABLE POLY object."
		)
	)

	on btn_count_texel rightclick do
	(
		global dirs_select = #()
		global theMapSize = 2048 
		global textureArea = theMapSize^2 -- Calculate the total texture area
		global unwrapmod = modpanel.getcurrentobject()
		global faces = #()
		if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
		(
			addmodifier selection[1] (Unwrap_UVW())
			unwrapmod = modpanel.getcurrentobject()
		)
		if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
		(
			faces = unwrapmod.getselectedfaces()
			if faces.count > 0 then
			(
				--print faces
				for f in faces do
				(
					unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
					usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
					texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
					--print texelDensity
					append dirs_select (texelDensity as string + "  " + unwrapmod.getSelectMatID() as string + "  " + mAreaGeom as string + "  " + mAreaUVW as string + "  " + f as string)
				)
			)
		)
		
		try(destroyDialog ::rocount_texel)catch()
		rollout rocount_texel "Counts texel density in UDIMS" width:350 --height:1000
		(
			--progressBar pb13 "ProgressBar" width:950 height:10
			dropdownlist dl_tex_dim "Texture Dims" items:#("256", "512", "1024", "2048", "4096") selection:4 width:80 across:2
			edittext edt "count: " style_sunkenedge:true text:(faces.count as string)	
			MultiListBox mlbList "density ID areaG areaUV num" items:(dirs_select as array) width:270 height:40 selection:#()
			button btnExport "Select" across:7
			button btnFilterBad "Bad HP"			
			button btnFilterZero "Zero"
			button btnFilterTen "<10 LP" 
			button btnFilterForty ">40 LP" 
			button btnFilterAll "All"
			button btnClose "Close"
			
			on dl_tex_dim selected i do 
			(
				theMapSize = case (dl_tex_dim.selection as integer) of
				(
					1: 256
					2: 512
					3: 1024
					4: 2048
					5: 4096
				)
				textureArea = theMapSize^2				
			)
			
			on mlbList rightClick val do 
			(
				--try (mlbList.width = ((dirs_select[val]).count)*10)catch()
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					faces_curr = unwrapmod.getselectedfaces()
					sel_face = (filterstring dirs_select[val] " ")[(filterstring dirs_select[val] " ").count] as integer
					unwrapmod.selectFaces #{sel_face}
					unwrapmod.setPolygonMode true
					unwrapmod.polygonSelect() 
					max zoomext sel all
					max zoomext sel all
				)
			)
			
			on btnFilterAll pressed do
			(
				dirs_select = #()
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					faces = unwrapmod.getselectedfaces()
					edt.text = faces.count as string
					if faces.count > 0 then
					(
						--print faces
						for f in faces do
						(
							unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
							texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
							--print texelDensity
							append dirs_select (texelDensity as string + "  " + unwrapmod.getSelectMatID() as string + "  " + mAreaGeom as string + "  " + mAreaUVW as string + "  " + f as string)
						)
					)
					mlbList.items = dirs_select as array
				)				
			)
			
			on btnFilterBad pressed do
			(
				dirs_select = #()
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					faces = unwrapmod.getselectedfaces()
					edt.text = faces.count as string	
					if faces.count > 0 then
					(
						--print faces
						for f in faces do
						(
							unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
							texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
							--print texelDensity
							if texelDensity <= 512 or texelDensity >= 1706 then append dirs_select (texelDensity as string + "  " + unwrapmod.getSelectMatID() as string + "  " + mAreaGeom as string + "  " + mAreaUVW as string + "  " + f as string)
						)
					)
					mlbList.items = dirs_select as array
				)				
			)
			
			on btnFilterZero pressed do
			(
				dirs_select = #()
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					faces = unwrapmod.getselectedfaces()
					edt.text = faces.count as string	
					if faces.count > 0 then
					(
						--print faces
						for f in faces do
						(
							unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
							texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
							--print texelDensity
							if texelDensity <= 0.01 then append dirs_select (texelDensity as string + "  " + unwrapmod.getSelectMatID() as string + "  " + mAreaGeom as string + "  " + mAreaUVW as string + "  " + f as string)
						)
					)
					mlbList.items = dirs_select as array
				)				
			)
			
			on btnFilterTen pressed do
			(
				dirs_select = #()
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					faces = unwrapmod.getselectedfaces()
					edt.text = faces.count as string	
					if faces.count > 0 then
					(
						--print faces
						for f in faces do
						(
							unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
							texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
							--print texelDensity
							if texelDensity < 10 then append dirs_select (texelDensity as string + "  " + unwrapmod.getSelectMatID() as string + "  " + mAreaGeom as string + "  " + mAreaUVW as string + "  " + f as string)
						)
					)
					mlbList.items = dirs_select as array
				)				
			)
			
			on btnFilterForty pressed do
			(
				dirs_select = #()
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					faces = unwrapmod.getselectedfaces()
					edt.text = faces.count as string	
					if faces.count > 0 then
					(
						--print faces
						for f in faces do
						(
							unwrapmod.getarea #{f} &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
							texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
							--print texelDensity
							if texelDensity >= 40 then append dirs_select (texelDensity as string + "  " + unwrapmod.getSelectMatID() as string + "  " + mAreaGeom as string + "  " + mAreaUVW as string + "  " + f as string)
						)
					)
					mlbList.items = dirs_select as array
				)				
			)			
			
			on btnExport pressed do
			(
				theMapSize = 2048
				if modpanel.getcurrentobject() != undefined and classof (modpanel.getcurrentobject()) == Unwrap_UVW then
				(
					print (((GetTexelDensity theMapSize)/(GetMetersFromGU())) as string)		
				)
				else messagebox "Please select an object with Unwrap UVW modifier applied to it."
				
				unwrapmod = modpanel.getcurrentobject()
				if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
				(
					sel_faces = #{}
					for val in mlbList.selection do append sel_faces (((filterstring dirs_select[val] " ")[(filterstring dirs_select[val] " ").count]) as integer)
					unwrapmod.selectFaces sel_faces
					unwrapmod.setPolygonMode true
					unwrapmod.polygonSelect() 
					max zoomext sel all
					max zoomext sel all
				)
			)

			on btnClose pressed do
			(
				try(destroyDialog ::rocount_texel)catch()
			)
		) --rollout
		createDialog rocount_texel style:#(#style_sunkenedge,#style_titlebar,#style_sysmenu,#style_minimizebox,#style_maximizebox)		
	)
	
	on btn_count_colors pressed do 
	(
		global dirs_select = #()
		global item_select = #()
		global dirs = #()
		global Selected_dir_Path = edt_multimat_path.text

		try(destroyDialog ::rocount_colors)catch()
		rollout rocount_colors "Counts colors of textures" width:1000 --height:1000
		(
			
			fn autoResizeColumn lv columns: = 
			(
				vScrollWidth = 21 -- vertical scrollbar width
				for c = 0 to columns-1 do
				(
					lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
					vScrollWidth += lv.Columns.Item[c].Width
				) 
				vScrollWidth
			)

			fn PopulateList lv dirs_select =
			(
				lv.Items.Clear()
				lv.view = (dotNetClass "system.windows.forms.view").details --lv.view = (dotNetClass "View").details
				lv.HideSelection = true 
				--lv.height = 390
				lv.FullRowSelect = true    
				lv.MultiSelect = true    
				lv.AllowColumnReorder = true
				lv.GridLines = true
				lv.checkBoxes = false 
				lv.Scrollable = true
				lv.ShowItemToolTips = true
				columnsAr = #("Colors Count", "Size", "Main Colors", "Filename")
				lv.columns.Clear()
				for i = 1 to 4 do lv.columns.add columnsAr[i] 0	
				lv.width = autoResizeColumn lv columns:4
				lv.width = 950
				
				rows = #()
				for t = 1 to dirs_select.count do
				(
					li = dotNetObject "System.Windows.Forms.ListViewItem" (dirs_select[t][1])
					li.UseItemStyleForSubItems = true
					li.subitems.add dirs_select[t][2]
					li.subitems.add dirs_select[t][3]
					li.subitems.add dirs_select[t][4]
					append rows li
				)
				lv.items.addRange rows
				lv.width = autoResizeColumn lv columns:4
				lv.width = 950
				lv.Update()
			)
			
			fn init =
			(
				dirs_select = #()
				dirs = #()
				local start = GetINI_ImageMagick()
				if Selected_dir_Path != undefined then dirs = getfiles (Selected_dir_Path + "*.png")
				if dirs.count != 0 then 
				for i in dirs do 
				(
					local str = ""
					local str_size = ""
					local str_colors = ""	
					local colors_counter = 0.0
					--local colors_arr = #()
				
					/*
					local ii = i + ".jpg"
					
					--HiddenDOSCommand ("magick " + "\"" + i + "\"" + " -unique-colors " + "\"" + ii + "\"") startpath:start
					HiddenDOSCommand ("magick " + "\"" + i + "\"" + " -colors 32 -unique-colors " + "\"" + ii + "\"") startpath:start
					--HiddenDOSCommand ("magick " + "\"" + i + "\"" + " -separate -threshold 50%% -combine -colors 32 -unique-colors " + "\"" + ii + "\"") startpath:start

					local bt = openbitmap ii
					if bt != undefined then
					(
						colors_counter = bt.width
						str = bt.width as string
						colors_arr = getPixels bt [0,0] bt.width linear:true
						--colors_arr_str = for col in colors_arr collect (substitutestring (col as string) "color " "")
						close bt
						free bt
					)
					else
					(
						str = "0"
						colors_counter = 0
					)
					--if doesFileExist ii then deleteFile ii
					local bt = openbitmap i
					if bt != undefined then
					(
						str_size = bt.width as string + "x" + bt.height as string
						if bt.height == 256 and bt.width == 256 then
						(
							
							for col in colors_arr do str_colors += (substitutestring (col as string) "color " "") + " = " + ((ceil ((100.0 * colors_counter) / (bt.height * bt.width)) ) as integer) as string + "%; "
						)
						else
						(
							
						)
						close bt
						free bt
						append dirs_select #(str, str_size, str_colors, (substitutestring i Selected_dir_Path ""))
					)
					else append dirs_select #("open error", " ", " ", (substitutestring i Selected_dir_Path ""))
					*/
					
					
					--/*					
					local bt = openbitmap i

					if bt != undefined then
					(
						bt.gamma = 1.0
						local colors_quantity = #()
						local colors = #()
						if bt.height <= 256 or bt.width <= 256 then 
						(
							for line_num in #{1..bt.height} do
							(
								local line_bitmap = getPixels bt [0,line_num] bt.width linear:true
								for pixel in line_bitmap do appendifunique colors pixel --for pixel in #{1..line_bitmap.count} do appendifunique colors line_bitmap[pixel]
							)
							
							for color_selected in colors where colors.count <= 5 and bt.height <= 256 and bt.width <= 256 do --and colors.count > 1
							(
								colors_counter = 0.0
								for line_num in #{1..bt.height} do
								(
									local line_bitmap = getPixels bt [0, line_num] bt.width linear:true
									for pixel in line_bitmap where color_selected == pixel do colors_counter += 1.0
								)
								local col = substitutestring (color_selected as string) "color " ""
								col = trimright (trimleft col "()") "()"
								col = ((filterstring col " ")[1] as integer) as string + " " + ((filterstring col " ")[2] as integer) as string + " " + ((filterstring col " ")[3] as integer) as string
								append colors_quantity (col + " = " + ((ceil ((100.0 * colors_counter) / (bt.height * bt.width)) ) as integer) as string + "%")
							)
						)
						else
						(
							for line_num in #{1..bt.height} where colors.count <= 19 do
							(
								local line_bitmap = getPixels bt [0,line_num] bt.width linear:true
								for pixel in line_bitmap where colors.count <= 19 do appendifunique colors pixel 
							)
						)
						if colors.count != undefined then 
						(
							case of
							(
								(colors.count == 0): str += "0" as string 
								(colors.count > 0 and colors.count < 20): str += colors.count as string
								(colors.count >= 20): str += "20+" as string 
							)
						)
						else 
						(
							str += "0" as string
						)
						str_size = bt.width as string + "x" + bt.height as string
						
						if colors_quantity.count != undefined then 
						(
							if colors_quantity.count > 0 then 
							(
								if colors_quantity.count == 1 then str_colors += colors_quantity[1] as string
								if colors_quantity.count > 1 then for j in colors_quantity do str_colors += j + "; "
							)
							else
							(
								str_colors += " "
							)
						)
						else
						(
							str_colors += " "
						)
						
						append dirs_select #(str, str_size, str_colors, (substitutestring i Selected_dir_Path ""))
						close bt
						free bt
					)
					else
					(
						append dirs_select #("open error", " ", " ", (substitutestring i Selected_dir_Path ""))
					)
					--*/
				)
			)

			dotNetControl lv "ListView" pos:[5,5] width:950 height:600
			progressBar pb13 "ProgressBar" width:950 height:10
			button btnExport "Write one most popular colors to selected textures..." across:3 tooltip:"???????? ????? ?????????????????? ????? ? ????????? ???????? | Write one most popular colors to selected textures"
			button btnOpenPath "Open Folder" tooltip:"??????? ????? | Open Folder"
			button btnClose "Close List" tooltip:"??????? ?????? | Close List"

			on rocount_colors open do
			(  
				init()
				PopulateList lv dirs_select 
			)
			
			on lv MouseDown arg do
			(
				if arg.button == arg.button.middle then
				(                
					if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
					(
					)                
				)
				if arg.button == arg.button.right then
				(                
					if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
					(
						val = hitNode.index + 1
						--bm = openbitmap (Selected_dir_Path + dirs_select[val][4])
						--bm.gamma = 1.0
						--display bm
						try (display (openbitmap (Selected_dir_Path + dirs_select[val][4])))catch()
					)                
				)
			)
			
			on btnOpenPath pressed do
			(	
				HiddenDOSCommand ("explorer.exe /e,/select, " + "\"" + Selected_dir_Path + "\"")
			)
			
			on btnExport pressed do
			(
				myfiles = #()
				item_select = for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected collect dirs_select[val+1]
				print item_select
				--print dirs_select
				btnExport.visible = false
				if item_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in item_select do
					(
						--print item
						--item[1] colors quantity
						--item[2] size
						--item[3] colors
						--item[4] filename
						
						filename = Selected_dir_Path + item[4] 
					
						if item[3] != undefined and item[3] != " " and (item[1] as integer) > 0 and item[1] != undefined and item[1] != " " then
						(
							colors_string = ""
							if item[1] as integer > 1 then
							(
								colors_string = (filterstring ((filterstring item[3] ";")[1]) "=")[1]
							)
							else -- == 1
							(
								colors_string = (filterstring item[3] "=")[1]
							)							
							print colors_string	
							color_to_write = color ((filterstring colors_string " ")[1] as integer) ((filterstring colors_string " ")[2] as integer) ((filterstring colors_string " ")[3] as integer)
							print color_to_write
							bm = openbitmap filename
							bm_new = bitmap bm.width bm.height color:color_to_write filename:filename gamma:1.0 hdr:false --??????????, ??????? ?? 24??? ???? ??? ???, ????? ???? ?????????? ? ?? ?? ????
							close bm 
							free bm
							save bm_new gamma:1.0 quiet:true
							close bm_new
							HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
							free bm_new
						)
						else messagebox ("File do not changed:\n" + item[4])
						pb13.value = 100 * ind / dirs_select.count
						ind += 1
					)
					pb13.value = 100
					
					init()
					PopulateList lv dirs_select 		
				)
				btnExport.visible = true
			) --btnExport
			
			on btnClose pressed do
			(
				try(destroyDialog ::rocount_colors)catch()
			)
		) --rollout
		createDialog rocount_colors style:#(#style_sunkenedge,#style_titlebar,#style_sysmenu,#style_minimizebox,#style_maximizebox)
	)
	
	on btn_count_colors rightclick do --????? ???????? ?? ???????????
	(
		global dirs_select = #()
		global item_select = #()
		global dirs = #()
		
		global Selected_dir_Path = edt_multimat_path.text
		if Selected_dir_Path != undefined then dirs = getfiles (Selected_dir_Path + "*.png")
		if dirs.count != 0 then 
		--kk=1
		for i in dirs do --where kk <= 20 do 
		(
			--kk+=1
			str = ""
			bt = openbitmap i
			if bt != undefined then
			(
				bt.gamma = 1.0
				colors_quantity = #()
				colors = #()
				if bt.height <= 256 or bt.width <= 256 then 
				(
					for line_num in #{1..bt.height} do
					(
						line_bitmap = getPixels bt [0,line_num] bt.width linear:true
						for pixel in line_bitmap do appendifunique colors pixel --for pixel in #{1..line_bitmap.count} do appendifunique colors line_bitmap[pixel]
					)
					
					for color_selected in colors where colors.count <= 5 and bt.height <= 256 and bt.width <= 256 do --and colors.count > 1
					(
						colors_counter = 0.0
						for line_num in #{1..bt.height} do
						(
							line_bitmap = getPixels bt [0,line_num] bt.width linear:true
							for pixel in line_bitmap where color_selected == pixel do colors_counter += 1.0
						)
						col = substitutestring (color_selected as string) "color " ""
						col = trimright (trimleft col "()") "()"
						col = ((filterstring col " ")[1] as integer) as string + " " + ((filterstring col " ")[2] as integer) as string + " " + ((filterstring col " ")[3] as integer) as string
						append colors_quantity (col + "=" + ((ceil ((100.0 * colors_counter) / (bt.height * bt.width)) ) as integer) as string)
					)
				)
				else
				(
					for line_num in #{1..bt.height} where colors.count <= 19 do
					(
						line_bitmap = getPixels bt [0,line_num] bt.width linear:true
						for pixel in line_bitmap where colors.count <= 19 do appendifunique colors pixel 
					)
					print colors.count
				)
				if colors.count != undefined then 
				(
					case of
					(
						(colors.count == 0): str += "0" as string + "   "
						(colors.count > 0 and colors.count < 20): str += colors.count as string + "   "
						(colors.count >= 20):str += "20+" as string + "   "
					)
					--if colors.count > 0 and colors.count <= 20 then str += colors.count as string + "   " else str += "20+" as string + "   "
				)
				else 
				(
					str += "0" as string + "   "
				)
				str += bt.width as string + "x" + bt.height as string + "   "
				if bt.width < 1000 then str += "  "
				if bt.height < 1000 then str += "  "
				str += "|" + substitutestring i Selected_dir_Path "" + "|"
				
				if colors_quantity.count != undefined then 
				(
					if colors_quantity.count > 0 then 
						for j in colors_quantity do str += j + "; "
					else str += "0" + "; "
				)
				else
				(
					str += "0" + "; "
				)
				print str
				append dirs_select str
				close bt
				free bt
			)
		)
		try(destroyDialog ::rocount_colors)catch()
		rollout rocount_colors "Counts colors of textures" width:1000 --height:1000
		(
			progressBar pb13 "ProgressBar" width:950 height:10
			MultiListBox mlbList "List of textures:" items:(dirs_select as array) width:950 height:40 selection:#()
			button btnExport "Write one most popular colors to selected textures..." across:3
			button btnOpenPath "Open one selected path"
			button btnClose "Close List"
			
			on mlbList rightClick val do 
			(
				--try (mlbList.width = ((dirs_select[val]).count)*10)catch()
				bm = openbitmap (Selected_dir_Path + (filterstring dirs_select[val] "|")[2])
				bm.gamma = 1.0
				display bm
			)
			
			on btnOpenPath pressed do
			(	
				--??????? ???? ?????????? ????????
			)
			
			on btnExport pressed do
			(
				myfiles = #()
				item_select = for i = 1 to (mlbList.selection as array).count collect ( (dirs_select[(mlbList.selection as array)[i]]) as string)
				print item_select
				--print dirs_select
				btnExport.visible = false
				if item_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in item_select do --and ind < 5 do 
					(
						print item
						filename = (Selected_dir_Path + (filterstring item "|")[3]) 

						if (filterstring item "|")[4] != undefined and ((filterstring item "|")[4] as integer) > 0 (filterstring item "|")[1] != undefined and ((filterstring item "|")[1] as integer) > 0 then
						(
							--print (filterstring item "|")[1]
							if (filterstring ((filterstring item "|")[1]) " ")[1] as integer > 1 then
							(
								colors_string = (filterstring ((filterstring ((filterstring item "|")[4]) ";")[1]) "=")[1]
								print colors_string	
							)
							color_to_wtite = color ((filterstring colors_string " ")[1] as integer) ((filterstring colors_string " ")[2] as integer) ((filterstring colors_string " ")[3] as integer)
							print color_to_wtite
							bm = openbitmap filename
							bm_new = bitmap bm.width bm.height color:color_to_wtite filename:filename gamma:1.0 hdr:false --??????????, ??????? ?? 24??? ???? ??? ???, ????? ???? ?????????? ? ?? ?? ????
							close bm 
							free bm
							save bm_new gamma:1.0 quiet:true
							close bm_new
							free bm_new
						)
						else print "file not edited"
						pb13.value = 100*ind/dirs_select.count
						ind += 1
					)
					pb13.value = 100
					
					
					for item = 1 to item_select.count do
					(
						print ((mlbList.items)[(mlbList.selection as array)[item]])
						filename = (Selected_dir_Path + (filterstring item_select[item] "|")[2]) 
						str = ""
						bt = openbitmap filename
						bt.gamma = 1.0
						colors = #()
						colors_quantity = #()
						if bt != undefined then
						(
							if bt.height <= 256 or bt.width <= 256 then 
							(
								for line_num in #{1..bt.height} do
								(
									line_bitmap = getPixels bt [0,line_num] bt.width linear:true
									for pixel in line_bitmap do appendifunique colors pixel 
								)
								for color_selected in colors where colors.count <= 5 and bt.height <= 256 and bt.width <= 256 do --and colors.count > 1
								(
									colors_counter = 0.0
									for line_num in #{1..bt.height} do
									(
										line_bitmap = getPixels bt [0,line_num] bt.width linear:true
										for pixel in line_bitmap where color_selected == pixel do colors_counter += 1.0
									)
									col = substitutestring (color_selected as string) "color " ""
									col = trimright (trimleft col "()") "()"
									col = ((filterstring col " ")[1] as integer) as string + " " + ((filterstring col " ")[2] as integer) as string + " " + ((filterstring col " ")[3] as integer) as string
									append colors_quantity (col + "=" + ((ceil ((100.0 * colors_counter) / (bt.height * bt.width)) ) as integer) as string)
								)
							)
						)
						if colors.count != undefined then 
						(
							case of
							(
								(colors.count == 0): str += "0" as string + "   "
								(colors.count > 0 and colors.count < 20): str += colors.count as string + "   "
								(colors.count >= 20):str += "20+" as string + "   "
							)
							--if colors.count > 0 then str += colors.count as string + "   " else str += "0" as string + "   "
						)
						else 
						(
							str += "0" as string + "   "
						)
						str += bt.width as string + "x" + bt.height as string + "   "
						if bt.width < 1000 then str += "  "
						if bt.height < 1000 then str += "  "
						str += "|" + substitutestring item_select[item] Selected_dir_Path "" + "|"
						if colors_quantity.count != undefined then 
						(
							if colors_quantity.count > 0 then 
								for j in colors_quantity do str += j + "; "
							else str += "0" + "; "
						)
						else
						(
							str += "0" + "; "
						)						
						append dirs_select str
						close bt
						free bt		
					)
				)
				btnExport.visible = true
			) --btnExport
			
			on btnClose pressed do
			(
				try(destroyDialog ::rocount_colors)catch()
			)
		) --rollout
		createDialog rocount_colors style:#(#style_sunkenedge,#style_titlebar,#style_sysmenu,#style_minimizebox,#style_maximizebox)
	)
	
	on btn_alpha_remove pressed do 
	(
		global dirs_select = #()
		global items_select = #()
		global dirs = #()
		global Selected_dir_Path = edt_multimat_path.text
		
		try(destroyDialog ::roalpha_remove)catch()
		rollout roalpha_remove "Remove alpha from textures" width:1000 --height:1000
		(
			fn autoResizeColumn lv columns: = 
			(
				vScrollWidth = 21 -- vertical scrollbar width
				for c = 0 to columns-1 do
				(
					lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
					vScrollWidth += lv.Columns.Item[c].Width
				) 
				vScrollWidth
			)
			
			fn PopulateList lv dirs_select =
			(
				lv.Items.Clear()
				lv.view = (dotNetClass "system.windows.forms.view").details --lv.view = (dotNetClass "View").details
				lv.HideSelection = true 
				--lv.height = 390
				lv.FullRowSelect = true    
				lv.MultiSelect = true    
				lv.AllowColumnReorder = true
				lv.GridLines = true
				lv.checkBoxes = false --true 
				lv.Scrollable = true
				lv.ShowItemToolTips = true
				--for i = 0 to lv.Items.count-1 do lv.Items.Item[i].checked = true
				columnsAr = #("Alpha channel", "Texture size", "Color Depth", "Filename")
				lv.columns.Clear()
				for i = 1 to 4 do lv.columns.add columnsAr[i] 0	
				lv.width = autoResizeColumn lv columns:4
				lv.width = 950
				
				rows = #()
				for t = 1 to dirs_select.count do
				(
					li = dotNetObject "System.Windows.Forms.ListViewItem" (dirs_select[t][1])
					li.UseItemStyleForSubItems = true
					li.subitems.add dirs_select[t][2]
					li.subitems.add dirs_select[t][3]
					li.subitems.add dirs_select[t][4]
					append rows li
				)
				lv.items.addRange rows
				lv.width = autoResizeColumn lv columns:4
				lv.width = 950
				lv.Update()
			)
			
			fn init =
			(	
				dirs_select = #()
				dirs = #()
				if Selected_dir_Path != undefined then dirs = getfiles (Selected_dir_Path + "*.png")
				if dirs.count != 0 then 
				for i in dirs do 
				(
					str = ""
					str_color = ""
					bt = openbitmap i
					if bt != undefined then
					(
						if bt.hasAlpha != undefined then 
						(
							str = if bt.hasAlpha then "alpha" else " "
						)
						else str = "error"
						
						if bt.width != undefined or bt.height != undefined then
						(
							HiddenDOSCommand ("identify " + "\"" + i + "\"" + " > !!.txt") startpath:(GetINI_ImageMagick()) --HiddenDOSCommand ("magick identify -verbose " + "\"" + i + "\"" + " > !.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
							stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!!.txt") ((dotNetClass "System.Text.Encoding").UTF8) --stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!.txt" ((dotNetClass "System.Text.Encoding").UTF8
							if stri != undefined then 
							(
								--print stri
								--for s in stri where (findstring s "-bit" != undefined) do str += (filterstring (substitutestring s i "") " ")[4] 
								--for s in stri where (findstring s "Depth:" != undefined) do str += s
								for s in stri do 
								(
									s = substitutestring s i ""
									sss1 = 4
									sss2 = (filterstring s " ").count - 3
									for ss = sss1 to sss2 do str_color += (filterstring s " ")[ss] + " " --(substitutestring ((filterstring s " ")[ss]) i "") + " "
								)
							)
							append dirs_select #(str,(bt.width as string + "x" + bt.height as string), str_color, (substitutestring i Selected_dir_Path ""))
						)
						close bt
					)
					else 
					(
						append dirs_select #("open error"," ", " ", (substitutestring i Selected_dir_Path ""))
					)
					free bt
				)
				--dirs_select
			)
				
			dotNetControl lv "ListView" pos:[5,5] width:950 height:600
			progressBar pb13 "ProgressBar" width:950 height:10
			button btnRemove "Remove alpha channel" across:6 tooltip:"??????? ?????-????? | Remove alpha channel"
			button btnBit "Make 8bit Depth and sRGB color" tooltip:"??????????????? ? 8-??? ? ? sRGB ???? | Make 8bit Depth and sRGB color" 
			button btn_resize_2048 "Resize to" tooltip:"????????????? | Resize to"
			dropdownlist ddl_resize "" items: #("256","512","1024","2048","4096") selection:4 width:100 fieldWidth:100
			button btnOpenFolder "Open Folder" tooltip:"??????? ????? | Open Folder"
			button btnClose "Close List" tooltip:"??????? ?????? | Close List"
			
			on roalpha_remove open do
			(
				init()
				PopulateList lv dirs_select 
			)
			
			on lv MouseDown arg do
			(
				if arg.button == arg.button.middle then
				(                
					if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
					(
					)                
				)
				if arg.button == arg.button.right then
				(               
					if (hitNode = lv.GetItemAt arg.x arg.y) != undefined do
					(
						val = hitNode.index + 1
						try (display (openbitmap (Selected_dir_Path + dirs_select[val][4])))catch()
						--HWND = for i in (UIAccessor.GetChildWindows (DialogMonitorOPS.GetWindowHandle())) where findstring (UIAccessor.GetWindowText i) (Selected_dir_Path + dirs_select[val][4]) != undefined do exit with i
						--print HWND
						--UIAccessor.CloseDialog HWND
						--windows.SendMessage HWND 0x0201 1 0
						--UIAccessor.SendMessage HWND[1] 0x0201 1 0
						--UIAccessor.SendMessage HWND[1] 0x0202 0 0
						--UIAccessor.SendMessage HWND 0xF5 1 0
					)                
				)
			)

			on btn_resize_2048 pressed do
			(
				btn_resize_2048.visible = false
				myfiles = #()
				items_select = for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected collect Selected_dir_Path + dirs_select[val+1][4]
				print #(items_select)
				if items_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in items_select do
					(
						print item
						if doesfileexist item then 
							case ddl_resize.selection of 
							(
								1: HiddenDOSCommand ("magick " + "\"" + item + "\"" + " -resize 256x256^ -define png:color-type=6 " + "\""+ item + "\"") startpath:(GetINI_ImageMagick())
								2: HiddenDOSCommand ("magick " + "\"" + item + "\"" + " -resize 512x512^ -define png:color-type=6 " + "\""+ item + "\"") startpath:(GetINI_ImageMagick())
								3: HiddenDOSCommand ("magick " + "\"" + item + "\"" + " -resize 1024x1024^ -define png:color-type=6 " + "\""+ item + "\"") startpath:(GetINI_ImageMagick())
								4: HiddenDOSCommand ("magick " + "\"" + item + "\"" + " -resize 2048x2048^ -define png:color-type=6 " + "\""+ item + "\"") startpath:(GetINI_ImageMagick())
								5: HiddenDOSCommand ("magick " + "\"" + item + "\"" + " -resize 4096x4096^ -define png:color-type=6 " + "\""+ item + "\"") startpath:(GetINI_ImageMagick())
							)
						--HiddenDOSCommand ("convert " + "\"" + filename + "\""+ " -alpha remove -alpha off " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						HiddenDOSCommand ("magick " + "\"" + item + "\""+ " PNG24:" + "\""+ item + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100 * ind / dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				--??????????????? ??????
				init()
				PopulateList lv dirs_select 
				btn_resize_2048.visible = true
			)
			
			on btnOpenFolder pressed do 
			(
				HiddenDOSCommand ("explorer.exe /e,/select, " + "\"" + Selected_dir_Path + "\"")
			)			
			
			on btnRemove pressed do --??????? ?????????? ?? ????????? ???????
			(
				myfiles = #()
				items_select = for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected collect Selected_dir_Path + dirs_select[val+1][4]
				print items_select
				btnRemove.visible = false
				if items_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in items_select do
					(
						print item
						--convert -alpha remove -alpha off 
						HiddenDOSCommand ("magick " + "\"" + item + "\""+ " -alpha remove -alpha off " + "\"" + item + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						HiddenDOSCommand ("magick " + "\"" + item + "\""+ " PNG24:" + "\""+ item + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100 * ind / dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				--??????????????? ??????
				init()
				PopulateList lv dirs_select 
				btnRemove.visible = true
			) --btnRemove

			on btnBit pressed do
			(
				myfiles = #()
				items_select = for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected collect Selected_dir_Path + dirs_select[val+1][4]
				print items_select
				btnBit.visible = false
				if items_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in items_select do
					(
						print item
							--HiddenDOSCommand ("convert " + "\"" + filename + "\""+ " -colorspace rgb -type truecolor -depth 8 -define png:include-chunk=none -define png:exclude-chunk=bkgd -define colorspace:auto-grayscale=off -verbose PNG24:" + "\""+ filename + "\"") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						HiddenDOSCommand ("magick " + "\"" + item + "\""+ " PNG24:" + "\""+ item + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100 * ind / dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				--??????????????? ??????
				init()	
				PopulateList lv dirs_select 
				btnBit.visible = true
			) --btnBit

			on btnClose pressed do
			(
				try(destroyDialog ::roalpha_remove)catch()
			)
		)
		createDialog roalpha_remove width:1000 height:650 style:#(#style_titlebar, #style_border, #style_sysmenu, #style_resizing)	
	)
	
	on btn_alpha_remove rightclick do 
	(
		global dirs_select = #()
		global item_select = #()
		global dirs = #()
		
		global Selected_dir_Path = edt_multimat_path.text
		if Selected_dir_Path != undefined then dirs = getfiles (Selected_dir_Path + "*.png")
		if dirs.count != 0 then 
		for i in dirs do 
		(
			str = ""
			bt = openbitmap i
			if bt != undefined then
			(
				if bt.hasAlpha != undefined then str += bt.hasAlpha as string + "   " else str += "error" + "   "
				if bt.hasAlpha != undefined then if bt.hasAlpha then str += " "
				if bt.width != undefined or bt.height != undefined then
				(
					str += bt.width as string + "x" + bt.height as string + "   "
					if bt.width < 1000 then str += "  "
					if bt.height < 1000 then str += "  "
					HiddenDOSCommand ("identify " + "\"" + i + "\"" + " > !!.txt") startpath:(GetINI_ImageMagick()) --HiddenDOSCommand ("magick identify -verbose " + "\"" + i + "\"" + " > !.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
					stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!!.txt") ((dotNetClass "System.Text.Encoding").UTF8) --stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!.txt" ((dotNetClass "System.Text.Encoding").UTF8
					str += "|" 
					if stri != undefined then 
					(
						--for s in stri where (findstring s "-bit" != undefined) do str += (filterstring (substitutestring s i "") " ")[4] 
						--for s in stri where (findstring s "Depth:" != undefined) do str += s
						for s in stri do for ss = 1 to (filterstring s " ").count where ss > 4 and ss < ((filterstring s " ").count) - 2 do str += (substitutestring ((filterstring s " ")[ss]) i "") + " "
					)
					str += "|" + substitutestring i Selected_dir_Path ""
					append dirs_select str
				)
				close bt
			)
			else 
			(
				str += "open error" + "| |" + substitutestring i Selected_dir_Path ""
				append dirs_select str
			)
			free bt
		)
		try(destroyDialog ::roalpha_remove)catch()
		rollout roalpha_remove "Remove alpha from textures" width:1000 --height:1000
		(
			progressBar pb13 "ProgressBar" width:950 height:10
			MultiListBox mlbList "List of textures:" items:(dirs_select as array) width:950 height:40 selection:#()
			button btnRemove "Remove alpha channel" across:6
			button btnBit "Make 8bit Depth and RGB color" 
			--button btnBitOne "Make 1bit Depth from selected textures..." 
			button btn_resize_2048 "Resize to"
			dropdownlist ddl_resize "" items: #("256","512","1024","2048","4096")
			button btnOpenFolder "Open Folder"
			button btnClose "Close List"
			
			on mlbList rightClick val do 
			(
				try (mlbList.width = ((dirs_select[val]).count)*10)catch()
				try (display (openbitmap (Selected_dir_Path + (filterstring dirs_select[val] "|")[3]) ) )catch()
			)
			
			on btn_resize_2048 pressed do
			(
				
				myfiles = #()
				item_select = for i = 1 to (mlbList.selection as array).count collect (Selected_dir_Path + (dirs_select[(mlbList.selection as array)[i]]) as string)
				print item_select
				if item_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in item_select do --and ind < 5 do 
					(
						print item
						filename = (Selected_dir_Path + (filterstring item "|")[3]) 
						print filename
						if doesfileexist filename then 
						case ddl_resize.selection of 
						(
							1: HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -resize 256x256^ -define png:color-type=6 " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
							2: HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -resize 512x512^ -define png:color-type=6 " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
							3: HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -resize 1024x1024^ -define png:color-type=6 " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
							4: HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -resize 2048x2048^ -define png:color-type=6 " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
							5: HiddenDOSCommand ("magick " + "\"" + filename + "\"" + " -resize 4096x4096^ -define png:color-type=6 " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
						)
						--HiddenDOSCommand ("convert " + "\"" + filename + "\""+ " -alpha remove -alpha off " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100*ind/dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				dirs_select = #()
				for i in dirs do 
				(
					str = ""
					bt = openbitmap i
					str += bt.hasAlpha as string + "   "
					if bt.hasAlpha then str += " "
					str += bt.width as string + "x" + bt.height as string + "   "
					if bt.width < 1000 then str += "  "
					if bt.height < 1000 then str += "  "
					HiddenDOSCommand ("identify " + "\"" + i + "\"" + " > !!.txt") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\") --HiddenDOSCommand ("magick identify -verbose " + "\"" + i + "\"" + " > !.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
					--stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!!.txt" ((dotNetClass "System.Text.Encoding").UTF8) 
					--stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!.txt" ((dotNetClass "System.Text.Encoding").UTF8)
					stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!!.txt") ((dotNetClass "System.Text.Encoding").UTF8)
					str += "|" 
					--for s in stri where (findstring s "-bit" != undefined) do str += (filterstring (substitutestring s i "") " ")[4] 
					--for s in stri where (findstring s "Depth:" != undefined) do str += s
					for s in stri do for ss = 1 to (filterstring s " ").count where ss > 4 and ss < ((filterstring s " ").count) - 2 do str += (substitutestring ((filterstring s " ")[ss]) i "") + " "
					str += "|" + substitutestring i Selected_dir_Path ""
					append dirs_select str
					close bt
					free bt
				)
				mlbList.items = (dirs_select as array) 
			)
			
			on btnOpenFolder pressed do 
			(
				HiddenDOSCommand ("explorer.exe /e,/select, " + "\"" + Selected_dir_Path + "\"")
			)			
			
			on btnRemove pressed do
			(
				myfiles = #()
				item_select = for i = 1 to (mlbList.selection as array).count collect (Selected_dir_Path + (dirs_select[(mlbList.selection as array)[i]]) as string)
				print item_select
				--print dirs_select
				btnRemove.visible = false
				if item_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in item_select do --and ind < 5 do 
					(
						print item
						filename = (Selected_dir_Path + (filterstring item "|")[3]) 
						--convert -alpha remove -alpha off 
						HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " -alpha remove -alpha off " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100*ind/dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				dirs_select = #()
				for i in dirs do 
				(
					str = ""
					bt = openbitmap i
					str += bt.hasAlpha as string + "   "
					if bt.hasAlpha then str += " "
					str += bt.width as string + "x" + bt.height as string + "   "
					if bt.width < 1000 then str += "  "
					if bt.height < 1000 then str += "  "
					HiddenDOSCommand ("identify " + "\"" + i + "\"" + " > !!.txt") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\") --HiddenDOSCommand ("magick identify -verbose " + "\"" + i + "\"" + " > !.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
					stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!!.txt") ((dotNetClass "System.Text.Encoding").UTF8) 
					--stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!!.txt" ((dotNetClass "System.Text.Encoding").UTF8) 
					--stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!.txt" ((dotNetClass "System.Text.Encoding").UTF8)
					str += "|" 
					--for s in stri where (findstring s "-bit" != undefined) do str += (filterstring (substitutestring s i "") " ")[4] 
					--for s in stri where (findstring s "Depth:" != undefined) do str += s
					for s in stri do for ss = 1 to (filterstring s " ").count where ss > 4 and ss < ((filterstring s " ").count) - 2 do str += (substitutestring ((filterstring s " ")[ss]) i "") + " "
					str += "|" + substitutestring i Selected_dir_Path ""
					append dirs_select str
					close bt
					free bt
				)
				mlbList.items = (dirs_select as array) 
				btnRemove.visible = true
			) --btnRemove

			on btnBit pressed do
			(
				myfiles = #()
				item_select = for i = 1 to (mlbList.selection as array).count collect (Selected_dir_Path + (dirs_select[(mlbList.selection as array)[i]]) as string)
				print item_select
				--print dirs_select
				btnBit.visible = false
				if item_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in item_select do --and ind < 5 do 
					(
						print item
						filename = (Selected_dir_Path + (filterstring item "|")[3]) 
						--HiddenDOSCommand ("convert " + "\"" + filename + "\""+ " -colorspace rgb -type truecolor -depth 8 -define png:include-chunk=none -define png:exclude-chunk=bkgd -define colorspace:auto-grayscale=off -verbose PNG24:" + "\""+ filename + "\"") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100*ind/dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				dirs_select = #()
				for i in dirs do 
				(
					str = ""
					bt = openbitmap i
					str += bt.hasAlpha as string + "   "
					if bt.hasAlpha then str += " "
					str += bt.width as string + "x" + bt.height as string + "   "
					if bt.width < 1000 then str += "  "
					if bt.height < 1000 then str += "  "
					HiddenDOSCommand ("identify " + "\"" + i + "\"" + " > !!.txt") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\") --HiddenDOSCommand ("magick identify -verbose " + "\"" + i + "\"" + " > !.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
					stri = (dotNetClass "System.IO.File").ReadAllLines (GetINI_ImageMagick() + "!!.txt") ((dotNetClass "System.Text.Encoding").UTF8)					
					--stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!!.txt" ((dotNetClass "System.Text.Encoding").UTF8) 
					--stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!.txt" ((dotNetClass "System.Text.Encoding").UTF8)
					str += "|" 
					--for s in stri where (findstring s "-bit" != undefined) do str += (filterstring (substitutestring s i "") " ")[4] 
					--for s in stri where (findstring s "Depth:" != undefined) do str += s
					for s in stri do for ss = 1 to (filterstring s " ").count where ss > 4 and ss < ((filterstring s " ").count) - 2 do str += (substitutestring ((filterstring s " ")[ss]) i "") + " "
					str += "|" + substitutestring i Selected_dir_Path ""
					append dirs_select str
					close bt
					free bt
				)
				mlbList.items = (dirs_select as array) 
				btnBit.visible = true
			) --btnBit
/*
			on btnBitOne pressed do
			(
				myfiles = #()
				item_select = for i = 1 to (mlbList.selection as array).count collect (Selected_dir_Path + (dirs_select[(mlbList.selection as array)[i]]) as string)
				print item_select
				--print dirs_select
				btnBitOne.visible = false
				if item_select.count > 0 then 
				(
					ind = 1
					pb13.value = 0
					for item in item_select do --and ind < 5 do 
					(
						print item
						filename = (Selected_dir_Path + (filterstring item "|")[3]) 
						--HiddenDOSCommand ("convert " + "\"" + filename + "\""+ " -flatten -type palette -depth 1 -colors 1 -define png:include-chunk=none -define png:exclude-chunk=bkgd -verbose " + "\""+ filename + "\"") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						HiddenDOSCommand ("convert " + "\"" + filename + "\""+ " -type palette -define png:include-chunk=none -define png:exclude-chunk=bkgd -verbose " + "\""+ filename + "\"") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
						pb13.value = 100*ind/dirs_select.count
						ind += 1
					)
					pb13.value = 100
				)
				
				dirs_select = #()
				for i in dirs do 
				(
					str = ""
					bt = openbitmap i
					str += bt.hasAlpha as string + "   "
					if bt.hasAlpha then str += " "
					str += bt.width as string + "x" + bt.height as string + "   "
					if bt.width < 1000 then str += "  "
					if bt.height < 1000 then str += "  "
					HiddenDOSCommand ("magick identify " + "\"" + i + "\"" + " > !!.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\") --HiddenDOSCommand ("magick identify -verbose " + "\"" + i + "\"" + " > !.txt") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
					stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!!.txt" ((dotNetClass "System.Text.Encoding").UTF8) --stri = (dotNetClass "System.IO.File").ReadAllLines "C:\\Program Files\\ImageMagick-7.1.1-Q16\\!.txt" ((dotNetClass "System.Text.Encoding").UTF8)
					str += "|" 
					for s in stri where (findstring s "-bit" != undefined) do str += (filterstring (substitutestring s i "") " ")[4] --for s in stri where (findstring s "Depth:" != undefined) do str += s
					str += "|" + substitutestring i Selected_dir_Path ""
					append dirs_select str
					close bt
					free bt
				)
				mlbList.items = (dirs_select as array) 
				btnBitOne.visible = true
			) --btnBitOne
*/			
			on btnClose pressed do
			(
				try(destroyDialog ::roalpha_remove)catch()
			)
		) --rollout
		createDialog roalpha_remove style:#(#style_sunkenedge,#style_titlebar,#style_sysmenu,#style_minimizebox,#style_maximizebox)
	)	

	on btn_get_multimat_path pressed do
	(
		case rdo_path.state of
		(
			1: edt_multimat_path.text = maxFilePath + "Maps\\"
			2: edt_multimat_path.text = maxFilePath + "Images\\"
			3: edt_multimat_path.text = maxFilePath + edt_path_end.text
		)
	)
	
	on btn_get_multimat_folder pressed do
	(
		try
		(
			edt_multimat_path.text = getSavePath caption:"Select Folder ..." initialDir: maxFilePath
			edt_multimat_path.text += "\\"
		)catch()
		lbl_multimat_path.text = "Search mask: ..." + "\\" + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png"
	)	
	
	on btn_open_multimat_path pressed do
	(
		HiddenDOSCommand ("explorer.exe /e,/select,\"" + edt_multimat_path.text)
	)
	
	on btn_ids_as_udims pressed do with undo "Set IDs as UDIMs" on with redraw off
	(
		if selection.count == 1 and classof selection[1].baseobject == editable_poly and classof selection[1].modifiers[1] == Unwrap_UVW then 
		(
			ctrl = keyboard.controlPressed
			max modify mode
			q = if selection[1].modifiers.count == 0 then selection[1] else selection[1].modifiers[1]
			q = modpanel.getcurrentobject()
			if q != undefined and classof q == Unwrap_UVW then
			(
				arr = #{1..q.numberPolygons()}
				q.unhide() 
				q.setTVSubObjectMode 3
				qq = #{}
				if ctrl then
				(
					poi = [0,0,0]
					while arr.numberset != 0 do 
					(	
						--print arr.numberset
						if keyboard.escpressed then exit 
						for p in arr do (q.selectFaces #{p}; exit)
						q.faceToVertSelect()
						sel = q.getselectedvertices()
						if sel.count > 0 then
						(
							--poi = (for i in sel collect (q.unwrap.getvertexposition currenttime i))[1]
							for i in sel do (poi = q.unwrap.getvertexposition currenttime i;exit)
							/*					
							poi = [(amax (for i in sel collect (q.unwrap.getvertexposition currenttime i).x) - amin (for i in sel collect (q.unwrap.getvertexposition currenttime i).x))/2, (amax (for i in sel collect (q.unwrap.getvertexposition currenttime i).y) - amin (for i in sel collect (q.unwrap.getvertexposition currenttime i).y))/2,0]
							uvMax = [-99999,-99999,0]
							uvMin = [99999,99999,0]
							for i in #{1..sel.count} do 
							(
								uvPos = q.unwrap.getvertexposition currenttime i
								if uvPos.x > uvMax.x then 
								(
									uvMax.x = uvPos.x
								)
								else 
								(
									if uvPos.x < uvMin.x do
									(
										uvMin.x = uvPos.x
									)
								)
								if uvPos.y > uvMax.y then 
								(
									uvMax.y = uvPos.y
								)
								else 
								(
									if uvPos.y < uvMin.y do 
									(
										uvMin.y = uvPos.y
									)
								)
							)
							q.unwrap2.setTVSubObjectMode 3
							poi = (uvMax+uvMin)/2 

							--poi = q.unwrap.getvertexposition currenttime sel[1]
							*/
							if poi != undefined then 
							(
								id = (poi.x as integer) + 1 + 10 * (poi.y as integer)
								q.selectElement()
								q.setSelectMatID id
								qq = q.getSelectedFaces()
								arr -= qq
							)
						)
					)
				)			
				else 
				while arr.numberset != 0  do 
				(
					--print arr.numberset
					if keyboard.escpressed then exit 
					for p in arr do (q.selectFaces #{p}; exit)
					poi = q.getselcenter() --??????? ??? ? ????? ????????
					if poi != undefined then 
					(
						id = (poi.x as integer) + 1 + 10 * (poi.y as integer)
						q.selectElement()
						q.setSelectMatID id
						qq = q.getSelectedFaces()
						arr -= qq
					)
				)
			)
			gc light:true
		)
		else
		(
			messagebox ("Select single EditablePoly object with single Unwrap_UVW modifier")
		)
	)

	
/*
	on btn_multimat_table pressed do
	(
		f = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png")
		f_norm = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Normal*" + edt_material_mat_number.text + "*.png")	
		f_erm = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*ERM*" + edt_material_mat_number.text + "*.png")	
	
		if f != undefined then edt_multimat_count.text = f.count as string
		num = edt_multimat_count.text as integer
	
		b = for i in f collect (openBitMap i)
		print #(b)
		
		--b1 = openBitMap f[1]
		--b1n = openBitMap f_norm[1]
		--b1e = openBitMap f_erm[1]
		--b2 = openBitMap f[2]
		--d1 = try (meditMaterials[1].originalMaterial.materialList[3].texmapDiffuse)catch(bitmap 50 50 color:black gamma:1.0 hdr:false)
		--d2 = try (meditMaterials[1].originalMaterial.materialList[2])catch(bitmap 50 50 color:black gamma:1.0 hdr:false)
		
		MatEditor.Close()
		str = ""
		append str ("rollout Bitmaps " + "\"" + "Bitmaps" + "\"" + "width:1000\n" + "(\n")
		
		for i = 1 to selection[1].material.materialList.count where selection.count > 0 do
		(
			path_pic = (getMaterialThumbnail (selection[1].material.materialList[i]) ("C:\\temp\\pic" + i as string + ".png")).filename as string
			if i == 1 then append str ("imgtag img_" + i as string + " " + "\"" + "\"" + " " + "bitmap: @" + "\"" + doubleslash path_pic + "\"" + " width:50 height:50 style:#bmp_stretch across:" + (selection[1].material.materialList.count) as string + "\n")
			else append str ("imgtag img_" + i as string + " " + "\"" + "\"" + " " + "bitmap: @" + "\"" + doubleslash path_pic + "\"" + " width:50 height:50 style:#bmp_stretch \n" )
		)
		for i = 1 to b.count do 
		(
			if i/10 != (i/10 as integer) then append str ("dropdownlist material_id" + i as string + " " + "\""  + "ID" + i as string + "\"" + " items: (for i in (selection[1].material.materialIDList) collect i as string) width:40 across:2 selection:" + i as string + " \n" + "imgtag img_tag" + i as string + " " + "\""+"\"" + " " + "bitmap: @" + "\"" + doubleslash (b[i].filename as string) + "\"" + " width:50 height:50 style:#bmp_stretch \n")
			if i/10 == (i/10 as integer) then append str ("dropdownlist material_id" + i as string + " " + "\""  + "ID" + i as string + "\"" + " items: (for i in (selection[1].material.materialIDList) collect i as string) width:40 across:20 selection:" + i as string + " \n" + "imgtag img_tag" + i as string + " " + "\""+"\"" + " " + "bitmap: @" + "\"" + doubleslash (b[i].filename as string) + "\"" + " width:50 height:50 style:#bmp_stretch \n")		
		)
		append str ("button btn_cr " + "\"" + "Create material and object" + "\"" + "\n")
		append str (")\n")
		append str ("createDialog Bitmaps\n")
		
		print str
		execute (str)
		
		--rollout Bitmaps "Bitmaps" 
		--(
			
			--dropdownlist material_id1 "ID1" items: (for i in (meditMaterials[1].originalMaterial.materialIDList) collect i as string) across:2
			--imgtag img_mat1 "ID1 Diffuse" bitmap:d1 align:#left width:50 height:50 style:#bmp_stretch  
			--imgtag img_mat2 "ID2 Diffuse" bitmap:d2 align:#left width:50 height:50 style:#bmp_stretch  
			
			--imgtag img_tag1 "1001 Diffuse" bitmap:b1 align:#left width:50 height:50 style:#bmp_stretch 
			--imgtag img_tag1n "1001 Normal" bitmap:b1n align:#left width:50 height:50 style:#bmp_stretch 			
			--imgtag img_tag1e "1001 ERM" bitmap:b1e align:#left width:50 height:50 style:#bmp_stretch 	
			
			--imgtag img_tag2 "1002 Diffuse" bitmap:b2 align:#left width:50 height:50 style:#bmp_stretch  
			
			--dropdownlist material_id2 "ID2" items: (for i in (meditMaterials[1].originalMaterial.materialIDList) collect i as string) across:2
			--imgtag img_tag2 "1002 Diffuse" bitmap:b2 align:#left width:50 height:50 style:#bmp_stretch
			--button btn_cr "Create material and object"
			--on img_tag1 mousedown do ()
		--)
		--createDialog Bitmaps
		
		--on btn_cr pressed do
		--(
			--makeit material_id i .selected f[i] f_norm[i] f_erm[i]
		--)
	)
*/	
	
	on btn_multimat_table pressed do
	(
		global sel = if selection.count > 0 then selection[1].name else "None"

		try(destroyDialog ::BitmapsFL)catch()
		try(closeRolloutFloater BitmapsFL)catch()
		BitmapsFL = newRolloutFloater "Bitmaps" 1000 800
		rollout Controls "Controls" autoLayoutOnResize:true width:1000 height:800
		(
			progressbar pb width:950 height:8
			edittext edt_tex "Textures Path: " width:800 fieldWidth:800 across:2 text: udims.edt_multimat_path.text --text:(maxFilePath + "Images\\")
			button bnt_getpath "<- Open Path" align:#right Tooltip:"<- ??????? ???? | <- Open Path"
			edittext edt_obj "Selected object: " width:800 fieldWidth:800 text:sel across:2 Tooltip:"????????? ??????: | Selected object: "
			button bnt_getobj "<- Get Selected" align:#right Tooltip:"<- ????? ???????? | <- Get Selected"
			label lb_status "Status: Ready" width:800 style_sunkenedge:true align:#left Tooltip:"?????? | Status"
			button btn_all "All Pictures" width:200 across:4 Tooltip:"??? ???????? | All Pictures"
			button btn_err "Open Errors" width:200 Tooltip:"?????? ?????????? ??????? | Open Errors in textures"
			button bnt_low "Only Lowpoly" width:200 Tooltip:"?????? ???????? ??? ??? | Only Lowpoly textures"
			button bnt_hi "Only Highpoly" width:200 Tooltip:"?????? ???????? ??? ??? | Only Highpoly textures"
			
			on Controls open do 
			(
				gc()
			)
			
			on Controls close do
			(
				gc()	
			)
			
			on bnt_getpath pressed do
			(
				edt_tex.text = getSavePath caption:"Select Folder ..." initialDir: maxFilePath
				edt_tex.text += "\\"
			)
			
			on bnt_getobj pressed do 
			(
				sel = if selection.count > 0 then selection[1].name else "None" 
				edt_obj.text = sel
			)				
			
			on btn_all pressed do
			(
				lb_status.text = "Status: Open files"
				f = #()
				f = getFiles (edt_tex.text + "*.png")
				join f (getFiles (edt_tex.text + "*.jpg"))
				join f (getFiles (edt_tex.text + "*.jpeg"))
				join f (getFiles (edt_tex.text + "*.psd"))	
				b = for i in f collect #((try(openBitMap i)catch("undefined")), i)
				--print b
				
				try (removeRollout Bitmaps)catch()
				--try(destroyDialog ::Bitmaps)catch()
				
				if b != undefined then
					if b.count > 0 then
					(
						lb_status.text = "Status: Arrange layout"
						pb.value = 0.0
						str = ""
						append str ("rollout Bitmaps " + "\"" + "Bitmaps" + "\"" + " autoLayoutOnResize:true width:1000 height:800\n" + "(\n")
						
						for i = 1 to b.count do 
						(
							if b[i][1] != undefined then
							(
								append str ("imgtag img_tag" + i as string + " bitmap: @" + "\"" + doubleslash (b[i][1].filename as string) + "\"" + " width:40 height:40 across:2 style:#bmp_stretch \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n")
								--"label lbn" + i as string + " " + "\"" + i as string + "\"" + " width:50 height:40 align:#left across:3\n
							)
							else
							(			
								append str ("label lb" + i as string + "\"" + "Error Open file" + "\"" + " width:50 height:40 color:red align:#left across:2 \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n") 
							)	
							pb.value = (i as float)/(b.count as float)*100
						)
						for i = 1 to b.count do 
						(
							if b[i][1] != undefined then
							(	
								append str ("on img_tag" + i as string + " mousedown do (display (openBitMap (" + "\"" + doubleslash (b[i][1].filename as string) + "\"" + ")))\n")
							)
						)

						append str (")\n")
						append str ("addRollout Bitmaps BitmapsFL\n")

						--print str
						pb.value = 100.0
						lb_status.text = "Status: Create rollout, wait..."
						execute (str)
						
					)
				lb_status.text = "Status: Ready"
			)
			
			on btn_err pressed do
			(
				lb_status.text = "Status: Open files"
				f = getFiles (edt_tex.text + "*.png") 
				b = for i in f collect #((try(openBitMap i)catch("undefined")), i)
				try (removeRollout Bitmaps)catch()
				
				if b != undefined then
					if b.count > 0 then
					(
						lb_status.text = "Status: Arrange layout"
						pb.value = 0.0
						str = ""
						append str ("rollout Bitmaps " + "\"" + "Bitmaps" + "\"" + " autoLayoutOnResize:true width:1000 height:800\n" + "(\n")
						
						for i = 1 to b.count where b[i][1] == undefined do 
						(
							append str ("label lb" + i as string + "\"" + "Error Open file" + "\"" + " width:50 height:40 color:red align:#left across:2 \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n") 
							pb.value = (i as float)/(b.count as float)*100
						)
						append str (")\n")
						append str ("addRollout Bitmaps BitmapsFL\n")

						--print str
						lb_status.text = "Status: Create rollout, wait..."
						pb.value = 100.0
						execute (str)
					)
				lb_status.text = "Status: Ready"
			)
			
			on bnt_low pressed do
			(
				
			)
				
			on bnt_hi pressed do
			(
				gc()
				sel = if selection.count > 0 then selection[1].name else "None" 
				edt_obj.text = sel
				max modify mode
				selmod = modpanel.getcurrentobject()
				if selection.count == 1 and selmod != undefined and ((superclassof selmod == GeometryClass) or (superclassof selmod == Value) or (classof selmod == Unwrap_UVW)) then
				(
					del = false
					dirname_udim = edt_tex.text + "UVs\\" + edt_obj.text + "\\"
					filename_udim = dirname_udim + edt_obj.text + "_udims.png"
					fd_uvs = #()
					fd_uvs_all = #()
					fd_d = #()
					fd_n = #()
					fd_e = #()
					fd_d_udims = #() 
					fd_n_udims = #() 
					fd_e_udims = #()
					fd_u_udims = #()
					
					unwrapmod = modpanel.getcurrentobject()
					if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
					(
						del = true
						addmodifier selection[1] (Unwrap_UVW())
						unwrapmod = modpanel.getcurrentobject()
					)
					if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
					(
						lb_status.text = "Status: Searching for UDIMs"
						makedir dirname_udim
						old_files = #()
						old_files = getfiles (dirname_udim + "*.*")
						if old_files.count > 0 then 
							for file in old_files where doesfileexist file do deletefile file
						--print filename_udim
						unwrapmod.renderuv_width = 200
						unwrapmod.renderuv_height = 200
						--unwrapmod.renderuv_edgeColor : color
						--unwrapmod.renderuv_edgealpha : float
						--unwrapmod.renderuv_seamColor : color
						unwrapmod.renderuv_visibleedges = true
						unwrapmod.renderuv_invisibleedges = false
						unwrapmod.renderuv_seamedges = true
						unwrapmod.renderuv_showframebuffer = false
						--unwrapmod.renderuv_force2sided : boolean
						unwrapmod.renderuv_fillmode = 0 --?????????? ?????
						--unwrapmod.renderuv_fillalpha : float
						--unwrapmod.renderuv_fillColor : color
						unwrapmod.renderuv_showoverlap = true
						--unwrapmod.renderuv_overlapColor : color
						unwrapmod.edit()
						unwrapmod.fit() 
						--unwrapmod.displayMap = true
						unwrapmod.showTileGridlines = true
						unwrapmod.DisplayPixelUnits = true
						unwrapmod.renderUV filename_udim 
						unwrapmod.renderUVDialog()
	
						--select from dropdownlist all tiles
						for o in UIAccessor.GetChildWindows 0 where (t = UIAccessor.GetWindowText o) != undefined and t == "Render UVs" do
						(
							cc = for c in (windows.getChildrenHWND o) where c[4] == "ComboBox" and c[5] == "Default" collect c[1]
							local CB_SHOWDROPDOWN = 0x014F
							local CB_SETCURSEL = 0x014E 
							local WM_LBUTTONDOWN = 0x0201
							local WM_LBUTTONUP = 0x0202
							windows.sendMessage cc[1] CB_SHOWDROPDOWN 1 0 -- Open combobox dropdown
							windows.sendMessage cc[1] CB_SETCURSEL 1 0 -- Select 2th item
							windows.sendMessage cc[1] WM_LBUTTONDOWN 0 -1  -- Press left mouse button
							windows.sendMessage cc[1] WM_LBUTTONUP 0 -1  -- Raise left mouse button
							windows.sendMessage cc[1] CB_SHOWDROPDOWN 0 0    -- Close dropdown
							--press render button
							UIAccessor.pressButton ((for c in (windows.getChildrenHWND o) where (c[5] == "Render UV Template") collect c)[1])[1]  
						)
						--close dialog
						for o in UIAccessor.GetChildWindows 0 where (t = UIAccessor.GetWindowText o) != undefined and t == "Render UVs" do UIAccessor.CloseDialog o
						
						fd_uvs = getFiles (dirname_udim + "*.png") 					
						--fd_uvs = getFiles (dirname_udim + "_udims*.png") 
						--fd_uvs = getFiles (dirname_udim + "*_udims_U*_V*.png")
						if fd_uvs.count != 0 then
						(
							--print fd_uvs
							for i in fd_uvs where findstring i "udims.png" != undefined do deletefile i
							for i in fd_uvs where findstring i "udims.png" == undefined do renamefile i (uv_file_rename i) --print (uv_file_rename i) 
						)
						--print fd_uvs
					)
					if del then deletemodifier selection[1] 1
					
					lb_status.text = "Status: Parsing name"
					err = 0
					nm = edt_obj.text
					if findstring nm "SM_" == undefined then err += 1
					if findstring nm "_" == undefined then err += 1
					if findstring nm "_Main" == undefined and findstring nm "_Ground" == undefined then err += 1
					if findstring nm "UCX_" != undefined then err += 1	
					if findstring nm "Glass" != undefined then err += 1	
					if err != 0 then lb_status.text = "Status: Name Error, no need textures for this name"
					
					nm = substitutestring nm "_Main" ""
					--nm = substitutestring nm "_Ground" ""
					-- ??? ?????? ???
					
					nm = substitutestring nm "SM_" "T_"
					print nm

					lb_status.text = "Status: Getting files"
					--fd_d = getFiles (edt_tex.text + nm + "*Diffuse*" + ".png")
					--print #(fd_d)
					fd_d = for f in (getFiles (edt_tex.text + nm + "*Diffuse*" + ".png")) where check_file f collect f
					fd_n = for f in (getFiles (edt_tex.text + nm + "*Normal*" + ".png")) where check_file f collect f
					fd_e = for f in (getFiles (edt_tex.text + nm + "*ERM*" + ".png")) where check_file f collect f
					--fd_uvs = getFiles (dirname_udim + "*.png")
					fd_uvs = for f in (getFiles (dirname_udim + "*.png")) where check_file_uv f collect f
					fd_uvs_all = getFiles (dirname_udim + "*.png")
						
					print #(fd_d)
					print #(fd_n)
					print #(fd_e)	
					sort fd_uvs
					print #(fd_uvs)

					if fd_d.count > 0 then fd_d_udims = for file in fd_d collect ((filterstring file ".")[(filterstring file ".").count - 1]) as integer
					if fd_n.count > 0 then fd_n_udims = for file in fd_n collect ((filterstring file ".")[(filterstring file ".").count - 1]) as integer
					if fd_e.count > 0 then fd_e_udims = for file in fd_e collect ((filterstring file ".")[(filterstring file ".").count - 1]) as integer
					if fd_uvs.count > 0 then fd_u_udims = for file in fd_uvs collect ((filterstring file ".")[(filterstring file ".").count - 1]) as integer
						
					if fd_d_udims != #() then sort fd_d_udims
					if fd_n_udims != #() then sort fd_n_udims
					if fd_e_udims != #() then sort fd_e_udims
					if fd_u_udims != #() then sort fd_u_udims
						
					print #(fd_d_udims)
						
					udims_err = 0
					if fd_d_udims != #() then if fd_d_udims.count > 0 then udims_err += if fd_d_udims.count != (fd_d_udims[fd_d_udims.count] - 1000) then 1 else 0
					if fd_n_udims != #() then if fd_n_udims.count > 0 then udims_err += if fd_n_udims.count != (fd_n_udims[fd_n_udims.count] - 1000) then 1 else 0
					if fd_e_udims != #() then if fd_e_udims.count > 0 then udims_err += if fd_e_udims.count != (fd_e_udims[fd_e_udims.count] - 1000) then 1 else 0
					if fd_u_udims != #() then if fd_u_udims.count > 0 then udims_err += if fd_u_udims.count != (fd_u_udims[fd_u_udims.count] - 1000) then 1 else 0
						
					if fd_d_udims.count == fd_n_udims.count == fd_e_udims.count == fd_u_udims.count == 0 then messagebox ("No textures found,\ncheck path!")
					
					if fd_d_udims != #() then 
						for u = 1 to fd_d_udims.count do
						(
							if (u + 1000) != fd_d_udims[u] then udims_err += 1
							--format "% + 1000  == %\n" u fd_d_udims[u]
						)
						
					if fd_n_udims != #() then for u = 1 to fd_n_udims.count do
					(
						if (u + 1000) != fd_n_udims[u] then udims_err += 1
						--format "% + 1000  == %\n" u fd_n_udims[u]
					)
						
					if fd_e_udims != #() then for u = 1 to fd_e_udims.count do
					(
						if (u + 1000) != fd_e_udims[u] then udims_err += 1
						--format "% + 1000  == %\n" u fd_e_udims[u]
					)
						
					if fd_u_udims != #() then for u = 1 to fd_u_udims.count do
					(
						if (u + 1000) != fd_u_udims[u] then udims_err += 1
						--format "% + 1000  == %\n" u fd_e_udims[u]
					)						

					if udims_err != 0 then lb_status.text = "Status: Textures numbers UDIMs error" else lb_status.text = "Status: Textures numbers UDIMs OK"
					print udims_err

					b = #()
					b_n = #()
					b_e = #()
					b_u = #()
					
					if fd_d_udims != #() then b = for i in fd_d_udims collect #((try(openBitMap (for t in fd_d where (findstring (getfilenamefile t + getfilenametype t) (i as string)) != undefined do exit with t))catch(undefined)), i, i)
					if fd_n_udims != #() then b_n = for i in fd_n_udims collect #((try(openBitMap (for t in fd_n where (findstring (getfilenamefile t + getfilenametype t) (i as string)) != undefined do exit with t))catch(undefined)), i, i)
					if fd_e_udims != #() then b_e = for i in fd_e_udims collect #((try(openBitMap (for t in fd_e where (findstring (getfilenamefile t + getfilenametype t) (i as string)) != undefined do exit with t))catch(undefined)), i, i)
					if fd_u_udims != #() then b_u = for i in fd_u_udims collect #((try(openBitMap (for t in fd_uvs where (findstring (getfilenamefile t + getfilenametype t) (i as string)) != undefined do exit with t))catch(undefined)), i, i)
						
					--if fd_d_udims != #() then b = for i = 1 to fd_d.count where (findItem fd_d_udims (i + 1000)) != 0 collect #((try(openBitMap fd_d[i])catch(undefined)), i, fd_d_udims[findItem fd_d_udims (i + 1000)])
					--if fd_n_udims != #() then b_n = for i = 1 to fd_n.count where (findItem fd_n_udims (i + 1000)) != 0 collect #((try(openBitMap fd_n[i])catch(undefined)), i, fd_n_udims[findItem fd_n_udims (i + 1000)])
					--if fd_e_udims != #() then b_e = for i = 1 to fd_e.count where (findItem fd_e_udims (i + 1000)) != 0 collect #((try(openBitMap fd_e[i])catch(undefined)), i, fd_e_udims[findItem fd_e_udims (i + 1000)])
					--if fd_u_udims != #() then b_u = for i = 1 to fd_uvs.count where (findItem fd_u_udims (i + 1000)) != 0 collect #((try(openBitMap fd_uvs[i])catch(undefined)), i, fd_u_udims[findItem fd_u_udims (i + 1000)])
						
					with PrintAllElements on print #(b)
					with PrintAllElements on print #(b_n)
					with PrintAllElements on print #(b_e)
					with PrintAllElements on print #(b_u)	
							
					with PrintAllElements on print #(fd_uvs)
					with PrintAllElements on print #(fd_u_udims)	

					str = ""
					append str ("rollout Bitmaps " + "\"" + "Highpoly Bitmaps" + "\"" + " autoLayoutOnResize:true width:1000 height:800\n" + "(\n")
						
					fd_udims_nums = #()
					join fd_udims_nums fd_d_udims
					join fd_udims_nums fd_n_udims
					join fd_udims_nums fd_e_udims
					join fd_udims_nums fd_u_udims	
					makeUniqueArray fd_udims_nums
					fd_udims_nums_new = #()
					for f in fd_udims_nums do appendIfUnique fd_udims_nums_new f
							
					fd_udims_num = 0
					if fd_udims_nums.count > 0 then fd_udims_num += amax fd_udims_nums	
					with PrintAllElements on print #(fd_udims_nums_new)
					--print (fd_udims_num)
					--fd_d_udims_num = amax (for i in fd_d_udims collect i)
					--fd_n_udims_num = amax (for i in fd_n_udims collect i)
					--fd_e_udims_num = amax (for i in fd_e_udims collect i)
					--fd_udims_num = amax #(fd_d_udims_num, fd_n_udims_num, fd_e_udims_num)
						
					cou = 0
					udim_count = 1000
					udim_count_old = 0
					if fd_udims_nums_new != 0 then
					(
						sort fd_udims_nums_new
						for i in fd_udims_nums_new do  --for i = 1001 to fd_udims_num do 
						(							
							cou += 1
							udim = i as integer 
							--print i		
							
							if i < 1001 then 
							(
								if cou == 1 then append str ("label lbn_udim_out" + cou as string + i as string + " " + "\"" + "Found errors overlaps in UVs UDIMS, see UNWRAP UV EDITOR for details" + "\"" + " width:800 height:20 align:#left offset:[0,0] style_sunkenedge:true \n")
								continue	
							)
							
							if fd_uvs.count != fd_uvs_all.count then --???? ?????? ????????? 
							(
								if cou == 1 then 
								(
									append str ("label lbn_udim_out" + cou as string + i as string + " " + "\"" + "Found errors in UVs UDIMS: " + abs (fd_uvs.count - fd_uvs_all.count) as string + ", see UNWRAP UV EDITOR for details" + "\"" + " width:800 height:20 align:#left offset:[0,0] style_sunkenedge:true \n")
									continue
								)									
							)
							udim_count += 1
							udim_count_old = udim							
							if udim_count != udim_count_old then -- ??????????? ????????? ??????
							(
								append str ("label lbn_udim_err_order" + cou as string + i as string + " " + "\"" + "There are missed udims between these" + "\"" + " width:800 height:20 align:#left offset:[0,0] style_sunkenedge:true \n")
								udim_count = udim_count_old = i
							)

							append str ("label lbn_udim" + cou as string + i as string + " " + "\"" + udim as string + "\"" + " width:50 height:200 align:#left across:5 offset:[0,0] style_sunkenedge:true \n")
								
							for a in b_u where a[3] == udim do  
							(
								if a[1] != undefined then
								(
									--print #(a)
									--append str ("imgtag img_tag_d" + i as string + " bitmap: (bitmap 200 200 gamma:1.0 hdr:false alpha:true filename:@" + "\"" + (doubleslash (a[1].filename as string)) + "\"" + ") width:200 height:200 style:#bmp_stretch \n")
									--(bitmap 200 200 gamma:1.0 hdr:false alpha:true filename:(doubleslash (a[1].filename as string)))
									append str ("imgtag img_tag_u" + cou as string  + i as string + " bitmap: @" + "\"" + doubleslash (a[1].filename as string) + "\"" + " width:200 height:200 style:#bmp_stretch \n")
									--	" \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n")
									--"label lbn" + i as string + " " + "\"" + i as string + "\"" + " width:50 height:40 align:#left across:3\n
								)
								else append str ("label lbn_u" + cou as string + i as string + " " + "\"" + "error: " + i as string + "\"" + " width:200 height:20 offset:[0,0] style_sunkenedge:true \n")
							)
							if (for a in b_u where a[3] == udim collect a).count == 0 then append str ("label lbn_u_err" + cou as string + i as string + " " + "\"" + "none: " + i as string + "\"" + " width:200 height:200 offset:[0,0] style_sunkenedge:true \n")

							for a in b where a[3] == udim do 
							(
								--print #(a)
								if a[1] != undefined then
								(
									--append str ("imgtag img_tag_d" + i as string + " bitmap: (bitmap 200 200 gamma:1.0 hdr:false alpha:true filename:@" + "\"" + (doubleslash (a[1].filename as string)) + "\"" + ") width:200 height:200 style:#bmp_stretch \n")
									--(bitmap 200 200 gamma:1.0 hdr:false alpha:true filename:(doubleslash (a[1].filename as string)))
									append str ("imgtag img_tag_d" + cou as string + i as string + " bitmap: @" + "\"" + doubleslash (a[1].filename as string) + "\"" + " width:200 height:200 style:#bmp_stretch \n")
									--	" \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n")
									--"label lbn" + i as string + " " + "\"" + i as string + "\"" + " width:50 height:40 align:#left across:3\n
								)
								else append str ("label lbn_d" + cou as string + i as string + " " + "\"" + "error: " + i as string + "\"" + " width:200 height:20 offset:[0,0] style_sunkenedge:true \n")
							)
							if (for a in b where a[3] == udim collect a).count == 0 then append str ("label lbn_d_err" + cou as string + i as string + " " + "\"" + "none: " + i as string + "\"" + " width:200 height:200 offset:[0,0] style_sunkenedge:true \n")

							for a in b_n where a[3] == udim do 
							(
								--print #(a)
								if a[1] != undefined then
								(
									append str ("imgtag img_tag_n" + cou as string + i as string + " bitmap: @" + "\"" + doubleslash (a[1].filename as string) + "\"" + " width:200 height:200 style:#bmp_stretch \n")
								)
								else
								(
									append str ("label lbn_n" + cou as string + i as string + " " + "\"" + "error: " + i as string + "\"" + " width:200 height:20 style_sunkenedge:true \n")
								)
							)	
							if (for a in b_n where a[3] == udim collect a).count == 0 then append str ("label lbn_n_err" + cou as string + i as string + " " + "\"" + "none: " + i as string + "\"" + " width:200 height:200 offset:[0,0] style_sunkenedge:true \n")

							for a in b_e where a[3] == udim do 
							(
								--print #(a)
								if a[1] != undefined then
								(
									append str ("imgtag img_tag_e" + cou as string + i as string + " bitmap: @" + "\"" + doubleslash (a[1].filename as string) + "\"" + " width:200 height:200 style:#bmp_stretch align:#right \n")
									--	" \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n")
									--"label lbn" + i as string + " " + "\"" + i as string + "\"" + " width:50 height:40 align:#left across:3\n
								)
								else
								(
									append str ("label lbn_e" + cou as string + i as string + " " + "\"" + "error: " + i as string + "\"" + " width:200 height:20 align:#right style_sunkenedge:true \n")
								)
							)	
							if (for a in b_e where a[3] == udim collect a).count == 0 then append str ("label lbn_e_err" + cou as string + i as string + " " + "\"" + "none: " + i as string + "\"" + " width:200 height:200 offset:[0,0] style_sunkenedge:true \n")
								
							--append str ("label lbn_udim_o" + cou as string + i as string + " " + "\"" + i as string + "\"" + " width:50 height:20 align:#left across:5 offset:[0,0] style_sunkenedge:true \n")
							append str ("label lbn_udim_o" + cou as string + i as string + " " + "\"" + " " + "\"" + " width:50 height:20 align:#left across:5 offset:[0,0] style_sunkenedge:false \n")

							append str ("label lbn_udim_uv" + cou as string + i as string + " " + "\"" + (udim_to_uv_num i) as string + "\"" + " width:180 height:20 align:#left offset:[0,0] style_sunkenedge:true \n")
								
							for a in b where a[3] == udim do append str ("edittext edt_bitmap_d" + cou as string + i as string + " width:180 fieldWidth:180 offset:[0,0] text: " + "\"" + (getfilenamefile a[1].filename) as string + "\"" + "\n")
							if (for a in b where a[3] == udim collect a).count == 0 then append str ("label lbn_d_err_path" + cou as string + i as string + " " + "\"" + "none" + "\"" + " width:180 fieldWidth:180 style_sunkenedge:true \n")
								
							for a in b_n where a[3] == udim do append str ("edittext edt_bitmap_n" + cou as string + i as string + " width:180 fieldWidth:180 offset:[0,0] text: " + "\"" + (getfilenamefile a[1].filename)  as string + "\"" + "\n")
							if (for a in b_n where a[3] == udim collect a).count == 0 then append str ("label lbn_n_err_path" + cou as string + i as string + " " + "\"" + "none" + "\"" + " width:180 fieldWidth:180 style_sunkenedge:true \n")
							
							for a in b_e where a[3] == udim do append str ("edittext edt_bitmap_e" + cou as string + i as string + " width:180 fieldWidth:180 offset:[0,0] align:#right text: " + "\"" + (getfilenamefile a[1].filename) as string + "\"" + "\n")
							if (for a in b_e where a[3] == udim collect a).count == 0 then append str ("label lbn_e_err_path" + cou as string + i as string + " " + "\"" + "none" + "\"" + " width:180 fieldWidth:180 style_sunkenedge:true \n")

							append str ("label lbn_udim_oo" + cou as string + i as string + " " + "\"" + " " + "\"" + " width:50 height:20 align:#left across:5 offset:[0,0] style_sunkenedge:false \n")
							append str ("label lbn_udim_uvv" + cou as string + i as string + " " + "\"" + udim as string + "\"" + " width:180 height:20 align:#left offset:[0,0] style_sunkenedge:true \n")
							for a in b where a[3] == udim do append str ("label lbn_udim_size_b" + cou as string + i as string + " " + "\"" + getsize a[1] + "\"" + " width:180 fieldWidth:180 offset:[0,0] style_sunkenedge:true \n")
							for a in b_n where a[3] == udim do append str ("label lbn_udim_size_n" + cou as string + i as string + " " + "\"" + getsize a[1] + "\"" + " width:180 fieldWidth:180 offset:[0,0] style_sunkenedge:true \n")
							for a in b_e where a[3] == udim do append str ("label lbn_udim_size_e" + cou as string + i as string + " " + "\"" + getsize a[1] + "\"" + " width:180 fieldWidth:180 offset:[0,0] style_sunkenedge:true align:#right \n")
							
							--(			
							--	append str ("label lb" + i as string + "\"" + "Error Open file" + "\"" + " width:50 height:40 color:red align:#left across:3 \nedittext edt_bitmap" + i as string + " width:800 fieldWidth:800 offset: [-400,15] text: " + "\"" + b[i][2] as string + "\"" + "\n") 
							--)	

							pb.value = (i as float)/(b.count as float)*100
						)
							
						--for i = 1 to b.count do 
						--(
						--	if b[i][1] != undefined then
						--	(	
						--		append str ("on img_tag" + i as string + " mousedown do (display (openBitMap (" + "\"" + doubleslash (b[i][1].filename as string) + "\"" + ")))\n")
						--	)
						--)

						append str (")\n")
						append str ("addRollout Bitmaps BitmapsFL\n")

						--print str
						pb.value = 100.0
						lb_status.text = "Status: Create rollout, wait..."
						execute (str)	
						lb_status.text = "Status: Done"
					)							
				)
				else
				(
					messagebox ("Select single Editable Poly object to find its textures...")
				)
			)
		)
		addRollout Controls BitmapsFL
	)
	
	on btn_name_from_sel pressed do
	(
		if selection.count > 0 then
		(
			edt_object_name.text = selection[1].name
			edt_tex_diffuse_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_Diffuse_1." + (spn_tex_udim.value as string) + ".png"
			edt_tex_diffuse_name.text = (substitutestring edt_tex_diffuse_name.text "_Main" "")
			edt_tex_normal_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_Normal_1." + (spn_tex_udim.value as string) + ".png"
			edt_tex_normal_name.text = (substitutestring edt_tex_normal_name.text "_Main" "")
			edt_tex_erm_name.text = (substitutestring edt_object_name.text "SM_" "T_") + "_ERM_1." + (spn_tex_udim.value as string) + ".png"
			edt_tex_erm_name.text = (substitutestring edt_tex_erm_name.text "_Main" "")
			
			edt_object_addr.text = (substitutestring edt_object_name.text "SM_" "")
			tt = filterstring edt_object_name.text "_"
			if tt.count > 1 then
			(
				edt_object_addr.text = ""
				for t = 1 to tt.count do 
				(
					if tt[t] == "SM" or tt[t] == "M" or tt[t] == "T" then continue
					if (for t1 = 1 to tt.count where tt[t1] == "77" collect tt[t1]).count == 0  and tt[t] == "001" or tt[t] == "002" or tt[t] == "003" or tt[t] == "004" or tt[t] == "005" then continue	
					if tt[t] == "Main" then continue
					if tt[t] == "Ground" then continue
					if tt[t] == "GroundEl" then continue						
					if tt[t] == "Flora" then continue
					if tt[t] == "Glass" or tt[t] == "MainGlass" or tt[t] == "GroundGlass" or tt[t] == "GroundElGlass" then continue	
					if edt_object_addr.text != "" then edt_object_addr.text += "_"
					edt_object_addr.text += tt[t]
				)
			)
		)
	)		
	
	on spn_tex_udim changed val do 
	(
		edt_tex_diffuse_name.text = (filterstring edt_tex_diffuse_name.text ".")[1] + "." + (val as string) + "." + (filterstring edt_tex_diffuse_name.text ".")[3]
		edt_tex_normal_name.text = (filterstring edt_tex_normal_name.text ".")[1] + "." + (val as string) + "." + (filterstring edt_tex_normal_name.text ".")[3]		
		edt_tex_erm_name.text = (filterstring edt_tex_erm_name.text ".")[1] + "." + (val as string) + "." + (filterstring edt_tex_erm_name.text ".")[3]			
	)
	
	on btn_rename pressed do
	(
		--f = getFiles (edt_multimat_path.text + "*Diffuse*.png")
		--f_norm = getFiles (edt_multimat_path.text + "*Normal*.png")	
		--f_erm = getFiles (edt_multimat_path.text + "*ERM*.png")
		--f_new = for i in #{1..(f_other.count)} where (for i2 in #{1..(f.count)} where f_other[i] == f[i2] collect f[i2]).count == 0 and (for i3 in #{1..(f_norm.count)} where f_other[i] == f_norm[i3] collect f_norm[i3]).count == 0 and (for i4 in #{1..(f_erm.count)} where f_other[i] == f_erm[i4] collect f_erm[i4]).count == 0 collect f_other[i]
		ctrl = if keyboard.controlPressed then true else false
		f_other = if ctrl then getFiles (edt_multimat_path.text + "*.*") else getFiles (edt_multimat_path.text + "*.png")
		
		for i in f_other do 
		(
			renamefile i (substitutestring i edt_tex_find.text edt_tex_rename.text) 
		)
	)
	
	on btn_rename rightclick do
	(
		ctrl = keyboard.controlPressed
		alt = keyboard.altPressed
		if ctrl then 
		(
			for mat in scenematerials where classof mat == material or superClassOf mat == material do mat.name = substitutestring mat.name edt_tex_find.text edt_tex_rename.text
			for c in material.classes where c.creatable do 
				for mat in (getClassInstances c processAllAnimatables:true) do 
				(
					mat.name = substitutestring mat.name edt_tex_find.text edt_tex_rename.text	
				)
		)
		
		if alt then 
		(
			texmaps = (GetBitmapTextures selection edt_tex_find.text edt_tex_rename.text)
			print #(texmaps)
			texmaps_paths = (GetBitmapTextures_Paths selection edt_tex_find.text edt_tex_rename.text)
			print #(texmaps_paths)	
		)
		
		if not ctrl and not alt then for i in selection do i.name = substitutestring i.name edt_tex_find.text edt_tex_rename.text
	)
	
	on btn_make_tex_diffuse pressed do 
	(
		rez = case rdo_tex.state of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)			
		filename = edt_multimat_path.text + edt_tex_diffuse_name.text
		
		if not doesDirectoryExist edt_multimat_path.text then makeDir edt_multimat_path.text
		
		b = bitmap rez rez filename:filename color:color_diffuse.color gamma:1 hdr:false alpha:false
		save b gamma:1.0 quiet:true
		close b
		free b
		HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " -alpha remove -alpha off PNG24:" + "\"" + filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
		HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
	)
	
	on btn_make_tex_diffuse rightclick do
	(
		try (display (openbitmap (edt_multimat_path.text + edt_tex_diffuse_name.text)))catch()
	)	
	
	on btn_open_tex_diffuse pressed do 
	(
		ctrl = keyboard.controlPressed
		rez = case rdo_tex.state of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)
		filename = edt_multimat_path.text + edt_tex_diffuse_name.text
		print filename
		sourcepath = getOpenFileName "Select file for diffuse map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
		print sourcepath
		--?????? ?????? print (("convert " + "\"" + sourcepath + "\"" + " -resize " + (rez as string) + "x" + (rez as string) + "! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()))
		if sourcepath != undefined then
		(
			if doesfileexist filename then 
			(
				if queryBox ("???????????? ???????????? ????:\n" + filename + "\n\n????? ??????:\n" + sourcepath) then
				(
					deleteFile filename
					if ctrl then 
					(
						resize_texture sourcepath filename rez rez
					)
					else
					(
						HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (rez as string) + "x" + (rez as string) + "^! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())	
					)
				)
			)
			else
			(
				if ctrl then 
				(
					resize_texture sourcepath filename rez rez
				)
				else
				(
					HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + (rez as string) + "x" + (rez as string) + "^! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
					HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())	
				)
			)
		)
	)
	
	on btn_open_tex_diffuse rightclick do
	(
		HiddenDOSCommand ("explorer.exe /e,/select, " + "\"" + edt_multimat_path.text + edt_tex_diffuse_name.text + "\"")
	)

	on btn_make_tex_normal pressed do 
	(	
		rez = case rdo_tex.state of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)	
		filename = edt_multimat_path.text + edt_tex_normal_name.text
		if not doesDirectoryExist edt_multimat_path.text then makeDir edt_multimat_path.text
		b = bitmap rez rez filename:filename color:color_normal.color gamma:1.0 hdr:false
		save b gamma:1.0 quiet:true
		close b
		free b
		HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " -alpha remove -alpha off " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
		HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
	)

	on btn_make_tex_normal rightclick do
	(
		try (display (openbitmap (edt_multimat_path.text + edt_tex_normal_name.text)))catch()
	)
	
	on btn_open_tex_normal pressed do 
	(
		rez = case rdo_tex.state of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)
		filename = edt_multimat_path.text + edt_tex_normal_name.text
		sourcepath = getOpenFileName "Select file for normal map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
		print sourcepath
		if sourcepath != undefined then
		(
			if doesfileexist filename then 
			(
				if queryBox ("???????????? ???????????? ????:\n" + filename "\n\n????? ??????:\n" + sourcepath) then
				(
					deleteFile filename
					if ctrl then 
					(
						resize_texture sourcepath filename rez rez
					)
					else
					(
						HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez + "x" + rez + "^! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())	
					)
				)
			)
			else
			(
				if ctrl then 
				(
					resize_texture sourcepath filename rez rez
				)
				else
				(
					HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez + "x" + rez + "^! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
					HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())	
				)
			)
		)
	)
	
	on btn_open_tex_normal rightclick do
	(
		HiddenDOSCommand ("explorer.exe /e,/select, " + "\"" + edt_multimat_path.text + edt_tex_normal_name.text + "\"")
	)	
	
	on btn_make_tex_erm pressed do 
	(
		rez = case rdo_tex.state of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)	
		filename = edt_multimat_path.text + edt_tex_erm_name.text
		if not doesDirectoryExist edt_multimat_path.text then makeDir edt_multimat_path.text
		b = bitmap rez rez filename:filename color:color_erm.color gamma:1.0 hdr:false
		save b gamma:1.0 quiet:true
		close b
		free b
		HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " -alpha remove -alpha off " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
		HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
	)	
	
	on btn_make_tex_erm rightclick do
	(
		try (display (openbitmap (edt_multimat_path.text + edt_tex_erm_name.text)))catch()
	)	
	
	on btn_open_tex_erm pressed do 
	(
		rez = case rdo_tex.state of
		(
			1: 256
			2: 512
			3: 1024
			4: 2048
			5: 4096
		)
		filename = edt_multimat_path.text + edt_tex_erm_name.text
		sourcepath = getOpenFileName "Select file for ERM map" types: "PNG|*.png|JPG|*.jpg|JPEG|*.jpeg|PSD|*.psd|ALL|*.*" 
		print sourcepath
		if sourcepath != undefined then
		(
			if doesfileexist filename then 
			(
				if queryBox ("???????????? ???????????? ????:\n" + filename "\n\n????? ??????:\n" + sourcepath) then
				(
					deleteFile filename
					if ctrl then 
					(
						resize_texture sourcepath filename rez rez
					)
					else
					(
						HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez + "x" + rez + "^! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())	
					)
				)
			)
			else
			(
				if ctrl then 
				(
					resize_texture sourcepath filename rez rez
				)
				else
				(
					HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -resize " + rez + "x" + rez + "^! " + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())
					HiddenDOSCommand ("magick " + "\"" + filename + "\""+ " PNG24:" + "\""+ filename + "\"") startpath:(GetINI_ImageMagick())	
				)			
			)
		)
	)	
	
	on btn_open_tex_erm rightclick do
	(
		HiddenDOSCommand ("explorer.exe /e,/select, " + "\"" + edt_multimat_path.text + edt_tex_erm_name.text + "\"")
	)	
	
	on btn_Streets_List pressed do
	(
		gc()
		excel_file = GetDir #maxroot + "GeoScripts\\ul3.csv"
		excel_file2 = GetDir #maxroot + "GeoScripts\\ul4.csv"
		global dirs_select = #()
		dirs_select_ = #()
		
		stri_pr = #()
		stri_pr = ReadAllLines excel_file	
		stri_pr2 = #()
		stri_pr2 = ReadAllLines excel_file2	
		if stri_pr != "" and stri_pr2 != ""then
		(
			if stri_pr.count > 0 then dirs_select_ = for i in #{1..stri_pr.count} collect (filterstring stri_pr[i] ";" splitEmptyTokens:true)
			if stri_pr2.count > 0 then join dirs_select_ (for i in #{1..stri_pr2.count} collect #((filterstring stri_pr2[i] ";" splitEmptyTokens:true)[1], (filterstring stri_pr2[i] ";" splitEmptyTokens:true)[2], (filterstring stri_pr2[i] ";" splitEmptyTokens:true)[2] + (filterstring stri_pr2[i] ";" splitEmptyTokens:true)[3]))
			--print #(dirs_select_.count)
			for i in #{2..dirs_select_.count} where dirs_select_[i][1] != dirs_select_[i-1][1] do append dirs_select dirs_select_[i-1]
				append dirs_select dirs_select_[dirs_select_.count]
				--for j in #{1..dirs_select_.count} where j > i and dirs_select_[i][1] != dirs_select_[j][1] do append dirs_select dirs_select_[i]
			--print #(dirs_select.count)
					
			try(destroyDialog ::StreetsFL)catch()
			rollout StreetsFL "Streets List" --autoLayoutOnResize:true width:800 height:800 
			(
				fn autoResizeColumn lv columns: = 
				(
					vScrollWidth = 21 -- vertical scrollbar width
					for c = 0 to columns-1 do
					(
						lv.AutoResizeColumn c (dotNetClass "ColumnHeaderAutoResizeStyle").HeaderSize --ColumnContent
						vScrollWidth += lv.Columns.Item[c].Width
					) 
					vScrollWidth
				)
				
				fn PopulateList lv dirs_select =
				(
					lv.Items.Clear()
					lv.view = (dotNetClass "system.windows.forms.view").details
					lv.HideSelection = true 
					lv.HeaderStyle = (dotNetClass "System.Windows.Forms.ColumnHeaderStyle").clickable
					--lv.height = 390
					lv.FullRowSelect = true    
					lv.MultiSelect = false --true    
					lv.AllowColumnReorder = true
					lv.GridLines = true
					lv.checkBoxes = false --true 
					lv.Scrollable = true
					lv.ShowItemToolTips = true
					columnsAr = #("Street/Place Full Name                                        ", "Street/Place Short Name                   ", "Street/Place Translit Short Name             ")
					lv.columns.Clear()
					for i = 1 to 3 do lv.columns.add columnsAr[i] 0	
					lv.width = autoResizeColumn lv columns:3
					lv.width = 700
					--lv.Update()
					
					rows = #()
					for t = 1 to dirs_select.count do
					(
						li = dotNetObject "System.Windows.Forms.ListViewItem" (dirs_select[t][1])
						li.UseItemStyleForSubItems = true
						li.subitems.add dirs_select[t][2]
						li.subitems.add dirs_select[t][3]
						append rows li
					)
					lv.items.addRange rows
					--lv.Update()
					--lv.width = autoResizeColumn lv columns:3
					--lv.width = 700
					lv.Update()
				)
				
				dotNetControl lv "ListView" pos:[5,5] width:700 height:700 tooltip:""
				button btnSelect "Select and Paste" align:#left offset:[0,0] across:2 tooltip:"Select and Paste"
				button btnClose "Close" align: #right tooltip:"Close this dialog"

				on StreetsFL open do
				(  
					--gc()
					PopulateList lv dirs_select 
				)

				on btnSelect pressed do
				(
					for val = 0 to lv.Items.count-1 where lv.Items.Item[val].selected do
					(
						print (dirs_select[val+1][3])
						setclipboardText (dirs_select[val+1][3])
						UDIMs.edt_object_addr.text = (dirs_select[val+1][3]) 
					)
				)

				on btnClose pressed do
				(
					try(destroyDialog ::StreetsFL)catch()
					gc()
				)	
			)
			createDialog StreetsFL width:800 height:800 style:#(#style_titlebar, #style_border, #style_sysmenu, #style_resizing)	
		)
	)

	on btn_color_diffuse_ral pressed do
	(
		excel_file = GetDir #maxroot + "GeoScripts\\ral_classic.csv" -- getFilenamePath(getSourceFileName()) + "ral_classic.csv"
		global arr_excel = #()
		stri_pr = #()
		stri_pr = ReadAllLines excel_file	
		if stri_pr != "" then
			if stri_pr.count > 0 then
			(
				arr_excel = for i = 2 to stri_pr.count collect (filterstring stri_pr[i] ";," splitEmptyTokens:true)
				if arr_excel.count > 0 then for i=1 to arr_excel.count do for j=1 to arr_excel[i].count do arr_excel[i][j] = substitutestring arr_excel[i][j] "\"" ""
			)	
			global sel = #()
			str = ""
			append str ("rollout Bitmaps " + "\"" + "RAL Colors Palette" + "\"" + " autoLayoutOnResize:true width:400 height:800\n" + "(\n")
						
			for i = 1 to arr_excel.count do
			(
				append str ("imgtag img_" + i as string + " " + "\"" + arr_excel[i][1] + "\"" + " " + "bitmap: (bitmap 100 30 color: (color " + (substitutestring arr_excel[i][2] "-" " ") + ") gamma:1 hdr:false alpha:false)" + " width:100 height:30 style:#bmp_stretch across:2 \n" )
				append str ("button btn_" + i as string + " " + "\"" + arr_excel[i][1] + " [" + (substitutestring arr_excel[i][2] "-" ",") + "] " + arr_excel[i][5] + "\"" + "border: false width:250 height:30 align: #left offset: [-70,0] \n")
			)
			for i = 1 to arr_excel.count do
			(
				append str ("on img_" + i as string + " mousedown do ( UDIMs.color_diffuse.color = (color " + (substitutestring arr_excel[i][2] "-" " ") + "); try(closeRolloutFloater BitmapsFL)catch() )\n")
				append str ("on btn_" + i as string + " pressed do ( UDIMs.color_diffuse.color = (color " + (substitutestring arr_excel[i][2] "-" " ") + "); try(closeRolloutFloater BitmapsFL)catch() )\n")
		
			)
			append str (")\n")
			append str ("addRollout Bitmaps BitmapsFL\n")
			
			try(destroyDialog ::BitmapsFL)catch()
			try(closeRolloutFloater BitmapsFL)catch()
			BitmapsFL = newRolloutFloater "RAL Colors Palette" 400 800
			execute (str)

	)
	
	on btn_singlemat pressed do
	(
		f = #()
		f_norm = #()
		f_r = #()
		f_m = #()
		f_o = #()
		mm = edt_material_object_number.text
		ctrl = keyboard.controlPressed
		if ctrl and selection.count == 1 then
		(
			mm = substitutestring selection[1].name "Main" ""
			mm = substitutestring mm "SM_" "T_"
		)
		if edt_material_object_number.text != "Ground" and not ctrl then
		(
			f = getFiles (edt_multimat_path.text + "*" + mm + "*_d_*" + "*.png")
			f_norm = getFiles (edt_multimat_path.text + "*" + mm + "*_n_*" + "*.png")	
			f_r = getFiles (edt_multimat_path.text + "*" + mm + "*_r_*" + "*.png")			
			f_m = getFiles (edt_multimat_path.text + "*" + mm + "*_m_*" + "*.png")			
			f_o = getFiles (edt_multimat_path.text + "*" + mm + "*_o_*" + "*.png")	
		)
		else
		(
			f = getFiles (edt_multimat_path.text + "*" + mm + "_d_*" + "*.png")
			f_norm = getFiles (edt_multimat_path.text + "*" + mm + "_n_*" + "*.png")	
			f_r = getFiles (edt_multimat_path.text + "*" + mm + "_r_*" + "*.png")			
			f_m = getFiles (edt_multimat_path.text + "*" + mm + "_m_*" + "*.png")			
			f_o = getFiles (edt_multimat_path.text + "*" + mm + "_o_*" + "*.png")				
		)
		
		print #(f)	
		print #(f_norm)		
		print #(f_r)	
		print #(f_m)
		print #(f_o)		
		
		if f.count != 1 or f_norm.count != 1 or f_r.count != 1 or f_m.count != 1 or f.count != f_norm.count or f.count != f_r.count or f_norm.count != f_m.count then 
		(
			messageBox ("Some files are missing\n" + "Diffuse: " + (f.count as string) + "\n" + "Normal: " + (f_norm.count as string) + "\n" + "r: " + (f_r.count as string) + "m: " + (f_m.count as string) + "\n")
		)	
		case rdo_type_mat.state of
		(
			2:
			(
				if f.count == 1 then m = Physical_Material name:(substitutestring (substitutestring (getFilenameFile f[1]) "T_" "M_") "_d" "")
				if f.count == 1 then m.base_color_map = BitmapTexture fileName: f[1]
				if f_r.count == 1 then m.roughness_map = BitmapTexture fileName: f_r[1]
				if f_m.count == 1 then m.metalness_map = BitmapTexture fileName: f_m[1]					
				if f_norm.count == 1 then m.bump_map = BitmapTexture fileName: f_norm[1]	
				if f_o.count == 1 then m.cutout_map = BitmapTexture fileName: f_o[1]
			)
			1:
			(
				if f.count == 1 then m = Standard name:(substitutestring (substitutestring (getFilenameFile f[1]) "T_" "M_") "_d" "")
				if f != undefined then if f.count == 1 then if doesfileexist f[1] then m.DiffuseMap = BitmapTexture fileName: f[1]
				if f_norm != undefined then if f_norm.count == 1 then if doesfileexist f_norm[1] then m.BumpMap = BitmapTexture fileName: f_norm[1]
				if f_m != undefined then if f_m.count == 1 then if doesfileexist f_m[1] then m.ReflectionMap = BitmapTexture fileName: f_m[1]
				if f_r != undefined then if f_r.count == 1 then if doesfileexist f_r[1] then m.GlossinessMap = BitmapTexture fileName: f_r[1]
				if f_o != undefined then if f_o.count == 1 then if doesfileexist f_o[1] then m.OpacityMap = BitmapTexture fileName: f_o[1]
			)
		)
		
		if ctrl then selection[1].material = m
		else 
		(
			if selection.count == 1 then
			case of
			(
				(findstring edt_material_object_number.text "Ground" != undefined): meditMaterials[19] = m 
				(findstring edt_material_object_number.text "GroundEl" != undefined): meditMaterials[20] = m
				(findstring edt_material_object_number.text "Flora" != undefined): meditMaterials[21] = m
				default: meditMaterials[12 + (edt_material_object_number.text as integer)] = m
			)
			print m
				--if findstring edt_material_object_number.text "Ground" == undefined then meditMaterials[12 + (edt_material_object_number.text as integer)] = m
				--else 
				--(
				--	if findstring edt_material_object_number.text "GroundEl" != undefined then meditMaterials[20] = m else meditMaterials[19] = m 
				--)
		)
	)
	
	on btn_multimat pressed do 
	(
		f = #()
		f_norm = #()
		f_erm = #()
		if keyboard.controlPressed then
		(
			mm = substitutestring selection[1].name "Main" ""
			mm = substitutestring mm "SM_" "T_"
			print (edt_multimat_path.text + mm + "Diffuse*" + ".png")	
			f = getFiles (edt_multimat_path.text + mm + "Diffuse*" + ".png")
			print f
			f_norm = getFiles (edt_multimat_path.text + mm + "Normal*" + ".png")	
			f_erm = getFiles (edt_multimat_path.text + mm + "ERM*" + ".png")	
		)
		else
		(
			if edt_material_object_number.text != "" then
			(
				--fd_d = for f in (getFiles (edt_tex.text + nm + "*Diffuse*" + ".png")) where check_file f collect f
				--fd_n = for f in (getFiles (edt_tex.text + nm + "*Normal*" + ".png")) where check_file f collect f
				--fd_e = for f in (getFiles (edt_tex.text + nm + "*ERM*" + ".png")) where check_file f collect f
						
				f = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png")
				f_norm = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Normal*" + edt_material_mat_number.text + "*.png")	
				f_erm = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*ERM*" + edt_material_mat_number.text + "*.png")
			)
			else
			(
				f = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png")
				f_norm = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Normal*" + edt_material_mat_number.text + "*.png")	
				f_erm = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*ERM*" + edt_material_mat_number.text + "*.png")

				f = for i in f where findstring (tolower i) "flora" == undefined collect i
				--f = for i in f where findstring (tolower i) "ground" == undefined collect i
				f = for i in f where findstring (tolower i) "groundel" == undefined collect i
				
				f_norm = for i in f_norm where findstring (tolower i) "flora" == undefined collect i
				--f_norm = for i in f_norm where findstring (tolower i) "ground" == undefined collect i	
				f_norm = for i in f_norm where findstring (tolower i) "groundel" == undefined collect i
				
				f_erm = for i in f_erm where findstring (tolower i) "flora" == undefined collect i
				--f_erm = for i in f_erm where findstring (tolower i) "ground" == undefined collect i
				f_erm = for i in f_erm where findstring (tolower i) "groundel" == undefined collect i				
			)
		)		
		
		if f != undefined then edt_multimat_count.text = f.count as string
		num = if f != #() then f.count else 0
		
		if f.count != f_norm.count or f.count != f_erm.count or f_norm.count != f_erm.count then 
		(
			messageBox ("Some files are missing\n" + "Diffuse: " + (f.count as string) + "\n" + "Normal: " + (f_norm.count as string) + "\n" + "ERM: " + (f_erm.count as string) + "\n")
		)
			if selection.count > 0 and num > 0 then
			(
				local ff = #()
				local ids = #()
				join ff f
				join ff f_norm
				join ff f_erm
				print #(ff)
				local sym = "."
				if (for aa in ff where (filterstring (getFilenameFile aa) ".").count > 1 collect aa).count > 0 then 
				(
					ids = for a in ff collect trim ((filterstring (getFilenameFile a) ".")[(filterstring (getFilenameFile a) ".").count])
					sym = "."
				)
				else 
				(
					ids = for a in ff collect trim ((filterstring (getFilenameFile a) "_")[(filterstring (getFilenameFile a) "_").count])
					sym = "_"
				)
				makeUniqueArray ids
				print #(ids)
								
				if ids.count > 0 then 
				(
						sel = selection[1]
						m = multiSubMaterial name:(substitutestring sel.name "SM_" "M_") --numsubs:ids.count materialIDList:ids
						--m.materialList.count = ids.count
						case rdo_type_mat.state of
						(
							1:
							(
								for i in #{1..f.count} do 
								(				
									if f != #() then 
										if f[i] != undefined then 
											if doesfileexist f[i] then 
												if (filterstring (getFilenameFile f[i]) sym)[(filterstring (getFilenameFile f[i]) sym).count] != undefined then
												(
													local id = trim ((filterstring (getFilenameFile f[i]) sym)[(filterstring (getFilenameFile f[i]) sym).count])
													--print id
													if id >= 1 then 
													(
														if classof m.materialList[id] != Standard then m.materialList[id] = Standard name:((substitutestring sel.name "SM_" "M_") + "_" + id as string)								
														if m.materialList[id].DiffuseMap == undefined then m.materialList[id].DiffuseMap = BitmapTexture fileName: f[i]
														try
														(
															bm = openbitmap f[i]
															if bm.hasAlpha then m.materialList[id].OpacityMap = BitmapTexture fileName: f[i] monoOutput:1 alphasource:0 RGBOutput:1
															close bm 
															free bm
														)catch()
													)
												)

								)		
								for i in #{1..f_norm.count} do
								(
									if f_norm != #() then 
										if f_norm[i] != undefined then 
											if doesfileexist f_norm[i] then
												if (filterstring (getFilenameFile f_norm[i]) sym)[(filterstring (getFilenameFile f_norm[i]) sym).count] != undefined then
												(
													local id = trim ((filterstring (getFilenameFile f_norm[i]) sym)[(filterstring (getFilenameFile f_norm[i]) sym).count])
													if id >= 1 then 
													(
														if classof m.materialList[id] != Standard then m.materialList[id] = Standard name:((substitutestring sel.name "SM_" "M_") + "_" + i as string)		
														m.materialList[id].BumpMap = BitmapTexture fileName: f_norm[i]
													)
												)
								)
								for i in #{1..f_erm.count} do
								(
									if f_erm != #() then 
										if f_erm[i] != undefined then 
											if doesfileexist f_erm[i] then 
												if (filterstring (getFilenameFile f_erm[i]) sym)[(filterstring (getFilenameFile f_erm[i]) sym).count] != undefined then
												(
													local id = trim ((filterstring (getFilenameFile f_erm[i]) sym)[(filterstring (getFilenameFile f_erm[i]) sym).count])
													if id >= 1 then 
													(
														if classof m.materialList[id] != Standard then m.materialList[id] = Standard name:((substitutestring sel.name "SM_" "M_") + "_" + i as string)								
														m.materialList[id].ReflectionMap = BitmapTexture fileName: f_erm[i]
													)
												)
								)						
							)
							
							2:
							(
								for i in #{1..f.count} do 
								(
									if f != #() then 
										if f[i] != undefined then 
											if doesfileexist f[i] then 
											(
												local id = trim ((filterstring (getFilenameFile f[i]) sym)[(filterstring (getFilenameFile f[i]) sym).count])
												if id >= 1 then 
												(
													if classof m.materialList[id] != Physical_Material then m.materialList[id] = Physical_Material name:((substitutestring sel.name "SM_" "M_") + "_" + i as string)								
													if m.materialList[id].base_color_map == undefined then m.materialList[id].base_color_map = BitmapTexture fileName: f[i]
													try
													(
														bm = openbitmap f[i]
														if bm.hasAlpha then m.materialList[id].cutout_map = BitmapTexture fileName: f[i] monoOutput:1 alphasource:0 RGBOutput:1
														close bm 
														free bm
													)catch()
												)
											)
								)
								for i in #{1..f_norm.count} do
								(
									if f_norm != #() then 
										if f_erm[i] != undefined then 
											if doesfileexist f_erm[i] then 
											(
												local id = trim ((filterstring (getFilenameFile f_erm[i]) sym)[(filterstring (getFilenameFile f_erm[i]) sym).count])
												if id >= 1 then 
												(
													if classof m.materialList[id] != Physical_Material then m.materialList[id] = Physical_Material name:((substitutestring sel.name "SM_" "M_") + "_" + i as string)								
													m.materialList[id].metalness_map = BitmapTexture fileName: f_erm[i]	--if f_erm != #() then if doesfileexist f_erm[i] then m.materialList[i].roughness_map = BitmapTexture fileName: f_erm[i]				
												)
											)
								)	
								for i in #{1..f_erm.count} do	
								(							
									if f_erm != #() then 
										if f_norm[i] != undefined then 
											if doesfileexist f_norm[i] then 
											(
												local id = trim ((filterstring (getFilenameFile f_norm[i]) sym)[(filterstring (getFilenameFile f_norm[i]) sym).count])
												if id >= 1 then 
												(
													if classof m.materialList[id] != Physical_Material then m.materialList[id] = Physical_Material name:((substitutestring sel.name "SM_" "M_") + "_" + i as string)								
													m.materialList[id].bump_map = BitmapTexture fileName: f_norm[i]	
												)
											)
												
									--bm = openbitmap f[i]
									--if bm.hasAlpha then 
									--(
									--	HiddenDOSCommand ("convert " + "\"" + f[i] + "\"" + " -alpha extract " + "\"" + (getfilenamepath f[i] + "_" + getFilenameFile f[i] + "_Alpha" + getFilenameType f[i]) + "\"") startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
									--	m.materialList[i].cutout_map = BitmapTexture fileName: (getfilenamepath f[i] + "_" + getFilenameFile f[i] + "_Alpha" + getFilenameType f[i]) 
									--)
									--close bm
									--m.materialList[i].emit_color_map = BitmapTexture fileName: f_erm[i]							
								)
							)
						)
						for i in #{1..m.materialList.count} where (usedMaps m.materialList[i]).count == 0 do m.materialList[i] = undefined
						sel.material = m
						meditMaterials[24] = m

				)
			)
			else
			(
				messageBox ("None object selected or no files found")
			)
	)
	
	on btn_multimat_read pressed do 
	(
		print (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png")
		f = getFiles (edt_multimat_path.text + "*" + edt_material_object_number.text + "*Diffuse*" + edt_material_mat_number.text + "*.png")
		if f != undefined then edt_multimat_count.text = f.count as string
	)
	
	on btn_make_all_tex pressed do
	(
		btn_make_tex_diffuse.pressed()
		btn_make_tex_normal.pressed()
		btn_make_tex_erm.pressed()
	)
	
	on btn_MakePlanes pressed do
	(
		if selection.count > 0 then
		(
			i = selection[1]
			p = plane pos:i.pos length: (i.max.z-i.min.z) width: (i.max.x-i.min.x) lengthsegs:1 widthsegs:1 
			rotate p (eulerangles 90 0 0)
			p.pivot.z = p.min.z
			p.pos.z = i.pos.z
			addmodifier p (mirror mirror_axis:2 Mirror_Offset:-0.01 copy: true)
		)
	)
	
	on btn_Udim_Rescale pressed do --with undo "Rescale To Density" on 
	(	
		if selection.count == 1 then
		(
			local theMapSize = case (ddl_texture_Rescale_size.selection as integer) of
			(
				1: 256
				2: 512
				3: 1024
				4: 2048
				5: 4096
			)
			local textureArea = theMapSize^2 -- Calculate the total texture area
			unwrapmod = modpanel.getcurrentobject()
			faces = #{} 
		
			max modify mode
			if unwrapmod != undefined and classof unwrapmod != Unwrap_UVW then 
			(
				if validModifier selection[1] (Unwrap_UVW()) then addmodifier selection[1] (Unwrap_UVW())
				unwrapmod = modpanel.getcurrentobject()
			)
			if unwrapmod != undefined and classof unwrapmod == Unwrap_UVW then
			(
				faces = unwrapmod.getselectedfaces()
				unwrapmod.setPolygonMode true
				unwrapmod.setTVSubObjectMode 3	
				if faces.count > 0 then
				(
					unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
					usedAreaPixels = mAreaUVW * textureArea -- Calculate the used area
					texelDensity = sqrt (usedAreaPixels/mAreaGeom) -- Calculate the texel density
				)
				local sc = spn_Udim_Rescale_Density.value / texelDensity
				local pos = unwrapmod.getSelCenter()
				unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter (sc) 0
				local pos_post = unwrapmod.getSelCenter()
				format "scale=% pos=% posnew=%\n" sc pos pos_post
			)
		)
		else messageBox ("Select single object")

	)
	
	on btn_MakeLowpolyPlant pressed do
	(
		global items_pl = #()
		global items_br = #()
		global dir_path = ""
		
		if selection.count > 0 then 
		(
			for i in selection where classof i.baseobject == Plane do
			(
				if i.parent != undefined then 
					if classof (i.parent).baseobject != Plane then appendIfUnique items_pl i.name
			)
			
			for i in selection where classof i.baseobject != Plane and findstring i.name "_branch" != undefined do
			(
				if i.children != undefined then
					if (for j in i.children where classof j.baseobject == plane collect j).count == 0 then append items_br i.name 
			)
			for i in selection do 
			(
				if i.parent == undefined then dir_path = i.name + "\\"
				if i.parent != undefined then
				(
					if (i.parent).parent != undefined then
					(
						if ((i.parent).parent).parent != undefined then dir_path = (((i.parent).parent).parent).name + "\\" 
						else dir_path = ((i.parent).parent).name + "\\"
					)
					else
					(
						dir_path = (i.parent).name + "\\"
					)
				)
				else dir_path = i.name + "\\"
			) 
		)
		
		try(destroyDialog ::Tree)catch()
		rollout Tree "Lowpoly Tree maker" width:300 height:830
		(
			group "Branches Detector"
			(
				--button start "Find IDs" align:#left width:100 across:2 enabled:false tooltip:"? ??????. Find IDs in selected Tree (by form of elements of Tree and material)"
			
				checkbox chk_fruits "Have fruits-blossom" checked:false across:2 width:80 align:#left tooltip:"????????, ???? ?????? ????? ????? ??? ?????? | Check it if tree have fruits or blossom"
				edittext edt_fruits "IDs" text:"7" width:80 fieldwidth:70 align:#left offset:[-45,0] tooltip:"IDs ?????? ??? ??????? | IDs fruits or blossom"

				checkbox chk_leafs "Have leaves" checked:true across:3 width:80 align:#left tooltip:"????????, ???? ?????? ????? ?????? | Check it if tree have leaves"
				edittext edt_leafs "IDs" text:"3,4,5" width:80 fieldwidth:70 align:#left offset:[0,0] tooltip:"IDs ??????? | IDs leaves"
				--radiobuttons rdo labels:#("Use IDs", "Use Material") default:1 columns:1 rows:2 offset:[10,-28] align:#right tooltip:""
				checkbox chk_leafs_from_trunks "tr>lv" checked:false width:45 align:#right tooltip:"????????, ???? ?????? ????? ?????? ??????? ?? ??????? ????? ? ???????, ???? ??? ?????? ??????? | Check it if tree have leaves near trunks without twigs"	
				
				checkbox chk_twigs "Have twigs" checked:true across:3 width:80 align:#left tooltip:"????????, ???? ?????? ????? ????????? ??????? ????? ??????? ? ????????, ???? ???? ID ?????????? | Check it if tree have small twigs between trunks and leafs, even if have the same IDs"
				edittext edt_twigs "IDs" text:"2" width:80 fieldwidth:70 align:#left offset:[0,0] tooltip:"IDs twigs\nIDs ????????? ???????"
				spinner spn_twigs_Cycles "Cycles" range:[1, 10, 1] type:#integer offset:[0,0] fieldWidth:15 align:#right tooltip:"?????????? ?????? ?????? | Searching cycles"
	
				checkbox chk_trunks "Have trunks" checked:true across:3 width:80 align:#left enabled:false tooltip:"??????????????, ??? ?????? ?????? ????? ?????, ????????? ?????? | Suppose that tree have trunks"
				edittext edt_trunks "IDs" text:"1" width:80 fieldwidth:70 align:#left tooltip:"IDs ????? | IDs trunks"
				button btn_find_set_trunks "Find & Set ID" width:80 align:#right tooltip:"????? ? ?????? ????? ? ????????? ?? ID | Find & Set IDs for trunks"
				
				checkbox chk_stems "Have stems" checked:true across:3 width:80 align:#left tooltip:"????????, ???? ?????? ????? ?????(?) | Check it if tree have stem(s)"
				edittext edt_stems "IDs" text:"6" width:80 fieldwidth:70 align:#left tooltip:"IDs ??????? | IDs stems"
				button btn_find_set_stems "Find & Set ID" width:80 align:#right tooltip:"????? ? ?????? ?????? ? ????????? ?? ID | Find & Set IDs for stems"
				
				spinner spn_distance "Seaching Distance" range:[0.0, 100.0, 0.05] type:#float fieldWidth:40 align:#left across:3 tooltip:"?????? ?????? ??????????? ????????? (? ??????), ??????? ???????? ???????? ? ??????? ????????? ?? ???????? ????? | Searching distance between elements of tree, larger values may take bad elements from other branches"
				checkbox chk_use_stems_distance "Stem" checked:true width:15 offset:[45,0] tooltip:"?? ????????: ??? ?????????? ????? ????? ?? ???????\n????????: ?????????? ??????? ????? ?? ?????? | When unchecked, do not separates brunches near stem\nWhen checked, separates very close branches to stem"
				spinner spn_distance_stem "Stem Diameter" range:[0.0, 100.0, 0.2] type:#float fieldWidth:40 align:#right tooltip:"??????????????? ??????? ??????, ????? ??? ????????? ????? ?? ?????? | Guess diameter of central stem, need to separation very close branches to stem"	
				spinner spn_distance_far "Far" range:[0.5, 100000, 2.0] type:#float width:50 fieldWidth:30 align:#left across:4 tooltip:"???????????? ????? ?????? ????? (??????? ???? ?????? ????? ??????? ?????) | Far distance range"
				checkbox chk_separate_trunks "Separate" checked:false offset:[-10,0] tooltip:"????????/????????? ??????? ????????? ?????????????? ????? ???? ?? ????? | When checked, try separate trunks from each other"
				spinner spn_branches_top_distance "Top" range:[0.0, 10000, 1.0] offset:[-10,0] type:#float width:50 fieldWidth:30 tooltip:"?????????? ?? ????? ?????? (?? ??????), ????? ??? ??????????? ?????? ??????? ????? | Distance from top of the tree"	
				spinner spn_rubbish "Rubbish" range:[0.001, 10000, 0.2] type:#float width:50 fieldWidth:30 align:#right tooltip:"??? ????? ?????? ????? ???????? ?????????? ??? ???????? ? ???????????? | All branches smaller treated as rabish"	

				checkbox chk_branches_all "Find All branches" checked:true across:3 width:100 align:#left tooltip:"??????? ?????? ??? ????? ???????? ?????????? ????? | Try to find as lot of branches as possible"
				spinner spn_branches_count "Find Only" enabled: false range:[1, 10000, 4] type:#integer width:50 offset: [20,0] fieldWidth:20 tooltip:"??????? ?????? ?????? ?????????? ????? ??????? ????? ?? ???? ????? | Should find only firsts number of all branches"	
				button btn_tree "Tree" align:#right width:80 tooltip:"????? ? ???????? ????? ????? ? ?????????? ??????\n????? ? ???????? ????? ?????? ?????? n ????? ??????? ?????, ??? ???????? | Find and create Branches in selected Tree\nFind all or only first few longest, as selected"

				progressBar pb "ProgressBar" align:#center width:280 height:5
				label lbl "Idle" width:280 align:#left style_sunkenedge:false	
			)
			group "Branches Planes Creation and Render"
			(		
				button rotate_obj_parallel_y "Rotate to Y" align:#left width:60 across:4 tooltip:"????????? ????? ? ??? Y (?????? ?? ???? ????????, ???????????? ????????) | Rotate branch to Y AXIS"
				button rotate_obj_parallel_z "Rotate to Z" width:60 tooltip:"????????? ????? ? ??? Z (?????? ?? ???? ????????, ???????????? ????????) | Rotate branch to Z AXIS"
				button create_plane_branch "Create planes" align:#right width:70 tooltip:"???: ??????????? ???? ?????????? ????? ? ??????? ?????????\n???: ??????????? ??? ?????????? ????? ? ??????? ?? ????????? | LMB: Render single Branch and Create Plane(s)\nRMB: Render few selected Branches and Create Planes with parameters"
				spinner spn_multy_render "Mult." range:[0.01, 1000, 2.0] type:#float fieldWidth:30 align:#right tooltip:"????????? ??????? ???????? ??? ?????????? ????? | Multipler for render size of branches"
		
				checkbox chk_hor_planes "Horizontal planes" checked:true across:3 width:100 align:#left tooltip:"????????? ?????????????? ????????? ??? ????? | Make horizontal planes from branches"	
				checkbox chk_vert_planes "Vertical planes" checked:true offset:[10,0] width:100 enabled:false tooltip:"????????? ???????????? ????????? ??? ????? | Make also vertical planes from branches"	
				spinner spn_angle_rotation "Accuracy" range:[0.1, 45.0, 5.0] type:#float fieldWidth:30 align:#right tooltip:"???????? ???? ???????? ?????, ? ???????? | Accuracy angle for branches rotation"
					
				checkbox chk_dual_planes "Dual planes" checked:true across:3 width:80 align:#left tooltip:"????????? ??????? ????????? ? ???????????????? ????????? (?????) | Make dual planes with opposite normals (better)"
				checkbox chk_dual_planes_render "Render other side" checked:true width:110 offset:[-10,0] tooltip:"???? ????????, ??????????? (??????) ????????? ????? ??????????? ? ????????? ???????? (?????)\n???? ?? ???????? - ???????? ????? ??????????? ? ??????? ????????? ? ?????????? ?????????? (????) | Dual (bottom) plane should be render to another texture (better)\nWhen unchecked - texture will be copied and mirrored from top side (worse)"
				spinner spn_rot_ang "Angle" range:[0.0, 180.0, 0.0] type:#float fieldWidth:40 align:#right toolTip:"????????????? ??????? (??????) ????? | Interactive changing for branches rotation"   
				
				spinner spn_plane_count_h "Plane hor. segments" range:[1, 1000, 2] type:#integer fieldWidth:20 align:#left across:2 tooltip:"????????????? ????????? ????? ????????? ????????? ????? ?? ??????????? (?????????? ???????) | Interactive changing of horizontal segments number for planes branches"
				spinner spn_plane_count_v "Plane ver. segments" range:[1, 1000, 3] type:#integer fieldWidth:20 align:#right tooltip:"????????????? ????????? ????? ????????? ????????? ????? ?? ????????? (?????????? ???????) | Interactive changing of vertical segments number for planes branches"
				
				spinner spn_bend_h "Bend hor. angle" range:[0.0, 180.0, 10.0] type:#float fieldWidth:40 across:2 align:#left toolTip:"????????????? ????????? ??????????? ???? ????? ? ????????????? ????? | Interactive changing for bend modifiers"   
				spinner spn_bend_v "Bend ver. angle" range:[0.0, 180.0, 30.0] type:#float fieldWidth:40 align:#right toolTip:"????????????? ????????? ??????????? ???? ????? ? ????????????? ????? | Interactive changing for bend modifiers"   

				button btn_tex_path "Path" across:2 align:#left width:30 tooltip:""
				edittext edt_tex_path "" text:(udims.edt_multimat_path.text + dir_path) align:#right width:240 fieldwidth:260 align:#right
			)
			group "Distribution FEW Planes to All other Branches"
			(
				MultiListBox mlbList_pl "List of planes:" items:items_pl width:138 height:10 selection:#() across:2 toolTip:"?????????? ????????????? ?????-????????? ??? ???????????, ?????? | List of unique planes-branches to be copied"
				MultiListBox mlbList_br "List of branches:" items:items_br width:138 height:10 selection:#() toolTip:"3D ?????, ?? ??????? ???? ??????????, ?????? | List of 3D branches"	
	
				button btn_Add_pl "Add" across:6 align:#left toolTip:"???????? ??????? ? ??????? ????????, ??????????? ?????? ??????????? ??????? ?????????-????? | Select objects and press Add, adds only valid planes" 
				button btn_Remove_pl "Remove" align:#left offset:[-8,0] toolTip:"??????? ?????????? ?????? ?? ?????? | Remove selected items from list" 
				button btn_Clear_pl "Clear" align:#left toolTip:"???????? ?????? | Clear all items from list" 
				button btn_Add_br "Add" align:#right toolTip:"???????? ??????? ? ??????? ????????, ??????????? ?????? ??????????? ??????? 3D ????? | Select objects and press Add, adds only valid branches"
				button btn_Remove_br "Remove" align:#right offset:[8,0] toolTip:"??????? ?????????? ?????? ?? ?????? | Remove selected items from list" 	
				button btn_Clear_br "Clear" align:#right offset:[2,0] toolTip:"???????? ?????? | Clear all items from list" 
				button btn_box_branches "Bound boxes" across:3 align:#left toolTip:"?????????? ??? ?????????? ????? ? ???? ?????????? ??????????? | Set all selected branches as bounding boxes" 	
				button btn_select_branches_planes "Select planes" offset:[-15,0] toolTip:"???: ???????? ??? ????????? ?? ????? ????????? ????????\n???+???: ???????? ?????? ????? ?? ?????????? ??????????\n???+CTRL: ???????? ????? ????????\n???+ALT: ???????? ?????????\n???+CRTL+ALT: ?????? ????????? ???????? ????????\n???: ??????? ?????? ?????????? ????????? ?? ???? ?????????? ??????????\n???+CTRL: ?????? ????????? ? ?????????? ?????????? ?? ???? ?????????? ?????????? | LMB: Select all planes from all selected\nLMB+LMB: Select children from selected planes\nLMB+CTRL: Select children\nLMB+ALT: Select parents\nLMB+CRTL+ALT: Deselect children\nRMB: Select only unique planes from selected\nRMB+CTRL: Deselect unique planes from selected"
				button btn_Distribute "Distribute Planes" align:#right width:100 tooltip:"?????????? ?????? ?????????? ?? ?????? 3D ?????, ??? ?????????? ????? ??????? ????????? ????????, ????????? ??????????? ??????? ?????????? ?? ????????? ????? ? ????????, ??? ????? ? ?????? ????????? ???????? | Distribute left list to right list"	
				progressBar pb2 "ProgressBar" align:#center width:280 height:5
			)
			group "Unwrap Branches Planes"
			(
				button btn_Del_Unwrap "Delete Unwraps" width:90 align:#left across:3 tooltip:"??????? ??? ???????????? ????????? ?? ???? ?????????? | Delete all unwrap modifiers from all planes"
				button btn_Unwrap "Unwrap together" offset:[5,0] width:90 tooltip:"?????????? ??? ?????????? ?????????-????? ?????? ? ???? UDIM ? ????? ????? ??????? ????????? ? ?????????? ??????? ? ??????? ?????????? ??????? | Unwrap selected plane-branches to one UDIM with one diffuse and opacity texture with target texels density"
				button btn_Collapse "Collapse together" width:90 align:#right tooltip:"C????? ??? ?????????? ??????????? ?????????-????? ? ???? ????? (??? ??????), ????????? ????? ???????? | Collapse selected planes to whole tree (without stems), get common material"
				label lbl_tex_size "Texture Size" align:#left across:3 tooltip:"?????? ???????? | Texture Size"
				dropdownlist ddl_Tex_size "" items: #("256","512","1024","2048","4096") selection:5 height:20 width:60 fieldWidth:60 offset:[-10,0] align:#left toolTip:"??????? ?????? ???????? | Target texture size"
				spinner spn_target_density "Target Density" range:[512.0, 1706.0, 520.0] type:#float fieldWidth:45 align:#right toolTip:"??????? ????????? ??????? | Target texels density" 
			)	
			group "Remesh and Unwrap Stems"
			(
				button btn_Stem_Remesh_Unwrap "Remesh Stem" width:80 align:#left across:3 tooltip:"???????? ?????? ?????? ?????? ? ??????? ?????? ??????????? ????? ? ????????? ?????? | Select only stems object and press Remesh Unwrap Stem"	
				spinner spn_target_density_stem "Density" enabled:false range:[512.0, 1706.0, 1700.0] type:#float fieldWidth:43 offset:[-12,0] toolTip:"??????? ????????? ??????? ??? ?????? | Target texels density stem" 
				spinner spn_target_polys "Polycount" range:[1, 100000, 1000] type:#integer fieldWidth:40 align:#right toolTip:"??????? ????? ????????? ?????? | Target count of poly of stem" 
				button btn_paste_stem "Blend Tex" width:80 align:#left toolTip:"?????? ?????? ????????? ????????? ???? ?????????? ????????????? ?????????, ????? ??? ???????? ??????? ?????? ? ????? | Blend together few material's diffuse textures according to unwrap, need to blend stem texture to branches texture" 
			)
			button btn_save "Save" across:3 width:60 align:#left tooltip:"????????? ????????? ? ???? | Save options to file"
			button btn_load "Load" width:60 tooltip:"????????? ????????? ?? ????? | Load options from file"
			button btn_close "Close" width:60 align:#right toolTip:"??????? ???? ?????? | Close this dialog" 
			
			fn qpos i j = --?????????? ?? ???????, ?????? ??-? ????? ???????
			(
				o = 0
				if i[5] > j[5] then o = -1
				if i[5] < j[5] then o = 1
				o
			)
			
			fn qgab i j = --?????????? ?? ????????????
			(
				o = 0
				if abs(i[3]-i[4]) > abs(j[3]-j[4]) then o = -1
				if abs(i[3]-i[4]) < abs(j[3]-j[4]) then o = 1
				o
			)
		
			fn to_elements s faces =
			(
				elems = #()
				part_of_faces = faces
				while not part_of_faces.isempty do with redraw off
				(
					if keyboard.escPressed then exit
					for i in part_of_faces where not keyboard.escPressed do 
					(
						elem = polyOp.getElementsUsingFace s #{i}
						vv = polyop.getVertsUsingFace s elem
						pp = for v in vv collect polyop.getVert s v
						xx = 0
						yy = 0
						zz = 0
						nn = pp.count
						for p in pp do 
						(
							xx += p.x
							yy += p.y
							zz += p.z
						)
						xx /= nn
						yy /= nn
						zz /= nn
						
						if pp != undefined then 
						(
							append elems #(elem, pp, [xx,yy,zz]) 
						)
						part_of_faces -= elem
						exit
					)
					pb.value = (100 - (100*part_of_faces.numberset/faces.count)) as integer
				)
				elems
			)	

			fn find_largestXY elems =
			(
				maxi = 0
				el = 1
				if elems.count > 0 then
				(
					for i in #{1..elems.count} do
					(
						xx = for j in elems[i][2] collect j.x
						yy = for j in elems[i][2] collect j.y
						zz = for j in elems[i][2] collect j.z
						--max_xx = amax xx
						--max_yy = amax yy
						--max_zz = amax zz
						--min_xx = amin xx
						--min_yy = amin yy
						--min_zz = amin zz
						--x = abs(max_xx - min_xx)
						--y = abs(max_yy - min_yy)
						--z = abs(max_zz - min_zz)
						--w = sqrt (x*x + y*y + z*z)
						--w = amax #(abs(amax(xx)-amin(xx)), abs(amax(yy)-amin(yy)), abs(amax(zz)-amin(zz)) ) 
						w = amax #(abs(amax(xx)-amin(xx)), abs(amax(yy)-amin(yy)) ) 	
							--sqrt(abs(amax(xx)-amin(xx))^2 + abs(amax(yy)-amin(yy))^2)
						if w > maxi then 
						(
							maxi = w
							el = i
						)
						pb.value = (100 - (100 * i / elems.count)) as integer
					)
				)
				el
			)
			
			fn find_largestZ elems =
			(
				size = 0
				el = 1
				if elems.count > 0 then 
				(
					for i in #{1..elems.count} where (w = abs(amax(ww = for j in elems[i][2] collect j.z) - amin(ww))) > size do
					(			
						size = w
						el = i
					)
				)
				el
			)
			
			fn find_point_nearest_stem elems poi =
			(
				pos = poi
				if elems.count > 0 then
				(
					d = for p in elems[2] collect #(distance [poi.x, poi.y, p.z] p, p)
					mind = amin (for p in d collect p[1])
					pos = for i in #{1..d.count} where d[i][1] == mind do exit with d[i][2] --el = d[findItem d (amin d)]
				)
				pos
			)
/*			
			fn by_distance elems1 elems2 e1 t =
			(		
				arr = #()
				if elems1.count > 0 and elems2.count > 0 and e1 <= elems1.count then
				(
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100*e2/elems2.count) as integer
						for v in elems1[e1][2] where not found do --?????????? ??????? ?????? ????? 
						(
							for w in elems2[e2][2] where distance v w <= t do 
							(
								appendIfUnique arr #(elems2[e2][1], elems2[e2][2])
								exit with found = true
							)
						)
					)
				)
				arr
			)	
*/
			fn by_distance_ex_ elems1 elems2 e1 t po m far =
			(		
				arr = #()	
				nums = #{}
				if elems1.count > 0 and elems2.count > 0 and e1 <= elems1.count then
				(				
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100 * e2 / elems2.count) as integer
						for v in elems1[e1][2] where not found do --?????????? ??????? ?????? ????? 
						(
							if distance v elems2[e2][3] > far then continue
							for w in elems2[e2][2] where distance v w <= t and distance w [po.x, po.y, w.z] >= m do 
							(
								append arr #(elems2[e2][1], elems2[e2][2], elems2[e2][3])
								append nums e2
								exit with found = true
							)
						)
					)
					elems2 = for i in (#{1..elems2.count} - nums) collect #(elems2[i][1], elems2[i][2], elems2[i][3])
				)
				#(arr, elems2)
			)	
			
			fn by_distance_ex_3 elems1 elems2 e1 t po m top_z far =
			(		
				arr = #()	
				nums = #{}
				if elems1.count > 0 and elems2.count > 0 and e1 <= elems1.count then
				(				
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100 * e2 / elems2.count) as integer
						for v in elems1[e1][2] where not found do --?????????? ??????? ?????? ????? 
						(
							if distance v elems2[e2][3] > far then continue
							--for w in elems2[e2][2] where distance v w <= t and distance w [po.x, po.y, w.z] >= m do 
							for w in elems2[e2][2] where distance v w <= t and distance w [po.x, po.y, (if w.z >= top_z then top_z else w.z) ] >= m do 
							(
								append arr #(elems2[e2][1], elems2[e2][2], elems2[e2][3])
								append nums e2
								exit with found = true
							)
						)
					)
					elems2 = for i in (#{1..elems2.count} - nums) collect #(elems2[i][1], elems2[i][2], elems2[i][3])
				)
				#(arr, elems2)
			)	
			
			fn by_distance_ex_2 elems1 elems2 e1 t far =
			(		
				arr = #()	
				nums = #{}
				if elems1.count > 0 and elems2.count > 0 and e1 <= elems1.count then
				(				
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100 * e2 / elems2.count) as integer
						for v in elems1[e1][2] where not found do --?????????? ??????? ?????? ????? 
						(
							if distance v elems2[e2][3] > far then continue
							for w in elems2[e2][2] where distance v w <= t do 
							(
								append arr #(elems2[e2][1], elems2[e2][2], elems2[e2][3])
								append nums e2
								exit with found = true
							)
						)
					)
					elems2 = for i in (#{1..elems2.count} - nums) collect #(elems2[i][1], elems2[i][2], elems2[i][3])
				)
				#(arr, elems2)
			)	
/*			
			fn by_distance_ex elems1 elems2 e1 t po m =
			(		
				arr = #()	
				if elems1.count > 0 and elems2.count > 0 and e1 <= elems1.count then
				(		
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100 * e2 / elems2.count) as integer
						for v in elems1[e1][2] where not found do --?????????? ??????? ?????? ????? 
						(
							for w in elems2[e2][2] where distance v w <= t and distance w [po.x, po.y, w.z] >= m do 
							(
								append arr #(elems2[e2][1], elems2[e2][2])
								found = true
								exit
							)
						)
					)
				)
				arr
			)
*/			
			fn by_distance_all_ elems1 elems2 t far =
			(		
				arr = #()	
				nums = #{}
				if elems1.count > 0 and elems2.count > 0 then
				(				
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100 * e2 / elems2.count) as integer
						for e1 in #{1..elems1.count} where not found and not keyboard.escPressed do
						(
							if distance elems1[e1][3] elems2[e2][3] > far then continue
							for v in elems1[e1][2] where not found do 
							(
								for w in elems2[e2][2] where distance v w <= t do 
								(
									append arr #(elems2[e2][1], elems2[e2][2], elems2[e2][3])
									append nums e2
									exit with found = true
								)
							)
						)
					)
					elems2 = for i in (#{1..elems2.count} - nums) collect #(elems2[i][1], elems2[i][2], elems2[i][3])
				)
				#(arr, elems2)
			)			
/*
			fn by_distance_all elems1 elems2 t =
			(		
				arr = #()	
				if elems1.count > 0 and elems2.count > 0 then
				(				
					for e2 in #{1..elems2.count} where not keyboard.escPressed do 
					(
						found = false
						pb.value = (100*e2/elems2.count) as integer
						for e1 in #{1..elems1.count} where not found and not keyboard.escPressed do
						(
							for v in elems1[e1][2] where not found do 
							(
								for w in elems2[e2][2] where distance v w <= t do 
								(
									append arr #(elems2[e2][1], elems2[e2][2])
									exit with found = true
								)
							)
						)
					)
				)
				--print elems1.count
				--print arr.count
				--print #(arr)
				arr
			)
*/			
			fn subarray b =
			(
				a = #{}				
				if b.count > 0 then 
					for i in #{1..b.count} do a += b[i][1]
				a
			)
			
			fn delete_elems_arr a b =
			(
				c = #()
				if a.count > 0 then
				(
					if b.count > 0 then
					(
						for j in #{1..a.count} do 
						(
							found = false
							for i in #{1..b.count} where (b[i][1] - a[j][1]).isempty do exit with found = true
							if not found then append c #(a[j][1], a[j][2]) 
						)
					)
					else c = a
				)
				c
			)
			
			fn rotate_to_Y s step =  			
			(
				gc()
				angles = 0.0 
				if s != undefined then
				(
					max create mode
					ss = copy s
					ResetXForm ss
					converttopoly ss
					mY = ss.max.y --abs(ss.max.y - ss.min.y)
					delete ss
					for ang = -180 to 180 by step where not keyboard.escPressed do
					(
						ss = copy s
						ResetXForm ss
						converttopoly ss
						in coordsys world rotate ss (eulerangles 0 0 ang)
						ResetXForm ss
						converttopoly ss
						--mX = abs(ss.max.x - ss.min.x)
						mmY = ss.max.y --abs(ss.max.y - ss.min.y)
						--format "mY=% mmY=% angle=%\n" mY mmY ang
						if mmY > mY then
						(
							mY = mmY 
							angles = ang
						)
						delete ss
					)
					--print angles
					--rotate s (eulerangles 0 0 angles)
				)
				angles
			)
			
			fn rotate_to_Z s step angleY =  			
			(
				gc()
				angles = 0.0 
				if s != undefined then
				(
					max create mode
					sss = copy s
					ResetXForm sss
					converttopoly sss
					rotate sss (eulerangles 0 0 angleY)
					ResetXForm sss
					converttopoly sss
					mZ = sss.max.y --abs(sss.max.z - sss.min.z) mZ = abs(s.max.z - s.min.z)
					for ang = -180 to 180 by step where not keyboard.escPressed do
					(
						ss = copy sss
						ResetXForm ss
						converttopoly ss
						in coordsys world rotate ss (eulerangles ang 0 0)
						ResetXForm ss
						converttopoly ss
						mmZ = ss.max.y --abs(ss.max.z - ss.min.z)
						--format "mZ=% mmZ=% angle=%\n" mZ mmZ ang
						if mmZ > mZ then
						(
							mZ = mmZ 
							angles = ang
						)
						delete ss
					)
					delete sss
					--print angles
					--rotate s (eulerangles angles 0 0)
				)
				angles
			)
			
			fn create_plane s normal = 
			(
				gc()
				pl = undefined
				if s != undefined then
				(
					ss = copy s
					select ss	
					
					ResetXForm ss
					converttopoly ss
					angleY = rotate_to_Y ss (spn_angle_rotation.value)
					in coordsys world rotate ss (eulerangles 0 0 angleY)
					ResetXForm ss
					converttopoly ss
					angleZ = rotate_to_Z ss (spn_angle_rotation.value) 0.0
					in coordsys world rotate ss (eulerangles angleZ 0 0)
					ResetXForm ss
					converttopoly ss

					mX = abs(ss.max.x - ss.min.x)
					mY = abs(ss.max.y - ss.min.y)
					mZ = abs(ss.max.z - ss.min.z)	
					
					size = if mX > mY then mX else mY
						
					pl = plane name:(s.name + "_Plane") length:mY width:mX pos:[ss.center.x, ss.center.y, ss.pos.z] rotation:ss.rotation lengthsegs:spn_plane_count_v.value widthsegs:spn_plane_count_h.value
					pl.pivot = ss.pos
					delete ss		
					
					addmodifier pl (uvwmap length:size width:size maptype:0 axis:2) --addmodifier pl (uvwmap length:mY width:mX maptype:0 axis:2)
					addmodifier pl (MaterialModifier materialID: 1)
					
					if normal then 
					(
						addmodifier pl (MaterialModifier materialID: 2)
						addmodifier pl (Normalmodifier flip: true)
						--in coordsys local 
							move pl [0, 0, -0.01]
						pl.name += "002"
					)
					else pl.name += "001"

					in coordsys local rotate pl (eulerangles 0 0 -angleY)
					in coordsys local rotate pl (eulerangles -angleZ 0 0)
				)
				pl	
			)
			
			fn bend_plane pl =
			(
				if pl != undefined then
				(
					addModifier pl (bend BendAngle:spn_bend_h.value BendDir:90 BendAxis:1 Center:[0, pl.min.y - pl.center.y, 0])
					addModifier pl (bend BendAngle:-spn_bend_v.value BendDir:0 BendAxis:0 Center:[0, pl.min.y - pl.center.y, 0])
				)	
				pl			
			)
			
			fn render_branch ss filename dual_render dual multy =
			(
				gc()
				mat = undefined
				if ss != undefined then
				(
					ResetXForm ss
					converttopoly ss
					
					mX = abs(ss.max.x - ss.min.x)
					mY = abs(ss.max.y - ss.min.y)
					mZ = abs(ss.max.z - ss.min.z)
					size = if mX > mY then mX else mY
						
					ss.receiveShadows = false
					ss.castShadows = false
					
					cam = freeCamera fov: ((1.013 * 2.0 * (atan (size / 2.0))) as float) name:"Camera001" pos:[ss.center.x, ss.center.y, ss.center.z + (mZ * 10)] dir:[0,0,1] orthoProjection:true targetDistance:1.0
					select ss
					
					max hide inv
					viewport.setLayout #layout_4 
					viewport.activeViewportEx 4
					viewport.setCamera cam
					IsolateSelection.EnterIsolateSelectionMode()
					setRenderType #view
					
					renderSceneDialog.close()
					pngio.setAlpha true
					pngio.setType #true24
					
					rendSaveFile = true
					rendOutputFilename = (udims.edt_multimat_path.text + dir_path + filename)
					backgroundColor = color 0 0 0
					FileInGamma = 1
					FileOutGamma = 2.2
					displayGamma = 2.2
					rendTimeType = 1 --single frame
					renderWidth = (size * multy * 1000) as integer --(mX / mY) * 4096 as integer
					renderHeight = (size * multy * 1000) as integer --4096 --mY as integer
					pngio.setAlpha true
					pngio.setType #true24

					if Renderers.Production != "Corona:Corona" then for rnd in 1 to (rendererClass.classes).count where matchPattern ((rendererClass.classes)[rnd] as string) pattern:"Corona" do Renderers.Production = RendererClass.Classes[rnd]()
					
					if ((maxversion())[1] / 1000) - 2 + 2000 == 2025 then ColorPipelineMgr.mode = #gamma 
					else 
					(
						IDisplayGamma.colorCorrectionMode = #gamma 	
						IDisplayGamma.colorCorrectionPrefMode = #gamma
					)
					
					vr = renderers.current
					try
					(					
						vr.bg_source = 1 --single map
						vr.bg_texmapUseDirect = true
						vr.bg_overrideDirect = true
						vr.bg_colorDirect = color 0 0 0
						vr.bg_color = color 255 255 255 

						vr.adaptivity_targetError = 3.0 
						vr.progressive_passLimit = 50
						vr.lights_useAdaptiveSolver = true 
					)catch()
		
					try 
					(
						renderers.current.colorMap_pipeline = IdentityOperatorPlugin() --delete all operators
						op = ReinhardOperatorPlugin()
						setProperty op "colorMappingOperator.id" 1
						setProperty op "colorMappingOperator.enabled" true
						setProperty op "colorMappingOperator.highlightCompression" 1.0
						setProperty renderers.current "colorMap.pipeline" op
						
						pipeline = getProperty renderers.current "colorMap.pipeline"
						while pipeline != undefined do
						(
							operatorClass = classOf pipeline
							if operatorClass == ReinhardOperatorPlugin then exit
							pipeline = getProperty pipeline "colorMappingOperator.nextOperator"
						)
						if pipeline != undefined then setProperty pipeline "colorMappingOperator.highlightCompression" 1.0

					)
					catch()
					
					if not doesDirectoryExist (udims.edt_multimat_path.text + dir_path) then makedir (udims.edt_multimat_path.text + dir_path) all:true	
					--if doesFileExist rendOutputFilename do deleteFile rendOutputFilename
					
					max quick render
					CoronaRenderer.CoronaFp.showvfb false
					--HiddenDOSCommand ("magick " + "\"" + rendOutputFilename + "\"" + " -background none -gravity Center -extent 4096x4096 -background none -alpha Background -define png:color-type=6 " + "\""+ rendOutputFilename + "\"") startpath:(GetINI_ImageMagick())
					--HiddenDOSCommand ("magick " + "\"" + rendOutputFilename + "\""+ " PNG24:" + "\""+ rendOutputFilename + "\"") startpath:(GetINI_ImageMagick())	
					delete cam
						
					if dual_render then
					(
						rendOutputFilename = (udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename) 
						cam = freeCamera fov: ((1.013 * 2.0 * (atan (size / 2.0))) as float) name:"Camera001" pos:[ss.center.x, ss.center.y, ss.center.z - (mZ * 10)] dir:[0,0,-1] orthoProjection:true targetDistance:1.0
						rotate cam (eulerangles 0 0 180) 
						viewport.setCamera cam
						max quick render
						CoronaRenderer.CoronaFp.showvfb false
						HiddenDOSCommand ("magick " + "\"" + rendOutputFilename + "\"" + " -background none -gravity Center -flop -background none -alpha Background -define png:color-type=6 " + "\""+ rendOutputFilename + "\"") startpath:(GetINI_ImageMagick())
						--HiddenDOSCommand ("magick " + "\"" + rendOutputFilename + "\"" + " -background none -gravity Center -flop -extent 4096x4096 -background none -alpha Background -define png:color-type=6 " + "\""+ rendOutputFilename + "\"") startpath:(GetINI_ImageMagick())
						--HiddenDOSCommand ("magick " + "\"" + rendOutputFilename + "\""+ " PNG24:" + "\""+ rendOutputFilename + "\"") startpath:(GetINI_ImageMagick())	
						delete cam
					)
					
					if not dual_render and dual then
					(
						HiddenDOSCommand ("magick " + "\"" + (udims.edt_multimat_path.text + dir_path + filename) + "\"" + " -background none -gravity Center -flop -background none -alpha Background -define png:color-type=6 " + "\""+ (udims.edt_multimat_path.text + dir_path + filename) + "\"") startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + (udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename) + "\""+ " PNG24:" + "\""+ (udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename) + "\"") startpath:(GetINI_ImageMagick())	
					)
					
					IsolateSelection.ExitIsolateSelectionMode()						
					max unhide all			
					
					case of
					(
						(dual_render and dual):
						(
							mat = multimaterial numsubs:2 name:ss.name
							mat.materialList[1] = standard DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + filename)) OpacityMap: (BitmapTexture fileName: (udims.edt_multimat_path.text + dir_path + filename) preMultAlpha: false rgbOutput:1 ) name:(dir_path + filename)
							mat.materialList[2] = standard DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename)) OpacityMap: (BitmapTexture fileName: (udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename) preMultAlpha: false rgbOutput:1 ) name:(dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename)
						)
						(not dual_render and dual): 
						(
							mat = multimaterial numsubs:2 name:ss.name
							mat.materialList[1] = standard DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + filename)) name:(dir_path + filename)
							mat.materialList[2] = standard DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename)) name:(dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename)
						)					
						(dual_render and not dual): --?????? ????? ?????????
						(
							mat = multimaterial numsubs:2 name:ss.name
							mat.materialList[1] = standard DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + filename)) name:(dir_path + filename)
							mat.materialList[2] = standard DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename)) name:(dir_path + getfilenamefile filename + "_bottom" + getfilenametype filename)
						)					
						(not dual_render and not dual):
						(
							mat = multimaterial numsubs:1 name:ss.name
							mat.materialList[1] = standard name:ss.name DiffuseMap: (BitmapTexture fileName:(udims.edt_multimat_path.text + dir_path + filename)) name:(dir_path + filename)
						)
					)				
				)
				mat
			)	
			
			on Tree open do 
			(
				for i in Tree.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_Tree.ini") i.name "Tree" (syssetup.rdo_lang.state))
			)
			
			on btn_tex_path pressed do 
			(
				case udims.rdo_path.state of
				(
					1: edt_tex_path.text = maxFilePath + "Maps\\" + dir_path
					2: edt_tex_path.text = maxFilePath + "Images\\" + dir_path
					3: edt_tex_path.text = maxFilePath + udims.edt_path_end.text + dir_path
				)
			)
			
			on btn_tex_path rightclick do 
			(
				try
				(
					edt_tex_path.text = getSavePath caption:"Select Folder ..." initialDir: maxFilePath
					edt_tex_path.text += "\\"
				)catch()
			)
			
			on btn_Stem_Remesh_Unwrap pressed do with undo "Remesh and Unwrap Stem" on
			(
				if selection.count > 0 then
				(
					for o in selection where not keyboard.escPressed do
					(
						max modify mode
						addmodifier o (RetopologyComponent engineType:0 numFacesTarget:((spn_target_polys.value/2) as integer) outputMeshType:2  doAutomatedRemesh:true) ui:on
						o.modifiers[RetopologyComponent].ComputeRetopology()
						addmodifier o (uvwmap maptype:0 axis:2)
						addmodifier o (Turn_to_Poly limitPolySize:true maxPolySize:3)
					)
				)
			)
			
			on btn_Collapse pressed do with undo "Collapse Planes to One" on
			(
				if selection.count > 0 then
				(
					sel = for i in selection collect copy i
					--sel = selection as array
					for i in #{1..sel.count} where (classof sel[i].baseobject == Plane) and (sel[i].modifiers[Unwrap_UVW]) != undefined do 
						case i of 
						(
							1: 
							(
								addmodifier sel[1] (Edit_poly())
								collapsestack sel[1]
							)
							
							default:
							(
								polyop.attach sel[1] sel[i] 
							)
						)
					sel[1].material = meditMaterials[1]	
					sel[1].parent = undefined 
					resetxform sel[1]
					converttopoly sel[1]
					worldalignpivot sel[1]
					addmodifier sel[1] (Unwrap_UVW())
					sel[1].pivot = [sel[1].center.x, sel[1].center.y, sel[1].min.z]
					select sel[1]
				)
			)
			
			on btn_box_branches pressed do
			(
				if selection.count > 0 then 
					for i in selection where findstring i.name "branch" != undefined and i.parent != undefined /* and (for j in i.children where classof j.baseobject == Plane collect j).count != 0*/ do i.boxmode = true
			)
		
			on btn_select_branches_planes pressed do with undo "Select planes" on
			(
				ctrl = keyboard.controlPressed
				alt = keyboard.altPressed
				
				if selection.count > 0 then 
				(
					if not alt and not ctrl then
					(
						sel = #()
						for i in selection where findstring i.name "_branch" != undefined and i.parent != undefined and (for j in i.children where classof j.baseobject == Plane collect j).count != 0 do 
						(
							for j in i.children where classof j.baseobject == Plane do 
							(
								appendIfUnique sel j
								for k in j.children where classof k.baseobject == Plane do appendIfUnique sel k
							)
						)
						select sel
					)
					if alt and not ctrl then 
					(
						selectmore (for i in selection where i.parent != undefined collect i.parent)
					)

					if ctrl and not alt then
					(
						for i in selection where i.children != undefined do 
							for o in i.children do selectmore o
					)	
					
					if ctrl and alt then
					(
						for i in selection where i.children != undefined do 
							for o in i.children do deselect o
					)						
					
				)
			)	
			
			on btn_select_branches_planes rightclick do with undo "Select planes" on
			(
				if selection.count > 0 then 
				(
					ctrl = keyboard.controlPressed
					sel = #()
					mats = #()
					
					for i in selection where findstring i.name "branch" != undefined and i.parent != undefined and classof i.baseobject == Plane do appendIfUnique mats i.material
					if  mats.count > 0 then
					for m in mats do
					(
						ss = for s in selection where findstring (m.materialList[1].name) ((s.parent).name) != undefined collect s
						--for nm in s where s.material.materialList[(s.modifiers[MaterialModifier].materialID)] == m then 
						for s in ss do join sel s.children
						join sel ss
					)
					print #(sel)
					print sel.count
					if ctrl then deselect sel else select sel
				)
			)

			on btn_Distribute pressed do with undo "Distribute planes" on
			(
				if mlbList_pl.items.count > 0 and mlbList_br.items.count > 0 then
				(
					obj_items_pl = #()
					obj_items_br = #()
					
					items_pl = mlbList_pl.items as array
					items_br = mlbList_br.items as array
					
					obj_items_pl = for j in objects where (for i in items_pl where i == j.name collect i).count > 0 collect j  
					obj_items_br = for j in objects where (for i in items_br where i == j.name collect i).count > 0 collect j  
					
					print #(obj_items_pl)
					print #(obj_items_br)
					
					cou = 0
					for br in obj_items_br where not keyboard.escPressed do
					(
						cou += 1
						pb2.value = (100 * cou / obj_items_br.count) as integer
												
						--print pl_ini
						--print obj_items_pl[ind].material
						--pl1 = instance obj_items_pl[ind]
						--pl2 = pl1
						--if obj_items_pl[ind].children != undefined then 
						--	for i in obj_items_pl[ind].children do 
						--	(
						--		pl2 = instance i
						--	)
						--try(pl1.parent = undefined)catch() 
						--try(pl2.parent = undefined)catch()
						--try(pl1.children = #())catch()
						--try(pl2.children = #())catch()
						
						--pl1.pos = pl.pos
						--pl1.rotation = pl.rotation
						--try(append br.children pl1)catch()	
						--try(append pl1.children pl2)catch()	
						
						--in coordsys local pl1.scale.x *= pl1.baseobject.width / pl.baseobject.width 
						--in coordsys local pl1.scale.y *= pl1.baseobject.length / pl.baseobject.length 
						--delete pl
						
						local pl, pl2
						pl = create_plane br false 
						pl = bend_plane pl
						
						ind = random 1 (obj_items_pl.count) --???? ?? ????????? ? ????? ?? ??????? ?????????
						
						val = amin (for p in obj_items_pl where classof p.baseobject == Plane collect (abs(pl.baseobject.length - p.baseobject.length))) --abs(pl.baseobject.width - p.baseobject.width) 
						ind = for p in #{1..(obj_items_pl.count)} where classof obj_items_pl[p].baseobject == Plane do 
							if (abs(pl.baseobject.length - obj_items_pl[p].baseobject.length)) == val do exit with p
						--local pl_ini = obj_items_pl[ind]	
						
						pl.material = obj_items_pl[ind].material
						append br.children pl
						if chk_dual_planes.checked then 
						(
							pl2 = create_plane br true
							pl2 = bend_plane pl2
							pl2.material = obj_items_pl[ind].material	
							append pl.children pl2				
						)
						pl.baseobject.width = (obj_items_pl[ind].baseobject.width / obj_items_pl[ind].baseobject.length) * pl.baseobject.length
						pl2.baseobject.width = (obj_items_pl[ind].baseobject.width / obj_items_pl[ind].baseobject.length) * pl2.baseobject.length
					)
				)
				pb2.value = 100
			)
			
			on btn_close pressed do try(destroyDialog ::Tree)catch() --try(closeRolloutFloater Tree)catch()
			
			on btn_paste_stem pressed do
			(
				max modify mode
				sel = selection as Array
				info = #()
				if sel.count > 1 then 
				(
					for s in sel where s.material != undefined do
					(
						m = s.material
						ss = copy s
						convertToPoly ss
						
						sourcepath = ""
						case ((classof m) as string) of 
						(
							default: continue 
							"Standardmaterial": if m.DiffuseMap != undefined then if m.DiffuseMap.filename != undefined then sourcepath = m.DiffuseMap.fileName
							"Physical_Material": if m.base_color_map != undefined then if m.base_color_map.filename != undefined then sourcepath = m.base_color_map.fileName
							"CoronaLegacyMtl": if m.texmapDiffuse != undefined then if m.texmapDiffuse.filename != undefined then sourcepath = m.texmapDiffuse.filename
						)				
						print sourcepath
						faces = #{1..(polyop.getnumfaces ss)} --faces = polyOp.getFaceSelection ss
						if faces.count > 0 then
						(
							select ss
							addmodifier ss (Unwrap_UVW())
							unwrapmod = modpanel.getcurrentobject()
							unwrapmod.selectFaces faces	
							unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							if sourcepath != "" then
							(
								bm = openbitmap sourcepath
								if bm != undefined then
								(
									append info #(s, sourcepath, bm.width, bm.height, mX, mY, mWidth, mHeight)	
									close bm
									free bm
								)
							)
						)	
						delete ss	
					)
					--print #(info)
					select sel
				)
				if info.count > 1 then
				(
					mwid = amax (for i in info where findstring i[2] "all_branches_diffuse.png" != undefined collect i[3]) --width
					mhei = amax (for i in info where findstring i[2] "all_branches_diffuse.png" != undefined collect i[4]) --height
					file = (for i in info where findstring i[2] "all_branches_diffuse.png" != undefined do exit with i[2])
					filename = (getfilenamepath file) + (getfilenamefile file) + "+.png" --"C:\\Temporary Files\\!.png"
					print filename
					HiddenDOSCommand ("magick -size " + mwid as string + "x" + mhei as string + " xc:transparent -define png:color-type=6 " + "\"" + filename + "\"") startpath:(GetINI_ImageMagick())

					for i in info do
					(
						sourcepath = i[2]
						sourcepath_temp = (getfilenamepath sourcepath) + (getfilenamefile sourcepath) + "_.png" --"C:\\Temporary Files\\!!.png"
						wid = i[3]
						hei = i[4]
						
						mWidth = i[7]
						mHeight = i[8]
						mX = i[5]
						mY = i[6]
						
						sw = mwid / wid
						sh = mhei / hei
						wid_r = (mWidth * mwid) as integer + 20
						hei_r = (mHeight * mhei) as integer + 20
						poi_x = (mX * mwid) as integer - 10
						poi_y = (mY * mhei) as integer - 10
						
						if findstring sourcepath "all_branches_diffuse.png" != undefined then
						(
							mWidth = 1
							mHeight = 1
							mX = 0
							mY = 0
							poi_x = 0
							poi_y = 0	
						)
						if findstring sourcepath "all_branches_diffuse.png" == undefined then 
						(
							HiddenDOSCommand ("magick " + "\"" + sourcepath + "\"" + " -alpha Background -background none -resize " + wid_r as string + "x" + hei_r as string + "^! -define png:color-type=6 " + "\"" + sourcepath_temp + "\"") startpath:(GetINI_ImageMagick())
						)
						else 
						(
							if doesFileExist sourcepath_temp then deleteFile sourcepath_temp
							copyfile sourcepath sourcepath_temp
						)
						--composite {overlay} {background} [{mask}] [-compose {method}]   {result}
						HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + sourcepath_temp + "\"" + " " + "\"" + filename + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + filename + "\"") startpath:(GetINI_ImageMagick())
						if doesFileExist sourcepath_temp then deleteFile sourcepath_temp
					)
				)
			)
						
			on btn_Remove_pl pressed do
			(		
				if mlbList_pl.items.count > 0 then
				(				
					items_pl = mlbList_pl.items as array
					items_pl = for j in #{1..(mlbList_pl.items as array).count} where (for i in mlbList_pl.selection where mlbList_pl.items[i] == mlbList_pl.items[j] collect i).count == 0 collect mlbList_pl.items[j] 	
					mlbList_pl.items = items_pl as array
				)
			)

			on btn_Remove_br pressed do
			(		
				if mlbList_br.items.count > 0 then
				(
					items_br = mlbList_br.items as array
					items_br = for j in #{1..(mlbList_br.items as array).count} where (for i in mlbList_br.selection where mlbList_br.items[i] == mlbList_br.items[j] collect i).count == 0 collect mlbList_br.items[j] 	
					mlbList_br.items = items_br as array
				)
			)
			
			on btn_Clear_pl pressed do
			(		
				if mlbList_pl.items.count > 0 then
				(				
					mlbList_pl.items = #()
				)
			)	

			on btn_Clear_br pressed do
			(		
				if mlbList_br.items.count > 0 then
				(				
					mlbList_br.items = #()
				)
			)				
			
			on btn_Add_pl pressed do 
			(
				items_pl = mlbList_pl.items as array
				if selection.count > 0 then 
				(
					for i in selection where i.baseobject != undefined do
					(
						if classof i.baseobject == Plane then
							if i.parent != undefined then 
								if classof (i.parent).baseobject != Plane then appendIfUnique items_pl i.name
							--if findstring i.parent.name "_branch" != undefined then 
								--if i.children != undefined then
								--(
								--	for j in i.children where classof j.baseobject == Plane do appendIfUnique items_pl i.name
								--)
					)
					mlbList_pl.items = items_pl as array 
				)
			)
			
			on btn_Add_br pressed do 
			(
				items_br = mlbList_br.items as array
				if selection.count > 0 then 
				(
					for i in selection where i.baseobject != undefined do 
					(
						if classof i.baseobject != Plane and findstring i.name "_branch" != undefined then
							if i.children != undefined then
								if (for j in i.children where classof j.baseobject == plane collect j).count == 0 then appendIfUnique items_br i.name 
					)
					mlbList_br.items = items_br as array 
				)
			)

			on chk_branches_all changed arg do spn_branches_count.enabled = not chk_branches_all.checked 
			on chk_use_stems_distance changed arg do spn_distance_stem.enabled = chk_use_stems_distance.checked 
					
			on spn_plane_count_h changed val do 
			(
				sel = if selection.count > 0 then selection else objects
				for o in sel where o.modifiers[Unwrap_UVW] == undefined and findstring o.name "_Plane" != undefined and findstring o.name "_branch" != undefined and classof o.baseobject == Plane do o.baseobject.widthsegs = val 
			)
				
			on spn_plane_count_v changed val do 
			(
				sel = if selection.count > 0 then selection else objects
				for o in sel where o.modifiers[Unwrap_UVW] == undefined and findstring o.name "_Plane" != undefined and findstring o.name "_branch" != undefined and classof o.baseobject == Plane do o.baseobject.lengthsegs = val 
			)
			
			on spn_bend_h changed val do 
			(
				sel = if selection.count > 0 then selection else objects
				for o in sel where findstring o.name "_Plane" != undefined and findstring o.name "_branch" != undefined and classof o.baseobject == Plane and classof o.modifiers[2] == bend do o.modifiers[2].BendAngle = val 
			)
			
			on spn_bend_v changed val do 
			(
				sel = if selection.count > 0 then selection else objects
				for o in sel where findstring o.name "_Plane" != undefined and findstring o.name "_branch" != undefined and classof o.baseobject == Plane and classof o.modifiers[1] == bend do o.modifiers[1].BendAngle = -val 
			)
			
			on spn_rot_ang changed val do 
			(
				sel = if selection.count > 0 then selection else objects
				for o in sel where o.modifiers[bend] != undefined and findstring o.name "_Plane" != undefined and findstring o.name "_branch" != undefined and classof o.baseobject == Plane do in coordsys local o.rotation.y = val 
			)

			on btn_Del_Unwrap pressed do
			(
				sel = if selection.count > 0 then selection else objects
				for o in sel where findstring o.name "_Plane" != undefined and findstring o.name "_branch" != undefined and classof o.baseobject == Plane do for i in o.modifiers where classof i == unwrap_uvw do deletemodifier o i  
			)
			
			on btn_load pressed do
			(
				setIniForceUTF16Default true
				local filenameIni = getOpenFileName  caption:"Select INI File to Load presets" types: "INI|*.ini|ALL|*.*" 
				if filenameIni != undefined then 
					for i in Tree.controls do
					(
						case classof i of 
						(
							CheckBoxControl: 
							(
								local params = filterstring  (getINISetting filenameIni "TreeMaker2" i.name) ";"
								if params != undefined then
									if params.count > 0 then
									(
										i.checked = params[1] as booleanClass
										i.enabled = params[2] as booleanClass
									)
							)
							
							SpinnerControl: 
							(
								local params = filterstring  (getINISetting filenameIni "TreeMaker2" i.name) ";"
								if params != undefined then
									if params.count > 0 then
									(
										i.value = params[1] as float
										i.enabled = params[2] as booleanClass
									)								
								--i.value = (getINISetting filenameIni "TreeMaker2" i.name) as float
							)
							
							ComboBoxControl: i.selection = (getINISetting filenameIni "TreeMaker2" i.name) as integer
							
							EditTextControl: i.text = (getINISetting filenameIni "TreeMaker2" i.name)
							
							MultiListBoxControl: i.items = for j in (filterstring (getINISetting filenameIni "TreeMaker2" i.name) ";") collect j   
						)
					)					
			)
			
			on btn_save pressed do
			(
				--print #(Tree.controls)
				--for i in Tree.controls do print (classof i)
				--for i in Tree.controls where classof i == CheckBoxControl do print i.checked
				--for i in Tree.controls where classof i == SpinnerControl do print i.value	
				--for i in Tree.controls where classof i == ComboBoxControl do print i.selection	
				--for i in Tree.controls where classof i == EditTextControl do print i.text		
				--for i in Tree.controls where classof i == MultiListBoxControl do print #(i.items)	
				
				setIniForceUTF16Default true
				--local filenameIni = GetDir #maxroot + "\\GeoScripts\\Tree.ini"
				local filenameIni = getSaveFileName caption:"Select INI File to Save presets" types: "INI|*.ini|ALL|*.*" 
				if filenameIni != undefined then 
					for i in Tree.controls do
					(
						case classof i of 
						(
							CheckBoxControl: (setINISetting filenameIni "TreeMaker2" i.name (i.checked as string + ";" + i.enabled as string))
							SpinnerControl: (setINISetting filenameIni "TreeMaker2" i.name (i.value as string + ";" + i.enabled as string))
							ComboBoxControl: (setINISetting filenameIni "TreeMaker2" i.name (i.selection as string))
							EditTextControl: (setINISetting filenameIni "TreeMaker2" i.name (i.text as string))
							MultiListBoxControl: 
							(
								local str = ""
								for j in i.items do str += j as string + ";"
								setINISetting filenameIni "TreeMaker2" i.name str
							)
						)
					)
			)
			
			/*			
			on btn_Unwrap pressed do
			(
				sel = selection
				if sel.count > 0 then 
				(
					num = sel.count
					mats = for m in sel collect m.material
					texes = #()
					for m in mats do
					(
						if classof m == multimaterial then 
						(
							append texes #(m.materialList[1].DiffuseMap.fileName, m.materialList[2].DiffuseMap.fileName)
						)
						if classof m == standard then
						(
							append texes #(m.DiffuseMap.fileName)
						)
					)
					count = 0
					width_all = 0
					texes_all = #()
					for tt in texes do 
						for t in tt do 
						(
							appendIfUnique texes_all t
						)
					count = texes_all.count		
				
					for t in texes_all do
					(
						a = openBitMap t
						if a != undefined then 
						(
							hei = a.height
							wid = a.width 
							close a
							free a
							width_all += wid
						)
					)
					print count
					print width_all
					stri = ""
					for t in texes_all do stri += "\"" + t + "\"" + " -trim +repage -alpha Background -bordercolor none -background none -border 20 "
					--stri += "\"" + t + "\"" + " -trim +repage -alpha Background -bordercolor none -background none -border 20 "
		
					--HiddenDOSCommand ("magick ( " + stri + " ) -background none -alpha Background +append -define png:color-type=6 " + "\""+ (maxFilePath + "all_branches_diffuse" + ".png") + "\"") startpath:(GetINI_ImageMagick())
					HiddenDOSCommand ("magick montage ( " + stri + " ) -background none -alpha Background -geometry +0+0 -define png:color-type=6 " + "\""+ (maxFilePath + "all_branches_diffuse" + ".png") + "\"") startpath:(GetINI_ImageMagick())

						-- magick montage font_[0-9].gif  -geometry 16x16+1+1  tile_0.gif
						-- magick montage  font_*.gif  -tile 4x1  -geometry +2+2  multi_%d.gif
						--magick montage font_[1-7].gif  -tile 4x  -geometry 16x16+1+1  tile_9x1.gif
						--magick montage balloon.gif medical.gif present.gif logo: -geometry 48x48+2+2   montage_geom_size.jpg
						--convert ( Img1.jpg Img2.jpg +append ) ( Img3.jpg Img4.jpg +append ) -background none -append   append_array.jpg
						--montage -resize 400x *  -mode Concatenate -tile 2x  AnotherDir/montage_array.jpg
					
				)
			)

			*/	
			/*
					fn have_mat mat1 mat2 =
					(
						local mats = #()
						if classof mat1.material == multiSubMaterial then
						(
							for m in mat1.material.materialList do appendIfUnique mats m
						)
						else
						(
							appendIfUnique mats mat1
						)
						have = false
						for m in mats where m == mat2 do (have = true; exit)
						print have
						have
					)
			*/
			
			fn havemat s mat =
			(
				if mat != undefined then
				(
					if s != undefined then
					(
						if s.material != undefined then
						(
							if classof s.material == multiSubMaterial then
							(
								if s.modifiers[MaterialModifier] != undefined then 
								(
									if s.material.materialList[(s.modifiers[MaterialModifier].materialID)] == mat then return true else return false
								)
								else return false
							)
							else return false
						)
						else return false
					)
					else return false
				)
				else return false
			)
			
			on btn_Unwrap pressed do with undo "Unwrap planes together" on
			(
				gc()
				if selection.count > 0 then
				(
					ctrl = keyboard.controlPressed
					max modify mode
					--elems = selection as array
					elems = for o in selection where classof o.baseobject == Plane collect o
					--theMapSize = 4096 
					theMapSize = case (ddl_Tex_size.selection as integer) of
					(
						1: 256
						2: 512
						3: 1024
						4: 2048
						5: 4096
					)
					textureArea = theMapSize ^ 2

					--???? ?? ????? ?????????? ????? ?????????????
					mats = #()
					for el in elems where el.material != undefined do 
					(
						if classof el.material == multiSubMaterial then
							for m in el.material.materialList do appendIfUnique mats m
						else
							appendIfUnique mats el.material
					)

					quant = if mats.count == 0 then elems.count else mats.count
					print quant
					--print mats.count
					
					size_h_row = 1.0
					size_g_col = 1.0	
					quota_g = 1.0 / size_g_col
					quota_h = 1.0 / size_h_row	
					
					--padding
					--quota_g *= 0.95 
					--quota_h *= 0.95 
					
					case of
					(
						(quant == 1):
						(
							size_h_row = 1
							size_g_col = 1							
						)
						
						(quant == 2):
						(
							size_h_row = 1
							size_g_col = 2							
						)
						
						(quant == 3):
						(
							size_h_row = 1
							size_g_col = 3							
						)		

						(quant == 4):
						(
							size_h_row = 1
							size_g_col = 4							
						)

						(quant == 5):
						(
							size_h_row = 1
							size_g_col = 5							
						)						
						
						(quant == 6):
						(
							size_h_row = 2
							size_g_col = 3							
						)							
						
						(quant == 7 or quant == 8):
						(
							size_h_row = 2
							size_g_col = 4							
						)	
						
						(quant == 9):
						(
							size_h_row = 3
							size_g_col = 3							
						)	
						
						(quant == 10):
						(
							size_h_row = 2
							size_g_col = 5							
						)	
						
						(quant == 11 or quant == 12):
						(
							size_h_row = 2
							size_g_col = 6							
						)							
						
						(quant == 13 or quant == 14):
						(
							size_h_row = 2
							size_g_col = 7							
						)	
						
						(quant == 15):
						(
							size_h_row = 3
							size_g_col = 5							
						)

						(quant == 16 or quant == 17 or quant == 18):
						(
							size_h_row = 3
							size_g_col = 6							
						)

						(quant == 19 or quant == 20 or quant == 21):
						(
							size_h_row = 3
							size_g_col = 7							
						)
						
						(quant == 22 or quant == 23 or quant == 24):
						(
							size_h_row = 3
							size_g_col = 8							
						)	

						default: 
						(
							size = ceil (sqrt quant)
							size_g_col = size * 2
							size_h_row = ceil (quant/(size * 2))	
							--size_h_row = size_g_col = ceil (sqrt quant)
						)
					)

					quota_g = 1.0 / size_g_col
					quota_h = 1.0 / size_h_row	
					
					--padding
					--quota_g *= 0.95 
					--quota_h *= 0.95 
					
					size_g = 0.0
					size_h = 0.0

					page = 0.0
					sc_h = 1.0
					sc_g = 1.0
					sc = 1.0	
					
					filename = udims.edt_multimat_path.text + dir_path + "all_branches_diffuse.png" --maxFilePath + "all_branches_diffuse.png"
					
					if not doesDirectoryExist (udims.edt_multimat_path.text + dir_path) then makedir (udims.edt_multimat_path.text + dir_path) all:true
					
					if doesFileExist filename then deleteFile filename
					b = bitmap theMapSize theMapSize filename: filename color:(color 0 0 0 0) gamma:1.0 hdr:false
					save b gamma:1.0 quiet:true
					close b
					free b
					
					for mm in mats where not keyboard.escPressed do
					(
						local tex, m
						local uv_h, uv_hs = #()
						local uv_w, uv_ws = #()
						local poi_x, poi_xs = #()
						local poi_y, poi_ys = #()
						
						local scale_density	= 1.0	
						local texelDensities = #() 	
						local mWidths = #(), mHeights = #()
						
						for s in elems where havemat s mm /*s.material.materialList[(s.modifiers[MaterialModifier].materialID)] == mm*/ and not keyboard.escPressed do  --where (have_mat s.material mm) do
						(
							--print s
							select s
							if classof s.modifiers[1] == bend and classof s.modifiers[2] == bend then addmodifier s (Unwrap_UVW()) before:2 else addmodifier s (Unwrap_UVW())
							unwrapmod = s.modifiers[Unwrap_UVW] --modpanel.getcurrentobject() --s.modifiers[1]
							unwrapmod.setPolygonMode true
							unwrapmod.setTVSubObjectMode 3
							faces = #{1..unwrapmod.numberPolygons()}
							unwrapmod.selectFaces faces
								
							sc_h = 1.0
							sc_g = 1.0
										
							unwrapmod.selectFaces faces
							unwrapmod.getarea faces &mXX &mYY &mWidth &mHeight &mAreaUVW &mAreaGeom
							
							case of
							(
								(mHeight > quota_h and mWidth > quota_g): (sc_h = quota_h / mHeight; sc_g = quota_g / mWidth)
								(mHeight > quota_h and mWidth <= quota_g): sc_h = quota_h / mHeight
								(mHeight <= quota_h and mWidth > quota_g): sc_g = quota_g / mWidth
								(mHeight <= quota_h and mWidth <= quota_g):	(sc_h = 1.0; sc_g = 1.0) --if mHeight > mWidth then sc_h = quota_h / mHeight else sc_g = quota_g / mWidth
							)

							sc = if sc_h < sc_g then sc_h else sc_g
								
							pos = unwrapmod.getSelCenter()
							unwrapmod.scaleSelectedXY sc sc [pos.x, pos.y, 0] --unwrapmod.scaleSelectedCenter (sc) 0
							pos = unwrapmod.getSelCenter()
							posX = (size_g * quota_g) + (0.5 / size_g_col) - pos.x
							posY = (size_h * quota_h) + (0.5 / size_h_row) - pos.y
							unwrapmod.moveSelected [posX, posY, 0]
							unwrapmod.getarea faces &mX &mY &mWidth &mHeight &mAreaUVW &mAreaGeom
							--textureArea = theMapSize ^ 2		
							usedAreaPixels = mAreaUVW * textureArea
							texelDensity = sqrt (usedAreaPixels / mAreaGeom)	
							append texelDensities texelDensity
							append mWidths mWidth
							append mHeights mHeight
							format "t=% sc_h=% sc_g=% sc=% quota_g=% quota_h=% size_g=% size_h=% size_g_col=% size_h_row=% posX=% posY=% \n" texelDensity sc_h sc_g sc quota_g quota_h size_g size_h size_g_col size_h_row (posX+pos.x) (posY+pos.y)

							--id = 1
							--if findstring s.name "Plane001" != undefined then id = 1 --unwrapmod.getSelectMatID()
							--if findstring s.name "Plane002" != undefined then id = 2
							--tex = undefined
							--m = s.material
							--if classof m == multimaterial then tex = m.materialList[id].DiffuseMap.fileName
							--if classof m == standard then tex = m.DiffuseMap.fileName
								
							--uv_h = (mHeight * theMapSize) as integer
							--uv_w = (mWidth * theMapSize) as integer
							--poi_x = (mX * theMapSize) as integer 
							--poi_y = (mY * theMapSize) as integer
						)
						if (amin texelDensities) != undefined and (amin texelDensities) != 0 then 
						(
							scale_density = (spn_target_density.value as float) / (amin texelDensities) --????????????? ??????? ? ??????????? ????????? ?? ????, ?.?. ? ????? ??????? ????? ?? ?????? ??????? ? ?????? ?????????

							if ((scale_density * (amax mWidths)) / quota_g) > ((scale_density * (amax mHeights)) / quota_h) then
							(
								if (scale_density * (amax mWidths)) >= quota_g then 
								(
									scale_density = (amax mWidths) / quota_g
									scale_density *= 0.98
								)								
							)
							else
							(
								if (scale_density * (amax mHeights)) >= quota_h then
								(
									scale_density = (amax mHeights) / quota_h
									scale_density *= 0.98	
								)
							)
						)
						else scale_density = 1.0
						
						--print #(texelDensities)
						--print spn_target_density.value
						print scale_density
						--??????? ??????????? ?? ?????, ????? ?? ?????????????? ?? ??????? ?????????
						--(mHeight > quota_h and mWidth > quota_g)
						for s in elems where s.material.materialList[(s.modifiers[MaterialModifier].materialID)] == mm and not keyboard.escPressed do 
						(
							select s
							unwrapmod = s.modifiers[Unwrap_UVW]
							unwrapmod.setPolygonMode true
							unwrapmod.setTVSubObjectMode 3
							faces = #{1..unwrapmod.numberPolygons()}
							unwrapmod.selectFaces faces
							unwrapmod.getarea faces &mXX &mYY &mWidthh &mHeightt &mAreaUVW_this &mAreaGeom_this						
							usedAreaPixels = mAreaUVW_this * textureArea 
							texelDensity = sqrt (usedAreaPixels / mAreaGeom_this) 	
							if faces.count > 0 and texelDensity > 0.0 then unwrapmod.scaleSelectedCenter scale_density 0 --(scale_density * (GetMetersFromGU()) / texelDensity) 0
							unwrapmod.getarea faces &mXXX &mYYY &mWidth_now &mHeight_now &mAreaUVW &mAreaGeom									
							
							uv_h = (mHeight_now * theMapSize) as integer
							uv_w = (mWidth_now * theMapSize) as integer
							poi_x = (mXXX * theMapSize) as integer 
							poi_y = (mYYY * theMapSize) as integer	

							append uv_hs uv_h
							append uv_ws uv_w
							append poi_xs poi_x
							append poi_ys poi_y
						)
						
						if size_g + 1.0 >= size_g_col then 
						(
							if size_h + 1.0 >= size_h_row then 
							(
								page += 1.0
								size_h = 0.0
								size_g = 0.0
							)
							else
							(
								size_h += 1.0
								size_g = 0.0
							)
						)
						else
						(
							size_g += 1.0
						)
						
						--print #(uv_hs)
						--print #(uv_ws)
						--print #(poi_xs)
						--print #(poi_ys)
						
						uv_h = amax uv_hs
						uv_w = amax uv_ws
						poi_x = amax poi_xs
						poi_y = amax poi_ys
						
						tex = mm.DiffuseMap.fileName
						
						if uv_w != undefined and uv_h != undefined and poi_x != undefined and poi_y != undefined then format "uv_w=% uv_h=% poi_x=% poi_y=% size_w=% size_h=% \n" uv_w uv_h poi_x poi_y (uv_w + poi_x) (uv_h + poi_y)
						
									--HiddenDOSCommand ("magick " + "\"" + tex + "\"" + " -trim +repage -alpha Background -background none -resize " + uv_h as string + "x" + uv_w as string + " -gravity southeast -geometry +" + poi_x as string + "+" + poi_y as string + " -extent 4096x4096 -define png:color-type=6 " + "\""+ tex + "\"") startpath:(GetINI_ImageMagick())
						HiddenDOSCommand ("magick " + "\"" + tex + "\"" + " -trim +repage -alpha Background -background none -bordercolor none -border 10x10 -resize " + uv_w as string + "x" + uv_h as string + " -define png:color-type=6 " + "\"" + tex + ".png" + "\"") startpath:(GetINI_ImageMagick())
						
						--composite {overlay} {background} [{mask}] [-compose {method}]   {result}
						--magick {background} {overlay} [{mask}] [-compose {method}] -composite   {result}
						-- -compose src-over modulate -define compose:args=100 -composite 
						HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " " + "\"" + tex + ".png" + "\"" + " " + "\"" + filename + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + filename + "\"") startpath:(GetINI_ImageMagick())
						if doesFileExist (tex + ".png") then deleteFile (tex + ".png")
							
						--HiddenDOSCommand ("composite -gravity Southwest -geometry +" + poi_x as string + "+" + poi_y as string + " ( " + "\"" + tex + "\"" + " -trim +repage -alpha Background -background none -resize " + uv_w as string + "x" + uv_h as string + " ) " + "\"" + filename + "\"" + " -compose src-over -define png:color-type=6 " + "\"" + filename + "\"") startpath:(GetINI_ImageMagick())
		
					/*	
						a = bitmap uv_w uv_h color:(color 0 0 0 0) gamma:1.0 hdr:false		
						c = openbitmap tex gamma:1.0
						if c != undefined then (a = copy c; print "copied good")
						close c
						free c
						if a != undefined and b != undefined then
						(
							--print a
							pasteBitmap a b [0,0] [poi_x, poi_y] type:#blend alphaMultiplier:1.0
						)							
						close a
						free a
					*/	
					)
					--save b gamma:1.0 quiet:true
					--close b
					--free b
					--???? ?????? ??? opacity ? ???? ?? ?????
					meditmaterials[1] = standard DiffuseMap: (BitmapTexture fileName:(filename)) OpacityMap: (BitmapTexture fileName:filename preMultAlpha:false rgbOutput:1 ) name:(filename)
					--for e in elems do e.material = mat	
					select elems
				)
			)
			
			on create_plane_branch pressed do with undo "Create branch" on
			(
				gc()
				if selection.count == 1 then
				(
					local pl, pl2
					local angleY, angleZ
					se = selection[1]
					select se
					ss = copy se
					select ss
					
					--rotate_obj_parallel_Z.pressed()
					angleY = rotate_to_Y ss (spn_angle_rotation.value)
					angleZ = rotate_to_Z ss (spn_angle_rotation.value) angleY
					in coordsys world rotate ss (eulerangles 0 0 angleY)
					in coordsys world rotate ss (eulerangles angleZ 0 0)

					mat = render_branch ss (se.name + ".png") chk_dual_planes_render.checked chk_dual_planes.checked spn_multy_render.value
					delete ss
						
					pl = create_plane se false 
					pl = bend_plane pl
					pl.material = mat
					append se.children pl
					if chk_dual_planes.checked then 
					(
						pl2 = create_plane se true
						pl2 = bend_plane pl2
						pl2.material = mat	
						append pl.children pl2				
					)
					select se
				)
			)
			
			on create_plane_branch rightclick do
			(
				sss = selection as array
				for sel in sss do
				( 
					select sel
					create_plane_branch.pressed()
				)
				gc()
			)
			
			on rotate_obj_parallel_y pressed do with undo "Rotate to Y" on with redraw off
			(
				if selection.count == 1 then
				(	
					angleY = rotate_to_Y selection[1] (spn_angle_rotation.value)
					in coordsys world rotate selection[1] (eulerangles 0 0 angleY)
				)				
			)
			
			on rotate_obj_parallel_Z pressed do with undo "Rotate to Z" on with redraw off
			(
				if selection.count == 1 then
				(	
					angleY = rotate_to_Y selection[1] (spn_angle_rotation.value)
					angleZ = rotate_to_Z selection[1] (spn_angle_rotation.value) angleY
					in coordsys world rotate selection[1] (eulerangles 0 0 angleY)
					in coordsys world rotate selection[1] (eulerangles angleZ 0 0)
				)				
			)
/*			
			on rdo changed state do 
			(
				case rdo.state of
				(
					1:
					(
						edt_fruits.enabled = true
						edt_leafs.enabled = true
						edt_twigs.enabled = true
						edt_trunks.enabled = true
						edt_stems.enabled = true 					
						
					)
					2:
					(
						edt_fruits.enabled = false
						edt_leafs.enabled = false
						edt_twigs.enabled = false
						edt_trunks.enabled = false
						edt_stems.enabled = false 
					)
				)
			)
*/			
			on btn_tree pressed do
			(
				gc()
				t = spn_distance.value as float --0.05
				fruits = #{}
				fruits_elems = #()
				leafs = #{}
				leafs_elems = #()
				twigs = #{}
				twigs_elems = #()
				trunks = #{}
				trunks_elems = #()
				stems = #{}
				stems_elems = #()
				branches = #()
				arr = #()
				points = #()
				bb = 1
				old_count = 0
				new_count = 0
				
				if selection.count == 1 and classof selection[1] == Editable_Poly then
				(	
					s = selection[1]
					max modify mode
					subObjectLevel = 0
					FacesSelection = #{1..(polyop.getnumfaces s)}
					lbl.text = "Analize tree"
					ids = #()
			
					fr = filterstring edt_fruits.text ","
					lf = filterstring edt_leafs.text ","
					tw = filterstring edt_twigs.text ","
					tr = filterstring edt_trunks.text ","
					st = filterstring edt_stems.text ","
/*					
					if s.material == undefined then rdo.state = 1 else if not (hasproperty s.material "materialIDList") then rdo.state = 1 

					case rdo.state of
					(
						2:
						(
							ids = s.material.materialIDList
						)
						
						1:	
						(		
*/							
							local ids_ = #()
							if chk_fruits.checked then join ids_ fr
							if chk_leafs.checked then join ids_ lf
							if chk_twigs.checked then join ids_ tw
							if chk_trunks.checked then join ids_ tr
							if chk_stems.checked then join ids_ st
							ids = for i in ids_ collect (i as integer)
--						)
--					)
					--print #(ids)
					for id in ids where not keyboard.escPressed do 
					(
						pb.value = (100 * id / ids.count) as integer
						s.selectbymaterial id 
						faceSel = polyOp.getFaceSelection s
						if chk_fruits.checked then for l in fr where (l as integer) == id do fruits += faceSel
						if chk_leafs.checked then for l in lf where (l as integer) == id do leafs += faceSel
						if chk_twigs.checked then for l in tw where (l as integer) == id do twigs += faceSel
						if chk_trunks.checked then for l in tr where (l as integer) == id do trunks += faceSel
						if chk_stems.checked then for l in st where (l as integer) == id do stems += faceSel					
					)
					--print #(trunks)
					
					lbl.text = "Finding elements"
					if chk_fruits.checked then fruits_elems = to_elements s fruits
					if chk_leafs.checked then leafs_elems = to_elements s leafs
					if chk_twigs.checked then twigs_elems = to_elements s twigs
					if chk_trunks.checked then trunks_elems = to_elements s trunks
					if chk_stems.checked then stems_elems = to_elements s stems
					lbl.text = "Finding elements done"
					
					bb = 1
					old_count = trunks_elems.count
					new_count = 0
					
					while old_count != new_count and trunks_elems.count > 0 and not keyboard.escPressed do
					(
						
						if not chk_branches_all.checked and bb > spn_branches_count.value then exit
						old_count = trunks_elems.count
						lbl.text = "Search largest trunk " + bb as string
						e = find_largestXY trunks_elems --????? ??????? ????? 
						--e = find_largestZ trunks_elems --????? ??????? ????? 
						append points (find_point_nearest_stem trunks_elems[e] s.pos)
						--branch = trunks_elems[e] --?????? ???????????? ????? ? ????????
						branch = #()
						branch2 = #()
						branch3 = #()
						branch4 = #()
						
						lbl.text = "Build branch: trunks " + bb as string
						--??????? ?????? ????? trunks_elems, ????? ????? twigs_elems, ????? ????? leafs_elems ? ????? fruits_elems

						if chk_separate_trunks.checked then --???? ???? ????????? ?????, ?? ???? ????? ????? ?? ???????, ?????? ????? ??????? ????? ? ???? ??????
						(
							append branch #(trunks_elems[e][1], trunks_elems[e][2], trunks_elems[e][3])
							trunks_elems = for i in (#{1..trunks_elems.count} - #{e}) collect #(trunks_elems[i][1], trunks_elems[i][2], trunks_elems[i][3])
						)	
						else
						(
							arr = case of
							(
								(chk_use_stems_distance.checked and spn_branches_top_distance.value == 0.0): by_distance_ex_ trunks_elems trunks_elems e t s.pos (spn_distance_stem.value as float) (spn_distance_far.value as float)
								(chk_use_stems_distance.checked and spn_branches_top_distance.value != 0.0): by_distance_ex_3 trunks_elems trunks_elems e t s.pos (spn_distance_stem.value as float) (s.max.z - spn_branches_top_distance.value) (spn_distance_far.value as float) --???? ???? ??????? ?? ??????? ???????
								(not chk_use_stems_distance.checked): by_distance_ex_2 trunks_elems trunks_elems e t (spn_distance_far.value as float)
							)
							branch = arr[1]
							trunks_elems = arr[2]
							--branch = by_distance_ex trunks_elems trunks_elems e t s.pos (spn_distance_stem.value as float) --???? ???? ??????? ?? ??????? ???????
							--????? ?????? ?????? ?????, ???? ??????? ?? ?? ?????? ????????? ?????, ??? ?????? ? ?????????? ????????? ??-???
							--trunks_elems = delete_elems_arr trunks_elems branch
						)
						
						if chk_twigs.checked then
						(		
							lbl.text = "Build branch: twigs " + bb as string
							arr = by_distance_all_ branch twigs_elems t (spn_distance_far.value as float)
							branch2 = arr[1]
							twigs_elems = arr[2]
							if spn_twigs_Cycles.value > 1 then
							(
								for c = 2 to spn_twigs_Cycles.value do
								(
									arr = by_distance_all_ branch2 twigs_elems t (spn_distance_far.value as float)
									for cc in arr[1] do append branch2 cc
									twigs_elems = arr[2]
								)
							)								
							--branch2 = by_distance_all branch twigs_elems t
							--twigs_elems = delete_elems_arr twigs_elems branch2
						)
						else
						(
							branch2 = branch
						)
						
						if chk_leafs.checked then
						(					
							lbl.text = "Build branch: leafs " + bb as string
							arr = by_distance_all_ branch2 leafs_elems t (spn_distance_far.value as float)
							branch3 = arr[1]
							leafs_elems = arr[2]
							--branch3 = by_distance_all branch2 leafs_elems t
							--leafs_elems = delete_elems_arr leafs_elems branch3
							if chk_leafs_from_trunks.checked then
							(
								arr = by_distance_all_ branch leafs_elems t (spn_distance_far.value as float)
								for cc in arr[1] do append branch3 cc
								leafs_elems = arr[2]
							)
						)
						else
						(
							branch3 = branch2
						)
						
						if chk_fruits.checked then
						(
							lbl.text = "Build branch: fruits " + bb as string
							arr = by_distance_all_ branch2 fruits_elems t (spn_distance_far.value as float)
							branch4 = arr[1]
							fruits_elems = arr[2]
							--branch4 = by_distance_all branch2 fruits_elems t
							--fruits_elems = delete_elems_arr fruits_elems branch4
						)
						else
						(
							branch4 = branch3
						)

						polyop.detachfaces s (subarray branch + subarray branch2 + subarray branch3 + subarray branch4) asNode:true delete:false name:(s.name + "_branch001")
						br = maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))
						if abs(br.max.x - br.min.x) < spn_rubbish.value and abs(br.max.y - br.min.y) < spn_rubbish.value and abs(br.max.z - br.min.z) < spn_rubbish.value then 
						(
							delete br
						)								
						else 
						(
							try
							(							
								append branches br
								branches[bb].pivot = points[bb]
								append s.children br
								bb += 1
							)
							catch(print ("errored branch found: " + br.name))
						)
						--bb += 1 --??????? ? try ????
						new_count = trunks_elems.count
						format "elems counts: tr=% tw=% lf=% fr=%\n" trunks_elems.count twigs_elems.count leafs_elems.count fruits_elems.count
					)
					lbl.text = "Done..."
					pb.value = 100
					gc()
					print #(branches)
					print #(points)
				)	
				else messageBox "select one Editable poly object"			
			)
			
			on btn_find_set_stems pressed do
			(
				t = spn_distance.value
				if selection.count > 0 then
				(	
					s = selection[1]
					lbl.text = "Analize tree"
					FacesSelection = #{1..(polyop.getnumfaces s)}
					elems_poly = #()
					part_of_faces = FacesSelection
					max create mode
					while not part_of_faces.isempty do with redraw off
					(
						if keyboard.escPressed then exit
						for i in part_of_faces where not keyboard.escPressed do 
						(
							elem = polyOp.getElementsUsingFace s #{i} --fence:<fence_facelist>
							--vv = polyop.getVertsUsingFace s elem
							--pp = for v in vv collect polyop.getVert s v
							if pp != undefined then 
							(
								append elems_poly #(elem, elem.numberset) --, pp) --, abs(ss.max.x - ss.min.x), abs(ss.max.y - ss.min.y), abs(ss.max.z - ss.min.z))
							)
							part_of_faces -= elem
							exit
							
						)
						pb.value = (100 - (100*part_of_faces.numberset/FacesSelection.count)) as integer
					)

					if elems_poly.count > 0 then with redraw off
					(
						size_st = 0
						el_stvol = 1
						--maxi = amax (for i in #{1..elems_poly.count} collect elems_poly[i][2])
						--el_stvol = for i in #{1..elems_poly.count} where elems_poly[i][2] == maxi do exit with elems_poly[i][1] 
						--/*
						for i in #{1..elems_poly.count} where not keyboard.escPressed do
						(		
							w = abs(amax(for j in elems_poly[i][2] collect j.z) - amin(for j in elems_poly[i][2] collect j.z)) 
							if w > size_stvol then
							(
								size_stvol = w
								el_stvol = i
							)
						)
						print size_st
						print el_stvol
						--*/
						polyop.setFaceSelection s el_stvol
						if (filterstring edt_stems.text ",")[1] as integer then polyop.setFaceMatID s el_stvol ((filterstring edt_stems.text ",")[1] as integer)
					)
				)	
			)	

			on btn_find_set_trunks pressed do
			(
				t = spn_distance.value
				if selection.count > 0 then
				(	
					s = selection[1]
					lbl.text = "Analize tree"
					FacesSelection = #{1..(polyop.getnumfaces s)}
					elems_poly = #()
					part_of_faces = FacesSelection
					max create mode
					while not part_of_faces.isempty do with redraw off
					(
						for i in part_of_faces where not keyboard.escPressed do 
						(
							elem = polyOp.getElementsUsingFace s #{i} --fence:<fence_facelist>
							vv = polyop.getVertsUsingFace s elem
							pp = for v in vv collect polyop.getVert s v
							if pp != undefined then 
							(
								append elems_poly #(elem, pp) --, abs(ss.max.x - ss.min.x), abs(ss.max.y - ss.min.y), abs(ss.max.z - ss.min.z))
							)
							part_of_faces -= elem
							exit
							
						)
						pb.value = (100 - (100*part_of_faces.numberset/FacesSelection.count)) as integer
					)
					xx = abs (s.max.x - s.min.x) / 6
					yy = abs (s.max.y - s.min.y) / 6
					dd = amax #(xx, yy) --sqrt(xx^2 + yy^2)
					print dd
					if elems_poly.count > 0 then with redraw off
					(
						size_stvol = 0
						el_stvol = 0
						for i = #{1..elems_poly.count} where (w = abs(amax(for j in elems_poly[i][2] collect j.z) - amin(for j in elems_poly[i][2] collect j.z))) > size_stvol do
						(			
							size_stvol = w
							el_stvol = i
						)
						for i = #{1..elems_poly.count} where i != el_stvol do
						(
							x1 = amax (for j in elems_poly[i][2] collect j.x)
							x2 = amin (for j in elems_poly[i][2] collect j.x) 
							y1 = amax (for j in elems_poly[i][2] collect j.y)
							y2 = amin (for j in elems_poly[i][2] collect j.y)
							z1 = amax (for j in elems_poly[i][2] collect j.z)
							z2 = amin (for j in elems_poly[i][2] collect j.z)
							
							w = sqrt((abs(x1 - x2)) ^ 2 + (abs(y1 - y2)) ^ 2 + (abs(z1 - z2)) ^ 2)
							print w
							if w >= dd then --???????, ?????? ?????
							(
								--polyop.setFaceSelection s elems_poly[i][1]
								if (filterstring edt_trunks.text ",")[1] as integer then polyop.setFaceMatID s elems_poly[i][1] ((filterstring edt_trunks.text ",")[1] as integer)
							)
						)
					)
				)
			)
		)
		createDialog Tree style:#(#style_sunkenedge,#style_titlebar,#style_sysmenu,#style_minimizebox)
	)
)

rollout Obj_Spln "Objects operations" autoLayoutOnResize:true
(
	group "Check Tools"
	(
		button btn_xViewCheckerVerts "xView Verts" width:70 across:4 align:#left tooltip:"?????????? ?????????? ?????? ??????, ?????????? ????? ???????? ?????? ?????????? ?????????? ???????? | Shows doubled and more groups of verts, which have distances less then selected treshold"
		button btn_xViewCheckerFaces "xView Faces" width:70 offset:[15,0] tooltip:"?????????? ?????????? ?????? ??????, ?????????? ????? ???????? ?????? ?????????? ?????????? ???????? | Shows doubled and more groups of faces, which have distances less then selected treshold"
		checkbox chk_autoupdate "Auto" checked:true offset:[20,0] tooltip:"?????????????? XView, ?????????? ??????, ????? ????????????? ?????????????? ?????????? ?? ??????? ??????? | Auto update xView, check off to prevent auto update on huge models"
		button btn_xViewDisable "Disable All" align:#right tooltip:"????????? ??? ????????? XView | Disables all xView procedures"
	
		edittext edt_xViewVerts "Verts" fieldwidth:50 width:70 offset:[0,0] across:3 align:#left
		edittext edt_xViewFaces "Faces" fieldwidth:50 width:70 offset:[-10,0] 
		button btn_xViewSelect "Select Result\Hide" offset:[0,0] align:#right tooltip:"LMB: ??????? ??????? ????? ??? ??????? ? ????????????? ???????? ? ???????? ?????????? \n\nRMB: ?????? ??????????? ????? ??? ???????. ??????? Unhide All, ????? ?????????? ??? ??????? | LMB: Selects current founded errored faces or verts and shows count\n\nRMB: Hide unselected faces or verts. Press Unhide All to show all back"

		button btn_FindFaces "Find Faces" width:60 across:3 align:#left tooltip:"??????????\nLMB: ????? ??????, ????????????? ????? ?????? ???? ? ?????, ?????? ??????? 0,005?\nLMB+CTRL: ????? ??????????? (?? ???????????????) ?????? ? ????????? [0,005-0,02]\nLMB+ALT: ????? ?? ???? ????????, ??????? | Obsolete\nLMB: Find very close to each other faces near treshhold 0.005m\nLMB+CTRL: Find coplanar (none overlapping) faces in range [0.005-0.02]\nLMB+ALT: Find by all vertices, longer"
		spinner spn_Tresh_xViewChecker "Range" range:[0.0, 1000.0, 0.002] scale:0.001 type:#float offset:[0,0] fieldwidth:40 width:40 tooltip:"???????????? ???????? ??????? ??? XView, ?????? [0.0 - 0.002] | Maximum of Range of doubles for XView, usually [0.0 - 0.002]"
		button btn_VertexWeld "Guess\VertexWeld" width:95 offset:[0,0] align:#right tooltip:"LMB: ??????? ??????? ??????? ? ???????? ??????, ???? ??? ??????????, ???????? ??. ??????????? VertexWeld ?? ???????????, ??? ?????? ??? ??????????? ??????\n\nRMB: ????????? ??????????? VertexWeld ? ??????? ??????? treshold | LMB: Try to weld vertices with treshold, if they exist - show them. The modifier VertexWeld do not applies, this only for showing errors\n\nRMB: apply modifier VertexWeld with treshold"	
		--spinner spn_Tresh "" range:[0.0, 1000.0, 0.002] scale:0.001 type:#float fieldwidth:40 width:30 tooltip:""
		--button btn_xViewAll "Autocheck" offset:[30,0] enabled:false 

		button btn_MoveFacesEdgesVerts "Move Duals" across:3 width:60 align:#left offset:[0,0] tooltip:"LMB: ?????????? ?????????? ????? ?? ???????? ??????????\nLMB+CTRL: ?????? ???????\nLMB+ALT: ???????????? ??????? ?????? ?????? ???????? ??????\n\nRMB: ?????????? ?????????? ??????? ?? ???????? ??????????\nRMB+ALT: ??????? ?? ?????? ?????? ???????? ?????? | LMB: Find and move coplanar dual faces in current range to desired distance\nLMB+CTRL: Select only\nLMB+ALT: Use verts normals instead of face normals\n\nRMB: Find and move dual verts\nRMB+ALT: Use dual verts as vector instead of using verts normals"
		button btn_FlipFaces "Flip Faces" width:60 offset:[10,0] enabled:false tooltip:"????? ??????????? ????? ? ????????????? ????????? ? ????????? ?? ? ??????????????? ??????? | Find coplanar faces with wrong normals and direct them in opposite sides"
		button btn_UnhideVertsFaces2 "Unhide All" align:#right tooltip:"?????????? ??? ??????? ????? ??????? EDITABLE POLY ? ????? UVW_Unwrap | Unhide all hidden parts of EDITABLE POLY object and after UVW_Unwrap"
		
		checkbox chk_MoveFacesEdgesVerts_acuracy "Accuracy" checked:true offset:[0,0] across:3 align:#left tooltip:"???????????? ??????? ???????? (????? ?? ?????????????? ????????, ? ??????? ??????), ??????????? ?????? ??????? | Use high accuracy (search with verts positions additional to face centers), need more time"
		checkbox chk_MoveFacesEdgesVerts_bidirectional "Bi-directional" checked:false offset:[-20,0] tooltip:"?????? ?????? ? ?????????????? ????????????? ???????, ??????????? ???? ?? ????? ??? ????????????, ??? ??????, ??????, ??????? | Find ONLY with opposite directional faces, overlapped inside each other or pared like fences, glasses, trees"
		checkbox chk_MoveFacesEdgesVerts_codirectional "Co-directional" checked:false offset:[0,0] align:#right tooltip:"?????? ?????? ? ??????????????? ???????, ???????? ???????????? ??????? ? ??????????? ????????? | Find ONLY with co-directional faces, near coplanar faces with same normals"
		spinner spn_MoveFacesEdgesVerts_angle "Angle" range:[0.0, 360.0, 0.01] scale:0.001 type:#float offset:[0,0] fieldwidth:40 width:40 across:3 align:#left tooltip:"????, ??????? ? ?????????????? | Angle of near parallelism"
		spinner spn_MoveFacesEdgesVerts_distance "To:" range:[0.0, 1000.0, 0.003] scale:0.001 type:#float offset:[-10,0] fieldwidth:40 width:40 tooltip:"??????????, ?? ??????? ?????????? ??????????? | Distance to be moved"
		dropdownList ddl_MoveFacesEdgesVerts_range "" items:#("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]") selection:1 fieldwidth:100 width:100 offset:[0,0] align:#right tooltip:"?????? ? ?????????:\n[0,0 - 0,002] ???????? ??? ??????? ?????? ? ??????\n [0,0 - 0,005] ???????? ??? ????? ??????????? ?????? \n[0,005 - 0,02] ???????? ??? ??????????? ?????? ? ???????????????? ?????????\n[0,01 - 0,02] ???????? ??? ??????? UCX\n?????? ????????? ?????? ??? ????? ????????????\n??? ?????? ?????????? ?????????? ?? ????? ????? ?? ?????? ???????, ??????? ??????????? ??????? ????????? ? ?????????? ? ?????????????? ? ????????? ??????, ????????? ??? ????? ???? ??????? ??-?? ??????????? ?????? ??? ???????????? ?????????? | Find in range:\n[0.0 - 0.002] suitable for dual faces and verts\n[0.0 - 0.005] suitable for near coplanar faces\n[0.005 - 0.02] suitable for coplanar faces with opposite normals\n[0.01 - 0.02] suitable for UCX models\n\nOther ranges for tests purpose only.\n\nAll methods just find the distance from one face to another blindly, so use large ranges with selected and detached isolated faces, overwise they may be moved out due unknown errors distance tests"
	)
	
	group "Modeling Tools"
	(		
		button btn_TriangulateRight "Triangulate" offset:[0,0] across:3 align:#left tooltip:"LMB: ?????? ?????? Connect ???? ?????? ? EDITABLE POLY, ?? ???????? ?? ???????? ?????????? ?????\nRMB: ????????? ???????????? ?????????? ??????? | LMB: Analog of All-vertices Connect button in Editable poly, but working better, do not produce overlayed edges\nRMB: Check Triangulation of selected object"
		button btn_TurnToPoly "TurnToPoly Mod" align:#left offset:[-10,0] tooltip:"??????????? TurnToPoly - ????? ????????? ? ??????? | 3ds max TurnToPoly modifier - may couse errors"  
		button btn_ConnectVerts "Connect Verts" offset:[0,0] align:#right tooltip:"??????????? Verts Connect - ????? ????????? ? ??????? | 3ds max Verts Connect modifier - may couse errors"  

		button btn_RemoveErrEdges "Remove Overlay Edges" align:#left across:2 tooltip:"LMB: ??????? ????? ? ??????????? ???????\nCTRL+LMB: ?????? ??????? | LMB: Try to remove errored-overlayed edges\nCTRL+LMB: only select"		
		button btn_RemoveVerts "Remove 2-edged Verts" offset:[0,0] align:#right tooltip:"??????? ??????? ? ???????? (????? ????????????? Slice ? ShapeMerge). ??? ????? ?????? ?? ?????? Slicers. ???????? ?????????????? ????? ?? RMB ? treshold | Try to Remove two-edged error vertices\n(after Slice and ShapeMerge modifiers)\nThis is the copy of button from Slicers Rollout\nSee there for more options by RMB and treshold" --btn_remove
	
		button btn_TargetWeld "Nearest Weld" offset:[0,0] width:70 across:4 align:#left tooltip:"??????? ????????? ??????? ? ?????? ?? ????????? ??????????? | Welds selected vertexes with nearest distance"		
		button btn_EdgeWeld "Edges Weld" offset:[5,0] width:60 align:#left tooltip:"??????? ??? ?????????? ????? ? ?????????? ???????, ???????? ????? ?????? ?? ????????? ????? | Weld all overlayed edges in selected objects, also work only on selected edges"
		button btn_ResetXform "ResetXform" offset:[3,0] width:60 tooltip:"??????????? ResetXform | 3ds max ResetXform modifier"
		button btn_DetachFaces "Detach Elems" offset:[0,0] width:70 align:#right tooltip:"??????????? ??? ????????, ????? ????????? EDITABLE POLY ??????? | Detach all elements to separate objects EDITABLE POLY"
		
		--button btn_UnhideVertsFaces "Unhide Errors" offset:[0,0] align:#right tooltip:"Unhide all verts and faces in Editable Poly object after UVW_Unwrap"

		button btn_Detriangulate "Detriangulate" align:#left across:4 tooltip:"LMB: ????????????????? ????????? ???????, ?????? ????????? ????? ? ???\nLMB+CTRL: ?????? ??????? ????????????????? ?????\nLMB+Alt: ????? ?? ????????????????? ????? | LMB: Detriangulate Selection of objects, only selected faces in objects\nLMB+CTRL: Only select triangulated edges\nLMB+Alt: Select none triangulated edges"
		checkbox chk_DetriangulateSel "Invert" checked:false offset:[25,0] tooltip:"??????? ?? ????????????????? ????? | Select none triangulated edges" 
		checkbox chk_DetriangulateUV "UV" checked:true offset:[15,0] tooltip:"?? ????????????????? ?????, ??????? ????????? ? ?????? UV-???????? | Do not detriangulate edge which in different UV islands" 
		checkbox chk_DetriangulateSM "SM Groups" checked:true offset:[0,0] align:#right tooltip:"?? ????????????????? ?????, ??????? ????????? ?? ???????? ?????? ????? ??????????? | Do not detriangulate edge which on border of different Smoothing Groups"
		checkbox chk_DetriangulateDisputed "Disputed" across:3 checked:false offset:[0,0] align:#left tooltip:"?? ????????????????? ????? ? ??????? ?????? | Do not detriangulate edges in Disputed places"
		checkbox chk_DetriangulateAn "Use angle" checked:true offset:[0,0] tooltip:"?? ????????????????? ????? ? ????? ????? ????????? ??????? ?????? ?????????? ?????????? ???????? | Do not detriangulate edges with angle between neighbour faces less then choosen treshold" 
		spinner spn_DetriangulateAngle "" range:[0.0, 360.0, 10.0] scale:0.001 type:#float fieldwidth:50 align:#right tooltip:"???? ????? ????????? ??????? | Angle between neighbour faces"
		--button btn_CreatePoly "Create Polygon" tooltip:"Try to create polygon from selected vertices"	
	
		button btn_Autosmooth "AutoSmooth" across:3 align:#left tooltip:"LMB: ?????????????? ??????????? ????????? ???????? ?? ?????????? ????\nRMB: ??????? ???? ????? ??????????? ????????? ???????? | LMB: Autosmooth selected objects by selected angle\nRMB: Clear all smoothing groups of selected objects"
		spinner spn_AutosmoothAngle "Angle" range:[0.0, 360.0, 30.0] scale:0.001 type:#float fieldwidth:35 align:#left offset:[0,0] tooltip:"???? ????? ????????? ??????? | Angle between neighbour faces"
		button btn_DeleteIso "Delete Isolated" offset:[0,0] width:80 align:#right tooltip:"??????? ????????????? ??????? ? ??????? ????????? ?? ???? ????????? ????????, ??????? ????? ?????????? ? Editable Poly | Delete isolated verts and dead structs in all selected objects, will be collapsed to Editable Poly objects"

		button btn_select_Outer_edges "Select Outer Edges" across:3 align:#left tooltip:"??????? ?????, ??????? ?? ????????? ??????? | Select object edges laying by perimeter of object"
		checkbox chk_ignoreHardEdges "Hard Edges" checked:false offset:[18,0] tooltip:"???????????? ??????? ????? (????? ?????? ????? ???????????) | Ignore Hard edges (edges on different smoothing groups)"
		checkbox chk_ignoreOpenEdges "Open Edges" checked:false offset:[5,0] align:#right tooltip:"???????????? ???????? ????? | Ignore Open edges"

		button btn_Projection "Surface Projection" align:#right width:260 tooltip:"LMB: ????????????? ????????? ??????? ?? ??????????? ???????? ??????? ?? ??? Z\nLMB+CTRL: ??????? ????? ??????????? ?? ???????? ???????\n\nRMB: ???????? ?????? ??? ???????\nRMB+CTRL: ???????? ??????? ? ??????? ? ???????? ?????? ??? ??????? | LMB: Project selected objects to surface of base object by Z-Axis\nLMB+CTRL: Create new surface from baseobject for projection\n\nRMB: Mark selected object as baseobject\nRMB+CTRL: for selected object extrude edges as padding edges and set it as baseobject"
	)	
	
	on Obj_Spln open do
	(
		for i in Obj_Spln.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_objs.ini") i.name "Obj_Spln" (syssetup.rdo_lang.state))
	)
	
	on ddl_MoveFacesEdgesVerts_range selected arg do 
	(
		spn_MoveFacesEdgesVerts_distance.value = case ddl_MoveFacesEdgesVerts_range.items[arg] of
		(
			--("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]")
			"[0.0 - 0.002]": 0.003
			"[0.0 - 0.005]": 0.01
			"[0.005 - 0.02]": 0.01
			"[0.01 - 0.02]": 0.015
			"[0.0 - 0.02]": 0.01
			"[0.0 - 0.03]": 0.01
			"[0.0 - 0.05]": 0.01
			"[0.0 - 0.1]": 0.01
			"[0.0 - 1.0]": 0.01
		)			
	)
	
	on btn_select_Outer_edges pressed do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then getConvexEdges selection[1] true 45 chk_ignoreHardEdges.checked chk_ignoreOpenEdges.checked
		else messagebox "Select single Editable Poly object" 
	)
	
	on btn_Projection rightclick do with undo "Padding border" on
	(
		ctrl = keyboard.controlPressed
		if selection.count == 1 then
		(
			if ctrl then 
			(
				s = selection[1] 
				if classof s != Editable_Poly then convertToPoly s
				select s
				max modify mode
				subObjectLevel = 3
				max select all
				--polyop.createShape s (polyop.getEdgeSelection s) smooth:false name:(s.name + "Shape01") node:$spl
				s.edgeExtrudeHeight = -0.001
				s.edgeExtrudeWidth = 0.0
				s.EditablePoly.buttonOp #Extrude
				s.edgeExtrudeHeight = 0.5
				s.edgeExtrudeWidth = 0.0
				s.EditablePoly.buttonOp #Extrude	
				subObjectLevel = 0		
				btn_Projection.text = selection[1].name				
			)
			else btn_Projection.text = selection[1].name
		)
	)
	
	on btn_Projection pressed do with undo "Projection" on
	(		
		ctrl = keyboard.controlPressed
		
		if ctrl then
		(
			s = (for i in objects where i.name == btn_Projection.text collect i)[1] 
			if s != undefined then	
			(
				if classof s != Editable_Poly then convertToPoly s
				select s
				max modify mode
				subObjectLevel = 3
				max select all				
				polyop.setEdgeSelection $ #all
				$.EditablePoly.SelectBorder()
				polyop.createShape s #selection smooth:false name:(s.name + "_Shape001") --node:&spl
				subObjectLevel = 0
				select (maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))) --(s.name + "_Shape001")
				spl = selection[1]
					
				flatten()					
				addmodifier spl (uvwmap length:2.5 width:2.5 maptype:0 axis:2)

				spl.pos = s.pos 	
				spl.pivot = spl.center
					
				slicers.spn_gor_X.value = 2.5
				slicers.spn_gor_Xoffset.value = 0.0
				slicers.chk_gor_Xfuses.checked = false
				slicers.spn_gor_Y.value = 2.5
				slicers.spn_gor_Yoffset.value = 0.0
				slicers.chk_gor_Yfuses.checked = false
					
				slicers.btn_slice.pressed()
				slicers.btn_conv.pressed()
				slicers.btn_remove.pressed()
					
				spl.pos.z += 10	
			)
		)
		else
		(
			BaseObject = (for i in objects where i.name == btn_Projection.text collect i)[1] 
			Axiz = [0,0,-1]
			if BaseObject != undefined then
				for GluedObject in selection do
				(
					if classof GluedObject != Editable_Poly then convertTo GluedObject PolyMeshObject
					for v in GluedObject.verts do
					(
						IntersectedRay = intersectRay BaseObject (ray v.pos Axiz)
						if IntersectedRay != undefined then v.pos = IntersectedRay.pos
					)
				)
		)
	)
	
	on btn_Autosmooth pressed do with undo "Autosmooth selected" on with redraw off
	(
		sel = selection as array
		max modify mode
		for i in sel do 
		(
			converttopoly i 
			polyop.setFaceSelection i #{1..(polyop.getNumFaces i)}
			i.autoSmoothThreshold = spn_AutosmoothAngle.value
			polyop.autoSmooth i 
		)
		select sel
	)
	
	on btn_Autosmooth rightclick do with undo "Clear smoothing groups" on with redraw off	
	(
		sel = selection as array
		max modify mode
		for i in sel do 
		(
			addmodifier i (edit_poly ()) 	
			i.modifiers[#Edit_Poly].SetSelection #Face #{1..(i.modifiers[#Edit_Poly].GetNumFaces())}
			i.modifiers[#Edit_Poly].SetOperation #SetSmooth
			i.modifiers[#Edit_Poly].smoothingGroupsToSet = 0
			i.modifiers[#Edit_Poly].smoothingGroupsToClear = -1
			converttopoly i 	
			--children = windows.getChildrenHWND (windows.getDesktopHWND())
			--pickBaseButton = (for c in (windows.getChildrenHWND (windows.getDesktopHWND())) where (c[5] == "Clear All") collect (c))[1]
			--UIAccessor.pressButton pickBaseButton[1]
		)
		select sel
	)	
		
	on btn_DeleteIso pressed do with undo "Delete isolated verts and dead structs" on 
	(
		sel = selection as array
		max modify mode
		for i in sel do 
		(
			converttopoly i 
			polyop.deleteIsoVerts i
			polyop.CollapseDeadStructs i
		)
		select sel
	)
	
	on btn_ConnectVerts pressed do with undo "Connect all verts" on 
	(
		sel = selection as array
		for i in sel where classof i == editable_poly do 
		(
			select i
			max modify mode
			subObjectLevel = 1
			i.unhideAll #Vertex
			i.unhideAll #Face
			max select all 
			i.ConnectVertices vertexFlag:1
			subObjectLevel = 0
		)
		select sel
	)
	
	on btn_Detriangulate pressed do with redraw off
	(
		sel = selection
		ctrl = keyboard.controlPressed
		alt = keyboard.altPressed
		if selection.count > 0 then
			for poly in selection do
			(
				if classof poly == Editable_Poly then
				(
					panel_mode = getCommandPanelTaskMode()
					sub_level = subObjectLevel
					max create mode 					
					numEdges = polyop.getNumEdges poly
					numFaces = polyop.getNumFaces poly
					faces_sel = #{}
					faces_sel = polyop.getFaceSelection poly
					faces = if not faces_sel.isempty and faces_sel.numberset < numFaces then faces_sel else #{1..numFaces}
					edges = polyop.getEdgesUsingFace poly faces
					if not alt then edges -= (polyop.getEdgesUsingFace poly (#{1..numFaces} - faces)) --???????? ????????? ????? ? ????????????? ??????????
					
					polyOp.setEdgeSelection poly edges
					--print #(edges)
						
					del = not ctrl
					uv = chk_DetriangulateUV.checked
					sm = chk_DetriangulateSM.checked
					ang = chk_DetriangulateAn.checked	
					an = spn_DetriangulateAngle.value
					disputed = chk_DetriangulateDisputed.checked
					inv = chk_DetriangulateSel.checked	
					
					if not alt then 
						detriangulate poly edges faces uv sm ang an disputed del inv --?????????????? ??? ????????? ???????? ??????
					else 
						detriangulate poly edges faces uv sm ang an disputed del true --????????? ????? ???????????? ?????
						--select_edges poly edges faces uv sm ang an 10.0

					setCommandPanelTaskMode panel_mode
					if sub_level != undefined then subObjectLevel = sub_level
				)
				else messagebox ("Selected object is not an Editable Poly.")			
			)
	)
	
	on chk_autoupdate changed arg do
	(
		xViewChecker.autoUpdate = chk_autoupdate.checked
	)		
	
	on btn_xViewCheckerVerts pressed do
	(
		xViewChecker.on = true
		xViewChecker.seeThrough = true
		xViewChecker.activeIndex = 6
		xViewChecker.autoUpdate = chk_autoupdate.checked --true
		OverlappingVertices.tolerance = spn_Tresh_xViewChecker.value
		xViewChecker.runCheck currentTime
		--edt_xViewVerts.text = xViewChecker.getCurrentOutputCount() as string
	)

	on btn_xViewCheckerFaces pressed do
	(
		xViewChecker.on = true
		xViewChecker.seeThrough = true
		xViewChecker.activeIndex = 2
		xViewChecker.autoUpdate = chk_autoupdate.checked --true
		OverlappingFaces.tolerance = spn_Tresh_xViewChecker.value
		xViewChecker.runCheck currentTime
		--edt_xViewFaces.text = xViewChecker.getCurrentOutputCount() as string
	)
	
	on btn_xViewSelect pressed do
	(
		if xViewChecker.activeIndex == 6 then try
		(
			edt_xViewVerts.text = xViewChecker.getCurrentOutputCount() as string
			subobjectlevel = 1
		)catch()
		if xViewChecker.activeIndex == 2 then try
		(
			edt_xViewFaces.text = xViewChecker.getCurrentOutputCount() as string
			subobjectlevel = 4
			
		)catch()
		xViewChecker.selectResults currentTime
	)
	
	on btn_xViewSelect rightclick do
	(
		if xViewChecker.activeIndex == 6 then try
		(
			subobjectlevel = 1
			polyop.setHiddenVerts $ (#{1..(polyop.getNumVerts $)} - (polyOp.getvertselection $)) --$.Hide #Vert
		)catch()
		if xViewChecker.activeIndex == 2 then try
		(
			subobjectlevel = 4
			polyop.setHiddenFaces $ (#{1..(polyop.getNumFaces $)} - (polyOp.getfaceselection $)) --$.Hide #Face
		)catch()
	)
	
	on btn_xViewDisable pressed do
	(
		xViewChecker.on = false
	)
	
	on btn_UnhideVertsFaces2 pressed do
	(
		max modify mode
		sel = selection as array
		for i in sel where classof i == editable_poly do 
		(
			select i
			i.unhideAll #Vertex
			i.unhideAll #Face
		)
	)
	
	on btn_UnhideVertsFaces pressed do
	(
		max modify mode
		sel = selection as array
		for i in sel where classof i == editable_poly do 
		(
			select i
			--subObjectLevel = 1
			i.unhideAll #Vertex
			i.unhideAll #Face
			--subObjectLevel = 0
		)
		select sel
	)

/*	
	on btn_DetachFaces pressed do with undo "Explode All Faces" on with redraw off
	(
		ctrl = keyboard.controlPressed
		if not ctrl then 
		(
			max modify mode
			selmod = modpanel.getcurrentobject()
			if selmod != undefined and classof selmod == edit_poly or classof selmod == editable_poly then
			(
				while (faces = selmod.GetSelection #Face) != 0 do polyOp.detachFaces selmod #{(faces as array)[1]} asNode:false delete:false node:editable_poly
			)		
		)
		else
		(
			if selection.count == 1 and classof selection[1] == Editable_Poly then	
			(
				max create mode 
				while polyOp.getNumFaces selection[1] != 0 do polyOp.detachFaces selection[1] #{1} asNode:false delete:false node:editable_poly
			)
		)
	)
*/	

	on btn_DetachFaces pressed do UCX.btn_UCX_explode.pressed()

	on btn_FindFaces pressed do --????? ???????? ?? ??????????????? ???????? ? ?????????????? ????????
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			s = selection[1]
			max modify mode
			err = #{}
			points = #()
			verts = #{}
			selfaces = #{}
			selfaces = polyOp.getfaceselection s
			if selfaces.isempty then selfaces = #{1..(polyOp.getNumFaces s)}
			for i in selfaces where not keyboard.escPressed do
			(
				vec_A = polyop.getFaceNormal s i
				points = #()
				append points (polyop.getFaceCenter s i)
				if alt then 
				(
					verts = polyop.getVertsUsingFace s #{i}
					join points (for v in verts collect	(polyop.getvert s v))
				)
				vec = polyop.getFaceNormal s i
				if points.count > 0 then 
					for poi_A in points where poi_A != undefined do
					(
						hits = intersectRayScene (ray poi_A vec_A)  -- collecting intersections	
						--hits2 = intersectRayScene (ray poi_A -vec_A) collecting inversed intersections			
						--print #(hits)
						if hits.count > 0 then
						(				
							for h in hits where h[1] == s do 
							(
								if ctrl then 
								(
									if distance poi_A h[2].pos < 0.02 then 
									(
										if (abs(dot vec_A hits[1][2].dir) >= 0.99 or abs(dot vec_A hits[1][2].dir) <= 0.01) then 
										(
											--print (dot vec_A hits[1][2].dir)
											append err i 
										)
									)
								)
								else
								(
									if distance poi_A h[2].pos <= 0.005 then append err i
								)
							)
						)
						/*
						if hits2.count > 0 then
						(				
							for h in hits2 where h[1] == s do 
							(
								if ctrl then 
								(							
									if ctrl then if distance poi_A h[2].pos < 0.02 and distance poi_A h[2].pos != 0.0 and abs(dot vec_A hits2[1][2].dir) >= 0.99 then append err i 
								)
								else
								(
									if distance poi_A h[2].pos <= 0.005 and distance poi_A h[2].pos != 0.0 then append err i --???????? ???? ????
								)
							)
						)
						*/					
					)
			)
			print #(err)
			max modify mode
			subObjectLevel = 4
			polyOp.setFaceSelection s err
			redrawViews()
		)				
	)	

	on btn_MoveFacesEdgesVerts pressed do with undo "Move Duals of Faces" on  
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			s = selection[1]
			max modify mode
			err = #()
			points = #()
			verts = #{}
			selfaces = #{}
			selfaces = polyOp.getfaceselection s
			if selfaces.isempty then selfaces = #{1..(polyOp.getNumFaces s)}
			
			if not selfaces.isempty then 
			(		
				--("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]")		
				minimum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.0
					2: 0.0
					3: 0.005
					4: 0.01
					5: 0.0
					6: 0.0
					7: 0.0
					8: 0.0
					9: 0.0
				)
				maximum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.002
					2: 0.005
					3: 0.02
					4: 0.02
					5: 0.02
					6: 0.03
					7: 0.05
					8: 0.1					
					9: 1.0
				)
				dist = spn_MoveFacesEdgesVerts_distance.value 
				do_verts = chk_MoveFacesEdgesVerts_acuracy.checked
				near_perpendicular = spn_MoveFacesEdgesVerts_angle.value 
				
				if not chk_MoveFacesEdgesVerts_bidirectional.checked and not chk_MoveFacesEdgesVerts_codirectional.checked then
				(
					invert_face = false
					direction = 1.0
					join err (get_hits s selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular)
				)
				if chk_MoveFacesEdgesVerts_bidirectional.checked then
				(
					polyop.flipNormals s selfaces
					direction = -1.0
					invert_face = false --true --false
					join err (get_hits s selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular)
					polyop.flipNormals s selfaces
				)
				if chk_MoveFacesEdgesVerts_codirectional.checked then
				(
					invert_face = true
					direction = -1.0
					join err (get_hits s selfaces do_verts invert_face direction minimum_range maximum_range near_perpendicular)
				)
				
				print #(err)
				if err.count > 0 then
				(
					vv_done = #{}
					max modify mode
					subObjectLevel = 4
					if not ctrl then
						for e in err where not keyboard.escPressed do
						(
							vv = polyop.getVertsUsingFace s #{e[1]}
								--if ctrl then polyop.moveVert s vv ((-0.003/2 + e[2]/2) * getVertNormal s vv)
								--polyop.moveVert s vv ((-dist/2 + e[2]/2) * (normalize (polyop.getFaceNormal s e[1])))
							if not alt then polyop.moveVert s (vv - vv_done) ((e[2]/2 - dist/2) * (normalize e[3])) --good working
							else polyop.moveVert s vv ((abs(e[2]/2) - dist/2) * getVertNormal s vv) 
								--polyop.moveVert s vv ((dist/2 - e[2]/2) * (normalize e[3])) 
								--polyop.moveVert s vv ((abs(e[2]/2) - dist/2) * (normalize e[3]))
								--e = #(i, direction * (distance poi h[2].pos), vec, h[2].pos, h[2].dir)
								--polyop.moveVert s vv ((abs(e[2]/2) - dist/2) * e[5]) 
								--polyop.moveVert s vv ((e[2]/2 - dist/2) * e[5]) 
							vv_done += vv --????????? ??? ?????????? ?????, ????? ?? ??????? ?? ?????, ????? ?????!
						)
					polyOp.setFaceSelection s ((for e in err collect e[1]) as bitarray)
					redrawViews()
				)
			)
			
			/*
			if alt then
			(
				verts_near = #()
				vv = polyop.getVertsUsingFace s selfaces
				for v1 in vv do
				(
					p1 = polyop.getvert s v1
					for v2 in vv where v1 < v2 do
					(
						p2 = polyop.getvert s v2
						if distance p1 p2 <= 0.002 then 
						(
							appendIfUnique verts_near #(v1, distance p1 p2, normalize (p1 - p2))
							appendIfUnique verts_near #(v2, distance p1 p2, normalize (p2 - p1))
						)
					)
				)
				
				if verts_near.count > 0 then
				(
					for v in verts_near do
					(
						polyop.moveVert s #{v[1]} ((0.003/2 - v[2]) * v[3])
					)
				)
				
				polyOp.setVertSelection s ((for v in verts_near collect v[1]) as bitarray)
			)
			redrawViews()
			*/
		)				
	)	
	
	on btn_MoveFacesEdgesVerts rightclick do with undo "Move Duals of Verts" on  
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			s = selection[1]
			max modify mode

			selverts = #{}
			selverts = polyOp.getvertselection s
			if selverts.isempty then selverts = #{1..(polyOp.getNumVerts s)}
			
			if not selverts.isempty then 
			(		
				--("[0.0 - 0.002]", "[0.0 - 0.005]", "[0.005 - 0.02]", "[0.01 - 0.02]", "[0.0 - 0.02]", "[0.0 - 0.03]", "[0.0 - 0.05]", "[0.0 - 0.1]", "[0.0 - 1.0]")		
				minimum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.0
					2: 0.0
					3: 0.005
					4: 0.01
					5: 0.0
					6: 0.0
					7: 0.0
					8: 0.0
					9: 0.0
				)
				maximum_range = case ddl_MoveFacesEdgesVerts_range.selection of
				(
					1: 0.002
					2: 0.005
					3: 0.02
					4: 0.02
					5: 0.02
					6: 0.03
					7: 0.05
					8: 0.1					
					9: 1.0
				)
				
				dist = spn_MoveFacesEdgesVerts_distance.value 

				verts_near = #()
				--polyop.moveVert s vv ((-0.003/2 + e[2]/2) * getVertNormal s vv)
				for v1 in selverts where not keyboard.escPressed do
				(
					local p1 = polyop.getvert s v1
					for v2 in selverts where v2 > v1 and not keyboard.escPressed do
					(
						local p2 = polyop.getvert s v2
						local d = distance p1 p2
						if d >= minimum_range and d <= maximum_range then 
						(
							appendIfUnique verts_near #(v1, d, normalize (p1 - p2), getVertNormal s #{v1})
							appendIfUnique verts_near #(v2, d, normalize (p2 - p1), getVertNormal s #{v2})
						)
					)
				)
				print #(verts_near)
				if verts_near.count > 0 then
				(
					if not ctrl then
					(
						vv_done = #{}
						if alt then
							for v in verts_near do
							(
								polyop.moveVert s (#{v[1]} - vv_done) ((dist/2 - v[2]/2) * v[3])
								vv_done += #{v[1]}
							)	
						else
							for v in verts_near do
							(
								polyop.moveVert s (#{v[1]} - vv_done) ((dist/2 - v[2]/2) * v[4])
								vv_done += #{v[1]}
							)
					)
				)
				
				polyOp.setVertSelection s ((for v in verts_near collect v[1]) as bitarray)
				redrawViews()
			)
		)
	)
	
/*
	on btn_FindFaces rightclick do with undo "Convert to mesh" on
	(
		if selection.count == 1 then --and classof selection[1] == Editable_Poly then
		(
			ctrl = keyboard.controlPressed
			s = selection[1]
			max modify mode
			converttomesh s
			err = #{}
			verts = #{}
			points = #()	
			arr = #()	
			a = #()					
			for i in #{1..(meshop.getNumFaces s)} where not keyboard.escPressed do
			(
				verts = meshop.getVertsUsingFace s #{i} -- polyop.getVertsUsingFace s #{i}
				points = for v in verts collect	(meshop.getVert s v) --(polyop.getvert s v)
				vec = getFaceNormal s i --polyop.getFaceNormal s i
				--meshop.getFaceRNormals <Mesh mesh> <int faceIndex> node:<node=unsupplied>

				if points.count > 0 then
				(
					for p in points do 
					(
						arr = (intersectRayEx s (ray p vec))
						if arr != undefined then 
							if arr.count > 0 then
							(
								--print #(arr)
								if distance p arr[1].pos <= 0.005 then 
								if distance p arr[1].pos >= 0.02 and distance p arr[1].pos <= 0.1 and abs(dot vec arr[1].dir) >= 0.99 then join err #{i, arr[2]}
							)
					)
				)					
			)
			print #(err)
			max modify mode
			subObjectLevel = 4
			setFaceSelection s err  --polyOp.setFaceSelection s err
		)
		else messagebox "Select single object"		
	)	
*/
	
/*	
	on btn_FindFaces_old pressed do --working bad now, need to rework
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			max modify mode
			err = #{}
			vertsA = #{}
			vertsB = #{}
			vertsAP = #()
			vertsBP = #()
			matches = #()
			matches_near = #()
			for i in #{1..(polyOp.getNumFaces $)} where not keyboard.escPressed do
			(
				vertsA = polyop.getVertsUsingFace $ #{i}
				vertsAP = for v in vertsA collect (polyop.getvert $ v)
				--print #(vertsAP)
				for j in #{1..(polyOp.getNumFaces $)} where j > i do
				(
					vertsB = polyop.getVertsUsingFace $ #{j}
					--print #(vertsA - vertsB)
					if (vertsA - vertsB).count < vertsA.count then continue --????? ??????????? ?????? ?????? ????? ?????? (?????????? ???????? ??????)
					vertsBP = for v in vertsB collect (polyop.getvert $ v)
					--print #(vertsBP)
					--print #(vertsA)
					--print #(vertsB)
					matches = #()
					matches_near = #()
					for b in vertsBP do --where vertsB.count == vertsA.count do 
						for a in vertsAP do
						(
							--if a.x == b.x and a.y == b.y and a.z == b.z then append matches a 
							if distance a b == 0.0 then append matches a 
							if distance a b <= 0.005 then append matches a
							if distance a b > 0.02 then append matches_near a
						)
					--print "matches:"
					--print matches.count
					--print " " 

					if matches != undefined then 
					(
						if vertsA.count > vertsB.count then 
						(
							if matches.count == vertsB.count then append err j
						)
						else
						(
							if matches.count == vertsA.count then append err i
						)
					)
					
					if matches_near != undefined then 
					(
						if vertsA.count > vertsB.count then 
						(
							if matches_near.count == vertsB.count then append err j
						)
						else
						(
							if matches_near.count == vertsA.count then append err i
						)
					)					
					
				)
			)
			print #(err)
			max modify mode
			subObjectLevel = 4
			polyOp.setFaceSelection $ err
		)				
	)		
*/

	on btn_RemoveVerts pressed do btn_remove.pressed()

	on btn_TriangulateRight pressed do with undo "Triangulate Geo" on with redraw off
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly and selection[1].modifiers.count == 0 then
		(
			btn_UnhideVertsFaces2.pressed()
			
			arr = #()
			arr_err = #()
			edges_ = #{}
			edges = #{}
			faces = #{}
			faces = polyop.getfaceselection selection[1]
			if faces.isempty then faces = #{1..(polyOp.getNumFaces selection[1])}
			max create mode
			for i in faces where not keyboard.escPressed do
			(
				edges = polyop.getEdgesUsingFace $ #{i}
				edges_ = for j in edges collect (polyop.getEdgeVerts $ j)
				verts = polyop.getVertsUsingFace $ #{i}
				for v1 in verts do
				(
					p1 = polyop.getvert $ v1
					for v2 in verts where v2 != v1 and not keyboard.escPressed do
					(
						p2 = polyop.getvert $ v2
						vec1 = p2 - p1
						for v3 in verts where v3 != v1 and v3 != v2 and not keyboard.escPressed do
						(
							p3 = polyop.getvert $ v3
							vec2 = p3 - p1
							if (acos (dot (normalize vec1) (normalize vec2))) <= 0.001 then
							(
								if finditem arr_err #{v1, v2} == 0 then append arr_err #{v1, v2}
								if finditem arr_err #{v2, v1} == 0 then append arr_err #{v2, v1}
								if finditem arr_err #{v1, v3} == 0 then append arr_err #{v1, v3}
								if finditem arr_err #{v3, v1} == 0 then append arr_err #{v3, v1}
								/*
								if distance p1 p2 >= distance p1 p3 then 
								(
									if finditem arr_err #{v1, v2} == 0 then append arr_err #{v1, v2}
									if finditem arr_err #{v2, v1} == 0 then append arr_err #{v2, v1}
								)
								else
								(
									if finditem arr_err #{v1, v3} == 0 then append arr_err #{v1, v3}
									if finditem arr_err #{v3, v1} == 0 then append arr_err #{v3, v1}
								)
								*/
							)
						)
					)
				)					
			)
			
			for i in faces where not keyboard.escPressed do
			(
				edges = polyop.getEdgesUsingFace $ #{i}
				edges_ = for j in edges collect (polyop.getEdgeVerts $ j)
				verts = polyop.getVertsUsingFace $ #{i}
				for v1 in verts where not keyboard.escPressed do
				(
					for v2 in verts where v2 > v1 and not keyboard.escPressed do
					(
						if finditem edges_ #{v1, v2} == 0 and finditem edges_ #{v2, v1} == 0 and finditem arr #{v1, v2} == 0 and finditem arr #{v2, v1} == 0 and finditem arr_err #{v1, v2} == 0 and finditem arr_err #{v2, v1} == 0 then 
						(
							max modify mode
							subobjectlevel = 1
							polyOp.setVertSelection $ #{v1, v2}
							--undo "connect verts" on 
							--????? ???????? ???????? ?????? ????????? ??????? ????? ? ?????? ????? ???????, ????? ?? ???????? ????? ??? ????????
							if ($.ConnectVertices vertexFlag:1) then append arr #{v1, v2} --$.buttonOp #ConnectVertices
						)
					)
				)					
			)
			print #(arr)
			print #(arr_err)
		)
		else
		(
			messageBox ("Select single collapsed Editable Poly object")
		)
	)
	
	on btn_TriangulateRight rightclick do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			sel = selection[1]
			sel_copy = copy sel
			select sel_copy
			max modify mode
			subObjectLevel = 1
			sel_copy.unhideAll #Vertex
			sel_copy.unhideAll #Face
			max select all 
			sel_copy.ConnectVertices vertexFlag:1
			subObjectLevel = 0
			select sel	
			numfaces = polyop.getNumFaces sel 
			numfaces_copy = polyop.getNumFaces sel_copy 
			delete sel_copy
			messagebox("Now faces: " + numfaces as string + "\nFaces after triangulation: " + numfaces_copy as string + "\nNot triangulated: " + (numfaces_copy - numfaces) as string)
		)
		else
		(
			messageBox ("Select single collapsed Editable Poly object")
		)
	)		
	
	on btn_RemoveErrEdges pressed do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly and selection[1].modifiers.count == 0 then
		(
			max create mode
			ctrl = keyboard.controlPressed
			arr = #{}
			faces = #{}
			faces = polyop.getfaceselection $
			if faces.isempty then faces = #{1..(polyOp.getNumFaces selection[1])}		
			
			for i in faces do --for i in #{1..(polyOp.getNumVerts $)} do
			(
				if keyboard.escPressed then exit
				edges = polyop.getEdgesUsingVert $ #{i}
				verts = #{}
				for j in edges do join verts (polyop.getVertsUsingEdge $ #{j})
				p1 = polyop.getvert $ i
				verts = verts - #{i}
				for k in verts do 
				(
					p2 = polyop.getvert $ k
					for l in verts where l > k do 
					(
						if keyboard.escPressed then exit
						p3 = polyop.getvert $ l
						v1 = p2 - p1
						v2 = p3 - p1
						if (acos(dot (normalize v1) (normalize v2))) <= 0.001 then --== 0.0
						(
							edge_k = 0
							edge_l = 0
							for m in edges do
							(
								pp = polyop.getVertsUsingEdge $ #{m}
								if finditem pp i > 0 and finditem pp k > 0 then edge_k = m
								if finditem pp i > 0 and finditem pp l > 0 then edge_l = m
							)
							if (distance p2 p1) >= (distance p3 p1) then append arr edge_k else append arr edge_l
						)

					)
				)		
			)
			polyOp.setEdgeSelection $ arr
			
			print arr
			
			if not ctrl then
				undo "Remove Overlay Edges" on $.remove selLevel:#edge
			else
			(
				max modify mode
				subObjectLevel = 2
			)
			
			if arr != undefined then 
			(
				if arr.count != 0 then messageBox ((arr.count as string) + " problematic edges found") 
				else messageBox ("No problematic edges found")
			)
		)
		else
		(
			messageBox ("Select single collapsed Editable Poly object")
		)
	)

/*	
	on btn_CreatePoly pressed do
	(
		arr = polyop.getVertSelection $
		if (polyop.createPolygon $ (arr as array)) == undefined then messagebox "Polygon do not created"
	)
*/
	
	on btn_VertexWeld rightclick do
	(
		for i in selection do addModifier i (VertexWeld threshold: spn_Tresh_xViewChecker.value)
	)
	
	on btn_VertexWeld pressed do
	(
		ctrl = if keyboard.controlPressed then true else false 
		for i in selection do
		(
			a = copy i
			b = copy i
			addModifier a (VertexWeld threshold: spn_Tresh_xViewChecker.value)
			convertToPoly a
			convertToPoly b
			if (va = polyop.getNumVerts a) != (vb = polyop.getNumVerts b) then 
			(
				if querybox ("There are: " + (vb-va) as string + " from " + (vb as string) +  " unwelded vertexes in current treshold\n\nContinue to show unwelded verticles?") then
				(
					--messagebox ("There are: " + (vb-va) as string + " from " + (vb as string) +  " unwelded vertexes in current treshold")
					arr = #{}
					for j in #{1..(vb-1)} do for k in #{(j+1)..vb} where k != j and distance (polyOp.getVert b j) (polyOp.getVert b k) <= spn_Tresh_xViewChecker.value do 
					(
						appendifunique arr k
						appendifunique arr j
					)
					print #(arr)
					
					addModifier i (Edit_poly())
					subObjectLevel = 1
					i.modifiers[#Edit_Poly].SetOperation #UnhideAllVertex --i.ButtonOp #UnhideAll
					i.modifiers[#Edit_Poly].SetSelection #Vertex arr --i.SetSelection #Vertex arr
					i.SetSelection #Vertex arr
					if ctrl then i.modifiers[#Edit_Poly].SetOperation #HideUnselectedVertex
				)
			)
			else
			(
				messagebox "There are no unwelded vertexes in current treshold"
			)
			delete a
			delete b
		)
	)
	
	on btn_TargetWeld pressed do with undo "Weld To Near" on 
	(
		if selection.count == 1 and classof selection[1] == editable_poly and selection[1].modifiers.count == 0 then
		(	
			max modify mode
			sel = modpanel.getcurrentobject()
			panel_mode = getCommandPanelTaskMode()
			sub_level = subObjectLevel
			max create mode
			verts_pos_near = #()
			vert_pos = #()			
			verts = sel.GetSelection #Vertex
			print verts
			for vert in verts do
			(
				vert_pos = polyOp.getVert sel vert 
				edges = polyop.getEdgesUsingVert sel #{vert} --face = polyOp.getFaceVerts selmod i
				verts_near = polyop.getVertsUsingEdge sel edges --polyop.getVertsUsedOnlyByFaces <Poly poly> <facelist>-
				verts_near = verts_near - #{vert}
				print verts_near
				verts_pos_near = for v in verts_near collect polyOp.getVert sel v
				print verts_pos_near
				nearest_dist = amin (for v in verts_pos_near collect (distance vert_pos v))
				need_verts = for v in verts_near where (distance (polyOp.getVert sel v) vert_pos) == nearest_dist collect v
				need_pos = for v in verts_near where v == need_verts[1] collect polyOp.getVert sel v
				print need_verts[1]
				print need_pos[1]
				polyop.weldVerts sel vert need_verts[1] need_pos[1]
			)	
			setCommandPanelTaskMode panel_mode
			if sub_level != undefined then subObjectLevel = sub_level
		) 
		else messagebox ("Collapse it first to Editable Poly")
	)	

	on btn_EdgeWeld pressed do with undo "Weld Edges" on 
	(
		if selection.count > 0 then
		(
			local spn = 0.01
			sel = selection as array
			for i in sel where not keyboard.escPressed do
			(
				converttopoly i
				local verts_new = #{}
				local edges_new = #{}
				local sel_edges = polyop.getEdgeSelection i
				if sel_edges.isempty then sel_edges = #{1..polyop.getNumEdges i}
				--local sel_verts = polyop.getVertsUsingEdge i sel_edges
				do 
				(
					if keyboard.escPressed then exit
					local cut = false
					for e in sel_edges where not keyboard.escPressed do
					(
						local vv = polyop.getedgeverts i e
						local pp = for v in vv collect (polyop.getvert i v)
						
						for vert in polyop.getVertsUsingEdge i sel_edges /*#{1..polyop.getNumVerts i}*/ where vert != vv[1] or vert != vv[2] and not keyboard.escPressed do
						(
							local p = polyop.getvert i vert
							if par pp p spn then 
							(
								local dist = distance pp[1] pp[2]
								
								local d1 = distance p pp[1]
								local d2 = distance p pp[2]
								local p1 = d1 / dist
								local p2 = d2 / dist
								
								if p1 > (0.0 + spn) and p1 < (1.0 - spn) and p2 > (0.0 + spn) and p2 < (1.0 - spn) then
								(
									--format "dist=% d1=% d2=% p1=% p2=%\n" dist d1 d2 p1 p2
									--if vv[1] < vv[2] then polyop.divideEdge $ e p1 else polyop.divideEdge $ e p2
									local vert_new = polyop.divideEdge i e p1
									--verts_new += #{vert_new}
									sel_edges += polyop.getEdgesUsingVert i #{vert_new}
									cut = true
									exit	
								)
							)
						)	
					)

				) while cut
				addmodifier i (VertexWeld threshold: 0.001)	
				converttopoly i
			)
		)
	)

	
	on btn_TurnToPoly pressed do
	(
		for i in selection do addmodifier i (Turn_to_Poly limitPolySize:true maxPolySize:3)
		messagebox "May be errors now with overlayed edges"
	)
	
	on btn_ResetXform pressed do
	(
		for i in selection do resetxform i
	)
)

rollout Obj_tools "Objects tools" autoLayoutOnResize:true
(
	group "Selection and View Tools"
	(
		button btn_sel_vert "Select Vert" across:3 width:80 align:#left tooltip:"??????? ??????? | Select Vert"
		button btn_sel_edge "Select Edge" width:80 align:#center tooltip:"??????? ????? | Select Edge"
		button btn_sel_face "Select Face" width:80 align:#right tooltip:"??????? ????? | Select Face"
		spinner spn_sel_vert "" range:[1, 10000000, 1] scale:1 type:#integer fieldwidth:40 width:30 across:3 align:#left tooltip:""
		spinner spn_sel_edge "" range:[1, 10000000, 1] scale:1 type:#integer fieldwidth:40 width:30 align:#center tooltip:""	
		spinner spn_sel_face "" range:[1, 10000000, 1] scale:1 type:#integer fieldwidth:40 width:30 align:#right tooltip:""	
		button btn_show_verts "Show\Off Verts Nums" across:2 align:#left tooltip:"??????????\????????? ?????? ?????? | Show\Off Verts Nums"
		--button btn_unshow_verts "UnShow Verts Nums" width:110 
		button btn_show_faces "Show\Off Faces Nums" align:#right tooltip:"??????????\????????? ?????? ?????? | Show\Off Faces Nums"
		--button btn_unshow_faces "UnShow Faces Nums" width:110 align:#right

		button btn_Sel_Thin "Select Thin Faces" offset:[0,0] width:90 across:3 align:#left tooltip:"LMB: ???????? ?????? ????? ?? ????????? ?????? ?????????????? ???????, ??????? ??????? ?? ????????? ????????? ???????? | LMB: Select thin faces from selected faces of poly object, thinner than treshold"
		spinner spn_Sel_Thin "Thinner" range:[0.0, 100.0, 0.02] scale:0.001 type:#float fieldwidth:35 offset:[0,0] 
		button btn_View_Normals "View Normals" width:70 offset:[0,0] align:#right tooltip:"LMB: ???????? ???????? ? ???? ???????? ????? ?????????? ?????? ????????????? ?????????. ??????? - ??????? ???????, ??????? - ??????? ?????. ??????? ??? ???, ????? ??????? ???????? ??????? | LMB: View Normals by assigning new two sided material in viewport. Red - front normal, green - back normal. Press once more to return material back"
	)
	group "Blueprints Tools"
	(
		button btn_clean_dwg "Clean DWG" align:#left across:4 width:60 tooltip:"???????? ?????? ? ??????? ??????? | Clean spline with tresholds"
		spinner spn_clean_dwg_tr "Angle" range:[0.0, 360.0, 1.0] scale:0.001 fieldwidth:25 offset:[-5,0] tooltip:"????? ???? ??????? ?????? | Angle clean knots treshhold"
		spinner spn_clean_dwg_dist "Dist" range:[0.0, 100000.0, 0.005] scale:0.001 fieldwidth:35 offset:[-5,0] tooltip:"????? ?????????? ??????? ?????? | Less than distance knots deletion treshold"
		spinner spn_clean_dwg_weld "Weld" range:[0.0, 100000.0, 0.002] scale:0.001 fieldwidth:35 align:#right tooltip:"????? ?????? ?????? | Weld treshhold"

		button btn_pic_dwg "Load Pic & Make Plane" align:#left across:3 tooltip:"???????? ? ????????? ??????????? ? ???? ????????? ?? ??????? ????? | Open and Load Image as Plane to viewport"
		button btn_TapeIt "Create Tape" width:70 offset:[28,0] tooltip:"??????? Tape ?????? ??? ?????? ????????? ? ????????? ?????????? ?? ??????? | Create Tape object to manual set and measure distance on Pic"	
		button btn_Match "Rescale Pic" align:#right tooltip:"???????? ??????? ?????????? ??????????? (????????? ???????????) ? ??????? ????????????? ????? Tape ? ???????????? ? ????????? ???????? ??????????? | Rescales selected Pic (Image-Plane) with set Tape to match specified real distance"	
		button btn_flatten "Flatten Spline to Zero" align:#left across:2 tooltip:"???????? DWG ??? ????????????? ?????? ?? ??? Z ?? ???? | Flatten DWG as Editable Spline in Z-axis to zero"		
		spinner spn_DWG "Real Pic Distance" range:[-100000.0, 100000.0, 2.0] scale:0.1 fieldwidth:40 width:80 align:#right tooltip:""
	)
	group "Grid Tools"
	(
		button btn_create_grid "Create & Activate Grid" align:#left across:2 tooltip:"??????? ??????????????? ?????? ?????, ?????????? ?? ??????, ??????????? ????? ??? ??????????? ?? ?????? | Create Grid helper object, align to building, activate grid to viewport"
		button btn_inactivate_grid "Inactivate Grid" align:#right tooltip:"?????????????? ????? ? ???? ????????? | Inactivate Grid from viewport"

		spinner spn_eu_x "X" range:[-360.0, 360.0, 0.0] fieldWidth:40 across:3 align:#left tooltip:""
		spinner spn_eu_y "Y" range:[-360.0, 360.0, 0.0] fieldWidth:40 align:#center tooltip:""
		spinner spn_eu_z "Z" range:[-360.0, 360.0, 0.0] fieldWidth:40 align:#right tooltip:""
	)	
	
	on Obj_tools open do
	(
		for i in Obj_tools.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_tools.ini") i.name "Obj_tools" (syssetup.rdo_lang.state))
	)
	
	on btn_sel_vert pressed do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			if spn_sel_vert.value <= polyOp.getnumverts $ then
			(
				max modify mode
				subobjectlevel = 1
				polyOp.setVertSelection $ #{spn_sel_vert.value}
				forcecompleteredraw()
			)
		)			
	)
	
	on btn_sel_edge pressed do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			if spn_sel_edge.value <= polyOp.getnumedges $ then
			(
				max modify mode
				subobjectlevel = 2
				polyOp.setEdgeSelection $ #{spn_sel_edge.value}
				forcecompleteredraw()
			)
		)			
	)
	
	on btn_sel_face pressed do
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			if spn_sel_face.value <= polyOp.getnumfaces $ then
			(
				max modify mode
				subobjectlevel = 4
				polyOp.setFaceSelection $ #{spn_sel_face.value}
				forcecompleteredraw()
			)
		)			
	)
	
	on btn_unshow_verts pressed do 
	(
		unregisterRedrawviewscallback VertexShow
		forcecompleteredraw()		
	)

	on btn_show_verts pressed do
	(
		local VertexIndexShow = false
		local lastviewport
		global Laca_callbacks
		global redrawscr_laca()
	
		if VertexIndexShow then 
		(
			Laca_callbacks -= 1
			unregisterRedrawviewscallback VertexShow
			if Laca_callbacks == 0 then unregisterRedrawViewsCallback redrawscr_laca
		)
		else 
		(
			if Laca_callbacks != undefined then Laca_callbacks += 1
			if Laca_callbacks == undefined then Laca_callbacks = 1
			registerRedrawviewscallback VertexShow
			unregisterRedrawViewsCallback redrawscr_laca
			registerRedrawviewsCallback redrawscr_laca
		)
		VertexIndexShow = not VertexIndexShow
		forcecompleteredraw()
		updateToolbarbuttons()
	)

	on btn_unshow_faces pressed do 
	(
		unregisterRedrawviewscallback FaceShow
		forcecompleteredraw()		
	)
	
	on btn_show_faces pressed do
	(
		local FaceIndexShow = false
		local lastviewport
		global Laca_callbacks
		global redrawscr_laca()		
		
		if FaceIndexShow then 
		(
			Laca_callbacks -= 1
			unregisterRedrawviewscallback FaceShow
			if Laca_callbacks == 0 then unregisterRedrawViewsCallback redrawscr_laca
		)
		else 
		(
			if Laca_callbacks != undefined then Laca_callbacks += 1
			if Laca_callbacks == undefined then Laca_callbacks = 1
			registerRedrawviewscallback FaceShow
			unregisterRedrawviewsCallback redrawscr_laca
			registerRedrawviewsCallback redrawscr_laca
		)
		FaceIndexShow = not FaceIndexShow
		forcecompleteredraw()
		updateToolbarbuttons()
	)

	on btn_Sel_Thin pressed do
	(
		if selection.count == 1 then
		(
			t = spn_Sel_Thin.value
			s = selection[1]
			ff = polyop.getFaceSelection s
			faces = #{}
			for i in ff do
			(
				vv = polyop.getvertsusingface s #{i}
				pp = for v in vv collect polyop.getvert s v
				for p1 in pp do 
					for p2 in pp where p1 != p2 and (p1.x == p2.x or p1.z == p2.z or p1.y == p2.y) and distance p1 p2 <= t do faces += #{i}
			)
			polyop.setFaceSelection s faces
		)
	)
	
	on btn_View_Normals pressed do
	(
		if selection.count > 0 then
		(
			for i in selection do
			(
				if i.material != undefined then
				(					
					if i.material.name == "ViewNormals" then i.material = i.material.originalMaterial
					else i.material = Shell_material name:"ViewNormals" originalMaterial: i.material bakedMaterial: (DoubleSided name:"ViewNormals" isTwoSidedMaterial:true material1: (StandardMaterial name:"FrontFaces" diffuse:red) material2: (StandardMaterial name:"BackFaces" diffuse:blue selfIllumAmount:100)) viewportMtlIndex:1 renderMtlIndex:1
				)
				else i.material = Shell_material name:"ViewNormals" originalMaterial: undefined bakedMaterial: (DoubleSided name:"ViewNormals" isTwoSidedMaterial:true material1: (StandardMaterial name:"FrontFaces" diffuse:red) material2: (StandardMaterial name:"BackFaces" diffuse:blue selfIllumAmount:100)) viewportMtlIndex:1 renderMtlIndex:1

			)
		)
		else messagebox "Select some object first"
	)
	
	on btn_pic_dwg pressed do
	(
		try 
		(	
			filename = getBitmapOpenFileName()
			--btn_pic_dwg.caption = getNameFromPath(filename)
			create_plane filename
		) 
		catch (messagebox "Something Wrong!")
	)	
	
	on btn_clean_dwg pressed do
	(
		for i in selection where classof i == LinkComposite do delete i
		tol = spn_clean_dwg_tr.value	
		for spl in selection do 
		(
				if classof spl == SplineShape or classof spl == line do
				(
					sub = subobjectlevel
					numLine = numSplines spl
					subSplinesArr = for i in 1 to numLine collect i
					for iLine in subSplinesArr do
					(
						bl = isClosed spl iLine
						iKnots = numKnots spl iLine
						if iKnots < 3 do continue
						i = 1
						while (i+2) <= iKnots do
						(
							p1 = getKnotpoint spl iLine i
							p2 = getKnotpoint spl iLine (i+1)
							p3 = getKnotpoint spl iLine (i+2)
							v1 = p1-p2
							v2 = p3-p2
							Angle = acos (dot (normalize v1) (normalize v2))
							comAng = int(Angle*100)/100.0							
							if comAng >= 180.0 - tol then (deleteKnot spl iLine (i+1)) else i+=1
							iKnots = numKnots spl iLine
						)
						if bl do
						(
							p1 = getKnotPoint spl iLine (iKnots-1)
							p2 = getKnotPoint spl iLine iKnots
							p3 = getKnotPoint spl iLine 1
							v1 = p1-p2
							v2 = p3-p2
							Angle = acos (dot (normalize v1) (normalize v2))
							comAng = int(Angle*100)/100.0
							if comAng >= 180.0 - tol then deleteKnot spl iLine iKnots
						)
					)
					updateShape spl
					allKnotPoints = #()
					closeKnots = #()
					subobjectLevel = 0
					for s = 1 to numSplines spl do for k = 1 to numKnots spl s do append allKnotPoints #(s, k, (getKnotPoint spl s k))
					for i = 1 to allKnotPoints.count do for j = i + 1 to allKnotPoints.count where i != j do 
						if distance allKnotPoints[i][3] allKnotPoints[j][3] <= spn_clean_dwg_dist.value do
						(
							appendifunique closeKnots #(allKnotPoints[i][1],allKnotPoints[i][2])
							appendifunique closeKnots #(allKnotPoints[j][1],allKnotPoints[j][2])
						)
					for s = 1 to numSplines spl do setKnotSelection spl s #() -- deselect all
					for a in closeKnots do setKnotSelection spl a[1] #(a[2]) keep:true -- select from array
					updateshape spl
					subobjectLevel = 1
					weldSpline spl spn_clean_dwg_weld.value
					updateshape spl
					subobjectLevel = 0
					opensplines = #()
					for i = 1 to numSplines spl where (isClosed spl i == false) do
					( 
						append opensplines i
						knotmax = numKnots spl i
						--knotindxarr = "#("+"1"+ "," +(knotmax as string)+")"
						setKnotSelection spl i (#(1,knotmax))
						--setKnotSelection spl i (execute knotindxarr)
						updateShape spl	
					)--end loop
					subobjectlevel = 1
					for s = 1 to numSplines spl do for k = 1 to numKnots spl s do setKnotType spl s k #corner
					updateShape spl	
					--max select all
					--subobjectlevel = 0
					subobjectlevel=sub
				) --endif
		) --end spl	
	)
	
	on btn_flatten pressed do flatten()
	
	on btn_TapeIt pressed do 
	(
		if selection.count > 0 then 
			tp = Tape pos:[selection[1].min.x,selection[1].center.y,selection[1].max.z] target:(targetObject pos:[selection[1].max.x,selection[1].center.y,selection[1].max.z]) 
		else
			tp = Tape pos:[-10,0,0] target:(targetObject pos:[10,0,0])
	)
			
	on btn_Match pressed do 
	(
		tp = $Tape001
		td = $Tape001.Target
		dist = distance tp.pos td.pos
		sc = dist/spn_DWG.value
		tp.parent = selection[1]
		td.parent = selection[1]
		selection[1].scale = selection[1].scale/sc
		tp.parent = undefined
		td.parent = undefined
		max zoomext sel
	)	
	
	on btn_create_grid pressed do
	(
		gr = grid length:1.0 width:1.0 grid:10.0 pos:[0,0,0] rotation: (EulerAngles spn_eu_x.value spn_eu_y.value spn_eu_z.value)
		if selection.count == 1 then
		(
			gr.pos = selection[1].pos 
			gr.dir = selection[1].dir --rotation
		)
		activegrid = gr 
		
	)
)

rollout UCX "UCX operations" autoLayoutOnResize:true
(
	button btn_UCX_make "UCX Make Form" width:80 across:3 offset:[0,0] align:#left tooltip:"LMB: ??????? UCX-?????????? ???????? ???????????? ????, ??????????? ??????? ?????? ????????? ?????? ????????\nLMB+CTRL: ?????? ??????? Remesh ????????? ? ????????? ???????????? ??????? ?????\nLMB+ALT: ?? ???????? ???????\nLMB+SHIFT: ???????? Push ? ????\n\nRMB: ??????? UCX-????????? ?????? ????????? ??????-????????? ???????\n\nRMB+CTRL: ???????? +0,005? | RMB: Make UCX box around selected faces-elements of object\n\nLMB+CTRL: make gabarites offset 0.005m"
	spinner spn_UCX_make "E-Lenght" range:[0.0, 1000.0, 0.0] offset:[-5,0] fieldWidth:35 tooltip:"???????????? ?????? ????? ??? ???????? Remesh. ?? ????????? 0 - ????????? ?????? ??? ????. ??? ??????????? ????????????? ????????? ?????????? Remesh ????????? ????? ?????? ?? ??? ???????? ?????? ?????, ????? ???????, ??? ??????????? ????????? Remesh ?????? ?????? ?? ????????? ??????????? UCX ????? ?????? Remesh ?????? | Maximum edge length for the Remesh operation. The default value is 0, which leaves the model as it is. When a positive value is selected, the selected part of the model is remeshed by the specified edge length, resulting in a reduced polygon count for the Remesh model, which affects the polygon count of the UCX shape created around the Remesh model"
	button btn_UCX_makeground "UCX Make Ground" width:90 offset:[0,0] align:#right tooltip:"??????? ?????????? UCX ?? ????????? ?????? Ground ???????. ???????????? ?????????????? ????????? ??? ???????-???????? ????, ?????? ? ???????????? ???? | Make UCX containers from selected faces from Ground object. Use automatic Convex-Concave subdivision, gaps and extrusions"	
	--button btn_UCX_pivot "UCX Pivot" tooltip: "Place Pivots to Zero"

	button btn_UCX_rename "UCX Rename" width:85 align:#left across:3 tooltip: "????????????? ????????? ??????? UCX ?? ??????? | Rename selected UCX objects by numbers"
	button btn_UCX_Clear_Mat "UCX Clear Mat" width:85 offset:[0,0] tooltip:"??????? ???????? ? ????????? UCX ???????? | Delete UCX Material on selected objects"
	button btn_UCX_connect "UCX Triangulate" width:85 align:#right offset:[0,0] tooltip:"??????????????? ????????? ??????? UCX | Triangulate selected UCX objects"

	button btn_UCX_check "UCX Check" width:85 offset:[0,0] across:3 align:#left tooltip:"LMB: ????????? UCX? ?? ???????????? ?????????? ?????????????\nLMB+CTRL: ?? ??????????????? ??? ????????\n\nRMB: ????????? UCX? ?? ??????? ???????????\nRMB+ALT: ????????? ????????\nRMB+CTRL: ????????? UCX-????? ?? ?????????? (??????????) ? ?????????? (????????????) | LMB: Check UCXs for maximum triangles\nLMB+CTRL: Don't triangulate\n\nRMB: Check UCXs for intersections\nRMB+ALT: Detailed check\nRMB+CTRL: Check UCXs forms for CONVEX (right) and CONCAVE (wrong)"
	button btn_UCX_move "UCX Move Faces" width:85 offset:[5,0] tooltip:"LMB: ?????????? ???????????? ????? ?? ?????????? [0,01 - 0,02], ?????? ?? ?????????? 0,015 ? ???? ?? ?????\n\nLMB+ALT: ????? ?????????? ??????? ??????? ? ?????\n\nLMB+CTRL: ????????????? ???????????? ????? ? ????????? ? ??????? ??????, ??? ??????? ???????? | LMB: Move parallel faces to range [0.01 - 0.02], usually to 0.015m from each other\n\nLMB+ALT: also moves near verts and edges (do not use with faces - will move twice)\n\nLMB+CTRL: additional use verts points with face centers normals, for more accuracy"
	button btn_UCX_gaps "UCX Make Gaps" width:85 offset:[0,0] align:#right tooltip:"LMB: ??????? ?????? ????? ??????????? ??????????? ????????? ????? ??????? ???????? ? ????????, ????? ??????????????? ???????? ?????, ???????? ???????? ???????? ????????? UCX-?????????? ???????? ???? | LMB: Make gaps between multiple selected UCX objects using Boolean operations with padding, which may produce concave shapes and may require re-creating UCX containers for convex shapes"
	
	button btn_UCX_Select "UCX Select" width:55 offset:[0,0] across:4 align:#left tooltip:"LMB: ??????? ??? UCX (????? ?? ?????) ??? ?????????????? ????????? ??? ??????\n\nRMB: ??????? ??? UCX ?????? ?? ?????? ??? ?????????? ????????? UCX | LMB: Select all UCXs for preselected model (by name)\n\nRMB: Select all the same UCXs from one or few selected UCX"	
	button btn_UCX_explode "UCX Explode-Attach" width:100 offset:[15,0] tooltip: "LMB: ????????? Editable Poly (UCX) ?? ????????\n\nRMB: ?????????? ??? ??????? ? ???? Editable Poly | LMB: Explode Editable Poly to elements\n\nRMB: attach all objects in one Editable Poly"
	button btn_UCX_Hide "UCX Hide" width:50 offset:[25,0] tooltip:"?????? ??? ??????? UCX (????? ?? ?????) | Hide all UCX objects by name"
	button btn_UCX_Unhide "Unhide" width:40 offset:[0,0] align:#right tooltip:"???????? ??? ??????? UCX (????? ?? ?????) | Unhide all UCX objects by name"
	
	on UCX open do
	(
		for i in UCX.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_UCX.ini") i.name "UCX" (syssetup.rdo_lang.state))
	)	
	
	on btn_UCX_check pressed do
	(
		error = "Select one object or UCX object(s)"
		ctrl = keyboard.controlPressed
		error = "Something wrong"
		error_open_edges = ""
		if selection.count > 0 then
		(
			sel = selection as array
			ucx = for o in objects where findstring o.name "UCX_" != undefined collect o
			
			if selection.count == 1 then
			(				
				if findstring selection[1].name "UCX_" == undefined then 
				(
					sel = #(selection[1])
					ucx = for o in objects where findstring o.name "UCX_" != undefined and findstring o.name sel[1].name != undefined collect o 
				)
				else 
				(
					ucx = #(selection[1])
					sel = for o in objects where findstring o.name "UCX_" == undefined and o.name == (substitutestring ucx[1].name "UCX_" "") collect o
				)
			)
			else
			(
				sel = for s in selection where findstring s.name "UCX_" == undefined collect s
				ucx = #()
				for s in sel do 
					for o in objects where findstring o.name "UCX_" != undefined and findstring o.name s.name != undefined do appendIfUnique ucx o 	
			)
			
			case of
			(
				(sel.count == 0 and ucx.count == 1): error = "Can't find source object for selected UCX model"
				(sel.count > 1 and ucx.count == 1): error = "Can't find SINGLE source object for selected UCX model"
				(sel.count == 1 and ucx.count > 0):
				(
					if ctrl then --??? ????????? ??????? ??? ??? ????????????
					(
						ss = copy sel[1]
						convertTopoly ss
						select ss	
						num = polyop.getnumfaces ss
						delete ss						
					)
					else --??? ????????? ??????? ??? ????????????
					(
						ss = copy sel[1]
						convertTopoly ss
						select ss
						max modify mode
						subObjectLevel = 1
						ss.unhideAll #Vertex
						ss.unhideAll #Face
						max select all 
						ss.ConnectVertices vertexFlag:1
						subObjectLevel = 0								
						num = polyop.getnumfaces ss
						delete ss
					)
					num_ucx = 0
					if ctrl then --??? ucx ??????? ??? ??? ????????????
					(
						for u in ucx where not keyboard.escPressed do
						(
							max create mode
							u_copy = copy u
							convertTopoly u_copy
							num_ucx += polyop.getnumfaces u_copy
							delete u_copy
						)
					)						
					else --??? ucx ??????? ??? ????????????
					(
						for u in ucx where not keyboard.escPressed do
						(
							u_copy = copy u
							convertTopoly u_copy
							select u_copy
							max modify mode
							subObjectLevel = 1
							u_copy.unhideAll #Vertex
							u_copy.unhideAll #Face
							max select all 
							u_copy.ConnectVertices vertexFlag:1
							subObjectLevel = 0				
							num_ucx += polyop.getnumfaces u_copy
							delete u_copy
						)
					)
					
					--error_open_edges = ""
					for u in ucx where not keyboard.escPressed do
					(	
						u_copy = copy u
						convertTopoly u_copy
						--local edges = #{1..u_copy.getNumEdges()} 
						--for e in edges where u_copy.GetEdgeFace e 1 == 0 or u_copy.GetEdgeFace e 2 == 0 do (error_open_edges += ("Open edges: " + u.name + "\n"); exit)
						if not (polyop.getOpenEdges u_copy).isempty then error_open_edges += "Open edges: " + u.name + "\n"
						delete u_copy
					)						
					
					if num <= 50000 then 
					(
						if num_ucx > 15000 then error = "UCXs have too high number of triangles.\n"
						else error = "UCXs have good number of triangles.\n"
						error += "For model with less than 50000 polys,\nLimit UCX triangles: 15000\nModel have triangles: " + num as string + "\nUCXs triangles: " + num_ucx as string + "\nNumber to limit triangles: " + (abs(15000 - num_ucx)) as string
					)
					else
					(
						if num_ucx > ceil (num * 0.05) then error = "UCXs have too high number of triangles.\n" --"For current model with " + num as string + " triangles after triangulation\nthe maximum number of triangles for UCX objects is " + ((ceil (num * 0.05)) as integer) as string + ",\nbut the current number of UCX triangles is:" + num_ucx as string
						else error = "UCXs have good number of triangles.\n" --"For current model with " + num as string + " triangles after triangulation\nthe maximum number of triangles for UCX objects is " + ((ceil (num * 0.05)) as integer) as string + ",\nthe current number of UCX triangles " + num_ucx as string + " less than upper limit." 
						error += "Model triangles: " + num as string + "\nLimit UCX triangles (5%): " + ((ceil (num * 0.05)) as integer) as string + "\nNow UCX triangles: " + num_ucx as string + "\nNumber to limit triangles: " + ((abs(ceil (num * 0.05) - num_ucx)) as integer) as string
					)
					if not ctrl then error += "\nAdditional triangulation done."
					else error += "\nAdditional triangulation NOT done.\nData may be wrong!\n"
				)
				(sel.count > 1 and ucx.count > 0): error = "Select single base object for one or multiple UCX objects"
			)
		)
		messagebox (error + "\n" + error_open_edges)
		select ucx
		selectmore sel
		gc()
	)
	
	on btn_UCX_check rightclick do with undo off
	(
		error = "Select one or few UCX objects"
		ctrl = keyboard.controlPressed
		alt = keyboard.altPressed
		error = "Something wrong"
		error_open_edges = ""
		if selection.count > 0 then
		(
			ucx = for o in selection where findstring o.name "UCX_" != undefined collect o

			case of
			(
				(ucx.count == 0): error = "No UCX objects in selection"
				(ucx.count == 1): --search within
				(
					if ctrl then 
					(
						s = if classOf ucx[1] != Editable_Poly then converttopoly (copy ucx[1]) else ucx[1]
						
						--opens = #{}
						--opens = polyop.getOpenEdges s
						if not (polyop.getOpenEdges s).isempty then error_open_edges += "There are open edges."
						
						--convex-concave test for faces of single poly
						selfaces = #{} 
						selfaces = polyop.getFaceSelection s --#{1..(polyop.getNumFaces s)}
						if selfaces.isempty then selfaces = #{1..(polyOp.getNumFaces s)}

						--???????? ?? convex concave ????????? ?????? (?? ?????????????????)
						concaves = #{}
						concaves = convex_concave s selfaces
												
						if not concaves.isempty then 
						(
							if classOf ucx[1] != Editable_Poly then select s else select ucx[1]
							max modify mode								
							polyOp.setfaceselection selection[1] concaves
							error = "UCX object is not good, have concave faces, selected.\n"
						)
						else
						(
							select ucx[1]
							error = "UCX object is good, hasn't concave faces!\n"
						)
							
						--????? ???????? ????? ??????? ?? convex concave ????? dot ???????? ??????, ???? ????????????, ?????? ???????, ???? 0 ???????????, ???? ????????????, ?????? ????????
						concave_faces = #{}
						for f in selfaces where not keyboard.escPressed do
						(
							local n = polyop.getFaceNormal s f
							--local ee = polyop.getEdgesUsingFace s #{f} --???????? ????? ?????
							--local ff = (polyop.getFacesUsingEdge s ee) - #{f} --???????? ????? ?????
							local vv = polyop.getVertsUsingFace s #{f} --???????? ??????? ?????
							local ff = (polyop.getFacesUsingVert s vv) - #{f} --???????? ???????? ????? ??????, ????? ????????

							for f_ in ff where dot (polyop.getFaceNormal s f_) n < 0.0 do --???? dot ????????????, ?????? ???????? ?????
							(
								--format "% % % % % %\n" f f_ n m ff d
								concave_faces += #{f_, f}
							)
						)						
						
						--????? ???????? ????? ?? ???????? ???????? ??????
						--???? ?? ??????? ??? ????????? ??????? ?? ?????: ?? ???????? ????? ????????? ???? ?? ??????? ??????? ? ????????? z=0, ???? ??????? ? ???? - concave
						--????? ??????????? ?? ????? ?????? ?? ?????????, ????????? ??? ??????? ???????

						points = #()
						hits = #()
						concave = #()
						--concave_faces = #{} --????? ?????????????? ? ?????????
						for i in selfaces where not keyboard.escPressed do
						(
							vec = polyop.getFaceNormal s i
							--vec_projection = [vec.x, vec.y, 0] --?? ????? ???????, ????????? ?? ??? ????? ????????
							points = #()
							append points (polyop.getSafeFaceCenter s i) -- + (0.001*vec))
							if points.count > 0 and vec != undefined then --and vec_projection != undefined then 
							(
								for poi in points where poi != undefined do
								(
									hits = intersectRayScene (ray poi vec)
									--join hits (intersectRayScene (ray poi vec_projection))
									if hits.count > 0 then
									(		
										concave = #()
										concave = for h in hits where h[1] == s collect h 
										if concave.count > 0 then concave_faces += #{i}
									)
								)
							)
							else error += "\nThere were error.\n"
							
						)

						if not concave_faces.isempty then 
						(
							error += "UCX object is not good, have whole concave form, error faces selected.\n"
							polyOp.setfaceselection selection[1] (concaves + concave_faces)
						)
						if classOf ucx[1] != Editable_Poly then delete s
					)
					else
					(
						--explode first
						u_copy_1 = copy ucx[1]
						ucx_copy = #()
						converttopoly u_copy_1
					
						--local edges = #{1..u_copy_1.getNumEdges()} 
						--for e in edges where u_copy_1.GetEdgeFace e 1 == 0 or u_copy_1.GetEdgeFace e 2 == 0 do (error_open_edges += "Open edges: " + ucx[1].name + "\n"; exit)
						if not (polyop.getOpenEdges u_copy_1).isempty then error_open_edges += "Open edges: " + ucx[1].name + "\n"

						while u_copy_1.getNumFaces() != 0 do 
						(
							if keyboard.escPressed then exit
							polyop.detachFaces u_copy_1 (polyOp.getElementsUsingFace u_copy_1 #{1}) asNode:true delete:true name:(uniqueName (u_copy_1.name + "_"))
							append ucx_copy (maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle)))
						)
						delete u_copy_1	
						
						if ucx_copy.count == 1 then 
						(
							delete ucx_copy 
							select ucx						
							error = "Only one UCX object in selection, no intersections."
						)
						else
						(
							max modify mode
/*
							for u in ucx_copy where not keyboard.escPressed do
							(	
								convertTopoly u
								local edges = #{1..u.getNumEdges()} 
								for e in edges where u.GetEdgeFace e 1 == 0 or u.GetEdgeFace e 2 == 0 do (error_open_edges += "Open edges: " + u.name + "\n"; exit)
							)	
*/							
							if not alt then
							(
								u_copy_1 = ucx_copy[1]
								addmodifier u_copy_1 (BooleanMod method:0 disableInteractiveUpdates:true)
								u_copy_1.modifiers[1].SetOperationType 1 #union
								u_copy_1.modifiers[1].AppendOperand	2
								u_copy_1.modifiers[1].SetOperationType 2 #intersection
								select u_copy_1	
								for u in #{2..ucx_copy.count} where not keyboard.escPressed do u_copy_1.modifiers[1].AppendFolderOperand 2 ucx_copy[u]
							
								convertTopoly u_copy_1
								if polyop.getnumfaces u_copy_1 != 0 then error = "UCX objects have intersections.\nSee intersection model for details." 
								else
								(
									delete u_copy_1
									error = "UCX objects have no intersections!" 
									select ucx
								)
							)
							else
							(
								error = "For individual detailed test for UCX objects intersections, explode them first to elements" 
							)
						)
					)	
				)
				(ucx.count > 1):
				(
					if ctrl then --convex-concave test 
					(
						--?? ????????
						/*
						err = #()
						for u in ucx where not keyboard.escPressed do
						(
							u_copy = copy u
							convertTopoly u_copy
							select u_copy
							subObjectLevel = 1
							polyop.setVertSelection u_copy #all
							PolyToolsSelect.ConvexConcave 0.001 1
							--baking AO to vertex colour
							--<boolean>nvpx.IsConvex <node>inode
							--PolyToolsSelect.ConvexConcave 0.001 1 --Select Concave Faces
							--PolyToolsSelect.ConvexConcave 0.001 2 --Select Convex Faces 	
							temp_true = #{}
							temp_true = polyop.getVertSelection u_copy	
							delete u_copy
							if not temp_true.isempty then append err u
						)
						if err.count > 0 then 
						(
							select err
							error = "Some UCX bad and Concave, are selected."
						)
						else
						(
							select ucx
							error = "All UCX good and Convex."
						)
						*/
						max create mode
						selfaces = #{}
						concave = #()
						concaves = #()
						for u in ucx where not keyboard.escPressed do
						(
							s = copy u
							convertToPoly s
							
							--selfaces = polyOp.getfaceselection s
							points = #()
							hits = #()
							--if selfaces == #{} then selfaces = #{1..(polyOp.getNumFaces s)}
							selfaces = #{1..(polyOp.getNumFaces s)}
							for i in selfaces where not keyboard.escPressed do
							(
								vec = polyop.getFaceNormal s i
								--vec_projection = [vec.x, vec.y, 0]
								points = #()
								append points (polyop.getSafeFaceCenter s i) -- + (0.1*vec)
								if points.count > 0 and vec != undefined then --and vec_projection != undefined then 
								(
									for poi in points where poi != undefined do
									(
										hits = intersectRayScene (ray poi vec)
										--join hits (intersectRayScene (ray poi vec_projection))
										if hits.count > 0 then
										(		
											concave = #()
											concave = for h in hits where h[1] == s collect h 
											if concave.count > 0 then appendIfUnique concaves u
										)
									)
								)
							)	
							
							if not (polyop.getOpenEdges s).isempty then error_open_edges += "There are open edges: " + u.name + "\n"
							
							--????? ???????? ????? ??????? ?? convex concave ????? dot ???????? ??????, ???? ????????????, ?????? ???????, ???? 0 ???????????, ???? ????????????, ?????? ????????
							--selfaces = #{1..(polyOp.getNumFaces s)}
							found = false
							for f in selfaces where not keyboard.escPressed and not found do
							(
								local n = polyop.getFaceNormal s f
								local vv = polyop.getVertsUsingFace s #{f} --???????? ??????? ?????
								local ff = (polyop.getFacesUsingVert s vv) - #{f} --???????? ???????? ????? ??????, ????? ????????

								for f_ in ff where dot (polyop.getFaceNormal s f_) n < 0.0 do --???? dot ????????????, ?????? ???????? ?????
								(
									--format "% % % % % %\n" f f_ n m ff d
									appendIfUnique concaves u
									found = true
									exit 
								)
							)					
							delete s
						)
						if concaves.count > 0 then 
						(
							error = "UCX objects are not good, have concave forms.\n"
							for concave in concaves do error += concave.name + "\n"
							select concaves
						)
						else 
						(
							error = "UCX objects are good, do not have concave forms!"
							select ucx
						)
					)
					else
					(
						max modify mode
						for u in ucx where not keyboard.escPressed do
						(
							u_copy_other = copy u 
							convertTopoly u
							--local edges = #{1..u_copy_other.getNumEdges()} 
							--for e in edges where u_copy_other.GetEdgeFace e 1 == 0 or u_copy_other.GetEdgeFace e 2 == 0 do (error_open_edges += ("Open edges: " + u.name + "\n"); exit)
							if not (polyop.getOpenEdges u_copy_other).isempty then error_open_edges += "Open edges: " + u.name + "\n"
							delete u_copy_other
							free u_copy_other
						)	
						
						if not alt then
						(
							u_copy_1 = copy ucx[1]
							convertTopoly u_copy_1
							--ProBoolean.CreateBooleanObject  b c 2 0 1; --2 mean Subtraction ,0  mean Reference, 1 mean Retain Original Material
							--try (ProBoolean.createBooleanObjects (u_copy_1) (#(top,top2)) 2 2 0)catch(messagebox("?????? ??????? ???????? ??? ??????? ? ????????"))
							--ProBoolean.SetBoolOp u_copy_1 2
							--ProBoolean.setoperandA u_copy_1
							addmodifier u_copy_1 (BooleanMod method:0 disableInteractiveUpdates:true)
							u_copy_1.modifiers[1].SetOperationType 1 #union
							u_copy_1.modifiers[1].AppendOperand	2
							u_copy_1.modifiers[1].SetOperationType 2 #intersection
							select u_copy_1
							/*
							  .Operands : paramBlock2 array
							  .pivotAlign : boolean
							  .useOperandMaterial : boolean
							  .method : integer
							  .hideReference : boolean
							  .retainNonPlanarFaces : boolean
							  .preserveNormalData : boolean
							  .displayType : integer
							  .displayShading : integer
							  .selectedOpacity : float
							  .unselectedOpacity : float
							  .voxelSize : worldUnits
							  .operandItems : paramBlock2 array
							  .toleranceFactor : worldUnits
							  .hideBooleanOnCreate : boolean
							  .Transform : maxObject array
							  .useLiveReference : boolean
							  .disableInteractiveUpdates : boolean
							  .doDeterministicEdgeSort : boolean
							  .operationVersion : integer
							  .doTinyFragmentCleanup : boolean
							  .doCloneCoplanarSplitOverlappedFaces : boolean
							  .bevelDistance : worldUnits
							  .bevelDepth : float
							  .bevelNumSegments : integer

								showInterfaces     $.modifiers[1]
							 Interface: BooleanModifier
							   Properties:
							   Methods:
								<integer>GetNumOperands()
								<boolean>GetRootOperandName <index>operandIndex <&string>nameout
								   nameout is Out parameter
								<boolean>SetRootOperandName <index>operandIndex <string>name
								<boolean>GetFlatOperandName <index>operandIndex <&string>nameout
								   nameout is Out parameter
								<boolean>SetFlatOperandName <index>operandIndex <string>name
								<boolean>GetFolderOperandName <index>operandIndex <index>subOperandIndex <&string>nameout
								   nameout is Out parameter
								<boolean>SetFolderOperandName <index>operandIndex <index>subOperandIndex <string>name
								<boolean>GetRootOperandType <index>operandIndex <&enum>type
								   type enums: {#modified|#single|#folder}
								   type is Out parameter
								<boolean>GetNumFolderOperands <index>operandIndex <&integer>count
								   count is Out parameter
								<boolean>GetOperationType <index>operandIndex <&enum>type
								   type enums: {#union|#intersection|#subtraction|#merge|#attach|#insert|#split}
								   type is Out parameter
								<boolean>SetOperationType <index>operandIndex <enum>type
								   type enums: {#union|#intersection|#subtraction|#merge|#attach|#insert|#split}
								<boolean>GetOperationOption <index>operandIndex <&enum>option
								   option enums: {#none|#imprint|#cookie}
								   option is Out parameter
								<boolean>SetOperationOption <index>operandIndex <enum>option
								   option enums: {#none|#imprint|#cookie}
								<boolean>GetDisable <index>operandIndex <&boolean>disable
								   disable is Out parameter
								<boolean>SetDisable <index>operandIndex <boolean>disable
								<boolean>RemoveOperand <index>operandIndex
								<boolean>AppendOperand <enum>operandtype operandNode:<node> operationType:<enum> operationOption:<enum>
								   operandtype enums: {#modified|#single|#folder}
								   operandNode default value: undefined
								   operationType enums: {#union|#intersection|#subtraction|#merge|#attach|#insert|#split}
								   operationType default value: #union
								   operationOption enums: {#none|#imprint|#cookie}
								   operationOption default value: #none
								<boolean>InsertOperand <enum>operandtype <index>where operandNode:<node> operationType:<enum> operationOption:<enum>
								   operandtype enums: {#modified|#single|#folder}
								   operandNode default value: undefined
								   operationType enums: {#union|#intersection|#subtraction|#merge|#attach|#insert|#split}
								   operationType default value: #union
								   operationOption enums: {#none|#imprint|#cookie}
								   operationOption default value: #none
								<boolean>RemoveFolderOperand <index>operandIndex <index>subOperandIndex
								<boolean>AppendFolderOperand <index>operandIndex <node>operandNode
								<boolean>InsertFolderOperand <index>operandIndex <index>where <node>operandNode
								<boolean>AlignPivot <index>operandIndex
								<boolean>ExtractAsObject <index>operandIndex
								<boolean>CutOperand()
								<boolean>PasteOperand <index>operandIndex
								<boolean>PasteToNewModifier()
								<boolean>ExtractSeams <index>operandIndex
								<boolean>CreateObjects <&node array>createdNodes
								   createdNodes is In and Out parameter
								<boolean>SelectFlatOperands <&index array>operandIndexes
								   operandIndexes is In and Out parameter
								<boolean>ClearClipboard()
							*/
							for u in #{2..ucx.count} where not keyboard.escPressed do
							(
								u_copy = copy ucx[u]
								convertTopoly u_copy
								u_copy_1.modifiers[1].AppendFolderOperand 2 u_copy
								
								--ProBoolean.createBooleanObjects u_copy_1 u_copy 1 2 0
								--ProBoolean.SetBoolOp u_copy_1 1
								--ProBoolean.setoperandB u_copy_1 u_copy 0 1
								--try (ProBoolean.createBooleanObjects u_copy_1 u_copy 1 2 0)catch()
							)	
							
							convertTopoly u_copy_1
							if polyop.getnumfaces u_copy_1 != 0 then error = "UCX objects have intersections.\nSee intersection model for details." 
							else
							(
								delete u_copy_1
								free u_copy_1
								error = "UCX objects have no intersections!" 
								select ucx
							)
						)
						else --????? ??????????? ?????? ?????????? 
						(
							error = ""
							for u in #{1..ucx.count} where not keyboard.escPressed do
							(
								print ucx[u].name
								for w in #{1..ucx.count} where w > u and not keyboard.escPressed do
								(
									local u_copy = copy ucx[u]
									local w_copy = copy ucx[w]
									convertToPoly u_copy
									convertToPoly w_copy
									local nam_u = (filterstring ucx[u].name "_")[(filterstring ucx[u].name "_").count]
									local nam_w = (filterstring ucx[w].name "_")[(filterstring ucx[w].name "_").count]
									--local v_copy = u_copy - w_copy
									--convertToPoly v_copy
									
									addmodifier u_copy (BooleanMod method:0 disableInteractiveUpdates:true)
									u_copy.modifiers[1].SetOperationType 1 #union
									u_copy.modifiers[1].AppendOperand 2
									u_copy.modifiers[1].SetOperationType 2 #intersection	
									u_copy.modifiers[1].AppendFolderOperand 2 w_copy
									convertToPoly u_copy
									
									if polyop.getnumfaces u_copy != 0 then (error += nam_u + " and " + nam_w + " intersects\n"; print (nam_u + " and " + nam_w + " intersects") ) 
									delete u_copy
									free u_copy
								)	
								gc()								
							)
							gc()
							if error == "" then error = "UCX objects do not intersect"					
							select ucx
						)
					)
				)
			)
		)
		gc()
		messagebox (error + "\n" + error_open_edges)
	)

	on btn_UCX_Select pressed do
	(
		if selection.count > 0 then
		(
			sel = selection as Array
			ucx = #()
			for i in sel do
				for o in objects where findstring o.name "UCX_" != undefined and findstring o.name i.name != undefined do appendifunique ucx o
			for i in sel where findstring i.name "UCX_" != undefined do
				for o in objects where findstring o.name "UCX_" != undefined and findstring o.name (trimright i.name "0123456789_") != undefined do appendifunique ucx o
			selectmore ucx
		)
	)
	
	on btn_UCX_Select rightclick do
	(
		if selection.count > 0 then
		(
			sel = selection as Array
			ucx = #()
			obj = #()
			ucx = for s in sel where findstring s.name "UCX_" != undefined collect s
			obj = for s in sel where findstring s.name "UCX_" == undefined collect s
			if obj.count > 0 then
				for i in obj do
					for o in objects where findstring o.name "UCX_" != undefined and findstring o.name i.name != undefined do appendifunique ucx o
			if ucx.count > 0 then
				for i in ucx do 
					for o in objects where findstring o.name "UCX_" != undefined and findstring o.name (trimright i.name "0123456789_") != undefined do appendifunique ucx o 
			selectmore ucx
		)
	)	
	
	on btn_UCX_move pressed do with undo "Move Faces" on  
	(
		if selection.count == 1 and classof selection[1] == Editable_Poly then
		(
			ctrl = keyboard.controlPressed
			alt = keyboard.altPressed
			s = selection[1]
			max modify mode
			err = #()
			points = #()
			verts = #{}
			selfaces = #{}
			selfaces = polyOp.getfaceselection s
			if selfaces.isempty then selfaces = #{1..(polyOp.getNumFaces s)}
			for i in selfaces where not keyboard.escPressed do
			(
				vec_A = polyop.getFaceNormal s i
				points = #()
				append points (polyop.getFaceCenter s i)
				if ctrl then 
				(
					verts = polyop.getVertsUsingFace s #{i}
					join points (for v in verts collect	(polyop.getvert s v))
				)
				if points.count > 0 then 
				(
					for poi_A in points do
					(
						if ctrl then
						(
							hits = intersectRayScene (ray poi_A vec_A)
							--print #(hits)
							if hits.count > 0 then
							(				
								for h in hits where h[1] == s do 
								(
									if distance poi_A h[2].pos < 0.01 or (distance poi_A h[2].pos > 0.01 and distance poi_A h[2].pos <= 0.02) and (abs(dot vec_A h[2].dir) >= 0.99 or abs(dot vec_A h[2].dir) <= 0.01) then 
									(
										appendIfUnique err #(i, distance poi_A h[2].pos) 
									)
								)
							)
						)
						else
						(
							hits = intersectRay s (ray poi_A vec_A) 
							--print #(hits)
							if hits != undefined then
							(				
								if distance poi_A hits.pos < 0.01 or (distance poi_A hits.pos > 0.01 and distance poi_A hits.pos <= 0.02) and (abs(dot vec_A hits.dir) >= 0.99 or abs(dot vec_A hits.dir) <= 0.01) then 
								(
									appendIfUnique err #(i, distance poi_A hits.pos) 
								)
							)
						)						
					)
				)
			)
			polyop.flipNormals s selfaces
			for i in selfaces where not keyboard.escPressed do
			(
				vec_A = polyop.getFaceNormal s i
				points = #()
				append points (polyop.getFaceCenter s i)
				if ctrl then 
				(
					verts = polyop.getVertsUsingFace s #{i}
					join points (for v in verts collect	(polyop.getvert s v))
				)
				if points.count > 0 then 
				(
					for poi_A in points do
					(
						if ctrl then
						(
							hits = intersectRayScene (ray poi_A vec_A)  -- collecting intersections
							--print #(hits)
							if hits.count > 0 then
							(				
								for h in hits where h[1] == s do 
								(
									--if distance poi_A h[2].pos < 0.01 or (distance poi_A h[2].pos > 0.01 and distance poi_A h[2].pos <= 0.02) and (abs(dot vec_A hits[1][2].dir) >= 0.99 or abs(dot vec_A hits[1][2].dir) <= 0.01) then 
									if distance poi_A h[2].pos < 0.01 or (distance poi_A h[2].pos > 0.01 and distance poi_A h[2].pos <= 0.02) and (abs(dot vec_A h[2].dir) >= 0.99 or abs(dot vec_A h[2].dir) <= 0.01) then 
									(
										appendIfUnique err #(i, -(distance poi_A h[2].pos)) 
									)
								)
							)
						)
						else
						(
							hits = intersectRay s (ray poi_A vec_A) 
							--print #(hits)
							if hits != undefined then
							(				
								if distance poi_A hits.pos < 0.01 or (distance poi_A hits.pos > 0.01 and distance poi_A hits.pos <= 0.02) and (abs(dot vec_A hits.dir) >= 0.99 or abs(dot vec_A hits.dir) <= 0.01) then 
								(
									appendIfUnique err #(i, -distance poi_A hits.pos) 
								)
							)
						)			
					)
				)
			)	
			polyop.flipNormals s selfaces
			print #(err)
			max modify mode
			subObjectLevel = 4
			--polyOp.setFaceSelection s err
			vv_done = #{}
			for e in err do
			(
				vv = polyop.getVertsUsingFace s #{e[1]}
				if alt then polyop.moveVert s (vv - vv_done) ((-0.015/2 + e[2]/2) * getVertNormal s vv)
				else polyop.moveVert s (vv - vv_done) ((-0.015/2 + e[2]/2) * (normalize (polyop.getFaceNormal s e[1])))
				vv_done += vv
			)
			
			polyOp.setFaceSelection s ((for e in err collect e[1]) as bitarray)
			
			if alt then
			(
				verts_near = #()
				vv = polyop.getVertsUsingFace s selfaces
				for v1 in vv do
				(
					p1 = polyop.getvert s v1
					for v2 in vv where v1 < v2 do
					(
						p2 = polyop.getvert s v2
						if distance p1 p2 <= 0.02 then 
						(
							appendIfUnique verts_near #(v1, distance p1 p2, normalize (p1 - p2))
							appendIfUnique verts_near #(v2, distance p1 p2, normalize (p2 - p1))
						)
					)
				)
				
				if verts_near.count > 0 then
				(
					for v in verts_near do
					(
						polyop.moveVert s #{v[1]} ((0.015/2 - v[2]) * v[3])
					)
				)
				
				polyOp.setVertSelection s ((for v in verts_near collect v[1]) as bitarray)
			)
			redrawViews()
		)
		else messagebox "Select one UCX object as Editable Poly with few attached elements"
	)	

/*	
	on btn_UCX_move rightclick do with undo "Move Faces" on  
	(
		if selection.count == 2 and classof selection[1] == Editable_Poly and classof selection[2] == Editable_Poly then
		(
			if findstring selection[1].name "UCX_" != undefined then 
			(
				s_ucx = selection[1]
				if findstring selection[2].name "UCX_" == undefined then s = selection[2]
			)
			if findstring selection[2].name "UCX_" != undefined then 
			(
				s_ucx = selection[2]
				if findstring selection[1].name "UCX_" == undefined then s = selection[1]				
			)
				
			if s != undefined and s_ucx != undefined then
			(
				ctrl = keyboard.controlPressed
				alt = keyboard.altPressed
				max modify mode
			
				selfaces = #{}
				selfaces = polyOp.getfaceselection s
				if selfaces == #{} then selfaces = #{1..(polyOp.getNumFaces s)}
			
				selfaces_ucx = #{}
				selfaces_ucx = polyOp.getfaceselection s_ucx
				if selfaces_ucx == #{} then selfaces_ucx = #{1..(polyOp.getNumFaces s_ucx)}
				--polyop.flipNormals s_ucx selfaces_ucx
				err = #()	
				for f in selfaces_ucx do
				(
					polyop.detachFaces s_ucx #{f} asNode:true delete:false name:(uniqueName (s_ucx.name + "_" + f as string))
					s_ucx_temp = maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))
					addmodifier s_ucx_temp (shell innerAmount:0.5 outerAmount:0.5)
					addmodifier s_ucx_temp (push Push_Value:0.5)
					vol = volumeselect level:2 type:1 method:0 volume:3 node:s_ucx_temp 	
					addmodifier s vol
					addModifier s (Edit_poly())
					max modify mode
					modPanel.setCurrentObject s.modifiers[#Edit_Poly]
					sel = s.modifiers[#Edit_Poly].getSelection #Face	
					--sel = polyOp.getfaceselection s.modifiers[#Edit_Poly]
					--print #(sel)
					--collapseStack s	
					deletemodifier s 1	
					deletemodifier s 1		
					deletemodifier s_ucx_temp 1
					deletemodifier s_ucx_temp 1
	
					points = #()
					verts = #{}
					--polyop.flipNormals s_ucx_temp #{1..(polyOp.getNumFaces s_ucx_temp)}
					for i in sel where not keyboard.escPressed do
					(
						vec = polyop.getFaceNormal s i
						points = #()
						append points (polyop.getFaceCenter s i)
						if ctrl then 
						(
							verts = polyop.getVertsUsingFace s #{i}
							join points (for v in verts collect	(polyop.getvert s v))
						)
						
						if points.count > 0 then 
						(
							for poi in points do
							(
								hits = intersectRayScene (ray poi vec) --collecting intersections
								--print #(hits)
								if hits.count > 0 then
								(	
									for h in hits where h[1] == s_ucx_temp do 
									(
										print #(h)
										if distance poi h[2].pos < 0.01 or (distance poi h[2].pos > 0.01 and distance poi h[2].pos <= 0.1) and (abs(dot vec hits[1][2].dir) >= 0.99 or abs(dot vec hits[1][2].dir) <= 0.01) then 
										(
											appendIfUnique err #(i, distance poi h[2].pos) 
										)
									)
								)
							)
						)
					)
					print #(err)
					delete s_ucx_temp
				)
				
				--polyop.flipNormals s_ucx selfaces_ucx
			)

			print #(err)
			max modify mode
			subObjectLevel = 4
			--polyOp.setFaceSelection s err
			for e in err do
			(
				vv = polyop.getVertsUsingFace s #{e[1]}
				if ctrl then polyop.moveVert s vv ((-0.015/2 + e[2]/2) * getVertNormal s vv)
				else polyop.moveVert s vv ((-0.015/2 + e[2]/2) * (normalize (polyop.getFaceNormal s e[1])))
			)
			
			polyOp.setFaceSelection s ((for e in err collect e[1]) as bitarray)
			

		)	
	)	
*/		

	on btn_UCX_Hide pressed do
	(
		for i in objects where findstring i.name "UCX_" != undefined do i.isHidden = true
	)
	
	on btn_UCX_Unhide pressed do
	(
		for i in objects where findstring i.name "UCX_" != undefined do i.isHidden = false
	)
	
	on btn_UCX_Clear_Mat pressed do
	(
		for i in selection do i.material = undefined
	)
	
	on btn_UCX_connect pressed do
	(
		sel = selection as array
		for i in sel where classof i == editable_poly do 
		(
			select i
			max modify mode
			subObjectLevel = 1
			i.unhideAll #Vertex
			i.unhideAll #Face
			max select all 
			i.ConnectVertices vertexFlag:1
			subObjectLevel = 0
		)
		select sel
	)

	on btn_UCX_rename pressed do
	(
		num = 0
		for i in selection do
		(
			i.name = trimright i.name "_0123456789"
			i.name = trimleft i.name "_0123456789"
			i.name = substitutestring i.name "UCX_" "" 
		)
		for i in selection do
		(
			i.name = uniqueName ("UCX_" + i.name + "_")
		)
	)
	
	/*
	on btn_UCX_pivot pressed do
	(
		for i in selection do i.pivot = [0,0,0]
	)
	*/
	
	on btn_UCX_makeground pressed do with undo "Make UCX" on -- with redraw off
	(
		if selection != undefined and selection.count == 1 and classof selection[1] == editable_poly then
		(
			max modify mode
			if subObjectLevel == 4 then
			(
				sel = selection[1]
				selFaces = polyop.getFaceSelection sel
				if selFaces.count > 0 then
				(
					selnew = copy sel
					selnew.name = "UCX_"+ sel.name
					select selnew
					subObjectLevel = 4
					max select invert
					max delete
					max select invert
					
					--polyop.splitEdges selnew (polyop.getEdgesUsingFace selnew (polyop.getFaceSelection selnew)) --selnew.SetSelection #Edge (polyop.getEdgesUsingFace selnew (polyop.getFaceSelection selnew))

					--subObjectLevel = 4
					--max select all 
					polyop.setFaceSelection selnew #all
					selectedFaces = polyop.getFaceSelection selnew
					
					--PolyToolsSelect.ConvexConcave 0.0 1
					--selectedFaces = polyop.getFaceSelection selnew	

					larges = #{}
					larges = convex_concave selnew selectedFaces --??????? ?????? ??, ??????? ???? ????????????? ?????????, concave, ????????

					--for ff in selectedFaces where (polyop.getFaceDeg selnew ff) > 4 do join larges #{ff} 
					--???? ??????????????? ????? ? ????? 4 ??????
					--larges = for f in #{1..polyop.getnumfaces selnew} where (polyop.getFaceDeg selnew f) > 4 collect f
					--print #(larges)
					
					--selectedFaces -= larges
					--polyop.setFaceSelection selnew selectedFaces
/*
					while larges.count > 0 do
					(
						if keyboard.escPressed then exit
						for f in larges do
						(
													
							arr = #()
							--edges = #{1..polyop.getnumedges selnew}
							ee = polyop.getEdgesUsingFace selnew #{f}
							vv = polyop.getVertsUsingFace selnew #{f}
							--otheredges = edges - vv
							pp = for v in vv collect #(v, polyop.getVert selnew v)
							for p1 in pp do
								for p2 in pp where p1[1] != p2[1] and ((polyop.getEdgesUsingVert selnew #{p1[1],p2[1]})).numberset > 3 do append arr #(p1[1], p2[1], (distance p1[2] p2[2]))
							--????? ????? ??????, ??? ???????? ???????? ??????????? ? ???? ??????????? ??????
						
							
							--?? ?????? ?? ????????
							--polyop.setFaceSelection #{f}
							--subObjectLevel = 4 --switch to Facelevel
							--PolyToolsSelect.ConvexConcave 0.001 1 --Select Concave Faces
							--PolyToolsSelect.ConvexConcave 0.001 2 --Select Convex Faces 
							
						
								select selnew
								polyop.setFaceSelection selnew #{f}
								polyop.detachFaces selnew #{f} asNode:true name:(uniqueName (selnew.name + "_" + f as string))
								sel_temp = maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))
								select sel_temp
								subObjectLevel = 3
								max select all 		
								sel_temp.extrusionType = 2			
								sel_temp.extrudeFaces -10.0 faceFlags:1
								sel_temp.MakePlanarIn #Z selLevel:#Face flag:1					
								subObjectLevel = 3
								max select all 
								sel_temp.capHoles #Edge flags:1
								subObjectLevel = 4	
								PolyToolsSelect.ConvexConcave 0.0 1
								sel_temp_true = #{}
								sel_temp_true = polyop.getFaceSelection sel_temp
								print #(sel_temp_true)
								subObjectLevel = 0
								--delete sel_temp
							if sel_temp_true != #{} then 
							(
							
								subObjectLevel == 1	
								polyop.setVertSelection selnew (polyop.getVertsUsingFace selnew #{f}) 
							
								selnew.ConnectVertices vertexFlag:1 --selnew.buttonOp #ConnectVertices 
								polyop.splitEdges selnew #{1..polyop.getnumedges selnew}
						
							)
							else
							(
								selectedFaces -= #{f}
							)
							
							larges = #{}
							--if selectedFaces.count > 0 then
								for ff in selectedFaces where (polyop.getFaceDeg selnew ff) > 4 do join larges #{ff}
							--larges = for f in #{1..polyop.getnumfaces selnew} where (polyop.getFaceDeg selnew f) > 4 collect f 
						)
					)						
*/

/*
					vv_sel = #{}
					if not larges.isempty then
					(
						for f in larges do
						(							
							vv_large = polyop.getVertsUsingFace selnew #{f}	
							pp_large = for v in vv_large collect #(v, polyop.getVert selnew v)
							
							--select selnew
							--polyop.setFaceSelection selnew #{f}
							polyop.detachFaces selnew #{f} asNode:true name:(uniqueName (selnew.name + "_" + f as string))
							sel_temp = maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))
							--select sel_temp				
							vv = polyop.getVertsUsingFace sel_temp #{1..polyop.getnumfaces sel_temp}
							
							vv_sel_copy = #{}	
							for v1 in vv do
								for v2 in vv where v1 < v2 do
								(
									sel_temp_copy = copy sel_temp				
									polyop.setVertSelection sel_temp_copy #{v1, v2}
									sel_temp_copy.ConnectVertices vertexFlag:1 
									polyop.setFaceSelection sel_temp_copy #all
									sel_copy = polyop.getFaceSelection sel_temp_copy
									larges_copy = convex_concave sel_temp_copy sel_copy
									if larges_copy.isempty then vv_sel_copy += #{v1, v2}
									--delete sel_temp_copy
								)
							pp = for v in vv_sel_copy collect #(v, polyop.getVert sel_temp v)
							for p_large in pp_large where (for p in pp where p_large[2] == p[2] collect p).count > 0 do vv_sel += #{p_large[1]}
							--delete sel_temp
						)
						print #(vv_sel)
						subObjectLevel == 1	
							--polyop.setVertSelection selnew (polyop.getVertsUsingFace selnew #{f}) 
						polyop.setVertSelection selnew vv_sel 
						selnew.ConnectVertices vertexFlag:1 --selnew.buttonOp #ConnectVertices 
					)
*/					
					
					if not larges.isempty then
					(
						subObjectLevel == 1
						for f in larges do
						(
							polyop.setVertSelection selnew (polyop.getVertsUsingFace selnew #{f}) 	
							selnew.ConnectVertices vertexFlag:1 --selnew.buttonOp #ConnectVertices
						)

					)	
					
					polyop.splitEdges selnew #{1..polyop.getnumedges selnew}	
					-- Inset
					select selnew
					subObjectLevel = 4
					max select all 
					selnew.EditablePoly.SetSelection #Face (polyop.getFaceSelection selnew) --$.Select #Face selectedFaces invert:false select:true --$.EditablePoly.SetSelection #Face selectedFaces
					selnew.extrusionType = 2 --by polygon
					selnew.extrudeFaces 0.0 faceFlags:1 --polyop.extrudeFaces $ selectedFaces 0.0
					selnew.outlineAmount = -0.01
					selnew.EditablePoly.Outline() --$.outline flag:1
					redrawViews()
					
					max select invert
					max delete
					max select all 
					subObjectLevel = 3
					max select all 			
					
					if keyboard.controlPressed then 
					(
						selnew.extrusionType = 2			
						selnew.extrudeFaces -10.0 faceFlags:1 --polyop.extrudeFaces $ selectedFaces -2.0
						selnew.MakePlanarIn #Z selLevel:#Face flag:1					
						subObjectLevel = 3
						max select all 
						selnew.capHoles #Edge flags:1
						subObjectLevel = 5
						max select all 
						selnew.flipNormals 1
						subObjectLevel = 0
						selnew.material = undefined
					)
					else
					(
						polyop.createShape selnew (polyop.getEdgeSelection selnew) smooth:false name:("!UCX_"+ sel.name) --node:&shp selnew.createShape "UCX_"+ sel.name false &shp edgeFlags:1
						shp = (maxOps.getNodeByHandle (amax (for o in shapes collect o.inode.handle))) --shp = getnodebyname ("!UCX_"+ sel.name)
						
						resetxform shp
						convertToSplineShape shp 
						addmodifier shp (extrude amount: -10.0 smooth:false capStart:false capEnd:true mapcoords:true useShapeIDs: false segs:1 matIDs:false)
						convertToPoly shp
						shp.material = undefined
						select shp
						subObjectLevel = 3
						max select all 	
						--subObjectLevel = 2	
						shp.MakePlanarIn #Z selLevel:#Edge flag:1					
						--subObjectLevel = 3
						max select all 
						shp.capHoles #Edge flags:1	
						shp.name = selnew.name
						delete selnew
						subObjectLevel = 0
					)
	--*/				
					redrawViews()	
				)
			)
			else messagebox "Select Horizontal faces from Ground object, do not change subobject level"
			/*
			max select invert
			max delete
			max select all 
			subObjectLevel = 3
			max select all 		
			selectedFaces = polyop.getFaceSelection $		
			$.extrusionType = 2			
			$.extrudeFaces -2.0 faceFlags:1 --polyop.extrudeFaces $ selectedFaces -2.0
			$.MakePlanarIn #Z selLevel:#Face flag:1	
			--$.SelectBorder()
			subObjectLevel = 3
			max select all 
			$.capHoles #Edge flags:1
			subObjectLevel = 5
			max select all 
			--$.flipNormals 1
			redrawViews()
			*/
			/*
			i.insetType = 1
			i.insetAmount = 0.01
			i.EditablePoly.buttonOp #Inset
 
			i.extrusionType = 2
			i.faceExtrudeHeight = -2.0
			i.EditablePoly.buttonOp #Extrude
			*/
		)
	)

	on btn_UCX_explode pressed do with undo "Explode UCX" on
	(
		if selection.count > 0 then
		(
			for i in selection where (superclassof i == GeometryClass) and (not isgrouphead i) do
			(
				converttopoly i
				while i.getNumFaces() != 0 do 
				(
					polyop.detachFaces i (polyOp.getElementsUsingFace $ #{1}) asNode:true name:(uniqueName ($.name + "_")) --(num as string)
				)
			)
			delete selection
		)
		else messagebox "Select few objects"
	)
	
	on btn_UCX_explode rightclick do with undo "Attach All in one UCX" on	
	(
		s = selection as array
		if selection.count > 0 then
		(
			if selection.count == 1 then 
			(
				converttopoly selection[1]
			)
			else
			(
				converttopoly selection[1]
				for w in #{2..s.count} where (superclassof s[w] == GeometryClass) and (not isgrouphead s[w]) do polyop.attach s[1] s[w] 
				s[1].name = trimright (s[1].name) "0123456789_"
			)
		)
		else messagebox "Select few objects"
	)

/*	
	on btn_UCX_explode rightclick do with redraw off
	(
		max create mode 
		obj0 = objects as array
		cur = $
		n = 0
		while (getFaceSelection $.mesh).numberset != 0 do 
		(
			El = polyOp.getElementsUsingFace $ #{1}
			polyOp.detachFaces $ El asNode:true name: (uniqueName ($.name + "_"))
			select cur
			n += 1
		)
		if n==1 then 
		(
			max undo 
			macros.run "Editable Polygon Object" "EPoly_Detach"
		)
		else 
		(
			delete $
			Exploded_objects = for i in objects where findItem obj0 i == 0 collect i
			for i in Exploded_objects do 
			(
				centerPivot i
				worldAlignPivot i 
				i.wirecolor = color 0 0 225 
			)
		)
	)
*/

	on btn_UCX_gaps pressed do with undo "Make UCX Gaps" on
	(
		local ctrl = keyboard.controlPressed
		local alt = keyboard.altPressed
		local shift = keyboard.shiftPressed		
		if selection.count > 1 then
		(
			/*
			local dir = GetDir #maxroot + "GeoScripts\\mesh\\"
			local filename = "1.obj"
			local filename_in = "2.obj" 
			local filename_out = "3.obj"
			--print filename	
			local start = GetDir #maxroot + "GeoScripts\\mesh\\"		
			
			--obj
			--theINI = objimp.getIniName()
			theINI = objexp.getIniName() --objExp.getPresetIniName()
			--getIniSetting theINI
			--getIniSetting theINI "General"
			setIniSetting theINI "General" "UseLogging" "0"
			setIniSetting theINI "General" "Preset" "<NONE>"
			setIniSetting theINI "General" "MapSearchPath" ""
			setIniSetting theINI "Geometry" "FlipZyAxis" "0"
			setIniSetting theINI "Geometry" "Shapes" "0"
			setIniSetting theINI "Geometry" "ExportHiddenObjects" "0"
			setIniSetting theINI "Geometry" "FaceType" "0"
			setIniSetting theINI "Geometry" "Normals" "1"
			setIniSetting theINI "Geometry" "SmoothingGroups" "1"
			setIniSetting theINI "Geometry" "TextureCoords" "0"
			setIniSetting theINI "Geometry" "ObjScale" "1.000000"
			setIniSetting theINI "Material" "UseMaterial" "0"
			setIniSetting theINI "Material" "CreateMatLibrary" "0"
			setIniSetting theINI "Material" "ForceBlackAmbient" "0"
			setIniSetting theINI "Material" "UseMapPath" "./"
			setIniSetting theINI "Material" "AutoMapChannel" "0"
			setIniSetting theINI "Material" "MapChannel" "1"
			setIniSetting theINI "Material" "ExtendedParams" "1"
			setIniSetting theINI "Material" "ConvertBitmaps" "0"
			setIniSetting theINI "Material" "RenderProcedural" "0"
			setIniSetting theINI "Material" "ResizeMaps" "0"
			setIniSetting theINI "Material" "ResizeMaps2n" "0"
			setIniSetting theINI "Material" "MapFormat" "3"
			setIniSetting theINI "Material" "MapSizeX" "512"
			setIniSetting theINI "Material" "MapSizeY" "512"
			setIniSetting theINI "Output" "RelativeIndex" "0"
			setIniSetting theINI "Output" "Target" "0"
			setIniSetting theINI "Output" "Precision" "6"
			setIniSetting theINI "Optimize" "optVertex" "1"
			setIniSetting theINI "Optimize" "optNormals" "1"
			setIniSetting theINI "Optimize" "optTextureCoords" "0"
			theClasses = exporterPlugin.classes
			*/
			
			local sel = selection as array
			for i in #{1..sel.count} where not keyboard.escPressed do
			(
				--select sel[i]
				--j = copy sel[i]
				--j.name = sel[i].name
				
				if classof sel[i] != Editable_Poly then converttopoly sel[i]
				--select j	
				
				--if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\1.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\1.obj")
				--if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\2.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\2.obj")
				--if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\3.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")				

				--exportFile (dir + filename) #noPrompt selectedOnly:true using:ObjExp -- using:theClasses[findItem theClasses ObjExp]
				--delete j
				
				for k in #{1..sel.count} where k > i do
				(
					l = copy sel[k]
					l.name = sel[k].name
				
					if classof l != Editable_Poly then converttopoly l
					addmodifier l (push Push_Value: 0.005)
					converttopoly l
					sel[i] = sel[i] - l
					delete l
					
				/*		
					select l
					exportFile (dir + filename_in) #noPrompt selectedOnly:true using:ObjExp -- using:theClasses[findItem theClasses ObjExp]
					delete l

					local cmd = "meshconv --input-file " + "\"" + filename + "\"" + " --intersect=" + "\"" + filename_in + "\"" + " --output-file " + "\"" + filename_out + "\""
					HiddenDOSCommand cmd startpath:start prompt:"Generating Gaps for UCX Forms..."
					importFile (dir + filename_out) #noPrompt
					local ucx_new = selection[1]
					ucx_new.name = "Int_UCX_" + sel[i].name
					centerpivot ucx_new	
					addmodifier ucx_new (push Push_Value: 0.005)
					converttopoly ucx_new
					if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\3.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")
					if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\2.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\2.obj")
					select ucx_new
					exportFile (dir + filename_in) #noPrompt selectedOnly:true using:ObjExp -- using:theClasses[findItem theClasses ObjExp]
					delete ucx_new
					local cmd = "meshconv --input-file " + "\"" + filename + "\"" + " --subtract=" + "\"" + filename_in + "\"" + " --output-file " + "\"" + filename_out + "\""
					HiddenDOSCommand cmd startpath:start prompt:"Generating Gaps for UCX Forms..."
					importFile (dir + filename_out) #noPrompt
					if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\3.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")
					local ucx_done = selection[1]
					ucx_done.name = sel[i].name
					centerpivot ucx_done	
					delete sel[i]
					sel[i] = ucx_done

					local cmd = "meshconv --input-file " + "\"" + filename + "\"" + " --subtract=" + "\"" + filename_in + "\"" + " --output-file " + "\"" + filename_out + "\""
					HiddenDOSCommand cmd startpath:start prompt:"Generating Gaps for UCX Forms..."
					importFile (dir + filename_out) #noPrompt
					local ucx_done = selection[1]
					ucx_done.name = sel[i].name
					centerpivot ucx_done	
					delete sel[i]
					sel[i] = ucx_done					
				*/	
				)
				
				--if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\1.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\1.obj")
				--if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\2.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\2.obj")
				--if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\3.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")				
			)	
			select sel	
		)
		else messagebox "Select more than one objects to generate Gaps between UCX forms"		
	)

	on btn_UCX_make pressed do with undo "Make UCX Forms" on
	(
		local ctrl = keyboard.controlPressed
		local alt = keyboard.altPressed
		local shift = keyboard.shiftPressed
		if selection.count > 0 then
		(
			local filename = GetDir #maxroot + "GeoScripts\\mesh\\1.obj" --pathConfig.GetDir #temp + "\\temp.obj" --GetDir #maxroot + "GeoScripts\\temp.obj"
			local filename_ = "1.obj"
			local filename_in = "2.obj" --pathConfig.GetDir #temp + "\\temp_in.obj" --"temp_in.obj"
			local filename_out = "3.obj" --pathConfig.GetDir #temp + "\\temp_out.obj" --"temp_out.obj"
			local filename_out_ = GetDir #maxroot + "GeoScripts\\mesh\\3.obj" --pathConfig.GetDir #temp + "\\temp_out.obj" --"temp_out.obj"
			--print filename	
			local start = GetDir #maxroot + "GeoScripts\\mesh\\"		
			
			--obj
			--theINI = objimp.getIniName()
			theINI = objexp.getIniName() --objExp.getPresetIniName()
			--getIniSetting theINI
			--getIniSetting theINI "General"
			setIniSetting theINI "General" "UseLogging" "0"
			setIniSetting theINI "General" "Preset" "<NONE>"
			setIniSetting theINI "General" "MapSearchPath" ""
			setIniSetting theINI "Geometry" "FlipZyAxis" "0"
			setIniSetting theINI "Geometry" "Shapes" "0"
			setIniSetting theINI "Geometry" "ExportHiddenObjects" "0"
			setIniSetting theINI "Geometry" "FaceType" "0"
			setIniSetting theINI "Geometry" "Normals" "1"
			setIniSetting theINI "Geometry" "SmoothingGroups" "1"
			setIniSetting theINI "Geometry" "TextureCoords" "1.000000"
			setIniSetting theINI "Geometry" "ObjScale" "1.000000"
			setIniSetting theINI "Material" "UseMaterial" "0"
			setIniSetting theINI "Material" "CreateMatLibrary" "0"
			setIniSetting theINI "Material" "ForceBlackAmbient" "0"
			setIniSetting theINI "Material" "UseMapPath" "./"
			setIniSetting theINI "Material" "AutoMapChannel" "0"
			setIniSetting theINI "Material" "MapChannel" "1"
			setIniSetting theINI "Material" "ExtendedParams" "1"
			setIniSetting theINI "Material" "ConvertBitmaps" "0"
			setIniSetting theINI "Material" "RenderProcedural" "0"
			setIniSetting theINI "Material" "ResizeMaps" "0"
			setIniSetting theINI "Material" "ResizeMaps2n" "0"
			setIniSetting theINI "Material" "MapFormat" "3"
			setIniSetting theINI "Material" "MapSizeX" "512"
			setIniSetting theINI "Material" "MapSizeY" "512"
			setIniSetting theINI "Output" "RelativeIndex" "0"
			setIniSetting theINI "Output" "Target" "0"
			setIniSetting theINI "Output" "Precision" "6"
			setIniSetting theINI "Optimize" "optVertex" "1"
			setIniSetting theINI "Optimize" "optNormals" "1"
			setIniSetting theINI "Optimize" "optTextureCoords" "1"
			theClasses = exporterPlugin.classes
			
			local sel = selection as array
			local ucxs = #()
			for i in sel where not keyboard.escPressed do
			(
				--select i
				j = copy i
				j.name = i.name
				
				if classof j != Editable_Poly then converttopoly j
				select j
				
				local sel_faces = #{}
				local sel_faces = polyop.getFaceSelection j
				
				if not sel_faces.isempty then polyop.deleteFaces j (#{1..(polyop.getNumFaces j)} - sel_faces) delIsoVerts:true
				
				if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\1.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\1.obj")
				if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\2.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\2.obj")
				if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\3.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")				

				exportFile filename #noPrompt selectedOnly:true using:ObjExp -- using:theClasses[findItem theClasses ObjExp]
					
				delete j
				--print ("meshconv.exe --input-file " + "\"" + filename + "\"" + " --remesh=" + (substitutestring (spn_UCX_make.value as string) "," ".") + " --output-file " + "\"" + filename_in + "\"")
				--print ("meshconv.exe --input-file " + "\"" + filename_in + "\"" + "--convex-hull --output-file " + "\"" + filename_out + "\"")
				--print start
				
				--cmd1 = "meshconv --input-file " + "\"" + filename_ + "\"" + " --remesh --output-file " + "\"" + filename_in + "\""
				local cmd1 = if spn_UCX_make.value == 0.0 then "meshconv --input-file " + "\"" + filename_ + "\"" + " --remesh --output-file " + "\"" + filename_in + "\""
					else "meshconv --input-file " + "\"" + filename_ + "\"" + " --remesh=" + (substitutestring (spn_UCX_make.value as string) "," ".") + " --output-file " + "\"" + filename_in + "\""
				local cmd2 = "meshconv --input-file " + "\"" + filename_in + "\"" + " --convex-hull --output-file " + "\"" + filename_out + "\""
				--print cmd1
				--print cmd2
				
				if ctrl then 
					HiddenDOSCommand cmd1 startpath:start prompt:"Processing Remeshing..."
				else 
					copyfile (GetDir #maxroot + "GeoScripts\\mesh\\1.obj") (GetDir #maxroot + "GeoScripts\\mesh\\2.obj")
				
				if not alt then 
					HiddenDOSCommand cmd2 startpath:start prompt:"Generating UCX Form..."
				else 
					copyfile (GetDir #maxroot + "GeoScripts\\mesh\\2.obj") (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")
				
				importFile filename_out_ #noPrompt
				
				--if doesFileExist filename_in then deletefile filename_in
				--if doesFileExist filename_out then deletefile filename_out	

				if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\1.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\1.obj")
				if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\2.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\2.obj")
				if doesFileExist (GetDir #maxroot + "GeoScripts\\mesh\\3.obj") then deletefile (GetDir #maxroot + "GeoScripts\\mesh\\3.obj")				
					
				local ucx_new = selection[1]
				ucx_new.name = "UCX_" + i.name
				centerpivot ucx_new
				if shift then addmodifier ucx_new (push Push_Value: 0.0)
				append ucxs ucx_new 
			)
			select ucxs
		)
		else messagebox "Select one or few objects to generate UCX forms"
	)		
	
	on btn_UCX_make rightclick do with undo "Make UCX Box" on
	(
		sel = selection[1]
		ctrl = keyboard.controlPressed
		t = 0.005
		if sel != undefined and classof sel == editable_poly then
		(
			max modify mode
			faces = polyop.getFaceSelection sel 
			polyop.detachFaces sel faces asNode:true delete:false name:"Test" node:j --editable_poly 
			j = maxOps.getNodeByHandle (amax (for i in objects collect i.inode.handle))
				
			ang = rotate_to_min_Y_gab j 2.0 -360 360
			ang = rotate_to_min_Y_gab j 0.1 (ang - 1.0) (ang + 1.0)

			j.pivot = [j.center.x, j.center.y, j.min.z]
			in coordsys world rotate j (eulerangles 0 0 ang) 
			resetxform j
			converttopoly j	
			j.pivot = [j.center.x, j.center.y, j.min.z]
			if ctrl then b = box width:(abs(j.max.x - j.min.x) + t) length:(abs(j.max.y - j.min.y) + t) height:(abs(j.max.z - j.min.z) + t) pos:[j.center.x, j.center.y, j.min.z] name:(uniquename ("UCX_" + sel.name + "_")) 
			else b = box width:(abs(j.max.x - j.min.x)) length:(abs(j.max.y - j.min.y)) height:(abs(j.max.z - j.min.z)) pos:[j.center.x, j.center.y, j.min.z] name:(uniquename ("UCX_" + sel.name + "_")) 
			in coordsys world rotate b (eulerangles 0 0 -ang)
			b.pos = [j.center.x, j.center.y, j.min.z]
			delete j
			select b
			converttopoly b
			Obj_Spln.btn_ConnectVerts.pressed()	
			select sel
			max modify mode
		)
	)
)

rollout Geojson "Geojson operations" autoLayoutOnResize:true
(
	group "Pivot operations"
	(
		button btn_combine_two_models "Combine two models near zero" width:260 tooltip:"??????????? ??? ?????? ????? ???? ?????????, ????? ?????????? ?? ????? ??????? Pivot | Combine two models near zero to combine their Pivots "		
		editText edt_pivot_pos_x "X position" text:"" fieldwidth:80 width:85 labelOnTop:true align:#left offset:[0,0] across:3 tooltip:""
		editText edt_pivot_pos_y "Y position" text:"" fieldwidth:80 width:85 labelOnTop:true offset:[0,0] tooltip:""
		editText edt_pivot_pos_z "Z Height position" text:"" fieldwidth:80 width:85 labelOnTop:true offset:[0,0] tooltip:""

		editText edt_pivot_rot_x "X rotation" text:"" fieldwidth:80 width:85 labelOnTop:true align:#left offset:[0,0] across:3 tooltip:""
		editText edt_pivot_rot_y "Y rotation" text:"" fieldwidth:80 width:85 labelOnTop:true offset:[0,0] tooltip:""
		editText edt_pivot_rot_z "Z rotation" text:"" fieldwidth:80 width:85 labelOnTop:true offset:[0,0] tooltip:""

		button btn_pivot_get "Get Pivot Pos & Rot" width:130 align:#left across:2 tooltip:"???????? ?????????? ????????? ? ???????? ? ???????? ?? ? ???? | Get Pivot Position and Rotation and write to fields"
		button btn_pivot_set "Set Pivot to Down Center" width:130 align:#right tooltip:"?????????? Pivot ? ????????? ????? ? ?? ?????? ???????, ???? ???? ??????? ????? ??? ???????, ???????????? ?? ??? ??????????? ??????? ??????? ?????? ??????? | Set Pivot to Down and Center of object\nIf faces or verts have been selected then use them as height of project Zero"
		button btn_pivot_pos "Set Position To" width:85 align:#left across:3 tooltip:"????????? ?????? ? ???????????? ? ????????????, ?????????? ? ????? | Place object to coordinates shown in fields"
		button btn_find_rot "Find Rotation" width:85 tooltip:"????????? ?????? ??????????? ??? ?????????, ??????? ????? ?????? ?????????????, ???????? ???? ? ???? ???????? | Try to Rotate object to parallel of axis, useful after transformations have been reseted, write angle to field"
		button btn_resetXForm "Reset Transforms" width:85 align:#right tooltip:"????? ?????????????? ???????? ? ?????????? ????? | Reset Transformations of objects and update fields"
		button btn_load_moscow "Check with Moscow borders" width:260 tooltip:"LMB: ????????? ????? ?????? ?????? ??? ?????? ????????? ? ?????????? ? ?????\nRMB: ??????? ????? ?????? ?????? | LMB: Load the Moscow boundary map to verify coordinates with the district\nRMB: Delete the Moscow boundary map"		

	)
	group "Geojson operations"
	(		
		editText edt_pic_dims "Dims" text:"" fieldwidth:40 width:100 align:#right offset:[0,0] tooltip:"???????? ??????????? ???????? | Dimensions of loaded picture"
		button btn_pic_open "Load Picture" across:2 align:#right tooltip:"????????? ???????????, ????? ???????? ?????? ?? 256x256 ? ???????????? ? Base64, ?????????? ??? ??????? ? Geojson | Load picture to resize to 256x256 and encode to Base64, neccessary to paste to Geojson"
		button btn_convert_to_base "Base64 to Clipboard" align:#right tooltip:"????????? ??? Base64 ? ????? ?????? | Put Base64 code to Clipboard"
		imgtag img_tag_pic "Picture" bitmap:(bitmap 50 50 color:(color 50 50 50)) align:#left width:50 height:50 style:#bmp_stretch offset:[0,-50] tooltip:""
		button btn_create_geojson "Create file"	across:3 align:#left offset:[0,0] enabled:false
		button btn_save_geojson "Save file" align:#center offset:[0,0] enabled:false
		button btn_load_geojson "Load file"	align:#right offset:[0,0] enabled:false 
	)	

	on Geojson open do
	(
		for i in Geojson.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_Geojson.ini") i.name "Geojson" (syssetup.rdo_lang.state))
	)
	
	on btn_load_moscow pressed do
	(
		local sel = #()
		sel = selection as array
		if (mergeMAXFile (GetDir #maxroot + "GeoScripts\\Moscow_boundaries_MSK.max") #noRedraw #deleteOldDups #useMergedMtlDups quiet:true) then 
		(
			print "Moscow_boundaries_MSK.max"	
			converttomesh $bounds_MSK
			if sel.count > 0 then
			(
				local err = ""
				for s in selection do
				(
					local hits_ex = #()
					hits_ex = intersectRayScene (ray [s.center.x, s.center.y, 1] [0,0,-1])
					print #(hits_ex)
					if hits_ex != undefined then
					(
						local good = false
						for hit in hits_ex where hit[1].name == "bounds_MSK" do
						(
							--poi = point pos:hit[2].pos
							err += s.name + ": is in boundaries of Moscow\n"
							good = true
						)
						if not good then err += s.name + ": is not in boundaries of Moscow\n"
					)	
					else
					(
						err += s.name + ": is not in boundaries of Moscow\n"
					)
						
				)
				messagebox err
			)
		)	
		else messageBox "Scene Moscow_boundaries_MSK.max do not loaded"
	)
	
	on btn_load_moscow rightclick do
	(
		delete ($bounds_MSK*)
	)
	
	on btn_find_rot pressed do
	(
		if selection.count == 1 then
		(
			j = selection[1]
			local ang = rotate_to_min_Y_gab j 2.0 -360 360
			ang = rotate_to_min_Y_gab j 0.1 (ang - 1.0) (ang + 1.0)
			in coordsys world rotate j (eulerangles 0 0 ang)
			edt_pivot_rot_z.text = (selection[1].rotation as eulerAngles).z as string
		)
	)
	
	on btn_resetXForm pressed do
	(
		for i in selection do
		(
			ResetXForm i
			ConverttoPoly i
			edt_pivot_pos_x.text = i.pos.x as string
			edt_pivot_pos_y.text = i.pos.y as string
			edt_pivot_pos_z.text = i.pos.z as string	

			edt_pivot_rot_x.text = (i.rotation as eulerAngles).x as string
			edt_pivot_rot_y.text = (i.rotation as eulerAngles).y as string
			edt_pivot_rot_z.text = (i.rotation as eulerAngles).z as string	
		)
	)
	
	on btn_combine_two_models pressed do 
	(
		if selection.count == 2 then
		(
			local a = selection[1]
			local b = selection[2]
			
			local a1 = copy a
			local b1 = copy b
			converttopoly a1 
			converttopoly b1 
			
			if polyop.getnumfaces a1 > polyop.getnumfaces b1 then
			(
				a = selection[1]
				b = selection[2]
			)
			else
			(
				a = selection[2]
				b = selection[1]				
			)
			
			delete a1
			delete b1
			
			a.pos = [0,0,0]
			move b (a.center-b.center)
			
		)
		else messageBox "Select only two objects"
	)
	
	on btn_pivot_get pressed do
	(
		if selection.count == 1 then
		(
			edt_pivot_pos_x.text = selection[1].pos.x as string
			edt_pivot_pos_y.text = selection[1].pos.y as string
			edt_pivot_pos_z.text = selection[1].pos.z as string
			
			edt_pivot_rot_x.text = (selection[1].rotation as eulerAngles).x as string
			edt_pivot_rot_y.text = (selection[1].rotation as eulerAngles).y as string
			edt_pivot_rot_z.text = (selection[1].rotation as eulerAngles).z as string	
		)
		else messageBox "Select one single object"
	)
	
	on btn_pivot_set pressed do
	(
		if selection.count == 1 then
		(
			local a = selection[1]
			if classof a == Editable_Poly then 
			(
				case of 
				(
					((polyop.getFaceSelection a).isempty and (polyop.getVertSelection a).isempty):
					(
						a.pivot = [a.center.x, a.center.y, a.min.z]
					)
					
					((polyop.getFaceSelection a).numberset > 0): 
					(
						local sel = polyop.getFaceSelection a
						polyop.detachFaces a sel delete:false asNode:true name:a.name node:&b
						b = maxOps.getNodeByHandle (amax (for o in objects collect o.inode.handle))
						a.pivot = [a.center.x, a.center.y, b.center.z]
						delete b
					)
					
					((polyop.getVertSelection a).numberset > 0): 
					(
						local sel = polyop.getVertSelection a
						polyop.detachVerts a sel delete:false asNode:true name:a.name node:&b
						b = maxOps.getNodeByHandle (amax (for o in objects collect o.inode.handle))
						a.pivot = [a.center.x, a.center.y, b.center.z]
						delete b
					)
					
					((polyop.getFaceSelection a).numberset == polyop.getnumfaces a): 
					(
						a.pivot = [a.center.x, a.center.y, a.min.z]
					)
					
					((polyop.getVertSelection a).numberset == polyop.getnumVerts a): 
					(
						a.pivot = [a.center.x, a.center.y, a.min.z]
					)
					
					default: 
					(
						a.pivot = [a.center.x, a.center.y, a.min.z]
					)
					
				)
			)
			else a.pivot = [a.center.x, a.center.y, a.min.z]
		)
		else messageBox "Select one single object"
	)
	
	on btn_pivot_pos pressed do
	(
		if selection.count == 1 then
		(
			selection[1].pos.x = edt_pivot_pos_x.text as float
			selection[1].pos.y = edt_pivot_pos_y.text as float
			selection[1].pos.z = edt_pivot_pos_z.text as float
		)
		else messageBox "Select one single object"		
	)
	
	on btn_pic_open pressed do 
	(
		pic = selectBitMap()
		if pic != undefined then
		(			
			img_tag_pic.bitmap = pic
			edt_pic_dims.text = pic.width as string + "x" + pic.height as string
		)
	)
	
	on btn_convert_to_base pressed do 
	(	
		if img_tag_pic.bitmap != undefined or img_tag_pic.bitmap != (bitmap 50 50 color:(color 50 50 50)) then
		(
			if img_tag_pic.bitmap.width != 256 or img_tag_pic.bitmap.height != 256 then 
			(
				HiddenDOSCommand ("magick " + "\"" + img_tag_pic.bitmap.filename + "\""+ " -trim -resize 256x256^! " + "\""+ (getfilenamepath img_tag_pic.bitmap.filename + getFilenameFile img_tag_pic.bitmap.filename + "+" + getFilenameType img_tag_pic.bitmap.filename) + "\"") startpath:(GetINI_ImageMagick()) --startpath:("C:\\Program Files\\ImageMagick-7.1.1-Q16\\")
				img_tag_pic.bitmap = openbitmap (getfilenamepath img_tag_pic.bitmap.filename + getFilenameFile img_tag_pic.bitmap.filename + "+" + getFilenameType img_tag_pic.bitmap.filename)
				img_tag_pic.bitmap.filename = (getfilenamepath img_tag_pic.bitmap.filename + getFilenameFile img_tag_pic.bitmap.filename + "+" + getFilenameType img_tag_pic.bitmap.filename)
				edt_pic_dims.text = img_tag_pic.bitmap.width as string + "x" + img_tag_pic.bitmap.height as string
				--setclipboardText (ConvertImageToBase64String (img_tag_pic.bitmap.filename))
				close img_tag_pic.bitmap
			)
			if doesfileexist img_tag_pic.bitmap.filename then 
			(
				setclipboardText (ConvertImageToBase64String (img_tag_pic.bitmap.filename))
				messagebox "Image in Clipboard"
			)
			--close img_tag_pic.bitmap
		)
		else messageBox ("No image selected")
	)
)

rollout File "File operations" autoLayoutOnResize:true
(
	button btn_export_preview "Export Preview" across:3 align:#left tooltip:"?????????????? ?????? ??? ???????????????? ????????? ? ?????? FBX ??? 3D-???????????? Autodesk ??? Unreal Engine | Export preview model to FBX for 3D Viewers or Unreal Engine"
	button btn_omkte "Get OMK TE Code" tooltip:"????????? ?????????? ???? ?????? ???? OMK TE | Start dialog for selection OMK TE code" offset:[20,0]
	edittext edt_omkte "" fieldWidth:50 width:50 text:"" offset:[0,0] align:#right

	button btn_export_lowpoly "Export LowPoly" across:3 align:#left tooltip:"?? ?????? ??????? ????????? ????????, ?????????????? ??? ?????? (Lowpoly) ? ?????? FBX ?? ??????????? ?????????? | Export Lowpoly model to FBX with embedded textures"	
	button btn_export_highpoly "Export HighPoly" offset:[8,0] tooltip:"?? ?????? ??????? ????????? ????????, ?????????????? ??? ?????? (Highpoly) ? ?????? FBX | Export Highpoly model to FBX with checking of selected objects"
	button btn_archivate "Archivate All" align:#right tooltip:"?????????????? ?????? ? ??????? ????? ???????? ?????? ??????, ? ?????????  | Archivate Models in Target Folder with checking"

	edittext edt_project_current_name "Current Project" align:#right Width:260 text:(GetINI_Current_Project_Name maxFilePath)
	dropdownlist dpl_ini_names "" items:(GetINI_Projects_Names()) selection:(GetINI_Current_Project_Index maxFilePath) width:260 fieldWidth:260 align:#right
	edittext edt_project_path "Current File Path" align:#left width:260 text:maxFilePath
	edittext edt_project_lowpoly_name "Lowpoly Name" align:#left width:260 text:(GetINI_Current_Project_Lowpoly maxFilePath) 
	edittext edt_project_highpoly_name "Highpoly Name" align:#left width:260 text:(GetINI_Current_Project_Highpoly maxFilePath)	

	button btn_load_Names "Load Names" across:3 align:#left tooltip:"Do not work yet. Load previous saved names of paths and objects names"	
	button btn_save_Names "Save Names" offset:[-10,0] tooltip:"Do not work yet. Save names of paths and objects names"
	button btn_delete_Names "Delete Names" offset:[0,0] align:#right tooltip:"Do not work yet. Delete selected names from INI file" 

	on File open do
	(
		for i in File.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_files.ini") i.name "File" (syssetup.rdo_lang.state))
	)
		
	on btn_omkte pressed do
	(
		excel_file = GetDir #maxroot +"\\GeoScripts\\OMK_TE.csv" 
		global arr_excel = #()
		stri_pr = #()
		stri_pr = ReadAllLines excel_file	
		if stri_pr != "" then
			if stri_pr.count > 0 then
			(
				arr_excel = for i = 1 to stri_pr.count collect (filterstring stri_pr[i] "\t\n" splitEmptyTokens:true)
				if arr_excel.count > 0 then for i=1 to arr_excel.count do for j=1 to arr_excel[i].count do arr_excel[i][j] = substitutestring arr_excel[i][j] "\"" ""
			)	
			--print #(arr_excel)
			global sel = #()
			str = ""
			append str ("rollout TableOMKTE " + "\"" + "Table OMK TE Codes" + "\"" + " autoLayoutOnResize:true width:300 height:800\n" + "(\n")
						
			for i = 1 to arr_excel.count do
			(
				append str ("label lbla_" + i as string + " " + "\"" + arr_excel[i][1] + "\"" + " align:#left across:3 width:20 height:15 \n")
				append str ("label lblb_" + i as string + " " + "\"" + arr_excel[i][2] + "\"" + " align:#left style_sunkenedge:true width:200 height:15 offset:[-90,0] \n")
				append str ("button btn_" + i as string + " " + "\"" + arr_excel[i][3] + "\"" + " width:100 height:15 align:#right \n") 
			)
			for i = 1 to arr_excel.count do
			(
				append str ("on btn_" + i as string + " pressed do ( File.edt_omkte.text = btn_" + i as string + ".text; setclipboardText (File.edt_omkte.text); try(closeRolloutFloater TableOMKTE_FL)catch() )\n")
			)
			append str (")\n")
			append str ("addRollout TableOMKTE TableOMKTE_FL\n")
			
			try(destroyDialog ::TableOMKTE_FL)catch()
			try(closeRolloutFloater TableOMKTE_FL)catch()
			TableOMKTE_FL = newRolloutFloater "OMK TE Codes" 400 800
			execute (str)
	)

	on btn_archivate pressed do
	(
		files = getFiles (UDIMs.edt_multimat_path.text + "*.*")
		print #(files)
		fbxs_hi = for f in files where (tolower (getFilenameType f) == ".fbx") and (findstring (getFilenameFile f) "SM_" != undefined) and ((findstring (getFilenameFile f) "_00" == undefined) or (findstring (getFilenameFile f) "_00" != undefined) or (findstring (getFilenameFile f) "_Ground" != undefined)) and (findstring (getFilenameFile f) "_Light" == undefined) collect f
		print #(fbxs_hi)
		fbxs_low = for f in files where (tolower (getFilenameType f) == ".fbx") and (findstring (getFilenameFile f) "SM_" == undefined) and (trimright ((filterstring (getFilenameFile f) "_")[1]) "0123456789" == "") collect f
		print #(fbxs_low)

		--archivate lowpoly *fbx
		stri = ""
		arch = ""
		for f in fbxs_low do stri += f + "\n"
		for f in fbxs_low where (findstring (getFilenameFile f) "_Ground" != undefined) do arch = (substitutestring (getFilenameFile f) "_Ground" "") + ".zip"
		if arch == "" then 
			for f in fbxs_low where (findstring (getFilenameFile f) "_Ground" == undefined) do arch = (substitutestring (getFilenameFile f + getFilenameType f) "_01.fbx" "") + ".zip"
		try 
		(
			dnSW = dotNetClass "System.IO.StreamWriter"
			dnFile = dotnetClass "System.IO.File"
			myTxt = dotNetObject dnSW (dnFile.create (UDIMs.edt_multimat_path.text + "zip.txt")) 
			myTxt.WriteLine stri 
			myTxt.Close() 
			myTxt.Dispose()
		)catch()				
		--ZIP = "\"C:\Program Files\7-Zip\7z.exe\"" + " a -tzip -y " + "\"" + arch + "\"" + " @zip.txt"
		ZIP = "\"" + GetDir #maxroot + "GeoScripts\\7z.exe" + "\"" + " a -tzip -y " + "\"" + arch + "\"" + " @zip.txt"
		print ZIP
		HiddenDOSCommand (ZIP) startpath:(UDIMs.edt_multimat_path.text)
		
		texes = #()
		geojson = #()
		dops = #()
		for f in fbxs_hi do
		(
			f_ = substitutestring (getFilenameFile f) "SM_" "T_"
			if findstring (getFilenameFile f) "_00" != undefined or findstring (getFilenameFile f) "_Ground" != undefined then
				texes = for t in files where findstring t f_ != undefined and findstring t "_d_" == undefined and findstring t "_o_" == undefined and findstring t "_m_" == undefined and findstring t "_n_" == undefined and findstring t "_r_" == undefined and tolower (getFilenameType t) == ".png" collect t 
			else
				texes = for t in files where findstring t f_ != undefined and findstring (getFilenameFile t) "_00" == undefined and findstring (getFilenameFile t) "_Ground" == undefined and findstring t "_d_" == undefined and findstring t "_o_" == undefined and findstring t "_m_" == undefined and findstring t "_n_" == undefined and findstring t "_r_" == undefined and tolower (getFilenameType t) == ".png" collect t 
			print #(texes)
			
			if findstring (getFilenameFile f) "_00" != undefined or findstring (getFilenameFile f) "_Ground" != undefined then
				geojson = for t in files where findstring t ((getFilenameFile f) + ".geojson") != undefined collect t
			else
				geojson = for t in files where findstring t ((getFilenameFile f) + ".geojson") != undefined and findstring (getFilenameFile t) "_00" == undefined and findstring (getFilenameFile t) "_Ground" == undefined collect t
			print #(geojson)
			
			if findstring (getFilenameFile f) "_00" != undefined or findstring (getFilenameFile f) "_Ground" != undefined then
				dops = for t in files where findstring t ".fbx" != undefined and findstring t (getFilenameFile f) != undefined and (getFilenameFile t) != (getFilenameFile f) collect t
			else
				dops = for t in files where findstring (getFilenameFile t) "_00" == undefined and findstring (getFilenameFile t) "_Ground" == undefined and findstring (getFilenameFile t) ".fbx" != undefined and findstring t (getFilenameFile f) != undefined /* and (getFilenameFile t) != (getFilenameFile f)*/ collect t
				
			print #(dops)
			
			arch = (getFilenameFile f) + ".zip"
			stri = f + "\n"
			for t in texes do stri += t + "\n"
			for t in geojson do stri += t + "\n"	
			for t in dops do stri += t + "\n"		
			
			try 
			(
				dnSW = dotNetClass "System.IO.StreamWriter"
				dnFile = dotnetClass "System.IO.File"
				myTxt = dotNetObject dnSW (dnFile.create (UDIMs.edt_multimat_path.text + "zip.txt")) 
				myTxt.WriteLine stri 
				myTxt.Close() 
				myTxt.Dispose()
			)catch()				
			--ZIP = "\"C:\Program Files\7-Zip\7z.exe\"" + " a -tzip -y " + "\"" + arch + "\"" + " @zip.txt"
			ZIP = "\"" + GetDir #maxroot + "GeoScripts\\7z.exe" + "\"" + " a -tzip -y " + "\"" + arch + "\"" + " @zip.txt"
			
			print ZIP
			HiddenDOSCommand (ZIP) startpath:(UDIMs.edt_multimat_path.text)
		)
		if doesFileExist (UDIMs.edt_multimat_path.text + "zip.txt") do deletefile (UDIMs.edt_multimat_path.text + "zip.txt")
	)
	
	on dpl_ini_names selected txt do edt_project_current_name.text = dpl_ini_names.items[txt] as string

	on btn_export_preview pressed do
	(
		--print UDIMs.edt_multimat_path.text
		allright = true
		/*
		ucx_obj = false
		for i in selection do
		(
			if findstring i.name "UCX" != undefined then ucx_obj = true
			if i.ishidden then i.ishidden = false
			j = copy i 
			converttopoly j
			ids = #()
			for p in #{1..polyop.getNumFaces j} do appendifunique ids (polyop.getFaceMatID j p)
			if classof j.material == multiSubMaterial then 
			(
				if j.material.materialList.count != ids.count then allright = false
			)
			else 
			(
				if findstring j.name "Glass" == undefined and findstring j.name "UCX" == undefined then allright = false
			)
			delete j
		)
		if ucx_obj then messagebox "Found UCX objects in export for preview"
		*/
		if allright then
		(
			pluginManager.loadClass FbxExporter
			FBXExporterSetParam "Cameras" false 
			FBXExporterSetParam "FileVersion" "FBX201400" 
			FBXExporterSetParam "SmoothingGroups" true
			FBXExporterSetParam "Triangulate" false
			FBXExporterSetParam "Animation" false
			FBXExporterSetParam "Lights" false
			FBXExporterSetParam "ASCII" false
			FBXExporterSetParam "EmbedTextures" true 
			FBXExporterSetParam "GeomAsBone" false
			FBXExporterSetParam "GenerateLog" false
			FBXExporterSetParam "UpAxis" "Y"
			FBXExporterSetParam "ScaleFactor" 1.0
			FBXExporterSetParam "AxisConversionMethod" "None"
			FBXExporterSetParam "Preserveinstances" false
			FBXExporterSetParam "Convert2Tiff" false
			FBXExporterSetParam "ConvertUnit" "m" 
			FBXExporterSetParam "FilterKeyReducer" false
			FBXExporterSetParam "NormalsPerPoly" false
			FBXExporterSetParam "PointCache"  false 
			FBXExporterSetParam "Shape"  false
			FBXExporterSetParam "Skin"  false 
			FBXExporterSetParam "SmoothMeshExport" true
			exportFile (UDIMs.edt_multimat_path.text + "preview.fbx") #noPrompt selectedOnly:true using:FBXEXP --theClasses[8] using:theClasses[(findItem theClasses FBXEXP)] 
		)
		--else messagebox "Wrong materials on models"
	)
	
	on btn_export_lowpoly pressed do
	(
		allright = true
		ucx_obj = false
		mats = false
		sel = false
		omkte = false
		dist = false
		objs = false
		if edt_omkte.text == "" then 
		(
			omkte = true
			allright = false
		)
		if selection.count == 0 then 
		(
			sel = true
			allright = false
		)
		if allright then
		for i in selection do
		(
			if findstring i.name "UCX" != undefined then 
			(
				ucx_obj = true
				allright = false
			)
			if classof i.material != Standard then 
			(
				allright = false
				mats = true
			)
			if distance i.pos [0,0,0] <= 100 then 
			(
				dist = true
				allright = false				
			)
			if superclassof i != GeometryClass then
			(
				objs = true
				allright = false					
			)
			if i.ishidden then i.ishidden = false
		)
		if allright then
		(
			pluginManager.loadClass FbxExporter
			FBXExporterSetParam "Cameras" false 
			FBXExporterSetParam "FileVersion" "FBX201400" 
			FBXExporterSetParam "SmoothingGroups" true
			FBXExporterSetParam "SmoothMeshExport" false
			FBXExporterSetParam "Triangulate" false
			FBXExporterSetParam "Animation" false
			FBXExporterSetParam "Lights" false
			FBXExporterSetParam "ASCII" false
			FBXExporterSetParam "EmbedTextures" true 
			FBXExporterSetParam "GeomAsBone" false
			FBXExporterSetParam "GenerateLog" false
			FBXExporterSetParam "UpAxis" "Y"
			FBXExporterSetParam "ScaleFactor" 1.0
			FBXExporterSetParam "AxisConversionMethod" "None"
			FBXExporterSetParam "Preserveinstances" false
			FBXExporterSetParam "Animation" false
			FBXExporterSetParam "Convert2Tiff" false
			FBXExporterSetParam "ConvertUnit" "m" 
			FBXExporterSetParam "FilterKeyReducer" false
			FBXExporterSetParam "GeomAsBone" false
			FBXExporterSetParam "GenerateLog" false
			FBXExporterSetParam "Lights" false
			FBXExporterSetParam "NormalsPerPoly" false --?
			FBXExporterSetParam "PointCache" false 
			FBXExporterSetParam "Shape" false
			FBXExporterSetParam "Skin" false 
			FBXExporterSetParam "SmoothMeshExport" true
			
			if not doesDirectoryExist UDIMs.edt_multimat_path.text then makeDir UDIMs.edt_multimat_path.text
			
			ground = #()
			oks = #()
			ground = for i in selection where findstring (tolower i.name) "ground" != undefined collect i
			oks = for i in selection where findstring (tolower i.name) "ground" == undefined collect i
			
			if ground.count > 0 then
			(
				nam = ""
				nam = substitutestring ground[1].name "SM_" ""
				nam = substitutestring nam "_GroundEl" ""
				nam = substitutestring nam "_Ground" ""
				
				select ground
				exportFile (UDIMs.edt_multimat_path.text + edt_omkte.text + "_" + nam + "_Ground.fbx") #noPrompt selectedOnly:true using:FBXEXP --theClasses[8] using:theClasses[(findItem theClasses FBXEXP)] 
			)
			if oks.count > 0 then
			(
				nam = ""
				nam = substitutestring oks[1].name "SM_" ""
				nam = substitutestring nam "_Main" ""
				nam = substitutestring nam "_001" ""
				nam = substitutestring nam "_002" ""
				nam = substitutestring nam "_003" ""
				nam = substitutestring nam "_004" ""
				nam = substitutestring nam "_005" ""				
				nam = substitutestring nam "_006" ""	
				nam = substitutestring nam "_007" ""	
				nam = substitutestring nam "_008" ""	
				nam = substitutestring nam "_009" ""					
				
				select oks
				exportFile (UDIMs.edt_multimat_path.text + edt_omkte.text + "_" + nam + "_01.fbx") #noPrompt selectedOnly:true using:FBXEXP --theClasses[8] using:theClasses[(findItem theClasses FBXEXP)] 
			)
		)
		else 
		(
			s = "Wrong: \n"
			if objs then s += "selected objects is not geometry\n"
			if dist then s += "one of selected object have wrong position near zero\n"
			if omkte then s += "OMK TE Code not selected\n"
			if ucx_obj then s += "selected UCX objects\n"
			if mats then s += "materials on models\n"
			if sel then s += "no objects selected\n"	
			messagebox s
		)
	)
	
	on btn_export_highpoly rightclick do
	(
		sel = selection[1]
		--objs = for i in objects where (findstring i.name "_Ground" != undefined or findstring i.name "_Main" != undefined) and findstring i.name "Glass" == undefined and findstring i.name "SM_" != undefined and findstring i.name "_SM_" == undefined and not i.isHidden and not i.isFrozen and abs(i.pos.x) <= 1.0 and abs(i.pos.y) <= 1.0 and abs(i.pos.z) <= 1.0 collect i 
		selectmore (for t in objects where findstring t.name "UCX_SM_" != undefined and findstring t.name sel.name != undefined collect t)
		selectmore (for t in objects where findstring t.name "Glass" != undefined and findstring t.name sel.name != undefined collect t)
	)
	
	on btn_export_highpoly pressed do
	(
		--print UDIMs.edt_multimat_path.text
		objs = for i in objects where (findstring i.name "_Ground" != undefined or findstring i.name "_Main" != undefined) and findstring i.name "Glass" == undefined and findstring i.name "SM_" != undefined and findstring i.name "_SM_" == undefined and not i.isHidden and not i.isFrozen and abs(i.pos.x) <= 1.0 and abs(i.pos.y) <= 1.0 and abs(i.pos.z) <= 1.0 collect i 
		print #(objs)
		for i in objs do
		(
			USXs = for t in objects where findstring t.name "UCX_SM_" != undefined and findstring t.name i.name != undefined collect t
			print #(USXs)
			Glasses = for t in objects where findstring t.name "Glass" != undefined and findstring t.name i.name != undefined collect t
			print #(Glasses)	
			Lightes = for t in objects where (findstring t.name "Spot" != undefined or findstring t.name "Root" != undefined) and findstring t.name (substitutestring i.name "SM_" "") != undefined collect t
			print #(Lightes)
			
			clearSelection()
			selectmore i
			selectmore Glasses
			selectmore USXs
			--selectmore Lightes
			if USXs != undefined then
			(
				if USXs.count > 0 then 
				(			
					pluginManager.loadClass FbxExporter
					FBXExporterSetParam "Cameras" false 
					FBXExporterSetParam "FileVersion" "FBX201400" 
					FBXExporterSetParam "SmoothingGroups" true
					FBXExporterSetParam "SmoothMeshExport" true
					FBXExporterSetParam "Triangulate" false
					FBXExporterSetParam "Animation" false
					FBXExporterSetParam "Lights" false
					FBXExporterSetParam "ASCII" false
					FBXExporterSetParam "EmbedTextures" false 
					FBXExporterSetParam "GeomAsBone" false
					FBXExporterSetParam "GenerateLog" false
					FBXExporterSetParam "UpAxis" "Y"
					FBXExporterSetParam "ScaleFactor" 1.0
					FBXExporterSetParam "AxisConversionMethod" "None"
					FBXExporterSetParam "Preserveinstances" false
					FBXExporterSetParam "Convert2Tiff" false
					FBXExporterSetParam "ConvertUnit" "m" 
					FBXExporterSetParam "FilterKeyReducer" false
					FBXExporterSetParam "NormalsPerPoly" true --?
					FBXExporterSetParam "PointCache"  false 
					FBXExporterSetParam "Shape"  false
					FBXExporterSetParam "Skin"  false 
					exportFile (UDIMs.edt_multimat_path.text + (substitutestring i.name "_Main" "") + ".fbx") #noPrompt selectedOnly:true using:FBXEXP --theClasses[8] using:theClasses[(findItem theClasses FBXEXP)] 
					if Lightes != undefined then 
						if Lightes.count > 0 then
						(
							select Lightes
							pluginManager.loadClass FbxExporter
							FBXExporterSetParam "Cameras" false 
							FBXExporterSetParam "FileVersion" "FBX201400" 
							FBXExporterSetParam "SmoothingGroups" true
							FBXExporterSetParam "SmoothMeshExport" true
							FBXExporterSetParam "Triangulate" false
							FBXExporterSetParam "Animation" false
							FBXExporterSetParam "Lights" true
							FBXExporterSetParam "ASCII" false
							FBXExporterSetParam "EmbedTextures" false 
							FBXExporterSetParam "GeomAsBone" false
							FBXExporterSetParam "GenerateLog" false
							FBXExporterSetParam "UpAxis" "Y"
							FBXExporterSetParam "ScaleFactor" 1.0
							FBXExporterSetParam "AxisConversionMethod" "None"
							FBXExporterSetParam "Preserveinstances" false
							FBXExporterSetParam "Convert2Tiff" false
							FBXExporterSetParam "ConvertUnit" "m" 
							FBXExporterSetParam "FilterKeyReducer" false
							FBXExporterSetParam "NormalsPerPoly" true --?
							FBXExporterSetParam "PointCache"  false 
							FBXExporterSetParam "Shape"  false
							exportFile (UDIMs.edt_multimat_path.text + i.name + "_Light" + ".fbx") #noPrompt selectedOnly:true using:FBXEXP --theClasses[8] using:theClasses[(findItem theClasses FBXEXP)] 
						)
				)
				else
				(
					messagebox ("No UCX models to export with model: " + i.name) 
				) 
				--clearSelection()
			)
		)
		/*
		ucx_obj = false
		glass_obj = false
		ground_obj = false
		for i in selection where findstring i.name "UCX" != undefined do ucx_obj = true
		for i in selection where findstring i.name "Glass" != undefined do glass_obj = true
		for i in selection where findstring i.name "Ground" != undefined do ground_obj = true			
		if ucx_obj and glass_obj and ground_obj then
		(
			pluginManager.loadClass FbxExporter
			FBXExporterSetParam "Cameras" false 
			FBXExporterSetParam "FileVersion" "FBX201400" 
			FBXExporterSetParam "SmoothingGroups" true
			FBXExporterSetParam "SmoothMeshExport" false
			FBXExporterSetParam "Triangulate" false
			FBXExporterSetParam "Animation" false
			FBXExporterSetParam "Lights" false
			FBXExporterSetParam "ASCII" false
			FBXExporterSetParam "EmbedTextures" false 
			FBXExporterSetParam "GeomAsBone" false
			FBXExporterSetParam "GenerateLog" false
			FBXExporterSetParam "UpAxis" "Y"
			FBXExporterSetParam "ScaleFactor" 1.0
			FBXExporterSetParam "AxisConversionMethod" "None"
			FBXExporterSetParam "Preserveinstances" false
			FBXExporterSetParam "Animation" false
			FBXExporterSetParam "Convert2Tiff" false
			FBXExporterSetParam "ConvertUnit" "m" 
			FBXExporterSetParam "FilterKeyReducer" false
			FBXExporterSetParam "GeomAsBone"  false
			FBXExporterSetParam "GenerateLog"  false
			FBXExporterSetParam "Lights"  false
			FBXExporterSetParam "NormalsPerPoly"  false --?
			FBXExporterSetParam "PointCache"  false 
			FBXExporterSetParam "Shape"  false
			FBXExporterSetParam "Skin"  false 
			FBXExporterSetParam "SmoothMeshExport"  true
			exportFile (edt_project_path.text + "Images\\" + "hipoly.fbx") #noPrompt selectedOnly:true using:FBXEXP --theClasses[8] using:theClasses[(findItem theClasses FBXEXP)] 
		)
		else 
		(
			mess = ""
			if not ucx_obj then mess += "UCX object not selected\n"
			if not glass_obj then mess += "Glass object not selected\n"
			if not ground_obj then mess += "Ground object not selected\n"
			messagebox ("Wrong selection\n" + mess)
		)
		*/
	)
)

rollout Docker "Dock and Update" autoLayoutOnResize:true
(
	button btn_update "Update Script" offset:[0,0] across:4 align:#left toolTip:"??????? ?????? ? ???????????? ? ??????? ????????-???????? | Open cloud with updates in current internet browser"
	button lbl2 "< Dock" border:false offset:[10,0] toolTip:"LMB: ????????? ?????? ???????????? ????? | LMB: Dock toolbar to left side"
	button lbl1 "Make Float" border:false offset:[10,0] toolTip:"LMB: ??????? ?????? ???????????? ?????????\nRMB: ??????? ?????? ???????????? | LMB: Make toolbar float\nRMB: Close toolbar"	
	button lbl3 "Dock >" border:false offset:[0,0] align:#right toolTip:"LMB: ????????? ?????? ???????????? ?????? | LMB: Dock toolbar to right side"

	on Docker open do
	(
		for i in Docker.controls where ValidTypeControl i /* where isProperty i "tooltip"*/ do (i.tooltip = TooltipReader (GetDir #maxroot + "GeoScripts\\tooltips_Docker.ini") i.name "Docker" (syssetup.rdo_lang.state))
	)
	
	on lbl1 pressed do
	(
		cui.RegisterDialogBar GeoAGR minSize:[10,700] maxSize:[500,700] --style:#(#cui_dock_all, #cui_floatable, #cui_floatableDialogbar, #cui_dock_allDialog, #cui_dock_bottomCan, #cui_dock_rightCan, #cui_dock_topCan, #cui_dock_left, #cui_dock_vertCan , #cui_dock_horzCan, #cui_handles, #cui_handlesShow, #cui_max_sized)
		cui.FloatDialogBar GeoAGR
	)

	on lbl1 rightclick do
	(
		try(cui.RegisterDialogBar GeoAGR minSize:[10,700] maxSize:[500,700])catch()
		try(cui.UnRegisterDialogBar GeoAGR)catch()
		try(destroyDialog ::GeoAGR)catch() --destroyDialog GeoAGR
		try(closeRolloutFloater GeoAGR)catch()
		gc()
	)

	on lbl2 pressed do
	(
		cui.RegisterDialogBar GeoAGR minSize:[10,700] maxSize:[500,700] --style:#(#cui_dock_all, #cui_floatable, #cui_floatableDialogbar, #cui_dock_allDialog, #cui_dock_bottomCan, #cui_dock_rightCan, #cui_dock_topCan, #cui_dock_left, #cui_dock_vertCan , #cui_dock_horzCan, #cui_handles, #cui_handlesShow, #cui_max_sized)
		cui.DockDialogBar GeoAGR #cui_dock_left
		--cui.UnRegisterDialogBar geo	
	)

	on lbl3 pressed do
	(
		cui.RegisterDialogBar GeoAGR minSize:[10,700] maxSize:[500,700] --style:#(#cui_dock_all, #cui_floatable, #cui_floatableDialogbar, #cui_dock_allDialog, #cui_dock_bottomCan, #cui_dock_rightCan, #cui_dock_topCan, #cui_dock_left, #cui_dock_vertCan , #cui_dock_horzCan, #cui_handles, #cui_handlesShow, #cui_max_sized)
		cui.DockDialogBar GeoAGR #cui_dock_right 	
		--cui.UnRegisterDialogBar geo	
	)

	on btn_update pressed do
	(
		process = dotnetclass "System.Diagnostics.Process"
		process.start ("https://cloud.mail.ru/public/Zq1B/2FKsi1fDn")
	)		
)

--addRollout RulesCheck GeoAGR rolledup:true
addRollout syssetup GeoAGR rolledup:true
addRollout slicers GeoAGR rolledup:true
addRollout UDIMs GeoAGR rolledup:false
addRollout Obj_Spln GeoAGR rolledup:true
addRollout Obj_tools GeoAGR rolledup:true
addRollout UCX GeoAGR rolledup:true
addRollout Geojson GeoAGR rolledup:true
addRollout File GeoAGR rolledup:true
addRollout Docker GeoAGR rolledup:false


/*
createDialog GeoAGR lockwidth:true lockheight:false autoLayoutOnResize:true style:#(#style_resizing, #style_sunkenedge, #style_titlebar, #style_sysmenu, #style_minimizebox) 
try (SetDialogPos GeoAGR [500, 90])catch()
AddSubRollout GeoAGR.S_slicers slicers rolledup:false autoLayoutOnResize:true lockheight:false
AddSubRollout GeoAGR.S_UDIMs UDIMs rolledup:false autoLayoutOnResize:true lockheight:false
AddSubRollout GeoAGR.S_Obj_Spln Obj_Spln rolledup:false autoLayoutOnResize:true lockheight:false
AddSubRollout GeoAGR.S_UCX UCX rolledup:false autoLayoutOnResize:true lockheight:false
AddSubRollout GeoAGR.S_Geojson Geojson rolledup:false autoLayoutOnResize:true lockheight:false
AddSubRollout GeoAGR.S_File File rolledup:false autoLayoutOnResize:true lockheight:false
*/

)
"
--			answer: undefined
--			timeStamp: "01.11.2025_95157"
--			show_lines: undefined
--		Externals:
--			localTime: SystemGlobal:localTime : "01.11.2025 9:51:57"
--	------------------------------------------------------
--	[stack level: 1]
--	called from top-level
